<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Triangulations</div>  </div>
</div><!--header-->
<div class="contents">

<p>Triangulations of manifolds in all supported dimensions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Example.html">regina::Example&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers static routines for constructing a variety of sample <em>dim</em>-dimensional triangulations.  <a href="classregina_1_1Example.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Example_3_012_01_4.html">regina::Example&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers routines for constructing a variety of sample 2-dimensional triangulations.  <a href="classregina_1_1Example_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Example_3_013_01_4.html">regina::Example&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers routines for constructing a variety of sample 3-dimensional triangulations.  <a href="classregina_1_1Example_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Example_3_014_01_4.html">regina::Example&lt; 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers routines for constructing a variety of sample 4-dimensional triangulations.  <a href="classregina_1_1Example_3_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FaceNumbering.html">regina::FaceNumbering&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how <em>subdim</em>-faces are numbered within a <em>dim</em>-dimensional simplex.  <a href="classregina_1_1FaceNumbering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacePair.html">regina::FacePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pair of tetrahedron face numbers.  <a href="classregina_1_1FacePair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html">regina::FacetPairing&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dual graph of a 3-manifold triangulation.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight class used to refer to a particular facet of a particular top-dimensional simplex in a <em>dim</em>-dimensional triangulation.  <a href="structregina_1_1FacetSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoundaryComponent.html">regina::BoundaryComponent&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component of the boundary of a <em>dim</em>-manifold triangulation.  <a href="classregina_1_1BoundaryComponent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Component.html">regina::Component&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connected component of a <em>dim</em>-manifold triangulation.  <a href="classregina_1_1Component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face.html">regina::Face&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <em>subdim</em>-face in the skeleton of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FaceEmbedding.html">regina::FaceEmbedding&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details how a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation appears within each top-dimensional simplex.  <a href="classregina_1_1FaceEmbedding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the dual graph of a <em>dim</em>-manifold triangulation; that is, the pairwise matching of facets of <em>dim</em>-dimensional simplices.  <a href="classregina_1_1FacetPairing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a combinatorial isomorphism from one <em>dim</em>-manifold triangulation into another.  <a href="classregina_1_1Isomorphism.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>dim</em>-dimensional triangulation, built by gluing together <em>dim</em>-dimensional simplices along their (<em>dim</em>-1)-dimensional facets.  <a href="classregina_1_1Triangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomologicalData.html">regina::HomologicalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type that deals with all the detailed homological information in a manifold.  <a href="classregina_1_1HomologicalData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1XMLTriangulationReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTriangulationReader_3_012_01_4.html">regina::XMLTriangulationReader&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single 2-dimensional triangulation.  <a href="classregina_1_1XMLTriangulationReader_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTriangulationReader_3_013_01_4.html">regina::XMLTriangulationReader&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single 3-dimensional triangulation.  <a href="classregina_1_1XMLTriangulationReader_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTriangulationReader_3_014_01_4.html">regina::XMLTriangulationReader&lt; 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single 4-dimensional triangulation.  <a href="classregina_1_1XMLTriangulationReader_3_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3442b4173f21eb1890a4c64743152328"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga3442b4173f21eb1890a4c64743152328">regina::Dim2ExampleTriangulation</a></td></tr>
<tr class="memdesc:ga3442b4173f21eb1890a4c64743152328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga3442b4173f21eb1890a4c64743152328">More...</a><br /></td></tr>
<tr class="separator:ga3442b4173f21eb1890a4c64743152328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6096eca562a01858ade2f9fe950a8dd3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga6096eca562a01858ade2f9fe950a8dd3">regina::NExampleTriangulation</a></td></tr>
<tr class="memdesc:ga6096eca562a01858ade2f9fe950a8dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga6096eca562a01858ade2f9fe950a8dd3">More...</a><br /></td></tr>
<tr class="separator:ga6096eca562a01858ade2f9fe950a8dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48fdc344134a7fa32045a9ffe7f55be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gac48fdc344134a7fa32045a9ffe7f55be">regina::Dim4ExampleTriangulation</a></td></tr>
<tr class="memdesc:gac48fdc344134a7fa32045a9ffe7f55be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#gac48fdc344134a7fa32045a9ffe7f55be">More...</a><br /></td></tr>
<tr class="separator:gac48fdc344134a7fa32045a9ffe7f55be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79926fe93b2994dc75769c5c564de4c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FacePair.html">FacePair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga79926fe93b2994dc75769c5c564de4c0">regina::NFacePair</a></td></tr>
<tr class="memdesc:ga79926fe93b2994dc75769c5c564de4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga79926fe93b2994dc75769c5c564de4c0">More...</a><br /></td></tr>
<tr class="separator:ga79926fe93b2994dc75769c5c564de4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7856ba44367811dafd267d9f9e8f1f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">regina::NFacePairing</a></td></tr>
<tr class="memdesc:ga8f7856ba44367811dafd267d9f9e8f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">More...</a><br /></td></tr>
<tr class="separator:ga8f7856ba44367811dafd267d9f9e8f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac38299d09566ac14cd2d4fbca24ae70"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaac38299d09566ac14cd2d4fbca24ae70">regina::Dim2TriangleEdge</a></td></tr>
<tr class="memdesc:gaac38299d09566ac14cd2d4fbca24ae70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#gaac38299d09566ac14cd2d4fbca24ae70">More...</a><br /></td></tr>
<tr class="separator:gaac38299d09566ac14cd2d4fbca24ae70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7efda7dff99a8a422a75e1bc2ca5d6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">regina::NTetFace</a></td></tr>
<tr class="memdesc:ga5d7efda7dff99a8a422a75e1bc2ca5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">More...</a><br /></td></tr>
<tr class="separator:ga5d7efda7dff99a8a422a75e1bc2ca5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696c1ecd18858c1f507967c4394e6dd0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga696c1ecd18858c1f507967c4394e6dd0">regina::Dim4PentFacet</a></td></tr>
<tr class="memdesc:ga696c1ecd18858c1f507967c4394e6dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#ga696c1ecd18858c1f507967c4394e6dd0">More...</a><br /></td></tr>
<tr class="separator:ga696c1ecd18858c1f507967c4394e6dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe03acab5f3950baadc9e7ecd494bedb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gafe03acab5f3950baadc9e7ecd494bedb">regina::NHomologicalData</a></td></tr>
<tr class="memdesc:gafe03acab5f3950baadc9e7ecd494bedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__triangulation.html#gafe03acab5f3950baadc9e7ecd494bedb">More...</a><br /></td></tr>
<tr class="separator:gafe03acab5f3950baadc9e7ecd494bedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab4859f568765540b75b5f2bd681163a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gab4859f568765540b75b5f2bd681163a0">regina::Example&lt; 2 &gt;::orientable</a> (unsigned genus, unsigned punctures)</td></tr>
<tr class="memdesc:gab4859f568765540b75b5f2bd681163a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the given orientable surface.  <a href="group__triangulation.html#gab4859f568765540b75b5f2bd681163a0">More...</a><br /></td></tr>
<tr class="separator:gab4859f568765540b75b5f2bd681163a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bf5456816a8d9405e37a3829d6a456"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga44bf5456816a8d9405e37a3829d6a456">regina::Example&lt; 2 &gt;::nonOrientable</a> (unsigned genus, unsigned punctures)</td></tr>
<tr class="memdesc:ga44bf5456816a8d9405e37a3829d6a456"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the given non-orientable surface.  <a href="group__triangulation.html#ga44bf5456816a8d9405e37a3829d6a456">More...</a><br /></td></tr>
<tr class="separator:ga44bf5456816a8d9405e37a3829d6a456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae208f58f76e1b1be3d316264e7bfaeb1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gae208f58f76e1b1be3d316264e7bfaeb1">regina::Example&lt; 2 &gt;::sphereTetrahedron</a> ()</td></tr>
<tr class="memdesc:gae208f58f76e1b1be3d316264e7bfaeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the four-triangle 2-sphere formed from the boundary of a tetrahedron.  <a href="group__triangulation.html#gae208f58f76e1b1be3d316264e7bfaeb1">More...</a><br /></td></tr>
<tr class="separator:gae208f58f76e1b1be3d316264e7bfaeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b01503ae389d74db8a1bd7d05f5980e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga8b01503ae389d74db8a1bd7d05f5980e">regina::Example&lt; 2 &gt;::sphereOctahedron</a> ()</td></tr>
<tr class="memdesc:ga8b01503ae389d74db8a1bd7d05f5980e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the eight-triangle 2-sphere formed from the boundary of an octahedron.  <a href="group__triangulation.html#ga8b01503ae389d74db8a1bd7d05f5980e">More...</a><br /></td></tr>
<tr class="separator:ga8b01503ae389d74db8a1bd7d05f5980e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1af9a63bb1d882c0b53f8e1a54bc95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaad1af9a63bb1d882c0b53f8e1a54bc95">regina::Example&lt; 2 &gt;::disc</a> ()</td></tr>
<tr class="memdesc:gaad1af9a63bb1d882c0b53f8e1a54bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-triangle disc.  <a href="group__triangulation.html#gaad1af9a63bb1d882c0b53f8e1a54bc95">More...</a><br /></td></tr>
<tr class="separator:gaad1af9a63bb1d882c0b53f8e1a54bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e58eb5bb9b7113dfdebe3d2846b35bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga1e58eb5bb9b7113dfdebe3d2846b35bd">regina::Example&lt; 2 &gt;::annulus</a> ()</td></tr>
<tr class="memdesc:ga1e58eb5bb9b7113dfdebe3d2846b35bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle annulus.  <a href="group__triangulation.html#ga1e58eb5bb9b7113dfdebe3d2846b35bd">More...</a><br /></td></tr>
<tr class="separator:ga1e58eb5bb9b7113dfdebe3d2846b35bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d94c206a8df611ae9ccb1b3f9301911"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga4d94c206a8df611ae9ccb1b3f9301911">regina::Example&lt; 2 &gt;::mobius</a> ()</td></tr>
<tr class="memdesc:ga4d94c206a8df611ae9ccb1b3f9301911"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-triangle Mobius band.  <a href="group__triangulation.html#ga4d94c206a8df611ae9ccb1b3f9301911">More...</a><br /></td></tr>
<tr class="separator:ga4d94c206a8df611ae9ccb1b3f9301911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd184660c001d3ae15322d7310e73e67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gacd184660c001d3ae15322d7310e73e67">regina::Example&lt; 2 &gt;::torus</a> ()</td></tr>
<tr class="memdesc:gacd184660c001d3ae15322d7310e73e67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle torus.  <a href="group__triangulation.html#gacd184660c001d3ae15322d7310e73e67">More...</a><br /></td></tr>
<tr class="separator:gacd184660c001d3ae15322d7310e73e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24271cded8848b5e7405d2a23a351de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa24271cded8848b5e7405d2a23a351de">regina::Example&lt; 2 &gt;::rp2</a> ()</td></tr>
<tr class="memdesc:gaa24271cded8848b5e7405d2a23a351de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle projective plane.  <a href="group__triangulation.html#gaa24271cded8848b5e7405d2a23a351de">More...</a><br /></td></tr>
<tr class="separator:gaa24271cded8848b5e7405d2a23a351de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084b60597c7d2b153251e4c80fd2f493"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga084b60597c7d2b153251e4c80fd2f493">regina::Example&lt; 2 &gt;::kb</a> ()</td></tr>
<tr class="memdesc:ga084b60597c7d2b153251e4c80fd2f493"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle Klein bottle.  <a href="group__triangulation.html#ga084b60597c7d2b153251e4c80fd2f493">More...</a><br /></td></tr>
<tr class="separator:ga084b60597c7d2b153251e4c80fd2f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6889651af52cb3675599b58a3aa224d1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga6889651af52cb3675599b58a3aa224d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga6889651af52cb3675599b58a3aa224d1">regina::faceOppositeEdge</a> (int i, int j)</td></tr>
<tr class="memdesc:ga6889651af52cb3675599b58a3aa224d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the (<em>dim</em>-2)-face number that is opposite the edge joining vertices <em>i</em> and <em>j</em> in a <em>dim</em>-dimensional simplex.  <a href="group__triangulation.html#ga6889651af52cb3675599b58a3aa224d1">More...</a><br /></td></tr>
<tr class="separator:ga6889651af52cb3675599b58a3aa224d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a83e60ddcf6dc24a1099f4c47353c1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga8a83e60ddcf6dc24a1099f4c47353c1f">regina::FacePair::FacePair</a> ()</td></tr>
<tr class="memdesc:ga8a83e60ddcf6dc24a1099f4c47353c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new face pair (0,1).  <a href="group__triangulation.html#ga8a83e60ddcf6dc24a1099f4c47353c1f">More...</a><br /></td></tr>
<tr class="separator:ga8a83e60ddcf6dc24a1099f4c47353c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91edc60bc3adda408908fe2deb2cc505"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga91edc60bc3adda408908fe2deb2cc505">regina::FacePair::FacePair</a> (int newFirst, int newSecond)</td></tr>
<tr class="memdesc:ga91edc60bc3adda408908fe2deb2cc505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new face pair from the two given face numbers.  <a href="group__triangulation.html#ga91edc60bc3adda408908fe2deb2cc505">More...</a><br /></td></tr>
<tr class="separator:ga91edc60bc3adda408908fe2deb2cc505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4f31581ca4c0b0101ec9010ff04df3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5e4f31581ca4c0b0101ec9010ff04df3">regina::FacePair::FacePair</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga5e4f31581ca4c0b0101ec9010ff04df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new face pair that is a clone of the given pair.  <a href="group__triangulation.html#ga5e4f31581ca4c0b0101ec9010ff04df3">More...</a><br /></td></tr>
<tr class="separator:ga5e4f31581ca4c0b0101ec9010ff04df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49df6b0caddae2da8425a7b8d4994b28"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga49df6b0caddae2da8425a7b8d4994b28">regina::FacePair::lower</a> () const</td></tr>
<tr class="memdesc:ga49df6b0caddae2da8425a7b8d4994b28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smaller of the two face numbers in this pair.  <a href="group__triangulation.html#ga49df6b0caddae2da8425a7b8d4994b28">More...</a><br /></td></tr>
<tr class="separator:ga49df6b0caddae2da8425a7b8d4994b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90847033b2a6b2300692ace623087ef5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga90847033b2a6b2300692ace623087ef5">regina::FacePair::upper</a> () const</td></tr>
<tr class="memdesc:ga90847033b2a6b2300692ace623087ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the larger of the two face numbers in this pair.  <a href="group__triangulation.html#ga90847033b2a6b2300692ace623087ef5">More...</a><br /></td></tr>
<tr class="separator:ga90847033b2a6b2300692ace623087ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef2c5c9d95b2409cdb1d19f789e0088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gacef2c5c9d95b2409cdb1d19f789e0088">regina::FacePair::isBeforeStart</a> () const</td></tr>
<tr class="memdesc:gacef2c5c9d95b2409cdb1d19f789e0088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face pair represents a before-the-start value.  <a href="group__triangulation.html#gacef2c5c9d95b2409cdb1d19f789e0088">More...</a><br /></td></tr>
<tr class="separator:gacef2c5c9d95b2409cdb1d19f789e0088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9d0d86d7587d25d2c9c88f3c04c948"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gada9d0d86d7587d25d2c9c88f3c04c948">regina::FacePair::isPastEnd</a> () const</td></tr>
<tr class="memdesc:gada9d0d86d7587d25d2c9c88f3c04c948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face pair represents a past-the-end value.  <a href="group__triangulation.html#gada9d0d86d7587d25d2c9c88f3c04c948">More...</a><br /></td></tr>
<tr class="separator:gada9d0d86d7587d25d2c9c88f3c04c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437fd5d91d38a9cc454b9ad53bffec3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga437fd5d91d38a9cc454b9ad53bffec3b">regina::FacePair::complement</a> () const</td></tr>
<tr class="memdesc:ga437fd5d91d38a9cc454b9ad53bffec3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complement of this face pair.  <a href="group__triangulation.html#ga437fd5d91d38a9cc454b9ad53bffec3b">More...</a><br /></td></tr>
<tr class="separator:ga437fd5d91d38a9cc454b9ad53bffec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2302e4b8cca31a3843058c2fa0e34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaec2302e4b8cca31a3843058c2fa0e34f">regina::FacePair::operator=</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gaec2302e4b8cca31a3843058c2fa0e34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this face pair to be a copy of the given pair.  <a href="group__triangulation.html#gaec2302e4b8cca31a3843058c2fa0e34f">More...</a><br /></td></tr>
<tr class="separator:gaec2302e4b8cca31a3843058c2fa0e34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f17f05c97615be65f67fef43c5ed40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad9f17f05c97615be65f67fef43c5ed40">regina::FacePair::operator==</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:gad9f17f05c97615be65f67fef43c5ed40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given face pair are equal.  <a href="group__triangulation.html#gad9f17f05c97615be65f67fef43c5ed40">More...</a><br /></td></tr>
<tr class="separator:gad9f17f05c97615be65f67fef43c5ed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bf3670cc5420659dd8da140a804ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gac1bf3670cc5420659dd8da140a804ead">regina::FacePair::operator!=</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:gac1bf3670cc5420659dd8da140a804ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given face pair are not equal.  <a href="group__triangulation.html#gac1bf3670cc5420659dd8da140a804ead">More...</a><br /></td></tr>
<tr class="separator:gac1bf3670cc5420659dd8da140a804ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79340c829625fd15dc7651c510a6c831"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga79340c829625fd15dc7651c510a6c831">regina::FacePair::operator&lt;</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:ga79340c829625fd15dc7651c510a6c831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than the given face pair.  <a href="group__triangulation.html#ga79340c829625fd15dc7651c510a6c831">More...</a><br /></td></tr>
<tr class="separator:ga79340c829625fd15dc7651c510a6c831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa54262654a989e8ca964f88bf8d162"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga1fa54262654a989e8ca964f88bf8d162">regina::FacePair::operator&gt;</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:ga1fa54262654a989e8ca964f88bf8d162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is greater than the given face pair.  <a href="group__triangulation.html#ga1fa54262654a989e8ca964f88bf8d162">More...</a><br /></td></tr>
<tr class="separator:ga1fa54262654a989e8ca964f88bf8d162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad647b24db98c0f783862b2d3c2396bdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad647b24db98c0f783862b2d3c2396bdd">regina::FacePair::operator&lt;=</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:gad647b24db98c0f783862b2d3c2396bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than or equal to the given face pair.  <a href="group__triangulation.html#gad647b24db98c0f783862b2d3c2396bdd">More...</a><br /></td></tr>
<tr class="separator:gad647b24db98c0f783862b2d3c2396bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994c28722d7450c1df4728a44f178923"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga994c28722d7450c1df4728a44f178923">regina::FacePair::operator&gt;=</a> (const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;other) const</td></tr>
<tr class="memdesc:ga994c28722d7450c1df4728a44f178923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is greater than or equal to the given face pair.  <a href="group__triangulation.html#ga994c28722d7450c1df4728a44f178923">More...</a><br /></td></tr>
<tr class="separator:ga994c28722d7450c1df4728a44f178923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23deb042ad632bef8f9cc0bd1359f9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga23deb042ad632bef8f9cc0bd1359f9b8">regina::FacePair::operator++</a> ()</td></tr>
<tr class="memdesc:ga23deb042ad632bef8f9cc0bd1359f9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this face pair.  <a href="group__triangulation.html#ga23deb042ad632bef8f9cc0bd1359f9b8">More...</a><br /></td></tr>
<tr class="separator:ga23deb042ad632bef8f9cc0bd1359f9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9939a7721e0a824c3f68d08836f1fc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga9939a7721e0a824c3f68d08836f1fc13">regina::FacePair::operator++</a> (int)</td></tr>
<tr class="memdesc:ga9939a7721e0a824c3f68d08836f1fc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this face pair.  <a href="group__triangulation.html#ga9939a7721e0a824c3f68d08836f1fc13">More...</a><br /></td></tr>
<tr class="separator:ga9939a7721e0a824c3f68d08836f1fc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5646e1705ca8c2c86f3ada5a0c3eb7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5646e1705ca8c2c86f3ada5a0c3eb7d6">regina::FacePair::operator--</a> ()</td></tr>
<tr class="memdesc:ga5646e1705ca8c2c86f3ada5a0c3eb7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this face pair.  <a href="group__triangulation.html#ga5646e1705ca8c2c86f3ada5a0c3eb7d6">More...</a><br /></td></tr>
<tr class="separator:ga5646e1705ca8c2c86f3ada5a0c3eb7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651bfa48591b0dfd381bcc8a061442f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga651bfa48591b0dfd381bcc8a061442f2">regina::FacePair::operator--</a> (int)</td></tr>
<tr class="memdesc:ga651bfa48591b0dfd381bcc8a061442f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this face pair.  <a href="group__triangulation.html#ga651bfa48591b0dfd381bcc8a061442f2">More...</a><br /></td></tr>
<tr class="separator:ga651bfa48591b0dfd381bcc8a061442f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe200cb708782c906744c2f5cb6f5d9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga7fe200cb708782c906744c2f5cb6f5d9">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;pair)</td></tr>
<tr class="memdesc:ga7fe200cb708782c906744c2f5cb6f5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given face pair to the given output stream.  <a href="group__triangulation.html#ga7fe200cb708782c906744c2f5cb6f5d9">More...</a><br /></td></tr>
<tr class="separator:ga7fe200cb708782c906744c2f5cb6f5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6eeacae3f9549ff06629ba71ceeb2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa6eeacae3f9549ff06629ba71ceeb2f5">regina::FacetPairing&lt; 3 &gt;::FacetPairing</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gaa6eeacae3f9549ff06629ba71ceeb2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new face pairing that is a clone of the given face pairing.  <a href="group__triangulation.html#gaa6eeacae3f9549ff06629ba71ceeb2f5">More...</a><br /></td></tr>
<tr class="separator:gaa6eeacae3f9549ff06629ba71ceeb2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb73123d32e9414cca6d7770cd2cf55f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gabb73123d32e9414cca6d7770cd2cf55f">regina::FacetPairing&lt; 3 &gt;::FacetPairing</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:gabb73123d32e9414cca6d7770cd2cf55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the face pairing of the given 3-manifold triangulation.  <a href="group__triangulation.html#gabb73123d32e9414cca6d7770cd2cf55f">More...</a><br /></td></tr>
<tr class="separator:gabb73123d32e9414cca6d7770cd2cf55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361ee550f483502a40ceed28f8ba93e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0">regina::FacetPairing&lt; 3 &gt;::followChain</a> (size_t &amp;tet, <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;faces) const</td></tr>
<tr class="memdesc:ga361ee550f483502a40ceed28f8ba93e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follows a chain as far as possible from the given point.  <a href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0">More...</a><br /></td></tr>
<tr class="separator:ga361ee550f483502a40ceed28f8ba93e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde7a8ad187d9bc3492105abf93f78e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gacde7a8ad187d9bc3492105abf93f78e7">regina::FacetPairing&lt; 3 &gt;::hasTripleEdge</a> () const</td></tr>
<tr class="memdesc:gacde7a8ad187d9bc3492105abf93f78e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a triple edge.  <a href="group__triangulation.html#gacde7a8ad187d9bc3492105abf93f78e7">More...</a><br /></td></tr>
<tr class="separator:gacde7a8ad187d9bc3492105abf93f78e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bda748de730da86e2c1032b9d7c5b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga1bda748de730da86e2c1032b9d7c5b14">regina::FacetPairing&lt; 3 &gt;::hasBrokenDoubleEndedChain</a> () const</td></tr>
<tr class="memdesc:ga1bda748de730da86e2c1032b9d7c5b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a broken double-ended chain.  <a href="group__triangulation.html#ga1bda748de730da86e2c1032b9d7c5b14">More...</a><br /></td></tr>
<tr class="separator:ga1bda748de730da86e2c1032b9d7c5b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b219eac1d9a0a0495488dd5ca99e038"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga3b219eac1d9a0a0495488dd5ca99e038">regina::FacetPairing&lt; 3 &gt;::hasOneEndedChainWithDoubleHandle</a> () const</td></tr>
<tr class="memdesc:ga3b219eac1d9a0a0495488dd5ca99e038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a one-ended chain with a double handle.  <a href="group__triangulation.html#ga3b219eac1d9a0a0495488dd5ca99e038">More...</a><br /></td></tr>
<tr class="separator:ga3b219eac1d9a0a0495488dd5ca99e038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827125a7939e2bf95a4cf57f02e7142c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga827125a7939e2bf95a4cf57f02e7142c">regina::FacetPairing&lt; 3 &gt;::hasWedgedDoubleEndedChain</a> () const</td></tr>
<tr class="memdesc:ga827125a7939e2bf95a4cf57f02e7142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a wedged double-ended chain.  <a href="group__triangulation.html#ga827125a7939e2bf95a4cf57f02e7142c">More...</a><br /></td></tr>
<tr class="separator:ga827125a7939e2bf95a4cf57f02e7142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372e9f00039b11782a3af1638d2122fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga372e9f00039b11782a3af1638d2122fd">regina::FacetPairing&lt; 3 &gt;::hasOneEndedChainWithStrayBigon</a> () const</td></tr>
<tr class="memdesc:ga372e9f00039b11782a3af1638d2122fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a one-ended chain with a stray bigon.  <a href="group__triangulation.html#ga372e9f00039b11782a3af1638d2122fd">More...</a><br /></td></tr>
<tr class="separator:ga372e9f00039b11782a3af1638d2122fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd526b75d1a1531af9a3932d4beec9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga1bd526b75d1a1531af9a3932d4beec9b">regina::FacetPairing&lt; 3 &gt;::hasTripleOneEndedChain</a> () const</td></tr>
<tr class="memdesc:ga1bd526b75d1a1531af9a3932d4beec9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a triple one-ended chain.  <a href="group__triangulation.html#ga1bd526b75d1a1531af9a3932d4beec9b">More...</a><br /></td></tr>
<tr class="separator:ga1bd526b75d1a1531af9a3932d4beec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2711bf8d99861f34dd759a833e4f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gace2711bf8d99861f34dd759a833e4f1a">regina::FacetPairing&lt; 3 &gt;::hasSingleStar</a> () const</td></tr>
<tr class="memdesc:gace2711bf8d99861f34dd759a833e4f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a single-edged star.  <a href="group__triangulation.html#gace2711bf8d99861f34dd759a833e4f1a">More...</a><br /></td></tr>
<tr class="separator:gace2711bf8d99861f34dd759a833e4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0b3a332ec4f0f7c5646e535894a0a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaca0b3a332ec4f0f7c5646e535894a0a5">regina::FacetPairing&lt; 3 &gt;::hasDoubleStar</a> () const</td></tr>
<tr class="memdesc:gaca0b3a332ec4f0f7c5646e535894a0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a double-edged star.  <a href="group__triangulation.html#gaca0b3a332ec4f0f7c5646e535894a0a5">More...</a><br /></td></tr>
<tr class="separator:gaca0b3a332ec4f0f7c5646e535894a0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b06b27853306a94eaf57b6ff72cdd04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5b06b27853306a94eaf57b6ff72cdd04">regina::FacetPairing&lt; 3 &gt;::hasDoubleSquare</a> () const</td></tr>
<tr class="memdesc:ga5b06b27853306a94eaf57b6ff72cdd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a double-edged square.  <a href="group__triangulation.html#ga5b06b27853306a94eaf57b6ff72cdd04">More...</a><br /></td></tr>
<tr class="separator:ga5b06b27853306a94eaf57b6ff72cdd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29701d0511868d6755dfcf13ab53314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad29701d0511868d6755dfcf13ab53314">regina::FacetSpec&lt; dim &gt;::FacetSpec</a> ()</td></tr>
<tr class="memdesc:gad29701d0511868d6755dfcf13ab53314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier with no initialisation.  <a href="group__triangulation.html#gad29701d0511868d6755dfcf13ab53314">More...</a><br /></td></tr>
<tr class="separator:gad29701d0511868d6755dfcf13ab53314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f0750bebaab41fea22a9c24a8cd0b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa4f0750bebaab41fea22a9c24a8cd0b3">regina::FacetSpec&lt; dim &gt;::FacetSpec</a> (int newSimp, int newFacet)</td></tr>
<tr class="memdesc:gaa4f0750bebaab41fea22a9c24a8cd0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier referring to the given facet of the given simplex.  <a href="group__triangulation.html#gaa4f0750bebaab41fea22a9c24a8cd0b3">More...</a><br /></td></tr>
<tr class="separator:gaa4f0750bebaab41fea22a9c24a8cd0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7af8dcff95510cb4056ecf0739ce1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga8d7af8dcff95510cb4056ecf0739ce1d">regina::FacetSpec&lt; dim &gt;::FacetSpec</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga8d7af8dcff95510cb4056ecf0739ce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier referring to the same simplex facet as the given specifier.  <a href="group__triangulation.html#ga8d7af8dcff95510cb4056ecf0739ce1d">More...</a><br /></td></tr>
<tr class="separator:ga8d7af8dcff95510cb4056ecf0739ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f49fbc941f1150c7109c7b2aedfe08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08">regina::FacetSpec&lt; dim &gt;::isBoundary</a> (size_t nSimplices) const</td></tr>
<tr class="memdesc:gaa8f49fbc941f1150c7109c7b2aedfe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents the overall boundary.  <a href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08">More...</a><br /></td></tr>
<tr class="separator:gaa8f49fbc941f1150c7109c7b2aedfe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba86c41b32df4f5750ffc36d1ddf3968"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaba86c41b32df4f5750ffc36d1ddf3968">regina::FacetSpec&lt; dim &gt;::isBeforeStart</a> () const</td></tr>
<tr class="memdesc:gaba86c41b32df4f5750ffc36d1ddf3968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents a before-the-start value.  <a href="group__triangulation.html#gaba86c41b32df4f5750ffc36d1ddf3968">More...</a><br /></td></tr>
<tr class="separator:gaba86c41b32df4f5750ffc36d1ddf3968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921b515966451ca7408c09c32a497fbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga921b515966451ca7408c09c32a497fbb">regina::FacetSpec&lt; dim &gt;::isPastEnd</a> (size_t nSimplices, bool boundaryAlso) const</td></tr>
<tr class="memdesc:ga921b515966451ca7408c09c32a497fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents a past-the-end value.  <a href="group__triangulation.html#ga921b515966451ca7408c09c32a497fbb">More...</a><br /></td></tr>
<tr class="separator:ga921b515966451ca7408c09c32a497fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cee2bae3a73929183a3ff2684500b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga4cee2bae3a73929183a3ff2684500b57">regina::FacetSpec&lt; dim &gt;::setFirst</a> ()</td></tr>
<tr class="memdesc:ga4cee2bae3a73929183a3ff2684500b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the first facet of the first simplex.  <a href="group__triangulation.html#ga4cee2bae3a73929183a3ff2684500b57">More...</a><br /></td></tr>
<tr class="separator:ga4cee2bae3a73929183a3ff2684500b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef773e92a8bb7deb185cd5a9bdaad44c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaef773e92a8bb7deb185cd5a9bdaad44c">regina::FacetSpec&lt; dim &gt;::setBoundary</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:gaef773e92a8bb7deb185cd5a9bdaad44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the overall boundary.  <a href="group__triangulation.html#gaef773e92a8bb7deb185cd5a9bdaad44c">More...</a><br /></td></tr>
<tr class="separator:gaef773e92a8bb7deb185cd5a9bdaad44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488b419491ef1fdc272ae194371b3014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga488b419491ef1fdc272ae194371b3014">regina::FacetSpec&lt; dim &gt;::setBeforeStart</a> ()</td></tr>
<tr class="memdesc:ga488b419491ef1fdc272ae194371b3014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to before-the-start.  <a href="group__triangulation.html#ga488b419491ef1fdc272ae194371b3014">More...</a><br /></td></tr>
<tr class="separator:ga488b419491ef1fdc272ae194371b3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd803a508697b9c808b40a3238b677e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gadd803a508697b9c808b40a3238b677e6">regina::FacetSpec&lt; dim &gt;::setPastEnd</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:gadd803a508697b9c808b40a3238b677e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to past-the-end.  <a href="group__triangulation.html#gadd803a508697b9c808b40a3238b677e6">More...</a><br /></td></tr>
<tr class="separator:gadd803a508697b9c808b40a3238b677e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc3f911db9bebfef4cb5ccb4c1ba510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gabdc3f911db9bebfef4cb5ccb4c1ba510">regina::FacetSpec&lt; dim &gt;::operator=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other)=default</td></tr>
<tr class="memdesc:gabdc3f911db9bebfef4cb5ccb4c1ba510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the value of the given specifier.  <a href="group__triangulation.html#gabdc3f911db9bebfef4cb5ccb4c1ba510">More...</a><br /></td></tr>
<tr class="separator:gabdc3f911db9bebfef4cb5ccb4c1ba510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572447ee1d803cbeb4a7fea712df837d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga572447ee1d803cbeb4a7fea712df837d">regina::FacetSpec&lt; dim &gt;::operator++</a> ()</td></tr>
<tr class="memdesc:ga572447ee1d803cbeb4a7fea712df837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this specifier.  <a href="group__triangulation.html#ga572447ee1d803cbeb4a7fea712df837d">More...</a><br /></td></tr>
<tr class="separator:ga572447ee1d803cbeb4a7fea712df837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1eb127387295a5e50e5f7e0ee979860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaf1eb127387295a5e50e5f7e0ee979860">regina::FacetSpec&lt; dim &gt;::operator++</a> (int)</td></tr>
<tr class="memdesc:gaf1eb127387295a5e50e5f7e0ee979860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this specifier.  <a href="group__triangulation.html#gaf1eb127387295a5e50e5f7e0ee979860">More...</a><br /></td></tr>
<tr class="separator:gaf1eb127387295a5e50e5f7e0ee979860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54580334365153f454be61d07c69a817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga54580334365153f454be61d07c69a817">regina::FacetSpec&lt; dim &gt;::operator--</a> ()</td></tr>
<tr class="memdesc:ga54580334365153f454be61d07c69a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this specifier.  <a href="group__triangulation.html#ga54580334365153f454be61d07c69a817">More...</a><br /></td></tr>
<tr class="separator:ga54580334365153f454be61d07c69a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefeb4f4f4b195476519ff4e4bb215a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaeefeb4f4f4b195476519ff4e4bb215a6">regina::FacetSpec&lt; dim &gt;::operator--</a> (int)</td></tr>
<tr class="memdesc:gaeefeb4f4f4b195476519ff4e4bb215a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this specifier.  <a href="group__triangulation.html#gaeefeb4f4f4b195476519ff4e4bb215a6">More...</a><br /></td></tr>
<tr class="separator:gaeefeb4f4f4b195476519ff4e4bb215a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748faf43c3c94c3e035cb77d34d5dd9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga748faf43c3c94c3e035cb77d34d5dd9f">regina::FacetSpec&lt; dim &gt;::operator==</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga748faf43c3c94c3e035cb77d34d5dd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given specifier are identical.  <a href="group__triangulation.html#ga748faf43c3c94c3e035cb77d34d5dd9f">More...</a><br /></td></tr>
<tr class="separator:ga748faf43c3c94c3e035cb77d34d5dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa44f091e013edb34324aa69ef149cba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa44f091e013edb34324aa69ef149cba1">regina::FacetSpec&lt; dim &gt;::operator!=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:gaa44f091e013edb34324aa69ef149cba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given specifier are not identical.  <a href="group__triangulation.html#gaa44f091e013edb34324aa69ef149cba1">More...</a><br /></td></tr>
<tr class="separator:gaa44f091e013edb34324aa69ef149cba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171b03ac5fffd3a8096fb38a8a0463a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga171b03ac5fffd3a8096fb38a8a0463a8">regina::FacetSpec&lt; dim &gt;::operator&lt;</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga171b03ac5fffd3a8096fb38a8a0463a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than the given specifier.  <a href="group__triangulation.html#ga171b03ac5fffd3a8096fb38a8a0463a8">More...</a><br /></td></tr>
<tr class="separator:ga171b03ac5fffd3a8096fb38a8a0463a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0477f547607c4b7011f33c098953d8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga0477f547607c4b7011f33c098953d8e8">regina::FacetSpec&lt; dim &gt;::operator&lt;=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga0477f547607c4b7011f33c098953d8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than or equal to the given specifier.  <a href="group__triangulation.html#ga0477f547607c4b7011f33c098953d8e8">More...</a><br /></td></tr>
<tr class="separator:ga0477f547607c4b7011f33c098953d8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6724c5b71f83afa5ea8be4068a0a02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga5a6724c5b71f83afa5ea8be4068a0a02"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5a6724c5b71f83afa5ea8be4068a0a02">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;spec)</td></tr>
<tr class="memdesc:ga5a6724c5b71f83afa5ea8be4068a0a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given facet specifier to the given output stream.  <a href="group__triangulation.html#ga5a6724c5b71f83afa5ea8be4068a0a02">More...</a><br /></td></tr>
<tr class="separator:ga5a6724c5b71f83afa5ea8be4068a0a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd309da07d43b92f8ccbe059fb022365"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gabd309da07d43b92f8ccbe059fb022365">regina::HomologicalData::SortedArray::SortedArray</a> ()</td></tr>
<tr class="memdesc:gabd309da07d43b92f8ccbe059fb022365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty array.  <a href="group__triangulation.html#gabd309da07d43b92f8ccbe059fb022365">More...</a><br /></td></tr>
<tr class="separator:gabd309da07d43b92f8ccbe059fb022365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028261be9190f5d1ecb649d23898fd48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga028261be9190f5d1ecb649d23898fd48">regina::HomologicalData::SortedArray::SortedArray</a> (const SortedArray &amp;)=default</td></tr>
<tr class="memdesc:ga028261be9190f5d1ecb649d23898fd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a clone of the given array.  <a href="group__triangulation.html#ga028261be9190f5d1ecb649d23898fd48">More...</a><br /></td></tr>
<tr class="separator:ga028261be9190f5d1ecb649d23898fd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27391304b84c0a67e52a0dffab7ab1d"><td class="memItemLeft" align="right" valign="top">SortedArray &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gae27391304b84c0a67e52a0dffab7ab1d">regina::HomologicalData::SortedArray::operator=</a> (const SortedArray &amp;)=default</td></tr>
<tr class="memdesc:gae27391304b84c0a67e52a0dffab7ab1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to a clone of the given array.  <a href="group__triangulation.html#gae27391304b84c0a67e52a0dffab7ab1d">More...</a><br /></td></tr>
<tr class="separator:gae27391304b84c0a67e52a0dffab7ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40affc338686fe21d7372a07e642df15"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga40affc338686fe21d7372a07e642df15">regina::HomologicalData::SortedArray::size</a> () const</td></tr>
<tr class="memdesc:ga40affc338686fe21d7372a07e642df15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this array.  <a href="group__triangulation.html#ga40affc338686fe21d7372a07e642df15">More...</a><br /></td></tr>
<tr class="separator:ga40affc338686fe21d7372a07e642df15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f309e75b9f5aab2f11b892a7ac8b1c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gab5f309e75b9f5aab2f11b892a7ac8b1c">regina::HomologicalData::SortedArray::operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:gab5f309e75b9f5aab2f11b892a7ac8b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer at the given index in this array.  <a href="group__triangulation.html#gab5f309e75b9f5aab2f11b892a7ac8b1c">More...</a><br /></td></tr>
<tr class="separator:gab5f309e75b9f5aab2f11b892a7ac8b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa49912a90419122457ea742abf3733"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gacfa49912a90419122457ea742abf3733">regina::HomologicalData::SortedArray::index</a> (unsigned long value) const</td></tr>
<tr class="memdesc:gacfa49912a90419122457ea742abf3733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the given integer in this array.  <a href="group__triangulation.html#gacfa49912a90419122457ea742abf3733">More...</a><br /></td></tr>
<tr class="separator:gacfa49912a90419122457ea742abf3733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffe3cbb1f2c5bc07605abd6c69a9321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gabffe3cbb1f2c5bc07605abd6c69a9321">regina::HomologicalData::SortedArray::push_back</a> (unsigned long value)</td></tr>
<tr class="memdesc:gabffe3cbb1f2c5bc07605abd6c69a9321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given integer onto the end of this array.  <a href="group__triangulation.html#gabffe3cbb1f2c5bc07605abd6c69a9321">More...</a><br /></td></tr>
<tr class="separator:gabffe3cbb1f2c5bc07605abd6c69a9321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986db7609750e0957ba2b1f1badaa689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga986db7609750e0957ba2b1f1badaa689">regina::HomologicalData::HomologicalData</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;input)</td></tr>
<tr class="memdesc:ga986db7609750e0957ba2b1f1badaa689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes as input a triangulation.  <a href="group__triangulation.html#ga986db7609750e0957ba2b1f1badaa689">More...</a><br /></td></tr>
<tr class="separator:ga986db7609750e0957ba2b1f1badaa689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbccd4549afd30c75d7169610adecdb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gadbccd4549afd30c75d7169610adecdb8">regina::HomologicalData::HomologicalData</a> (const <a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a> &amp;h)</td></tr>
<tr class="memdesc:gadbccd4549afd30c75d7169610adecdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="group__triangulation.html#gadbccd4549afd30c75d7169610adecdb8">More...</a><br /></td></tr>
<tr class="separator:gadbccd4549afd30c75d7169610adecdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307c7ecaaccd31d0f6d0f886276cd074"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga307c7ecaaccd31d0f6d0f886276cd074">regina::HomologicalData::~HomologicalData</a> ()</td></tr>
<tr class="memdesc:ga307c7ecaaccd31d0f6d0f886276cd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="group__triangulation.html#ga307c7ecaaccd31d0f6d0f886276cd074">More...</a><br /></td></tr>
<tr class="separator:ga307c7ecaaccd31d0f6d0f886276cd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff98ccbba15e8fed20725f41511663d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaff98ccbba15e8fed20725f41511663d8">regina::HomologicalData::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaff98ccbba15e8fed20725f41511663d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__triangulation.html#gaff98ccbba15e8fed20725f41511663d8">More...</a><br /></td></tr>
<tr class="separator:gaff98ccbba15e8fed20725f41511663d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc149260561f8138938281b9a838b5d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gabc149260561f8138938281b9a838b5d6">regina::HomologicalData::homology</a> (unsigned q)</td></tr>
<tr class="memdesc:gabc149260561f8138938281b9a838b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine gives access to the manifold's homology computed with the regular CW-decomposition.  <a href="group__triangulation.html#gabc149260561f8138938281b9a838b5d6">More...</a><br /></td></tr>
<tr class="separator:gabc149260561f8138938281b9a838b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e4c0dff533a6dbef6167c9b50e3608"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaf8e4c0dff533a6dbef6167c9b50e3608">regina::HomologicalData::bdryHomology</a> (unsigned q)</td></tr>
<tr class="memdesc:gaf8e4c0dff533a6dbef6167c9b50e3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine gives access to the homology of the boundary of the manifold, computed with the regular CW-decomposition.  <a href="group__triangulation.html#gaf8e4c0dff533a6dbef6167c9b50e3608">More...</a><br /></td></tr>
<tr class="separator:gaf8e4c0dff533a6dbef6167c9b50e3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa80d88d74e7092ab75bd405f3d2be4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga2aa80d88d74e7092ab75bd405f3d2be4">regina::HomologicalData::bdryHomologyMap</a> (unsigned q)</td></tr>
<tr class="memdesc:ga2aa80d88d74e7092ab75bd405f3d2be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine gives access to the homomorphism from the homology of the boundary to the homology of the manifold.  <a href="group__triangulation.html#ga2aa80d88d74e7092ab75bd405f3d2be4">More...</a><br /></td></tr>
<tr class="separator:ga2aa80d88d74e7092ab75bd405f3d2be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04afa01579431203d94cf268c4940830"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga04afa01579431203d94cf268c4940830">regina::HomologicalData::dualHomology</a> (unsigned q)</td></tr>
<tr class="memdesc:ga04afa01579431203d94cf268c4940830"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine gives access to the manifold's homology computed with the dual CW-decomposition.  <a href="group__triangulation.html#ga04afa01579431203d94cf268c4940830">More...</a><br /></td></tr>
<tr class="separator:ga04afa01579431203d94cf268c4940830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94bb041603ecf51b92a68b9ce2deead"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gae94bb041603ecf51b92a68b9ce2deead">regina::HomologicalData::h1CellAp</a> ()</td></tr>
<tr class="memdesc:gae94bb041603ecf51b92a68b9ce2deead"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the isomorphism from dualHomology(1) to homology(1) given by a cellular approximation to the identity map on the manifold.  <a href="group__triangulation.html#gae94bb041603ecf51b92a68b9ce2deead">More...</a><br /></td></tr>
<tr class="separator:gae94bb041603ecf51b92a68b9ce2deead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d2df0dadbed328f33eb4500b00946bc"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5d2df0dadbed328f33eb4500b00946bc">regina::HomologicalData::countStandardCells</a> (unsigned dimension)</td></tr>
<tr class="memdesc:ga5d2df0dadbed328f33eb4500b00946bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the standard genuine CW-decomposition of the manifold.  <a href="group__triangulation.html#ga5d2df0dadbed328f33eb4500b00946bc">More...</a><br /></td></tr>
<tr class="separator:ga5d2df0dadbed328f33eb4500b00946bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5bc2ee7b0fdfda137f7159cc05ce57"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaab5bc2ee7b0fdfda137f7159cc05ce57">regina::HomologicalData::countDualCells</a> (unsigned dimension)</td></tr>
<tr class="memdesc:gaab5bc2ee7b0fdfda137f7159cc05ce57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the dual CW-decomposition of the manifold.  <a href="group__triangulation.html#gaab5bc2ee7b0fdfda137f7159cc05ce57">More...</a><br /></td></tr>
<tr class="separator:gaab5bc2ee7b0fdfda137f7159cc05ce57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe53a5fcd2506d4b4af91cf0dd2e1bc"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga0fe53a5fcd2506d4b4af91cf0dd2e1bc">regina::HomologicalData::countBdryCells</a> (unsigned dimension)</td></tr>
<tr class="memdesc:ga0fe53a5fcd2506d4b4af91cf0dd2e1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the standard CW-decomposition of the boundary of the manifold.  <a href="group__triangulation.html#ga0fe53a5fcd2506d4b4af91cf0dd2e1bc">More...</a><br /></td></tr>
<tr class="separator:ga0fe53a5fcd2506d4b4af91cf0dd2e1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada63e639a7df3ee88c88a69bca4b0058"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gada63e639a7df3ee88c88a69bca4b0058">regina::HomologicalData::eulerChar</a> ()</td></tr>
<tr class="memdesc:gada63e639a7df3ee88c88a69bca4b0058"><td class="mdescLeft">&#160;</td><td class="mdescRight">The proper Euler characteristic of the manifold, computed from the dual CW-decomposition.  <a href="group__triangulation.html#gada63e639a7df3ee88c88a69bca4b0058">More...</a><br /></td></tr>
<tr class="separator:gada63e639a7df3ee88c88a69bca4b0058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391792f07dd6c6ac7c8332b6f59788dc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, std::vector&lt; unsigned long &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga391792f07dd6c6ac7c8332b6f59788dc">regina::HomologicalData::torsionRankVector</a> ()</td></tr>
<tr class="memdesc:ga391792f07dd6c6ac7c8332b6f59788dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the torsion form rank vector.  <a href="group__triangulation.html#ga391792f07dd6c6ac7c8332b6f59788dc">More...</a><br /></td></tr>
<tr class="separator:ga391792f07dd6c6ac7c8332b6f59788dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9020bc0a0f506abda7363e6642cf3c06"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga9020bc0a0f506abda7363e6642cf3c06">regina::HomologicalData::torsionRankVectorString</a> ()</td></tr>
<tr class="memdesc:ga9020bc0a0f506abda7363e6642cf3c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__triangulation.html#ga391792f07dd6c6ac7c8332b6f59788dc" title="Returns the torsion form rank vector.">torsionRankVector()</a> but returns as a human-readable string.  <a href="group__triangulation.html#ga9020bc0a0f506abda7363e6642cf3c06">More...</a><br /></td></tr>
<tr class="separator:ga9020bc0a0f506abda7363e6642cf3c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10c1028861c4f198147557e5cbdaad3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad10c1028861c4f198147557e5cbdaad3">regina::HomologicalData::torsionSigmaVector</a> ()</td></tr>
<tr class="memdesc:gad10c1028861c4f198147557e5cbdaad3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 2-torsion sigma vector.  <a href="group__triangulation.html#gad10c1028861c4f198147557e5cbdaad3">More...</a><br /></td></tr>
<tr class="separator:gad10c1028861c4f198147557e5cbdaad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3054d736240904b1831b84da81aef8d9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga3054d736240904b1831b84da81aef8d9">regina::HomologicalData::torsionSigmaVectorString</a> ()</td></tr>
<tr class="memdesc:ga3054d736240904b1831b84da81aef8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__triangulation.html#gad10c1028861c4f198147557e5cbdaad3" title="Returns the 2-torsion sigma vector.">torsionSigmaVector()</a> but returns as a human-readable string.  <a href="group__triangulation.html#ga3054d736240904b1831b84da81aef8d9">More...</a><br /></td></tr>
<tr class="separator:ga3054d736240904b1831b84da81aef8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bc618d73869c4aac5ffb14c3d7ecf2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, std::vector&lt; int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gae4bc618d73869c4aac5ffb14c3d7ecf2">regina::HomologicalData::torsionLegendreSymbolVector</a> ()</td></tr>
<tr class="memdesc:gae4bc618d73869c4aac5ffb14c3d7ecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the odd p-torsion Legendre symbol vector.  <a href="group__triangulation.html#gae4bc618d73869c4aac5ffb14c3d7ecf2">More...</a><br /></td></tr>
<tr class="separator:gae4bc618d73869c4aac5ffb14c3d7ecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1283cc606f9ccc0b9192fd5616e2790c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga1283cc606f9ccc0b9192fd5616e2790c">regina::HomologicalData::torsionLegendreSymbolVectorString</a> ()</td></tr>
<tr class="memdesc:ga1283cc606f9ccc0b9192fd5616e2790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__triangulation.html#gae4bc618d73869c4aac5ffb14c3d7ecf2" title="Returns the odd p-torsion Legendre symbol vector.">torsionLegendreSymbolVector()</a> but returns as a human-readable string.  <a href="group__triangulation.html#ga1283cc606f9ccc0b9192fd5616e2790c">More...</a><br /></td></tr>
<tr class="separator:ga1283cc606f9ccc0b9192fd5616e2790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38599047d12bc7e999b197ef0db55965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga38599047d12bc7e999b197ef0db55965">regina::HomologicalData::formIsHyperbolic</a> ()</td></tr>
<tr class="memdesc:ga38599047d12bc7e999b197ef0db55965"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff torsion linking form is &lsquo;hyperbolic&rsquo; in the linking-form sense of the word.  <a href="group__triangulation.html#ga38599047d12bc7e999b197ef0db55965">More...</a><br /></td></tr>
<tr class="separator:ga38599047d12bc7e999b197ef0db55965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae998e8c01036e360a8623a27489936f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gae998e8c01036e360a8623a27489936f7">regina::HomologicalData::formIsSplit</a> ()</td></tr>
<tr class="memdesc:gae998e8c01036e360a8623a27489936f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff the torsion linking form is split.  <a href="group__triangulation.html#gae998e8c01036e360a8623a27489936f7">More...</a><br /></td></tr>
<tr class="separator:gae998e8c01036e360a8623a27489936f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a6460d0e7fb71aaa7c366dd9c5ed86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaf4a6460d0e7fb71aaa7c366dd9c5ed86">regina::HomologicalData::formSatKK</a> ()</td></tr>
<tr class="memdesc:gaf4a6460d0e7fb71aaa7c366dd9c5ed86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff the torsion linking form satisfies the Kawauchi-Kojima 2-torsion condition.  <a href="group__triangulation.html#gaf4a6460d0e7fb71aaa7c366dd9c5ed86">More...</a><br /></td></tr>
<tr class="separator:gaf4a6460d0e7fb71aaa7c366dd9c5ed86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe81cf9fb4549e16a26c74ec25d780d5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gafe81cf9fb4549e16a26c74ec25d780d5">regina::HomologicalData::embeddabilityComment</a> ()</td></tr>
<tr class="memdesc:gafe81cf9fb4549e16a26c74ec25d780d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a comment on whether the manifold might embed in a homology 3-sphere or 4-sphere.  <a href="group__triangulation.html#gafe81cf9fb4549e16a26c74ec25d780d5">More...</a><br /></td></tr>
<tr class="separator:gafe81cf9fb4549e16a26c74ec25d780d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a62209c6bafb4ae202ea5af7ed9054"><td class="memItemLeft" align="right" valign="top"><a id="ga22a62209c6bafb4ae202ea5af7ed9054"></a>
<a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HomologicalData::operator=</b> (const <a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a> &amp;)=delete</td></tr>
<tr class="separator:ga22a62209c6bafb4ae202ea5af7ed9054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430867631ebaecf328d1609192fbc38c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga430867631ebaecf328d1609192fbc38c">regina::XMLTriangulationReader&lt; dim &gt;::XMLTriangulationReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga430867631ebaecf328d1609192fbc38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation reader.  <a href="group__triangulation.html#ga430867631ebaecf328d1609192fbc38c">More...</a><br /></td></tr>
<tr class="separator:ga430867631ebaecf328d1609192fbc38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee7f2cc5baf65eadc997d9e1408aa50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gafee7f2cc5baf65eadc997d9e1408aa50">regina::XMLTriangulationReader&lt; dim &gt;::startPropertySubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:gafee7f2cc5baf65eadc997d9e1408aa50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation.  <a href="group__triangulation.html#gafee7f2cc5baf65eadc997d9e1408aa50">More...</a><br /></td></tr>
<tr class="separator:gafee7f2cc5baf65eadc997d9e1408aa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad224fd1504559e98208a8dfa8eb1e43a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad224fd1504559e98208a8dfa8eb1e43a">regina::XMLTriangulationReader&lt; 2 &gt;::XMLTriangulationReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:gad224fd1504559e98208a8dfa8eb1e43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation reader.  <a href="group__triangulation.html#gad224fd1504559e98208a8dfa8eb1e43a">More...</a><br /></td></tr>
<tr class="separator:gad224fd1504559e98208a8dfa8eb1e43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fc3b4164b0fd901c6fd51b8e6084aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga72fc3b4164b0fd901c6fd51b8e6084aa">regina::XMLTriangulationReader&lt; 2 &gt;::startPropertySubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:ga72fc3b4164b0fd901c6fd51b8e6084aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation.  <a href="group__triangulation.html#ga72fc3b4164b0fd901c6fd51b8e6084aa">More...</a><br /></td></tr>
<tr class="separator:ga72fc3b4164b0fd901c6fd51b8e6084aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c36f0c743f0141ff54a19fcdb17ade"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga24c36f0c743f0141ff54a19fcdb17ade">regina::XMLTriangulationReader&lt; 3 &gt;::XMLTriangulationReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga24c36f0c743f0141ff54a19fcdb17ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation reader.  <a href="group__triangulation.html#ga24c36f0c743f0141ff54a19fcdb17ade">More...</a><br /></td></tr>
<tr class="separator:ga24c36f0c743f0141ff54a19fcdb17ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db6e37f29b9c271d47af6eef99c0fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga3db6e37f29b9c271d47af6eef99c0fff">regina::XMLTriangulationReader&lt; 3 &gt;::startPropertySubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:ga3db6e37f29b9c271d47af6eef99c0fff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation.  <a href="group__triangulation.html#ga3db6e37f29b9c271d47af6eef99c0fff">More...</a><br /></td></tr>
<tr class="separator:ga3db6e37f29b9c271d47af6eef99c0fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287350de6e977d479b11f0df6f31c55e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga287350de6e977d479b11f0df6f31c55e">regina::XMLTriangulationReader&lt; 4 &gt;::XMLTriangulationReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga287350de6e977d479b11f0df6f31c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation reader.  <a href="group__triangulation.html#ga287350de6e977d479b11f0df6f31c55e">More...</a><br /></td></tr>
<tr class="separator:ga287350de6e977d479b11f0df6f31c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db2f450c03ec469695a263eaba05f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga3db2f450c03ec469695a263eaba05f81">regina::XMLTriangulationReader&lt; 4 &gt;::startPropertySubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:ga3db2f450c03ec469695a263eaba05f81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation.  <a href="group__triangulation.html#ga3db2f450c03ec469695a263eaba05f81">More...</a><br /></td></tr>
<tr class="separator:ga3db2f450c03ec469695a263eaba05f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2697037b7441f2a126882fe861209d37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga2697037b7441f2a126882fe861209d37">regina::FacetSpec&lt; dim &gt;::simp</a></td></tr>
<tr class="memdesc:ga2697037b7441f2a126882fe861209d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplex referred to.  <a href="group__triangulation.html#ga2697037b7441f2a126882fe861209d37">More...</a><br /></td></tr>
<tr class="separator:ga2697037b7441f2a126882fe861209d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a68d576c23c475c65a9a4b2aef7ff95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5a68d576c23c475c65a9a4b2aef7ff95">regina::FacetSpec&lt; dim &gt;::facet</a></td></tr>
<tr class="memdesc:ga5a68d576c23c475c65a9a4b2aef7ff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet of the simplex referred to.  <a href="group__triangulation.html#ga5a68d576c23c475c65a9a4b2aef7ff95">More...</a><br /></td></tr>
<tr class="separator:ga5a68d576c23c475c65a9a4b2aef7ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga5a693e6ee9e5197cc258efca9bd1a9b7"><td class="memItemLeft" align="right" valign="top"><a id="ga5a693e6ee9e5197cc258efca9bd1a9b7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::FacetPairing&lt; 3 &gt;::detail::FacetPairingBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga5a693e6ee9e5197cc258efca9bd1a9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Closed Triangulations</h2></td></tr>
<tr class="memitem:ga82d83880a7a5ae6cccbc3703e1514875"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga82d83880a7a5ae6cccbc3703e1514875">regina::Example&lt; 3 &gt;::threeSphere</a> ()</td></tr>
<tr class="memdesc:ga82d83880a7a5ae6cccbc3703e1514875"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-tetrahedron triangulation of the 3-sphere.  <a href="group__triangulation.html#ga82d83880a7a5ae6cccbc3703e1514875">More...</a><br /></td></tr>
<tr class="separator:ga82d83880a7a5ae6cccbc3703e1514875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2510eb639214e287f9e70768238dd6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaaa2510eb639214e287f9e70768238dd6">regina::Example&lt; 3 &gt;::bingsHouse</a> ()</td></tr>
<tr class="memdesc:gaaa2510eb639214e287f9e70768238dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the two-tetrahedron triangulation of the 3-sphere that is dual to Bing's house with two rooms.  <a href="group__triangulation.html#gaaa2510eb639214e287f9e70768238dd6">More...</a><br /></td></tr>
<tr class="separator:gaaa2510eb639214e287f9e70768238dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61f654a7890f50a33d852358b8c5351"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gad61f654a7890f50a33d852358b8c5351">regina::Example&lt; 3 &gt;::s2xs1</a> ()</td></tr>
<tr class="memdesc:gad61f654a7890f50a33d852358b8c5351"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron triangulation of the product space <code>S^2 x S^1</code>.  <a href="group__triangulation.html#gad61f654a7890f50a33d852358b8c5351">More...</a><br /></td></tr>
<tr class="separator:gad61f654a7890f50a33d852358b8c5351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59882029efa17df29c9168ee33bc9ccd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga59882029efa17df29c9168ee33bc9ccd">regina::Example&lt; 3 &gt;::rp2xs1</a> ()</td></tr>
<tr class="memdesc:ga59882029efa17df29c9168ee33bc9ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-tetrahedron triangulation of the non-orientable product space <code>RP^2 x S^1</code>.  <a href="group__triangulation.html#ga59882029efa17df29c9168ee33bc9ccd">More...</a><br /></td></tr>
<tr class="separator:ga59882029efa17df29c9168ee33bc9ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464927e6ffa157b939740fb25d59e9aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga464927e6ffa157b939740fb25d59e9aa">regina::Example&lt; 3 &gt;::rp3rp3</a> ()</td></tr>
<tr class="memdesc:ga464927e6ffa157b939740fb25d59e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the connected sum <code>RP^3 # RP^3</code>.  <a href="group__triangulation.html#ga464927e6ffa157b939740fb25d59e9aa">More...</a><br /></td></tr>
<tr class="separator:ga464927e6ffa157b939740fb25d59e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7f5fdfa00b2500e424c42f6b2a9ce0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga2f7f5fdfa00b2500e424c42f6b2a9ce0">regina::Example&lt; 3 &gt;::lens</a> (size_t p, size_t q)</td></tr>
<tr class="memdesc:ga2f7f5fdfa00b2500e424c42f6b2a9ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the lens space <code>L(p,q)</code>.  <a href="group__triangulation.html#ga2f7f5fdfa00b2500e424c42f6b2a9ce0">More...</a><br /></td></tr>
<tr class="separator:ga2f7f5fdfa00b2500e424c42f6b2a9ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0076bf4f17cd5348b99d34348ef71dfb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga0076bf4f17cd5348b99d34348ef71dfb">regina::Example&lt; 3 &gt;::poincareHomologySphere</a> ()</td></tr>
<tr class="memdesc:ga0076bf4f17cd5348b99d34348ef71dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the five-tetrahedron triangulation of the Poincare homology sphere.  <a href="group__triangulation.html#ga0076bf4f17cd5348b99d34348ef71dfb">More...</a><br /></td></tr>
<tr class="separator:ga0076bf4f17cd5348b99d34348ef71dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2a2880d95c9c8894d22bce7eb25a8cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa2a2880d95c9c8894d22bce7eb25a8cd">regina::Example&lt; 3 &gt;::weeks</a> ()</td></tr>
<tr class="memdesc:gaa2a2880d95c9c8894d22bce7eb25a8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nine-tetrahedron minimal triangulation of the Weeks manifold.  <a href="group__triangulation.html#gaa2a2880d95c9c8894d22bce7eb25a8cd">More...</a><br /></td></tr>
<tr class="separator:gaa2a2880d95c9c8894d22bce7eb25a8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305cd2fb5a63a446a3516e536469be29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga305cd2fb5a63a446a3516e536469be29">regina::Example&lt; 3 &gt;::weberSeifert</a> ()</td></tr>
<tr class="memdesc:ga305cd2fb5a63a446a3516e536469be29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-vertex triangulation of the Weber-Seifert dodecahedral space.  <a href="group__triangulation.html#ga305cd2fb5a63a446a3516e536469be29">More...</a><br /></td></tr>
<tr class="separator:ga305cd2fb5a63a446a3516e536469be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948f7a47cafd266a1232fb6bf9d8ac92"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga948f7a47cafd266a1232fb6bf9d8ac92">regina::Example&lt; 3 &gt;::smallClosedOrblHyperbolic</a> ()</td></tr>
<tr class="memdesc:ga948f7a47cafd266a1232fb6bf9d8ac92"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the nine-tetrahedron closed orientable hyperbolic 3-manifold with volume 0.94270736.  <a href="group__triangulation.html#ga948f7a47cafd266a1232fb6bf9d8ac92">More...</a><br /></td></tr>
<tr class="separator:ga948f7a47cafd266a1232fb6bf9d8ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82197acebacc5603f4cfdecc519b2372"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga82197acebacc5603f4cfdecc519b2372">regina::Example&lt; 3 &gt;::smallClosedNonOrblHyperbolic</a> ()</td></tr>
<tr class="memdesc:ga82197acebacc5603f4cfdecc519b2372"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the eleven-tetrahedron closed non-orientable hyperbolic 3-manifold with volume 2.02988321.  <a href="group__triangulation.html#ga82197acebacc5603f4cfdecc519b2372">More...</a><br /></td></tr>
<tr class="separator:ga82197acebacc5603f4cfdecc519b2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6262c206ae0a147eab8a7b54842c693"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaf6262c206ae0a147eab8a7b54842c693">regina::Example&lt; 3 &gt;::sphere600</a> ()</td></tr>
<tr class="memdesc:gaf6262c206ae0a147eab8a7b54842c693"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary 3-sphere of the regular 600-cell.  <a href="group__triangulation.html#gaf6262c206ae0a147eab8a7b54842c693">More...</a><br /></td></tr>
<tr class="separator:gaf6262c206ae0a147eab8a7b54842c693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Finite Bounded Triangulations</h2></td></tr>
<tr class="memitem:ga6ca40e28f7379f33730a9134ddd7e127"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga6ca40e28f7379f33730a9134ddd7e127">regina::Example&lt; 3 &gt;::lst</a> (size_t a, size_t b)</td></tr>
<tr class="memdesc:ga6ca40e28f7379f33730a9134ddd7e127"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus <code>LST(a,b,c)</code>.  <a href="group__triangulation.html#ga6ca40e28f7379f33730a9134ddd7e127">More...</a><br /></td></tr>
<tr class="separator:ga6ca40e28f7379f33730a9134ddd7e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961cb443c5b6bdfd148931bd93c9f7c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga961cb443c5b6bdfd148931bd93c9f7c3">regina::Example&lt; 3 &gt;::solidKleinBottle</a> ()</td></tr>
<tr class="memdesc:ga961cb443c5b6bdfd148931bd93c9f7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the solid Klein bottle.  <a href="group__triangulation.html#ga961cb443c5b6bdfd148931bd93c9f7c3">More...</a><br /></td></tr>
<tr class="separator:ga961cb443c5b6bdfd148931bd93c9f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Ideal Triangulations</h2></td></tr>
<tr class="memitem:gafc20dc0c93677d15b551a25e6206e88d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gafc20dc0c93677d15b551a25e6206e88d">regina::Example&lt; 3 &gt;::figureEight</a> ()</td></tr>
<tr class="memdesc:gafc20dc0c93677d15b551a25e6206e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron ideal triangulation of the figure eight knot complement.  <a href="group__triangulation.html#gafc20dc0c93677d15b551a25e6206e88d">More...</a><br /></td></tr>
<tr class="separator:gafc20dc0c93677d15b551a25e6206e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc75b323f8dcf6b12c547044c1970e37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gadc75b323f8dcf6b12c547044c1970e37">regina::Example&lt; 3 &gt;::trefoil</a> ()</td></tr>
<tr class="memdesc:gadc75b323f8dcf6b12c547044c1970e37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron ideal triangulation of the trefoil knot complement.  <a href="group__triangulation.html#gadc75b323f8dcf6b12c547044c1970e37">More...</a><br /></td></tr>
<tr class="separator:gadc75b323f8dcf6b12c547044c1970e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf56d7888a5df6a20428c91f1898e60e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaaf56d7888a5df6a20428c91f1898e60e">regina::Example&lt; 3 &gt;::whiteheadLink</a> ()</td></tr>
<tr class="memdesc:gaaf56d7888a5df6a20428c91f1898e60e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-tetrahedron ideal triangulation of the Whitehead link complement.  <a href="group__triangulation.html#gaaf56d7888a5df6a20428c91f1898e60e">More...</a><br /></td></tr>
<tr class="separator:gaaf56d7888a5df6a20428c91f1898e60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6493f8eea568410c50d864730e1f72d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaa6493f8eea568410c50d864730e1f72d">regina::Example&lt; 3 &gt;::gieseking</a> ()</td></tr>
<tr class="memdesc:gaa6493f8eea568410c50d864730e1f72d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the one-tetrahedron ideal triangulation of the non-orientable Gieseking manifold.  <a href="group__triangulation.html#gaa6493f8eea568410c50d864730e1f72d">More...</a><br /></td></tr>
<tr class="separator:gaa6493f8eea568410c50d864730e1f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8ee855fa7dc7c2af3119619d37cbe7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaed8ee855fa7dc7c2af3119619d37cbe7">regina::Example&lt; 3 &gt;::cuspedGenusTwoTorus</a> ()</td></tr>
<tr class="memdesc:gaed8ee855fa7dc7c2af3119619d37cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of a solid genus two torus with a cusped boundary.  <a href="group__triangulation.html#gaed8ee855fa7dc7c2af3119619d37cbe7">More...</a><br /></td></tr>
<tr class="separator:gaed8ee855fa7dc7c2af3119619d37cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Closed Triangulations</h2></td></tr>
<tr class="memitem:ga229499e503960053a037c27724e6dd78"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga229499e503960053a037c27724e6dd78">regina::Example&lt; 4 &gt;::fourSphere</a> ()</td></tr>
<tr class="memdesc:ga229499e503960053a037c27724e6dd78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the 4-sphere.  <a href="group__triangulation.html#ga229499e503960053a037c27724e6dd78">More...</a><br /></td></tr>
<tr class="separator:ga229499e503960053a037c27724e6dd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ef0f8dfb29bca4ffe5b218ac6d0317"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga51ef0f8dfb29bca4ffe5b218ac6d0317">regina::Example&lt; 4 &gt;::simplicialFourSphere</a> ()</td></tr>
<tr class="memdesc:ga51ef0f8dfb29bca4ffe5b218ac6d0317"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the standard six-pentachoron triangulation of the 4-sphere as the boundary of a 5-simplex.  <a href="group__triangulation.html#ga51ef0f8dfb29bca4ffe5b218ac6d0317">More...</a><br /></td></tr>
<tr class="separator:ga51ef0f8dfb29bca4ffe5b218ac6d0317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed01a539c457b9f3192a7ab22656486"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga2ed01a539c457b9f3192a7ab22656486">regina::Example&lt; 4 &gt;::rp4</a> ()</td></tr>
<tr class="memdesc:ga2ed01a539c457b9f3192a7ab22656486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-pentachoron triangulation of real projective 4-space.  <a href="group__triangulation.html#ga2ed01a539c457b9f3192a7ab22656486">More...</a><br /></td></tr>
<tr class="separator:ga2ed01a539c457b9f3192a7ab22656486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b02ea2239dbf99cacc2f260ffacd480"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga9b02ea2239dbf99cacc2f260ffacd480">regina::Example&lt; 4 &gt;::s3xs1</a> ()</td></tr>
<tr class="memdesc:ga9b02ea2239dbf99cacc2f260ffacd480"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the product space <code>S^3 x S^1</code>.  <a href="group__triangulation.html#ga9b02ea2239dbf99cacc2f260ffacd480">More...</a><br /></td></tr>
<tr class="separator:ga9b02ea2239dbf99cacc2f260ffacd480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5328e86cbd0cb3c288a3c5208d1ce3f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5328e86cbd0cb3c288a3c5208d1ce3f7">regina::Example&lt; 4 &gt;::s3xs1Twisted</a> ()</td></tr>
<tr class="memdesc:ga5328e86cbd0cb3c288a3c5208d1ce3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the twisted product space <code>S^3 x~ S^1</code>.  <a href="group__triangulation.html#ga5328e86cbd0cb3c288a3c5208d1ce3f7">More...</a><br /></td></tr>
<tr class="separator:ga5328e86cbd0cb3c288a3c5208d1ce3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Ideal Triangulations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp96629c75c90040475641ef5d0feb0101"></a>(end: Closed Triangulations) </p>
</td></tr>
<tr class="memitem:gaf235e03602b241e316980bfbc78858f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#gaf235e03602b241e316980bfbc78858f3">regina::Example&lt; 4 &gt;::cappellShaneson</a> ()</td></tr>
<tr class="memdesc:gaf235e03602b241e316980bfbc78858f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of a Cappell-Shaneson 2-knot complement in the 4-sphere.  <a href="group__triangulation.html#gaf235e03602b241e316980bfbc78858f3">More...</a><br /></td></tr>
<tr class="separator:gaf235e03602b241e316980bfbc78858f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructions from 3-Manifold Triangulations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3f96c41ededa7e0fea390f47bef10008"></a>(end: Ideal Triangulations) </p>
</td></tr>
<tr class="memitem:ga5cc3bc3ba5e4eca69d1722bbb1a27e6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga5cc3bc3ba5e4eca69d1722bbb1a27e6c">regina::Example&lt; 4 &gt;::iBundle</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;base)</td></tr>
<tr class="memdesc:ga5cc3bc3ba5e4eca69d1722bbb1a27e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product <code>M x I</code>, where <em>M</em> is the given 3-manifold triangulation.  <a href="group__triangulation.html#ga5cc3bc3ba5e4eca69d1722bbb1a27e6c">More...</a><br /></td></tr>
<tr class="separator:ga5cc3bc3ba5e4eca69d1722bbb1a27e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c28c0df94615136457875dc03f15caf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga9c28c0df94615136457875dc03f15caf">regina::Example&lt; 4 &gt;::s1Bundle</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;base)</td></tr>
<tr class="memdesc:ga9c28c0df94615136457875dc03f15caf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product <code>M x S1</code>, where <em>M</em> is the given 3-manifold triangulation.  <a href="group__triangulation.html#ga9c28c0df94615136457875dc03f15caf">More...</a><br /></td></tr>
<tr class="separator:ga9c28c0df94615136457875dc03f15caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32798a08d8fc2c8fc9a8e3313a9e86c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__triangulation.html#ga32798a08d8fc2c8fc9a8e3313a9e86c0">regina::Example&lt; 4 &gt;::bundleWithMonodromy</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;base, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;monodromy)</td></tr>
<tr class="memdesc:ga32798a08d8fc2c8fc9a8e3313a9e86c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a bundle formed from a given 3-manifold and a given monodromy.  <a href="group__triangulation.html#ga32798a08d8fc2c8fc9a8e3313a9e86c0">More...</a><br /></td></tr>
<tr class="separator:ga32798a08d8fc2c8fc9a8e3313a9e86c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Triangulations of manifolds in all supported dimensions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3442b4173f21eb1890a4c64743152328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3442b4173f21eb1890a4c64743152328">&#9670;&nbsp;</a></span>Dim2ExampleTriangulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt;2&gt; <a class="el" href="group__triangulation.html#ga3442b4173f21eb1890a4c64743152328">regina::Dim2ExampleTriangulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000221">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim2ExampleTriangulation, you should use the full class name <a class="el" href="classregina_1_1Example_3_012_01_4.html" title="Offers routines for constructing a variety of sample 2-dimensional triangulations.">Example&lt;2&gt;</a>. </dd></dl>

</div>
</div>
<a id="gaac38299d09566ac14cd2d4fbca24ae70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac38299d09566ac14cd2d4fbca24ae70">&#9670;&nbsp;</a></span>Dim2TriangleEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;2&gt; <a class="el" href="group__triangulation.html#gaac38299d09566ac14cd2d4fbca24ae70">regina::Dim2TriangleEdge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000228">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim2TriangleEdge, you should use the real class name <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec&lt;2&gt;</a>. </dd></dl>

</div>
</div>
<a id="gac48fdc344134a7fa32045a9ffe7f55be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac48fdc344134a7fa32045a9ffe7f55be">&#9670;&nbsp;</a></span>Dim4ExampleTriangulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt;4&gt; <a class="el" href="group__triangulation.html#gac48fdc344134a7fa32045a9ffe7f55be">regina::Dim4ExampleTriangulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000223">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim4ExampleTriangulation, you should use the full class name <a class="el" href="classregina_1_1Example_3_014_01_4.html" title="Offers routines for constructing a variety of sample 4-dimensional triangulations.">Example&lt;4&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga696c1ecd18858c1f507967c4394e6dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696c1ecd18858c1f507967c4394e6dd0">&#9670;&nbsp;</a></span>Dim4PentFacet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;4&gt; <a class="el" href="group__triangulation.html#ga696c1ecd18858c1f507967c4394e6dd0">regina::Dim4PentFacet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000230">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim4PentFacet, you should use the real class name <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec&lt;4&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga6096eca562a01858ade2f9fe950a8dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6096eca562a01858ade2f9fe950a8dd3">&#9670;&nbsp;</a></span>NExampleTriangulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Example.html">Example</a>&lt;3&gt; <a class="el" href="group__triangulation.html#ga6096eca562a01858ade2f9fe950a8dd3">regina::NExampleTriangulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000222">Deprecated:</a></b></dt><dd>Instead of the old typedef NExampleTriangulation, you should use the full class name <a class="el" href="classregina_1_1Example_3_013_01_4.html" title="Offers routines for constructing a variety of sample 3-dimensional triangulations.">Example&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga79926fe93b2994dc75769c5c564de4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79926fe93b2994dc75769c5c564de4c0">&#9670;&nbsp;</a></span>NFacePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FacePair.html">FacePair</a> <a class="el" href="group__triangulation.html#ga79926fe93b2994dc75769c5c564de4c0">regina::NFacePair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000224">Deprecated:</a></b></dt><dd>The class NFacePair has now been renamed to <a class="el" href="classregina_1_1FacePair.html" title="Represents a pair of tetrahedron face numbers.">FacePair</a>. </dd></dl>

</div>
</div>
<a id="ga8f7856ba44367811dafd267d9f9e8f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7856ba44367811dafd267d9f9e8f1f">&#9670;&nbsp;</a></span>NFacePairing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;3&gt; <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">regina::NFacePairing</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000227">Deprecated:</a></b></dt><dd>Instead of the old typedef NFacePairing, you should use the full class name <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html" title="Represents the dual graph of a 3-manifold triangulation.">FacetPairing&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="gafe03acab5f3950baadc9e7ecd494bedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe03acab5f3950baadc9e7ecd494bedb">&#9670;&nbsp;</a></span>NHomologicalData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a> <a class="el" href="group__triangulation.html#gafe03acab5f3950baadc9e7ecd494bedb">regina::NHomologicalData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000231">Deprecated:</a></b></dt><dd>The class NHomologicalData has now been renamed to <a class="el" href="classregina_1_1HomologicalData.html" title="Data type that deals with all the detailed homological information in a manifold.">HomologicalData</a>. </dd></dl>

</div>
</div>
<a id="ga5d7efda7dff99a8a422a75e1bc2ca5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d7efda7dff99a8a422a75e1bc2ca5d6">&#9670;&nbsp;</a></span>NTetFace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;3&gt; <a class="el" href="group__triangulation.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">regina::NTetFace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000229">Deprecated:</a></b></dt><dd>Instead of the old typedef NTetFace, you should use the real class name <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1e58eb5bb9b7113dfdebe3d2846b35bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e58eb5bb9b7113dfdebe3d2846b35bd">&#9670;&nbsp;</a></span>annulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::annulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle annulus. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#ga4fbb67097da4b4a488d3a07efe3a5477" title="Returns a triangulation of the product space B^(dim-1) x S^1.">ballBundle()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf8e4c0dff533a6dbef6167c9b50e3608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e4c0dff533a6dbef6167c9b50e3608">&#9670;&nbsp;</a></span>bdryHomology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&amp; regina::HomologicalData::bdryHomology </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine gives access to the homology of the boundary of the manifold, computed with the regular CW-decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the dimension of the homology group: can be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the q-th boundary homology group, in standard cellular homology coordinates </dd></dl>

</div>
</div>
<a id="ga2aa80d88d74e7092ab75bd405f3d2be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aa80d88d74e7092ab75bd405f3d2be4">&#9670;&nbsp;</a></span>bdryHomologyMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&amp; regina::HomologicalData::bdryHomologyMap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine gives access to the homomorphism from the homology of the boundary to the homology of the manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the dimension of the map: can be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from H_q of the boundary to H_q of the manifold, computed in standard coordinates. </dd></dl>

</div>
</div>
<a id="gaaa2510eb639214e287f9e70768238dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2510eb639214e287f9e70768238dd6">&#9670;&nbsp;</a></span>bingsHouse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::bingsHouse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the two-tetrahedron triangulation of the 3-sphere that is dual to Bing's house with two rooms. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga32798a08d8fc2c8fc9a8e3313a9e86c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32798a08d8fc2c8fc9a8e3313a9e86c0">&#9670;&nbsp;</a></span>bundleWithMonodromy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::bundleWithMonodromy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>monodromy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a bundle formed from a given 3-manifold and a given monodromy. </p>
<p>Specifically, let <em>M</em> be the given 3-manifold triangulation. This routine builds the bundle <code>M x I</code>, and then identifies the two copies of <em>M</em> on the boundary according to the given homeomorphism from <em>M</em> to itself. The homeomorphism must be expressed as a combinatorial automorphism, which means that for a non-trivial monodromy you may need to do some work to find a sufficiently symmetric 3-manifold triangulation to begin with.</p>
<p>The resulting manifold will contain 82 pentachora for each original tetrahedron of <em>M</em>, and will contain many internal vertices. It is highly recommended that you call <a class="el" href="group__dim4.html#gaaa321f1bfb037aac23161b1f40745337" title="Attempts to simplify the triangulation as intelligently as possible without further input.">Triangulation&lt;4&gt;::intelligentSimplify()</a> afterwards if you do not need to preserve the combinatorial structure.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given monodromy must be an isomorphism from <em>M</em> to itself; that is, a combinatorial automorphism.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the given 3-manifold triangulation has ideal boundary, then you will obtain an invalid 4-manifold triangulation as a result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the 3-manifold triangulation <em>M</em>, as described above. </td></tr>
    <tr><td class="paramname">monodromy</td><td>the homeomorphism from <em>M</em> to itself, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf235e03602b241e316980bfbc78858f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf235e03602b241e316980bfbc78858f3">&#9670;&nbsp;</a></span>cappellShaneson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::cappellShaneson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of a Cappell-Shaneson 2-knot complement in the 4-sphere. </p>
<p>This triangulation is described and analysed in "Triangulating a Cappell-Shaneson knot complement", Budney, Burton and Hillman, Mathematical Research Letters 19 (2012), no. 5, 1117-1126.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga437fd5d91d38a9cc454b9ad53bffec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437fd5d91d38a9cc454b9ad53bffec3b">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> regina::FacePair::complement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complement of this face pair. </p>
<p>The complement is the pair containing the two faces not included in this face pair.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This face pair is neither before-the-start nor past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the complement of this face pair. </dd></dl>

</div>
</div>
<a id="ga0fe53a5fcd2506d4b4af91cf0dd2e1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe53a5fcd2506d4b4af91cf0dd2e1bc">&#9670;&nbsp;</a></span>countBdryCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::HomologicalData::countBdryCells </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the standard CW-decomposition of the boundary of the manifold. </p>
<p>This is a subcomplex of the complex used in <a class="el" href="group__triangulation.html#ga5d2df0dadbed328f33eb4500b00946bc" title="Returns the number of cells of the given dimension in the standard genuine CW-decomposition of the ma...">countStandardCells()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>the dimension of the cells in question; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells of the given dimension in the standard CW-decomposition of the boundary. </dd></dl>

</div>
</div>
<a id="gaab5bc2ee7b0fdfda137f7159cc05ce57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5bc2ee7b0fdfda137f7159cc05ce57">&#9670;&nbsp;</a></span>countDualCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::HomologicalData::countDualCells </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the dual CW-decomposition of the manifold. </p>
<p>This is typically much smaller than <a class="el" href="group__triangulation.html#ga5d2df0dadbed328f33eb4500b00946bc" title="Returns the number of cells of the given dimension in the standard genuine CW-decomposition of the ma...">countStandardCells()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>the dimension of the cells in question; this must be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells of the given dimension in the dual CW-decomposition to the triangulation. </dd></dl>

</div>
</div>
<a id="ga5d2df0dadbed328f33eb4500b00946bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d2df0dadbed328f33eb4500b00946bc">&#9670;&nbsp;</a></span>countStandardCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::HomologicalData::countStandardCells </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of cells of the given dimension in the standard genuine CW-decomposition of the manifold. </p>
<p>In the case that the triangulation is a proper triangulation of a manifold (or delta-complex decomposition) it simply returns the same information as in the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> vertex, edge, face and tetrahedron lists.</p>
<p>In the case that this is an ideal triangulation, this algorithm returns the details of the corresponding compact manifold with boundary a union of closed surfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>the dimension of the cells in question; this must be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells of the given dimension in the standard CW-decomposition of the closed manifold. </dd></dl>

</div>
</div>
<a id="gaed8ee855fa7dc7c2af3119619d37cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8ee855fa7dc7c2af3119619d37cbe7">&#9670;&nbsp;</a></span>cuspedGenusTwoTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::cuspedGenusTwoTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of a solid genus two torus with a cusped boundary. </p>
<p>This triangulation has one internal finite vertex and one genus two ideal vertex.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaad1af9a63bb1d882c0b53f8e1a54bc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1af9a63bb1d882c0b53f8e1a54bc95">&#9670;&nbsp;</a></span>disc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::disc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-triangle disc. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gabbc7d22517bbb59c938e7302102c110f" title="Bounded Triangulations.">ball()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga04afa01579431203d94cf268c4940830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04afa01579431203d94cf268c4940830">&#9670;&nbsp;</a></span>dualHomology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&amp; regina::HomologicalData::dualHomology </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine gives access to the manifold's homology computed with the dual CW-decomposition. </p>
<p>This routine is typically faster than <a class="el" href="group__triangulation.html#gabc149260561f8138938281b9a838b5d6" title="This routine gives access to the manifold&#39;s homology computed with the regular CW-decomposition.">homology()</a> since the dual CW-decomposition generally has far fewer cells.</p>
<p>Note that the groups returned by <a class="el" href="group__triangulation.html#gabc149260561f8138938281b9a838b5d6" title="This routine gives access to the manifold&#39;s homology computed with the regular CW-decomposition.">homology()</a> and <a class="el" href="group__triangulation.html#ga04afa01579431203d94cf268c4940830" title="This routine gives access to the manifold&#39;s homology computed with the dual CW-decomposition.">dualHomology()</a> are isomorphic, though they are generally described by different presentations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the dimension of the homology group: can be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the q-th homology group, computed in the dual CW-decomposition. </dd></dl>

</div>
</div>
<a id="gafe81cf9fb4549e16a26c74ec25d780d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe81cf9fb4549e16a26c74ec25d780d5">&#9670;&nbsp;</a></span>embeddabilityComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::HomologicalData::embeddabilityComment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a comment on whether the manifold might embed in a homology 3-sphere or 4-sphere. </p>
<p>Basically, this routine runs through all the Kawauchi-Kojima conditions, plus a few other &lsquo;elementary&rsquo; conditions.</p>
<p>Each comment will be formatted as one or more English sentences (i.e., with capitalisation and punctuation). The comments themselves are subject to change between releases of Regina, since later releases may have more detailed tests at their disposal.</p>
<p>This routine is available for both orientable and non-orientable triangulations. In the non-orientable case it may return additional information regarding the orientable double cover.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a string giving a one-line description of what is known about where this manifold embeds, based solely on the manifold's homological data. </dd></dl>

</div>
</div>
<a id="gada63e639a7df3ee88c88a69bca4b0058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada63e639a7df3ee88c88a69bca4b0058">&#9670;&nbsp;</a></span>eulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long int regina::HomologicalData::eulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The proper Euler characteristic of the manifold, computed from the dual CW-decomposition. </p>
<p>This routine calculates the Euler characteristic of the corresponding compact triangulated 3-manifold, with each ideal vertex treated as a surface boundary component.</p>
<p>This routine returns the same value as <a class="el" href="group__dim3.html#gaea8890fe2a84e4c147c43c2ae3c2386f" title="Returns the Euler characteristic of the corresponding compact 3-manifold.">Triangulation&lt;3&gt;::eulerCharManifold()</a>, though it computes it in a different way.</p>
<p>On the other hand, this routine differs from <a class="el" href="group__detail.html#ga8063bd8d3c1ff8d896ae0a24db2203d5" title="Returns the Euler characteristic of this triangulation.">Triangulation&lt;3&gt;::eulerCharTri()</a>, which handles ideal triangulations in a non-standard way (treating each ideal vertex as just a single vertex).</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the corresponding compact triangulated 3-manifold. </dd></dl>

</div>
</div>
<a id="ga6889651af52cb3675599b58a3aa224d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6889651af52cb3675599b58a3aa224d1">&#9670;&nbsp;</a></span>faceOppositeEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::faceOppositeEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the (<em>dim</em>-2)-face number that is opposite the edge joining vertices <em>i</em> and <em>j</em> in a <em>dim</em>-dimensional simplex. </p>
<p>This function is offered because its implementation is faster than working through the <a class="el" href="classregina_1_1FaceNumbering.html" title="Specifies how subdim-faces are numbered within a dim-dimensional simplex.">FaceNumbering</a> class.</p>
<p>The arguments <em>i</em> and <em>j</em> do not need to appear in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the first vertex of an edge in a <em>dim</em>-dimensional simplex. This must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">j</td><td>the second vertex of an edge in a <em>dim</em>-dimensional simplex. This must be between 0 and <em>dim</em> inclusive, and must be different from <em>i</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the (<em>dim</em>-2)-face opposite the given edge. </dd></dl>

</div>
</div>
<a id="ga8a83e60ddcf6dc24a1099f4c47353c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a83e60ddcf6dc24a1099f4c47353c1f">&#9670;&nbsp;</a></span>FacePair() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::FacePair::FacePair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new face pair (0,1). </p>

</div>
</div>
<a id="ga5e4f31581ca4c0b0101ec9010ff04df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e4f31581ca4c0b0101ec9010ff04df3">&#9670;&nbsp;</a></span>FacePair() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::FacePair::FacePair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new face pair that is a clone of the given pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the face pair to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91edc60bc3adda408908fe2deb2cc505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91edc60bc3adda408908fe2deb2cc505">&#9670;&nbsp;</a></span>FacePair() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::FacePair::FacePair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new face pair from the two given face numbers. </p>
<p>The two given numbers need not be in any particular order.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given face numbers must be distinct integers between 0 and 3 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newFirst</td><td>the first face number in the new pair. </td></tr>
    <tr><td class="paramname">newSecond</td><td>the second face number in the new pair. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6eeacae3f9549ff06629ba71ceeb2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6eeacae3f9549ff06629ba71ceeb2f5">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new face pairing that is a clone of the given face pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the face pairing to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb73123d32e9414cca6d7770cd2cf55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb73123d32e9414cca6d7770cd2cf55f">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the face pairing of the given 3-manifold triangulation. </p>
<p>This describes how the tetrahedron faces of the given triangulation are joined together in pairs.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is not empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose face pairing should be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad29701d0511868d6755dfcf13ab53314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad29701d0511868d6755dfcf13ab53314">&#9670;&nbsp;</a></span>FacetSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::<a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier with no initialisation. </p>
<p>This specifier must be initialised before it is used. </p>

</div>
</div>
<a id="ga8d7af8dcff95510cb4056ecf0739ce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7af8dcff95510cb4056ecf0739ce1d">&#9670;&nbsp;</a></span>FacetSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::<a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier referring to the same simplex facet as the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the specifier to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4f0750bebaab41fea22a9c24a8cd0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f0750bebaab41fea22a9c24a8cd0b3">&#9670;&nbsp;</a></span>FacetSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::<a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSimp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier referring to the given facet of the given simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSimp</td><td>the given simplex; see the class notes for allowable values of this parameter. </td></tr>
    <tr><td class="paramname">newFacet</td><td>the given facet; this should be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc20dc0c93677d15b551a25e6206e88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc20dc0c93677d15b551a25e6206e88d">&#9670;&nbsp;</a></span>figureEight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::figureEight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron ideal triangulation of the figure eight knot complement. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga361ee550f483502a40ceed28f8ba93e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361ee550f483502a40ceed28f8ba93e0">&#9670;&nbsp;</a></span>followChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::followChain </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Follows a chain as far as possible from the given point. </p>
<p>A chain is the underlying face pairing for a layered chain; specifically it involves one tetrahedron joined to a second along two faces, the remaining two faces of the second tetrahedron joined to a third and so on. A chain can involve as few as one tetrahedron or as many as we like. Note that the remaining two faces of the first tetrahedron and the remaining two faces of the final tetrahedron remain unaccounted for by this structure.</p>
<p>This routine begins with two faces of a given tetrahedron, described by parameters <em>tet</em> and <em>faces</em>. If these two faces are both joined to some different tetrahedron, parameter <em>tet</em> will be changed to this new tetrahedron and parameter <em>faces</em> will be changed to the remaining faces of this new tetrahedron (i.e., the two faces that were not joined to the original faces of the original tetrahedron).</p>
<p>This procedure is repeated as far as possible until either the two faces in question join to two different tetrahedra, the two faces join to each other, or at least one of the two faces is unmatched.</p>
<p>Thus, given one end of a chain, this procedure can be used to follow the face pairings through to the other end of the chain.</p>
<dl class="section warning"><dt>Warning</dt><dd>You must be sure when calling this routine that you are not inside a chain that loops back onto itself! If the face pairing forms a large loop with each tetrahedron joined by two faces to the next, this routine will cycle around the loop forever and never return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the index in the underlying triangulation of the tetrahedron to begin at. This parameter will be modified directly by this routine as a way of returning the results. </td></tr>
    <tr><td class="paramname">faces</td><td>the pair of face numbers in the given tetrahedron at which we begin. This parameter will also be modified directly by this routine as a way of returning results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38599047d12bc7e999b197ef0db55965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38599047d12bc7e999b197ef0db55965">&#9670;&nbsp;</a></span>formIsHyperbolic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomologicalData::formIsHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff torsion linking form is &lsquo;hyperbolic&rsquo; in the linking-form sense of the word. </p>
<p>To be a little more precise, Poincare-duality in a compact orientable boundaryless manifold gives an isomorphism between the torsion subgroup of H_1(M) denoted tH_1(M) and Hom(tH_1(M),Q/Z), where Q is the rationals and Z the integers. The associated bilinear form (with values in Q/Z) is said to be &lsquo;hyperbolic&rsquo; if tH_1(M) splits as a direct sum A+B such that Poincare duality sends A to Hom(B,Q/Z) and B to Hom(A,Q/Z).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff the torsion linking form is hyperbolic. </dd></dl>

</div>
</div>
<a id="gae998e8c01036e360a8623a27489936f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae998e8c01036e360a8623a27489936f7">&#9670;&nbsp;</a></span>formIsSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomologicalData::formIsSplit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff the torsion linking form is split. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff the linking form is split. </dd></dl>

</div>
</div>
<a id="gaf4a6460d0e7fb71aaa7c366dd9c5ed86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a6460d0e7fb71aaa7c366dd9c5ed86">&#9670;&nbsp;</a></span>formSatKK()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomologicalData::formSatKK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> true iff the torsion linking form satisfies the Kawauchi-Kojima 2-torsion condition. </p>
<p>This condition states that on all elements <em>x</em> of order 2^k, 2^{k-1}form(x,x) = 0.</p>
<p>This is a neccessary condition for an orientable 3-manifold perhaps with boundary to embed in a homology 4-sphere.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff the form satisfies the 2-torsion condition of Kawauchi-Kojima. </dd></dl>

</div>
</div>
<a id="ga229499e503960053a037c27724e6dd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga229499e503960053a037c27724e6dd78">&#9670;&nbsp;</a></span>fourSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::fourSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the 4-sphere. </p>
<p>This is identical to calling the generic routine <a class="el" href="group__detail.html#gac44d1474b152e941ff3e57ca342095ff" title="Closed Triangulations.">sphere()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaa6493f8eea568410c50d864730e1f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6493f8eea568410c50d864730e1f72d">&#9670;&nbsp;</a></span>gieseking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::gieseking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the one-tetrahedron ideal triangulation of the non-orientable Gieseking manifold. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gae94bb041603ecf51b92a68b9ce2deead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94bb041603ecf51b92a68b9ce2deead">&#9670;&nbsp;</a></span>h1CellAp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&amp; regina::HomologicalData::h1CellAp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the isomorphism from dualHomology(1) to homology(1) given by a cellular approximation to the identity map on the manifold. </p>
<dl class="section return"><dt>Returns</dt><dd>The isomorphism from dualHomology(1) to homology(1) computed via a cellular approximation of the identity map from the first 1-skeleton to the second. </dd></dl>

</div>
</div>
<a id="ga1bda748de730da86e2c1032b9d7c5b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bda748de730da86e2c1032b9d7c5b14">&#9670;&nbsp;</a></span>hasBrokenDoubleEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasBrokenDoubleEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a broken double-ended chain. </p>
<p>A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p>A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus). A double-ended chain is a chain in which the first tetrahedron is joined to itself along one face and the final tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered lens space).</p>
<p>A broken double-ended chain consists of two one-ended chains (using distinct sets of tetrahedra) joined together along one face. The remaining two faces (one from each chain) that were unaccounted for by the individual one-ended chains remain unaccounted for by this broken double-ended chain.</p>
<p>In this routine we are interested specifically in finding a broken double-ended chain that is not a part of a complete double-ended chain, i.e., the final two unaccounted faces are not joined together.</p>
<p>A face pairing containing a broken double-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing
graphs and 3-manifold enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a broken double-ended chain that is not part of a complete double-ended chain. </dd></dl>

</div>
</div>
<a id="ga5b06b27853306a94eaf57b6ff72cdd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b06b27853306a94eaf57b6ff72cdd04">&#9670;&nbsp;</a></span>hasDoubleSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasDoubleSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a double-edged square. </p>
<p>A double-edged square involves four distinct tetrahedra that meet each other as follows. Two pairs of tetrahedra are joined along two pairs of faces each. Then each tetrahedron is joined along a single face to one tetrahedron of the other pair. The four tetrahedron faces not yet joined to anything (one from each tetrahedron) remain unaccounted for by this structure.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a double-edged square. </dd></dl>

</div>
</div>
<a id="gaca0b3a332ec4f0f7c5646e535894a0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0b3a332ec4f0f7c5646e535894a0a5">&#9670;&nbsp;</a></span>hasDoubleStar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasDoubleStar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a double-edged star. </p>
<p>A double-edged star involves two tetrahedra that are adjacent along two separate pairs of faces, where the four remaining faces of these tetrahedra are joined to four entirely new tetrahedra (so that none of the six tetrahedra described in this structure are the same).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a double-edged star. </dd></dl>

</div>
</div>
<a id="ga3b219eac1d9a0a0495488dd5ca99e038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b219eac1d9a0a0495488dd5ca99e038">&#9670;&nbsp;</a></span>hasOneEndedChainWithDoubleHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasOneEndedChainWithDoubleHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a one-ended chain with a double handle. </p>
<p>A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p>A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p>A one-ended chain with a double handle begins with a one-ended chain. The two faces that are unaccounted for by this one-ended chain must be joined to two different tetrahedra, and these two tetrahedra must be joined to each other along two faces. The remaining two faces of these two tetrahedra remain unaccounted for by this structure.</p>
<p>A face pairing containing a one-ended chain with a double handle cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing graphs and 3-manifold enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a one-ended chain with a double handle. </dd></dl>

</div>
</div>
<a id="ga372e9f00039b11782a3af1638d2122fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga372e9f00039b11782a3af1638d2122fd">&#9670;&nbsp;</a></span>hasOneEndedChainWithStrayBigon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasOneEndedChainWithStrayBigon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a one-ended chain with a stray bigon. </p>
<p>A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p>A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p>A one-ended chain with a stray bigon describes the following structure. We begin with a one-ended chain. Two new tetrahedra are added; these are joined to each other along two pairs of faces, and one of the new tetrahedra is joined to the end of the one-ended chain. We then ensure that:</p><ul>
<li>This configuration is not part of a longer one-ended chain that encompasses all of the aforementioned tetrahedra;</li>
<li>There is no extra tetrahedron that is joined to both the two new tetrahedra and the end of the chain;</li>
<li>There is no extra tetrahedron that is joined to the end of the chain along one face and the far new tetrahedron along two additional faces (where by "the far new tetrahedron" we mean the new tetrahedron that was not originally joined to the chain).</li>
</ul>
<p>Aside from these constraints, the remaining four tetrahedron faces (two faces of the far new tetrahedron, one face of the other new tetrahedron, and one face at the end of the chain) remain unaccounted for by this structure.</p>
<p>A face pairing containing a structure of this type cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a one-ended chain with a stray bigon. </dd></dl>

</div>
</div>
<a id="gace2711bf8d99861f34dd759a833e4f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace2711bf8d99861f34dd759a833e4f1a">&#9670;&nbsp;</a></span>hasSingleStar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasSingleStar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a single-edged star. </p>
<p>A single-edged star involves two tetrahedra that are adjacent along a single face, where the six remaining faces of these tetrahedra are joined to six entirely new tetrahedra (so that none of the eight tetrahedra described in this structure are the same).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a single-edged star. </dd></dl>

</div>
</div>
<a id="gacde7a8ad187d9bc3492105abf93f78e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacde7a8ad187d9bc3492105abf93f78e7">&#9670;&nbsp;</a></span>hasTripleEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasTripleEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a triple edge. </p>
<p>A triple edge is where two different tetrahedra are joined along three of their faces.</p>
<p>A face pairing containing a triple edge cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing graphs and 3-manifold
enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a triple edge. </dd></dl>

</div>
</div>
<a id="ga1bd526b75d1a1531af9a3932d4beec9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd526b75d1a1531af9a3932d4beec9b">&#9670;&nbsp;</a></span>hasTripleOneEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasTripleOneEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a triple one-ended chain. </p>
<p>A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p>A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p>A triple one-ended chain is created from three one-ended chains as follows. Two new tetrahedra are added, and each one-ended chain is joined to each of the new tetrahedra along a single face. The remaining two faces (one from each of the new tetrahedra) remain unaccounted for by this structure.</p>
<p>A face pairing containing a triple one-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a triple one-ended chain. </dd></dl>

</div>
</div>
<a id="ga827125a7939e2bf95a4cf57f02e7142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827125a7939e2bf95a4cf57f02e7142c">&#9670;&nbsp;</a></span>hasWedgedDoubleEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasWedgedDoubleEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a wedged double-ended chain. </p>
<p>A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="group__triangulation.html#ga361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p>A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus). A double-ended chain is a chain in which the first tetrahedron is joined to itself along one face and the final tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered lens space).</p>
<p>A wedged double-ended chain is created from two one-ended chains as follows. Two new tetrahedra are added, and each one-ended chain is joined to each of the new tetrahedra along a single face. In addition, the two new tetrahedra are joined to each other along a single face. The remaining two faces (one from each of the new tetrahedra) remain unaccounted for by this structure.</p>
<p>An alternative way of viewing a wedged double-ended chain is as an ordinary double-ended chain, where one of the internal tetrahedra is removed and replaced with a pair of tetrahedra joined to each other. Whereas the original tetrahedron met its two neighbouring tetrahedra along two faces each (giving a total of four face identifications), the two new tetrahedra now meet each of the two neighbouring tetrahedra along a single face each (again giving four face identifications).</p>
<p>Note that if this alternate construction is used to replace one of the end tetrahedra of the double-ended chain (not an internal tetrahedron), the resulting structure will either be a triple edge or a one-ended chain with a double handle (according to whether the original chain has zero or positive length). See <a class="el" href="group__triangulation.html#gacde7a8ad187d9bc3492105abf93f78e7" title="Determines whether this face pairing contains a triple edge.">hasTripleEdge()</a> and <a class="el" href="group__triangulation.html#ga3b219eac1d9a0a0495488dd5ca99e038" title="Determines whether this face pairing contains a one-ended chain with a double handle.">hasOneEndedChainWithDoubleHandle()</a> for further details.</p>
<p>A face pairing containing a wedged double-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a wedged double-ended chain. </dd></dl>

</div>
</div>
<a id="gadbccd4549afd30c75d7169610adecdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbccd4549afd30c75d7169610adecdb8">&#9670;&nbsp;</a></span>HomologicalData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomologicalData::HomologicalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomologicalData.html">HomologicalData</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the homological data to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga986db7609750e0957ba2b1f1badaa689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga986db7609750e0957ba2b1f1badaa689">&#9670;&nbsp;</a></span>HomologicalData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomologicalData::HomologicalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes as input a triangulation. </p>
<p>This class takes its own copy of the input triangulation. This means that the input triangulation can change or even be destroyed, and this homological data will happily continue to work with the original triangulation as it was first passed to the constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the triangulation to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc149260561f8138938281b9a838b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc149260561f8138938281b9a838b5d6">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&amp; regina::HomologicalData::homology </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine gives access to the manifold's homology computed with the regular CW-decomposition. </p>
<p>This routine is typically slower than <a class="el" href="group__triangulation.html#ga04afa01579431203d94cf268c4940830" title="This routine gives access to the manifold&#39;s homology computed with the dual CW-decomposition.">dualHomology()</a>, since <a class="el" href="group__triangulation.html#ga04afa01579431203d94cf268c4940830" title="This routine gives access to the manifold&#39;s homology computed with the dual CW-decomposition.">dualHomology()</a> uses the dual CW-decomposition which typically has an order of magnitude fewer cells.</p>
<p>Note that the groups returned by <a class="el" href="group__triangulation.html#gabc149260561f8138938281b9a838b5d6" title="This routine gives access to the manifold&#39;s homology computed with the regular CW-decomposition.">homology()</a> and <a class="el" href="group__triangulation.html#ga04afa01579431203d94cf268c4940830" title="This routine gives access to the manifold&#39;s homology computed with the dual CW-decomposition.">dualHomology()</a> are isomorphic, though they are generally described by different presentations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the dimension of the homology group: can be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the q-th homology group, computed in the standard CW-decomposition. </dd></dl>

</div>
</div>
<a id="ga5cc3bc3ba5e4eca69d1722bbb1a27e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc3bc3ba5e4eca69d1722bbb1a27e6c">&#9670;&nbsp;</a></span>iBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::iBundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product <code>M x I</code>, where <em>M</em> is the given 3-manifold triangulation. </p>
<p>The boundary of this product will consist of two copies of <em>M</em>, both combinatorially isomorphic to the original triangulation. If <em>n</em> is the number of tetrahedra in <em>M</em>, then the first copy of <em>M</em> on the boundary is obtained by mapping vertices 0,1,2,3 of tetrahedron <em>i</em> of <em>M</em> to vertices 0,1,2,3 of pentachoron <em>i</em>, and the second copy is obtained by mapping vertices 0,1,2,3 of tetrahedron <em>i</em> of <em>M</em> to vertices 0,1,2,3 of pentachoron <em>n+i</em>.</p>
<p>The product itself will contain 82 pentachora for each original tetrahedron of <em>M</em>, and will contain many internal vertices. It is highly recommended that you call <a class="el" href="group__dim4.html#gaaa321f1bfb037aac23161b1f40745337" title="Attempts to simplify the triangulation as intelligently as possible without further input.">Triangulation&lt;4&gt;::intelligentSimplify()</a> afterwards if you do not need to preserve the combinatorial structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the given 3-manifold triangulation has ideal boundary, then you will obtain an invalid 4-manifold triangulation as a result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the 3-manifold triangulation <em>M</em>, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gacfa49912a90419122457ea742abf3733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa49912a90419122457ea742abf3733">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t regina::HomologicalData::SortedArray::index </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the given integer in this array. </p>
<p>This routine runs in logarithmic time (it uses a binary search).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the array index that holds the given integer, or -1 if the given integer is not stored in this array. </dd></dl>

</div>
</div>
<a id="gacef2c5c9d95b2409cdb1d19f789e0088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef2c5c9d95b2409cdb1d19f789e0088">&#9670;&nbsp;</a></span>isBeforeStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::isBeforeStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face pair represents a before-the-start value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pair is before-the-start. </dd></dl>

</div>
</div>
<a id="gaba86c41b32df4f5750ffc36d1ddf3968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba86c41b32df4f5750ffc36d1ddf3968">&#9670;&nbsp;</a></span>isBeforeStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isBeforeStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents a before-the-start value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier is before-the-start. </dd></dl>

</div>
</div>
<a id="gaa8f49fbc941f1150c7109c7b2aedfe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f49fbc941f1150c7109c7b2aedfe08">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isBoundary </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents the overall boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that the boundary is represented in this specifier as simplex <em>nSimplices</em>, facet 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier represents the overall boundary. </dd></dl>

</div>
</div>
<a id="gada9d0d86d7587d25d2c9c88f3c04c948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9d0d86d7587d25d2c9c88f3c04c948">&#9670;&nbsp;</a></span>isPastEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::isPastEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face pair represents a past-the-end value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pair is past-the-end. </dd></dl>

</div>
</div>
<a id="ga921b515966451ca7408c09c32a497fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921b515966451ca7408c09c32a497fbb">&#9670;&nbsp;</a></span>isPastEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isPastEnd </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boundaryAlso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents a past-the-end value. </p>
<p>You can optionally declare the overall boundary to be past-the-end as well as the already predefined past-the-end value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that past-the-end is represented in this specifier as simplex <em>nSimplices</em>, facet 1. </td></tr>
    <tr><td class="paramname">boundaryAlso</td><td><code>true</code> if the overall boundary should be considered past-the-end in addition to the predefined past-the-end value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier is past-the-end. </dd></dl>

</div>
</div>
<a id="ga084b60597c7d2b153251e4c80fd2f493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084b60597c7d2b153251e4c80fd2f493">&#9670;&nbsp;</a></span>kb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle Klein bottle. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gaf14d0b08a11aafcfe98af561437676f4" title="Returns a two-simplex triangulation of the twisted product space S^(dim-1) x~ S^1.">twistedSphereBundle()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga2f7f5fdfa00b2500e424c42f6b2a9ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7f5fdfa00b2500e424c42f6b2a9ce0">&#9670;&nbsp;</a></span>lens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::lens </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the lens space <code>L(p,q)</code>. </p>
<p>The triangulation uses a layered lens space, which is conjectured (but not proven in all cases) to be the triangulation requiring the fewest tetrahedra.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>p</em> &gt; <em>q</em> &gt;= 0 unless (<em>p</em>,<em>q</em>) = (0,1). </dd>
<dd>
gcd(<em>p</em>, <em>q</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a parameter of the desired lens space. </td></tr>
    <tr><td class="paramname">q</td><td>a parameter of the desired lens space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga49df6b0caddae2da8425a7b8d4994b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49df6b0caddae2da8425a7b8d4994b28">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::FacePair::lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smaller of the two face numbers in this pair. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This face pair is neither before-the-start or past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the lower face number. </dd></dl>

</div>
</div>
<a id="ga6ca40e28f7379f33730a9134ddd7e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca40e28f7379f33730a9134ddd7e127">&#9670;&nbsp;</a></span>lst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::lst </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus <code>LST(a,b,c)</code>. </p>
<p>This is a parameterised triangulation of the solid torus. It has two boundary triangles and three boundary edges, and the meridional disc of the solid torus cuts these boundary edges <em>a</em>, <em>b</em> and <em>c</em> times respectively.</p>
<p>Only the parameters <em>a</em> and <em>b</em> are passed as arguments to this routine. The third parameter <em>c</em> will be deduced automatically as <em>c</em> = (<em>a</em> + <em>b</em>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>gcd(<em>a</em>, <em>b</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first parameter of the layered solid torus. </td></tr>
    <tr><td class="paramname">b</td><td>the second parameter of the layered solid torus. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga4d94c206a8df611ae9ccb1b3f9301911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d94c206a8df611ae9ccb1b3f9301911">&#9670;&nbsp;</a></span>mobius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::mobius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-triangle Mobius band. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gaceae3ff4fb520f6df2d13966b5cfcc22" title="Returns a triangulation of the twisted product space B^(dim-1) x~ S^1.">twistedBallBundle()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga44bf5456816a8d9405e37a3829d6a456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44bf5456816a8d9405e37a3829d6a456">&#9670;&nbsp;</a></span>nonOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::nonOrientable </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>genus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>punctures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the given non-orientable surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genus</td><td>the non-orientable genus of the surface, i.e., the number of crosscaps that it contains; this must be greater than or equal to one. </td></tr>
    <tr><td class="paramname">punctures</td><td>the number of punctures in the surface; this must be greater than or equal to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gac1bf3670cc5420659dd8da140a804ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1bf3670cc5420659dd8da140a804ead">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given face pair are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given pair are not equal. </dd></dl>

</div>
</div>
<a id="gaa44f091e013edb34324aa69ef149cba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa44f091e013edb34324aa69ef149cba1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given specifier are not identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given specifier are not equal. </dd></dl>

</div>
</div>
<a id="ga23deb042ad632bef8f9cc0bd1359f9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23deb042ad632bef8f9cc0bd1359f9b8">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&amp; regina::FacePair::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments this face pair. </p>
<p>It will be set to the following face pair in the lexicographical ordering, or to a past-the-end value if there are no more face pairs.</p>
<p>This is a preincrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postincrement operator is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga572447ee1d803cbeb4a7fea712df837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga572447ee1d803cbeb4a7fea712df837d">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator++</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments this specifier. </p>
<p>It will be changed to point to the next simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, although the postincrement operator is present in python as the member function inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this specifier. </dd></dl>

</div>
</div>
<a id="ga9939a7721e0a824c3f68d08836f1fc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9939a7721e0a824c3f68d08836f1fc13">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> regina::FacePair::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments this face pair. </p>
<p>It will be set to the following face pair in the lexicographical ordering, or to a past-the-end value if there are no more face pairs.</p>
<p>This is a postincrement operator: the object will be changed, but a copy of the original reference will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="gaf1eb127387295a5e50e5f7e0ee979860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1eb127387295a5e50e5f7e0ee979860">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments this specifier. </p>
<p>It will be changed to point to the next simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is named inc() since python does not support the increment operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this specifier before it was incremented. </dd></dl>

</div>
</div>
<a id="ga5646e1705ca8c2c86f3ada5a0c3eb7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5646e1705ca8c2c86f3ada5a0c3eb7d6">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&amp; regina::FacePair::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements this face pair. </p>
<p>It will be set to the previous face pair in the lexicographical ordering, or to a before-the-start value if there are no previous face pairs.</p>
<p>This is a predecrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postdecrement operator is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga54580334365153f454be61d07c69a817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54580334365153f454be61d07c69a817">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator--</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements this specifier. </p>
<p>It will be changed to point to the previous simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not before-the-start.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, although the postdecrement operator is present in python as the member function dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this specifier. </dd></dl>

</div>
</div>
<a id="ga651bfa48591b0dfd381bcc8a061442f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651bfa48591b0dfd381bcc8a061442f2">&#9670;&nbsp;</a></span>operator--() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> regina::FacePair::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements this face pair. </p>
<p>It will be set to the previous face pair in the lexicographical ordering, or to a before-the-start value if there are no previous face pairs.</p>
<p>This is a postdecrement operator: the object will be changed, but a copy of the original reference will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="gaeefeb4f4f4b195476519ff4e4bb215a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeefeb4f4f4b195476519ff4e4bb215a6">&#9670;&nbsp;</a></span>operator--() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements this specifier. </p>
<p>It will be changed to point to the previous simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not before-the-start.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is named dec() since python does not support the decrement operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this specifier before it was decremented. </dd></dl>

</div>
</div>
<a id="ga79340c829625fd15dc7651c510a6c831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79340c829625fd15dc7651c510a6c831">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than the given face pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than <em>other</em>. </dd></dl>

</div>
</div>
<a id="ga171b03ac5fffd3a8096fb38a8a0463a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga171b03ac5fffd3a8096fb38a8a0463a8">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than the given specifier. </dd></dl>

</div>
</div>
<a id="ga7fe200cb708782c906744c2f5cb6f5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe200cb708782c906744c2f5cb6f5d9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given face pair to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">pair</td><td>the face pair to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga5a6724c5b71f83afa5ea8be4068a0a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6724c5b71f83afa5ea8be4068a0a02">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given facet specifier to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gad647b24db98c0f783862b2d3c2396bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad647b24db98c0f783862b2d3c2396bdd">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than or equal to the given face pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a id="ga0477f547607c4b7011f33c098953d8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0477f547607c4b7011f33c098953d8e8">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than or equal to the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than or equal to the given specifier. </dd></dl>

</div>
</div>
<a id="gaec2302e4b8cca31a3843058c2fa0e34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2302e4b8cca31a3843058c2fa0e34f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacePair.html">FacePair</a>&amp; regina::FacePair::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this face pair to be a copy of the given pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the face pair to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this face pair. </dd></dl>

</div>
</div>
<a id="gabdc3f911db9bebfef4cb5ccb4c1ba510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc3f911db9bebfef4cb5ccb4c1ba510">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the value of the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the given specifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this specifier. </dd></dl>

</div>
</div>
<a id="gae27391304b84c0a67e52a0dffab7ab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27391304b84c0a67e52a0dffab7ab1d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SortedArray&amp; regina::HomologicalData::SortedArray::operator= </td>
          <td>(</td>
          <td class="paramtype">const SortedArray &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this to a clone of the given array. </p>

</div>
</div>
<a id="gad9f17f05c97615be65f67fef43c5ed40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f17f05c97615be65f67fef43c5ed40">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given face pair are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given pair are equal. </dd></dl>

</div>
</div>
<a id="ga748faf43c3c94c3e035cb77d34d5dd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748faf43c3c94c3e035cb77d34d5dd9f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given specifier are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given specifier are equal. </dd></dl>

</div>
</div>
<a id="ga1fa54262654a989e8ca964f88bf8d162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa54262654a989e8ca964f88bf8d162">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is greater than the given face pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than <em>other</em>. </dd></dl>

</div>
</div>
<a id="ga994c28722d7450c1df4728a44f178923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994c28722d7450c1df4728a44f178923">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::FacePair::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is greater than or equal to the given face pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pair to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than or equal to <em>other</em>. </dd></dl>

</div>
</div>
<a id="gab5f309e75b9f5aab2f11b892a7ac8b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f309e75b9f5aab2f11b892a7ac8b1c">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::HomologicalData::SortedArray::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the integer at the given index in this array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the requested array index; this must be between 0 and size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding element of this array. </dd></dl>

</div>
</div>
<a id="gab4859f568765540b75b5f2bd681163a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4859f568765540b75b5f2bd681163a0">&#9670;&nbsp;</a></span>orientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::orientable </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>genus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>punctures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the given orientable surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genus</td><td>the genus of the surface; this must be greater than or equal to zero. </td></tr>
    <tr><td class="paramname">punctures</td><td>the number of punctures in the surface; this must be greater than or equal to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga0076bf4f17cd5348b99d34348ef71dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0076bf4f17cd5348b99d34348ef71dfb">&#9670;&nbsp;</a></span>poincareHomologySphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::poincareHomologySphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the five-tetrahedron triangulation of the Poincare homology sphere. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gabffe3cbb1f2c5bc07605abd6c69a9321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabffe3cbb1f2c5bc07605abd6c69a9321">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomologicalData::SortedArray::push_back </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given integer onto the end of this array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given integer is at least as large as every integer currently stored in the array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to insert into this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa24271cded8848b5e7405d2a23a351de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa24271cded8848b5e7405d2a23a351de">&#9670;&nbsp;</a></span>rp2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::rp2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle projective plane. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga59882029efa17df29c9168ee33bc9ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59882029efa17df29c9168ee33bc9ccd">&#9670;&nbsp;</a></span>rp2xs1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::rp2xs1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-tetrahedron triangulation of the non-orientable product space <code>RP^2 x S^1</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga464927e6ffa157b939740fb25d59e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464927e6ffa157b939740fb25d59e9aa">&#9670;&nbsp;</a></span>rp3rp3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::rp3rp3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the connected sum <code>RP^3 # RP^3</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga2ed01a539c457b9f3192a7ab22656486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed01a539c457b9f3192a7ab22656486">&#9670;&nbsp;</a></span>rp4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::rp4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-pentachoron triangulation of real projective 4-space. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="ga9c28c0df94615136457875dc03f15caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c28c0df94615136457875dc03f15caf">&#9670;&nbsp;</a></span>s1Bundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::s1Bundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product <code>M x S1</code>, where <em>M</em> is the given 3-manifold triangulation. </p>
<p>This simply calls <a class="el" href="group__triangulation.html#ga5cc3bc3ba5e4eca69d1722bbb1a27e6c" title="Returns a triangulation of the product M x I, where M is the given 3-manifold triangulation.">iBundle()</a> and then glues together the two copies of <em>M</em> on the boundary.</p>
<p>The product will contain 82 pentachora for each original tetrahedron of <em>M</em>, and will contain many internal vertices. It is highly recommended that you call <a class="el" href="group__dim4.html#gaaa321f1bfb037aac23161b1f40745337" title="Attempts to simplify the triangulation as intelligently as possible without further input.">Triangulation&lt;4&gt;::intelligentSimplify()</a> afterwards if you do not need to preserve the combinatorial structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the given 3-manifold triangulation has ideal boundary, then you will obtain an invalid 4-manifold triangulation as a result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the 3-manifold triangulation <em>M</em>, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gad61f654a7890f50a33d852358b8c5351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad61f654a7890f50a33d852358b8c5351">&#9670;&nbsp;</a></span>s2xs1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::s2xs1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron triangulation of the product space <code>S^2 x S^1</code>. </p>
<p>This is identical to calling the generic routine <a class="el" href="group__detail.html#gac808405b4900c8fdff2153d1e404f1bb" title="Returns a two-simplex triangulation of the product space S^(dim-1) x S^1.">sphereBundle()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga9b02ea2239dbf99cacc2f260ffacd480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b02ea2239dbf99cacc2f260ffacd480">&#9670;&nbsp;</a></span>s3xs1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::s3xs1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the product space <code>S^3 x S^1</code>. </p>
<p>This is identical to calling the generic routine <a class="el" href="group__detail.html#gac808405b4900c8fdff2153d1e404f1bb" title="Returns a two-simplex triangulation of the product space S^(dim-1) x S^1.">sphereBundle()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga5328e86cbd0cb3c288a3c5208d1ce3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5328e86cbd0cb3c288a3c5208d1ce3f7">&#9670;&nbsp;</a></span>s3xs1Twisted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::s3xs1Twisted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-pentachoron triangulation of the twisted product space <code>S^3 x~ S^1</code>. </p>
<p>This is identical to calling the generic routine <a class="el" href="group__detail.html#gaf14d0b08a11aafcfe98af561437676f4" title="Returns a two-simplex triangulation of the twisted product space S^(dim-1) x~ S^1.">twistedSphereBundle()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga488b419491ef1fdc272ae194371b3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488b419491ef1fdc272ae194371b3014">&#9670;&nbsp;</a></span>setBeforeStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setBeforeStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to before-the-start. </p>

</div>
</div>
<a id="gaef773e92a8bb7deb185cd5a9bdaad44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef773e92a8bb7deb185cd5a9bdaad44c">&#9670;&nbsp;</a></span>setBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setBoundary </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the overall boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that the boundary is represented in this specifier as simplex <em>nSimplices</em>, facet 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cee2bae3a73929183a3ff2684500b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cee2bae3a73929183a3ff2684500b57">&#9670;&nbsp;</a></span>setFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setFirst</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the first facet of the first simplex. </p>

</div>
</div>
<a id="gadd803a508697b9c808b40a3238b677e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd803a508697b9c808b40a3238b677e6">&#9670;&nbsp;</a></span>setPastEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setPastEnd </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to past-the-end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that past-the-end is represented in this specifier as simplex <em>nSimplices</em>, facet 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51ef0f8dfb29bca4ffe5b218ac6d0317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ef0f8dfb29bca4ffe5b218ac6d0317">&#9670;&nbsp;</a></span>simplicialFourSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 4 &gt;::simplicialFourSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the standard six-pentachoron triangulation of the 4-sphere as the boundary of a 5-simplex. </p>
<p>This is identical to calling the generic routine <a class="el" href="group__detail.html#gaad291d03ffaac87219b0be9a3b6d3cc8" title="Returns the standard (dim+2)-simplex triangulation of the dim-sphere as the boundary of a (dim+1)-sim...">simplicialSphere()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga40affc338686fe21d7372a07e642df15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40affc338686fe21d7372a07e642df15">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::HomologicalData::SortedArray::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in this array. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements. </dd></dl>

</div>
</div>
<a id="ga82197acebacc5603f4cfdecc519b2372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82197acebacc5603f4cfdecc519b2372">&#9670;&nbsp;</a></span>smallClosedNonOrblHyperbolic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::smallClosedNonOrblHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the eleven-tetrahedron closed non-orientable hyperbolic 3-manifold with volume 2.02988321. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga948f7a47cafd266a1232fb6bf9d8ac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga948f7a47cafd266a1232fb6bf9d8ac92">&#9670;&nbsp;</a></span>smallClosedOrblHyperbolic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::smallClosedOrblHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the nine-tetrahedron closed orientable hyperbolic 3-manifold with volume 0.94270736. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga961cb443c5b6bdfd148931bd93c9f7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga961cb443c5b6bdfd148931bd93c9f7c3">&#9670;&nbsp;</a></span>solidKleinBottle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::solidKleinBottle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the solid Klein bottle. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gaceae3ff4fb520f6df2d13966b5cfcc22" title="Returns a triangulation of the twisted product space B^(dim-1) x~ S^1.">twistedBallBundle()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gabd309da07d43b92f8ccbe059fb022365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd309da07d43b92f8ccbe059fb022365">&#9670;&nbsp;</a></span>SortedArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomologicalData::SortedArray::SortedArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty array. </p>

</div>
</div>
<a id="ga028261be9190f5d1ecb649d23898fd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga028261be9190f5d1ecb649d23898fd48">&#9670;&nbsp;</a></span>SortedArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomologicalData::SortedArray::SortedArray </td>
          <td>(</td>
          <td class="paramtype">const SortedArray &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a clone of the given array. </p>

</div>
</div>
<a id="gaf6262c206ae0a147eab8a7b54842c693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6262c206ae0a147eab8a7b54842c693">&#9670;&nbsp;</a></span>sphere600()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::sphere600 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary 3-sphere of the regular 600-cell. </p>
<p>This is a triangulation of the 3-sphere that is a simplicial complex, and in which every edge has degree five.</p>
<p>The triangulation was extracted from the Benedetti-Lutz library of triangulations. See: <a href="http://page.math.tu-berlin.de/~lutz/stellar/library_of_triangulations.html">http://page.math.tu-berlin.de/~lutz/stellar/library_of_triangulations.html</a></p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga8b01503ae389d74db8a1bd7d05f5980e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b01503ae389d74db8a1bd7d05f5980e">&#9670;&nbsp;</a></span>sphereOctahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::sphereOctahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the eight-triangle 2-sphere formed from the boundary of an octahedron. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gae208f58f76e1b1be3d316264e7bfaeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae208f58f76e1b1be3d316264e7bfaeb1">&#9670;&nbsp;</a></span>sphereTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::sphereTetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the four-triangle 2-sphere formed from the boundary of a tetrahedron. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gaad291d03ffaac87219b0be9a3b6d3cc8" title="Returns the standard (dim+2)-simplex triangulation of the dim-sphere as the boundary of a (dim+1)-sim...">simplicialSphere()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gafee7f2cc5baf65eadc997d9e1408aa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee7f2cc5baf65eadc997d9e1408aa50">&#9670;&nbsp;</a></span>startPropertySubElement() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; dim &gt;::startPropertySubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation. </p>
<p>If <em>subTagName</em> names an XML element that describes an optional property of a triangulation (such as <code>H1</code> or <code>fundgroup</code> for 3-manifold triangulations), then this function should return a corresponding element reader.</p>
<p>Otherwise this function should return a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a>, which will cause the XML element to be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the XML subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should not take care of the new reader's destruction; that will be done by the parser. </dd></dl>

</div>
</div>
<a id="ga72fc3b4164b0fd901c6fd51b8e6084aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72fc3b4164b0fd901c6fd51b8e6084aa">&#9670;&nbsp;</a></span>startPropertySubElement() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 2 &gt;::startPropertySubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation. </p>
<p>If <em>subTagName</em> names an XML element that describes an optional property of a triangulation (such as <code>H1</code> or <code>fundgroup</code> for 3-manifold triangulations), then this function should return a corresponding element reader.</p>
<p>Otherwise this function should return a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a>, which will cause the XML element to be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the XML subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should not take care of the new reader's destruction; that will be done by the parser. </dd></dl>

</div>
</div>
<a id="ga3db6e37f29b9c271d47af6eef99c0fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db6e37f29b9c271d47af6eef99c0fff">&#9670;&nbsp;</a></span>startPropertySubElement() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* <a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 3 &gt;::startPropertySubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation. </p>
<p>If <em>subTagName</em> names an XML element that describes an optional property of a triangulation (such as <code>H1</code> or <code>fundgroup</code> for 3-manifold triangulations), then this function should return a corresponding element reader.</p>
<p>Otherwise this function should return a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a>, which will cause the XML element to be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the XML subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should not take care of the new reader's destruction; that will be done by the parser. </dd></dl>

</div>
</div>
<a id="ga3db2f450c03ec469695a263eaba05f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db2f450c03ec469695a263eaba05f81">&#9670;&nbsp;</a></span>startPropertySubElement() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* <a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 4 &gt;::startPropertySubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML element reader for the given optional property of a <em>dim</em>-dimensional triangulation. </p>
<p>If <em>subTagName</em> names an XML element that describes an optional property of a triangulation (such as <code>H1</code> or <code>fundgroup</code> for 3-manifold triangulations), then this function should return a corresponding element reader.</p>
<p>Otherwise this function should return a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a>, which will cause the XML element to be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the XML subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should not take care of the new reader's destruction; that will be done by the parser. </dd></dl>

</div>
</div>
<a id="ga82d83880a7a5ae6cccbc3703e1514875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d83880a7a5ae6cccbc3703e1514875">&#9670;&nbsp;</a></span>threeSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::threeSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-tetrahedron triangulation of the 3-sphere. </p>
<p>This is <em>different</em> from the generic routine <a class="el" href="group__detail.html#gac44d1474b152e941ff3e57ca342095ff" title="Closed Triangulations.">sphere()</a>, which uses two tetrahedra instead.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gae4bc618d73869c4aac5ffb14c3d7ecf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4bc618d73869c4aac5ffb14c3d7ecf2">&#9670;&nbsp;</a></span>torsionLegendreSymbolVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, std::vector&lt; int &gt; &gt; &gt; &amp; regina::HomologicalData::torsionLegendreSymbolVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the odd p-torsion Legendre symbol vector. </p>
<p>This is the last of the three Kawauchi-Kojima invariants.</p>
<p>For details, see "Algebraic classification of linking pairings on
3-manifolds", Akio Kawauchi and Sadayoshi Kojima, Math. Ann. 253 (1980), 29&ndash;42.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Legendre symbol vector associated to the torsion linking form. </dd></dl>

</div>
</div>
<a id="ga1283cc606f9ccc0b9192fd5616e2790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1283cc606f9ccc0b9192fd5616e2790c">&#9670;&nbsp;</a></span>torsionLegendreSymbolVectorString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::HomologicalData::torsionLegendreSymbolVectorString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__triangulation.html#gae4bc618d73869c4aac5ffb14c3d7ecf2" title="Returns the odd p-torsion Legendre symbol vector.">torsionLegendreSymbolVector()</a> but returns as a human-readable string. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Legendre symbol vector in human-readable form. </dd></dl>

</div>
</div>
<a id="ga391792f07dd6c6ac7c8332b6f59788dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391792f07dd6c6ac7c8332b6f59788dc">&#9670;&nbsp;</a></span>torsionRankVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, std::vector&lt; unsigned long &gt; &gt; &gt; &amp; regina::HomologicalData::torsionRankVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the torsion form rank vector. </p>
<p>This is the first of the three Kawauchi-Kojima complete invariants of the torsion linking form.</p>
<p>This vector describes the rank of the torsion subgroup of H1, given in prime power form. It is a vector of pairs (<em>p</em>, <em>x</em>), where <em>p</em> is a prime and <em>x</em> is its exponent.</p>
<p>For details, see "Algebraic classification of linking pairings on
3-manifolds", Akio Kawauchi and Sadayoshi Kojima, Math. Ann. 253 (1980), 29&ndash;42.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the torsion form rank vector. </dd></dl>

</div>
</div>
<a id="ga9020bc0a0f506abda7363e6642cf3c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9020bc0a0f506abda7363e6642cf3c06">&#9670;&nbsp;</a></span>torsionRankVectorString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::HomologicalData::torsionRankVectorString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__triangulation.html#ga391792f07dd6c6ac7c8332b6f59788dc" title="Returns the torsion form rank vector.">torsionRankVector()</a> but returns as a human-readable string. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>human-readable prime power factorization of the order of the torsion subgroup of H1. </dd></dl>

</div>
</div>
<a id="gad10c1028861c4f198147557e5cbdaad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10c1028861c4f198147557e5cbdaad3">&#9670;&nbsp;</a></span>torsionSigmaVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp; regina::HomologicalData::torsionSigmaVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 2-torsion sigma vector. </p>
<p>This is the second of the three Kawauchi-Kojima invariants. It is orientation-sensitive.</p>
<p>For details, see "Algebraic classification of linking pairings on
3-manifolds", Akio Kawauchi and Sadayoshi Kojima, Math. Ann. 253 (1980), 29&ndash;42.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Kawauchi-Kojima sigma-vector. </dd></dl>

</div>
</div>
<a id="ga3054d736240904b1831b84da81aef8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3054d736240904b1831b84da81aef8d9">&#9670;&nbsp;</a></span>torsionSigmaVectorString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::HomologicalData::torsionSigmaVectorString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__triangulation.html#gad10c1028861c4f198147557e5cbdaad3" title="Returns the 2-torsion sigma vector.">torsionSigmaVector()</a> but returns as a human-readable string. </p>
<p>This is an orientation-sensitive invariant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation is of a connected orientable 3-manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Kawauchi-Kojima sigma-vector in human readable form. </dd></dl>

</div>
</div>
<a id="gacd184660c001d3ae15322d7310e73e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd184660c001d3ae15322d7310e73e67">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 2 &gt;::torus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-triangle torus. </p>
<p>This is isomorphic to the triangulation returned by the generic routine <a class="el" href="group__detail.html#gac808405b4900c8fdff2153d1e404f1bb" title="Returns a two-simplex triangulation of the product space S^(dim-1) x S^1.">sphereBundle()</a>, though it will have a different packet label.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gadc75b323f8dcf6b12c547044c1970e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc75b323f8dcf6b12c547044c1970e37">&#9670;&nbsp;</a></span>trefoil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::trefoil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-tetrahedron ideal triangulation of the trefoil knot complement. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga90847033b2a6b2300692ace623087ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90847033b2a6b2300692ace623087ef5">&#9670;&nbsp;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::FacePair::upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the larger of the two face numbers in this pair. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This face pair is neither before-the-start or past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the upper face number. </dd></dl>

</div>
</div>
<a id="ga305cd2fb5a63a446a3516e536469be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305cd2fb5a63a446a3516e536469be29">&#9670;&nbsp;</a></span>weberSeifert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::weberSeifert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-vertex triangulation of the Weber-Seifert dodecahedral space. </p>
<p>This 3-manifold is described in "Die beiden Dodekaederraume", C. Weber and H. Seifert, Math. Z. 37 (1933), no. 1, 237-253. The triangulation returned by this routine (with 23 tetrahedra) is given in "The Weber-Seifert dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaa2a2880d95c9c8894d22bce7eb25a8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2a2880d95c9c8894d22bce7eb25a8cd">&#9670;&nbsp;</a></span>weeks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::weeks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nine-tetrahedron minimal triangulation of the Weeks manifold. </p>
<p>The Weeks manifold is the smallest-volume closed hyperbolic 3-manifold, with a volume of roughly 0.9427. Note that there are nine minimal triangulations of the Weeks manifold (of course this routine returns just one).</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaaf56d7888a5df6a20428c91f1898e60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf56d7888a5df6a20428c91f1898e60e">&#9670;&nbsp;</a></span>whiteheadLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Example.html">regina::Example</a>&lt; 3 &gt;::whiteheadLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-tetrahedron ideal triangulation of the Whitehead link complement. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaff98ccbba15e8fed20725f41511663d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff98ccbba15e8fed20725f41511663d8">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomologicalData::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>Note this only writes pre-computed data. Thus if you have not yet asked <a class="el" href="classregina_1_1HomologicalData.html" title="Data type that deals with all the detailed homological information in a manifold.">HomologicalData</a> to compute anything about this triangulation, writeTextShort may be empty.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga430867631ebaecf328d1609192fbc38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga430867631ebaecf328d1609192fbc38c">&#9670;&nbsp;</a></span>XMLTriangulationReader() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; dim &gt;::<a class="el" href="classregina_1_1XMLTriangulationReader.html">XMLTriangulationReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new triangulation reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad224fd1504559e98208a8dfa8eb1e43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad224fd1504559e98208a8dfa8eb1e43a">&#9670;&nbsp;</a></span>XMLTriangulationReader() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1XMLTriangulationReader.html">XMLTriangulationReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new triangulation reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24c36f0c743f0141ff54a19fcdb17ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c36f0c743f0141ff54a19fcdb17ade">&#9670;&nbsp;</a></span>XMLTriangulationReader() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1XMLTriangulationReader.html">XMLTriangulationReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new triangulation reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga287350de6e977d479b11f0df6f31c55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287350de6e977d479b11f0df6f31c55e">&#9670;&nbsp;</a></span>XMLTriangulationReader() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLTriangulationReader.html">regina::XMLTriangulationReader</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1XMLTriangulationReader.html">XMLTriangulationReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new triangulation reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga307c7ecaaccd31d0f6d0f886276cd074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307c7ecaaccd31d0f6d0f886276cd074">&#9670;&nbsp;</a></span>~HomologicalData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomologicalData::~HomologicalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5a68d576c23c475c65a9a4b2aef7ff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a68d576c23c475c65a9a4b2aef7ff95">&#9670;&nbsp;</a></span>facet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::facet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The facet of the simplex referred to. </p>
<p>The facet number is between 0 and <em>dim</em> inclusive. </p>

</div>
</div>
<a id="ga2697037b7441f2a126882fe861209d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2697037b7441f2a126882fe861209d37">&#9670;&nbsp;</a></span>simp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::simp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The simplex referred to. </p>
<p>Simplex numbering begins at 0. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
