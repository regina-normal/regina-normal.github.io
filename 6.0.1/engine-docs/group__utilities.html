<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous helper classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorByType.html">regina::BitManipulatorByType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the underlying data type.  <a href="classregina_1_1BitManipulatorByType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorBySize.html">regina::BitManipulatorBySize&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the size of the underlying data type.  <a href="classregina_1_1BitManipulatorBySize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulator.html">regina::BitManipulator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised class for bitwise analysis and manipulation of native data types.  <a href="classregina_1_1BitManipulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask that can store arbitrarily many true-or-false bits.  <a href="classregina_1_1Bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) true-or-false bits.  <a href="classregina_1_1Bitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) true-or-false bits.  <a href="classregina_1_1Bitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoolSet.html">regina::BoolSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of booleans.  <a href="classregina_1_1BoolSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Flags.html">regina::Flags&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a bitwise combination of flags defined by an enumeration type.  <a href="classregina_1_1Flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1Locale.html">regina::i18n::Locale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class with static routines for querying information about the current locale.  <a href="classregina_1_1i18n_1_1Locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">regina::i18n::IConvStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream buffer that translates between character encodings.  <a href="classregina_1_1i18n_1_1IConvStreamBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStream.html">regina::i18n::IConvStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream that converts between character encodings.  <a href="classregina_1_1i18n_1_1IConvStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaInteger.html">regina::IsReginaInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's own integer types.  <a href="structregina_1_1IsReginaInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>exactly</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>at least</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfMinSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers a hard-coded list of expensive objects that should only be created if they are required.  <a href="classregina_1_1ListOnCall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html">regina::MarkedElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for elements of <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="classregina_1_1MarkedElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of objects with fast, space-efficient reverse lookup of array indices.  <a href="classregina_1_1MarkedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__istream.html">regina::mem_istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input stream that reads an array of characters in memory.  <a href="classregina_1_1mem__istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__streambuf.html">regina::mem_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer that provides the implementation details for <a class="el" href="classregina_1_1mem__istream.html" title="An input stream that reads an array of characters in memory.">mem_istream</a>.  <a href="classregina_1_1mem__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNew.html">regina::FuncNew&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable generator used to create objects using default constructors.  <a href="structregina_1_1FuncNew.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using the <code>clone()</code> method.  <a href="structregina_1_1FuncNewClonePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to deallocate objects.  <a href="structregina_1_1FuncDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by value.  <a href="classregina_1_1StoreValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by constant pointer.  <a href="classregina_1_1StoreConstPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by pointer and that the property wrapper will also take responsibility for memory management.  <a href="classregina_1_1StoreManagedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Property.html">regina::Property&lt; T, Storage &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a calculable property of an object.  <a href="classregina_1_1Property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref&lt; T, Comp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable binary function used to compare the objects to which pointers are pointing.  <a href="classregina_1_1LessDeref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1RandomEngine.html">regina::RandomEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers threadsafe access to Regina's global uniform random bit generator.  <a href="classregina_1_1RandomEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Returns.html">regina::Returns&lt; ReturnType_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience base class for a non-void function object, which does nothing beyond provide a <em>ReturnType</em> typedef.  <a href="structregina_1_1Returns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HasReturnType.html">regina::HasReturnType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal to <a class="el" href="structregina_1_1ReturnsTraits.html" title="Helper class to assist with compile-time analysis of Regina&#39;s function objects.">ReturnsTraits</a>.  <a href="classregina_1_1HasReturnType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ReturnsTraitsImplementation.html">regina::ReturnsTraitsImplementation&lt; T, hasReturnType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the implementation of <a class="el" href="structregina_1_1ReturnsTraits.html" title="Helper class to assist with compile-time analysis of Regina&#39;s function objects.">ReturnsTraits</a>.  <a href="structregina_1_1ReturnsTraitsImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ReturnsTraits.html">regina::ReturnsTraits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to assist with compile-time analysis of Regina's function objects.  <a href="structregina_1_1ReturnsTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NewFunction.html">regina::NewFunction&lt; Base &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object that creates a new object subclassed from <em>Base</em>, where the particular subclass is chosen according to the template argument to operator().  <a href="structregina_1_1NewFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for objects of type <em>T</em> to be referenceable by a <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a>.  <a href="classregina_1_1SafePointeeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference counted smart pointer that supports alternate models of ownership.  <a href="classregina_1_1SafePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight class for storing a random-access sequence of objects.  <a href="classregina_1_1LightweightSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LightweightSequence_1_1Less.html">regina::LightweightSequence&lt; T &gt;::Less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary function object that compares sequences lexicographically, for use in containers that hold pointers to sequences.  <a href="structregina_1_1LightweightSequence_1_1Less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary function object for comparing subsequences, for use in associative containers whose keys are pointers to sequences.  <a href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie-like data structure for storing and retriving sets.  <a href="classregina_1_1TrieSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1Tritmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1Tritmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a map from property names to property values.  <a href="classregina_1_1xml_1_1XMLPropertyDict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">regina::xml::XMLParserCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the callbacks for an <a class="el" href="classregina_1_1xml_1_1XMLParser.html" title="Used to parse an entire XML file.">XMLParser</a>.  <a href="classregina_1_1xml_1_1XMLParserCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParser.html">regina::xml::XMLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to parse an entire XML file.  <a href="classregina_1_1xml_1_1XMLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5ffec6ccec6eaaf2e875fd1533a50c05">INT128_AVAILABLE</a></td></tr>
<tr class="memdesc:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined if and only if native 128-bit arithmetic is available on this platform.  <a href="group__utilities.html#ga5ffec6ccec6eaaf2e875fd1533a50c05">More...</a><br /></td></tr>
<tr class="separator:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">regina::BitmaskLen8</a></td></tr>
<tr class="memdesc:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">More...</a><br /></td></tr>
<tr class="separator:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79171eb0dd3165e733ca97b8240b861b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">regina::BitmaskLen16</a></td></tr>
<tr class="memdesc:ga79171eb0dd3165e733ca97b8240b861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">More...</a><br /></td></tr>
<tr class="separator:ga79171eb0dd3165e733ca97b8240b861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb60aab55cbe801e14a1654bccbeee20"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">regina::BitmaskLen32</a></td></tr>
<tr class="memdesc:gadb60aab55cbe801e14a1654bccbeee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">More...</a><br /></td></tr>
<tr class="separator:gadb60aab55cbe801e14a1654bccbeee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecadfef5ba587ad7030165a79b277ec5"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">regina::BitmaskLen64</a></td></tr>
<tr class="memdesc:gaecadfef5ba587ad7030165a79b277ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">More...</a><br /></td></tr>
<tr class="separator:gaecadfef5ba587ad7030165a79b277ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">regina::NBoolSet</a></td></tr>
<tr class="memdesc:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">More...</a><br /></td></tr>
<tr class="separator:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdf90e8b84a918ef0de50ec862110ad"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabbdf90e8b84a918ef0de50ec862110ad">regina::Flags&lt; T &gt;::Enum</a></td></tr>
<tr class="memdesc:gabbdf90e8b84a918ef0de50ec862110ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying enumeration type.  <a href="group__utilities.html#gabbdf90e8b84a918ef0de50ec862110ad">More...</a><br /></td></tr>
<tr class="separator:gabbdf90e8b84a918ef0de50ec862110ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e439042b321fb0e4acd637f142e673"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga15e439042b321fb0e4acd637f142e673">regina::IntOfSize&lt; bytes &gt;::type</a></td></tr>
<tr class="memdesc:ga15e439042b321fb0e4acd637f142e673"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native signed integer type with exactly <em>k</em> bytes, where <em>k</em> is the template parameter.  <a href="group__utilities.html#ga15e439042b321fb0e4acd637f142e673">More...</a><br /></td></tr>
<tr class="separator:ga15e439042b321fb0e4acd637f142e673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6a3a2fd5eff7865bf401918d3399d0"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaec6a3a2fd5eff7865bf401918d3399d0">regina::IntOfSize&lt; bytes &gt;::utype</a></td></tr>
<tr class="memdesc:gaec6a3a2fd5eff7865bf401918d3399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native unsigned integer type with exactly <em>k</em> bytes, where <em>k</em> is the template parameter.  <a href="group__utilities.html#gaec6a3a2fd5eff7865bf401918d3399d0">More...</a><br /></td></tr>
<tr class="separator:gaec6a3a2fd5eff7865bf401918d3399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be809f5e841c27471510295afe33413"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1IntOfSize.html">IntOfSize</a>&lt; <a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">nextPowerOfTwo</a>(bytes)&gt;::<a class="el" href="group__utilities.html#ga6be809f5e841c27471510295afe33413">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6be809f5e841c27471510295afe33413">regina::IntOfMinSize&lt; bytes &gt;::type</a></td></tr>
<tr class="memdesc:ga6be809f5e841c27471510295afe33413"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native signed integer type with at least <em>k</em> bytes, where <em>k</em> is the template parameter.  <a href="group__utilities.html#ga6be809f5e841c27471510295afe33413">More...</a><br /></td></tr>
<tr class="separator:ga6be809f5e841c27471510295afe33413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65305efb63d2daed6a8ce2e64c335163"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1IntOfSize.html">IntOfSize</a>&lt; <a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">nextPowerOfTwo</a>(bytes)&gt;::<a class="el" href="group__utilities.html#ga65305efb63d2daed6a8ce2e64c335163">utype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga65305efb63d2daed6a8ce2e64c335163">regina::IntOfMinSize&lt; bytes &gt;::utype</a></td></tr>
<tr class="memdesc:ga65305efb63d2daed6a8ce2e64c335163"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native unsigned integer type with at least <em>k</em> bytes, where <em>k</em> is the template parameter.  <a href="group__utilities.html#ga65305efb63d2daed6a8ce2e64c335163">More...</a><br /></td></tr>
<tr class="separator:ga65305efb63d2daed6a8ce2e64c335163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c59ac14b7b95cee666f39804fa1580"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; const T * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">regina::ListOnCall&lt; T &gt;::iterator</a></td></tr>
<tr class="memdesc:gad5c59ac14b7b95cee666f39804fa1580"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over this list.  <a href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">More...</a><br /></td></tr>
<tr class="separator:gad5c59ac14b7b95cee666f39804fa1580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245bb7f4aa8ace4704fdd054299dacfd"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga245bb7f4aa8ace4704fdd054299dacfd">regina::FuncNew&lt; T &gt;::result_type</a></td></tr>
<tr class="memdesc:ga245bb7f4aa8ace4704fdd054299dacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for this generator.  <a href="group__utilities.html#ga245bb7f4aa8ace4704fdd054299dacfd">More...</a><br /></td></tr>
<tr class="separator:ga245bb7f4aa8ace4704fdd054299dacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a9eae5d19a0251b4c8eca0cc1fdcef"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab5a9eae5d19a0251b4c8eca0cc1fdcef">regina::FuncNewCopyPtr&lt; T &gt;::argument_type</a></td></tr>
<tr class="memdesc:gab5a9eae5d19a0251b4c8eca0cc1fdcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument type for this unary function.  <a href="group__utilities.html#gab5a9eae5d19a0251b4c8eca0cc1fdcef">More...</a><br /></td></tr>
<tr class="separator:gab5a9eae5d19a0251b4c8eca0cc1fdcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffdeb10aece6ad482049b9b19bf12ee"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6ffdeb10aece6ad482049b9b19bf12ee">regina::FuncNewCopyPtr&lt; T &gt;::result_type</a></td></tr>
<tr class="memdesc:ga6ffdeb10aece6ad482049b9b19bf12ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for this unary function.  <a href="group__utilities.html#ga6ffdeb10aece6ad482049b9b19bf12ee">More...</a><br /></td></tr>
<tr class="separator:ga6ffdeb10aece6ad482049b9b19bf12ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d77a56c39300bfd5cd4e803395d18"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7e0d77a56c39300bfd5cd4e803395d18">regina::FuncNewCopyRef&lt; T &gt;::argument_type</a></td></tr>
<tr class="memdesc:ga7e0d77a56c39300bfd5cd4e803395d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument type for this unary function.  <a href="group__utilities.html#ga7e0d77a56c39300bfd5cd4e803395d18">More...</a><br /></td></tr>
<tr class="separator:ga7e0d77a56c39300bfd5cd4e803395d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3e32dac13bd0df45d847ae9f8fbc44"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5d3e32dac13bd0df45d847ae9f8fbc44">regina::FuncNewCopyRef&lt; T &gt;::result_type</a></td></tr>
<tr class="memdesc:ga5d3e32dac13bd0df45d847ae9f8fbc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for this unary function.  <a href="group__utilities.html#ga5d3e32dac13bd0df45d847ae9f8fbc44">More...</a><br /></td></tr>
<tr class="separator:ga5d3e32dac13bd0df45d847ae9f8fbc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b5f37135fc402ae122d093f64ad884"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga18b5f37135fc402ae122d093f64ad884">regina::FuncNewClonePtr&lt; T &gt;::argument_type</a></td></tr>
<tr class="memdesc:ga18b5f37135fc402ae122d093f64ad884"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument type for this unary function.  <a href="group__utilities.html#ga18b5f37135fc402ae122d093f64ad884">More...</a><br /></td></tr>
<tr class="separator:ga18b5f37135fc402ae122d093f64ad884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffae5f2da82f58de4f8579a2d0e429a7"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaffae5f2da82f58de4f8579a2d0e429a7">regina::FuncNewClonePtr&lt; T &gt;::result_type</a></td></tr>
<tr class="memdesc:gaffae5f2da82f58de4f8579a2d0e429a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for this unary function.  <a href="group__utilities.html#gaffae5f2da82f58de4f8579a2d0e429a7">More...</a><br /></td></tr>
<tr class="separator:gaffae5f2da82f58de4f8579a2d0e429a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc26f1f39beac07c5e4e250facde232"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacdc26f1f39beac07c5e4e250facde232">regina::FuncDelete&lt; T &gt;::argument_type</a></td></tr>
<tr class="memdesc:gacdc26f1f39beac07c5e4e250facde232"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument type for this unary function.  <a href="group__utilities.html#gacdc26f1f39beac07c5e4e250facde232">More...</a><br /></td></tr>
<tr class="separator:gacdc26f1f39beac07c5e4e250facde232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa120de9d57db06de9469ad0b8a2367f6"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa120de9d57db06de9469ad0b8a2367f6">regina::FuncDelete&lt; T &gt;::result_type</a></td></tr>
<tr class="memdesc:gaa120de9d57db06de9469ad0b8a2367f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for this unary function.  <a href="group__utilities.html#gaa120de9d57db06de9469ad0b8a2367f6">More...</a><br /></td></tr>
<tr class="separator:gaa120de9d57db06de9469ad0b8a2367f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949767b095cf660d16478a14b5628541"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga949767b095cf660d16478a14b5628541">regina::StoreValue&lt; T &gt;::InitType</a></td></tr>
<tr class="memdesc:ga949767b095cf660d16478a14b5628541"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which new values for the underlying property are passed.  <a href="group__utilities.html#ga949767b095cf660d16478a14b5628541">More...</a><br /></td></tr>
<tr class="separator:ga949767b095cf660d16478a14b5628541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95455eccee62a6658b0485202ed4ff44"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">regina::StoreValue&lt; T &gt;::QueryType</a></td></tr>
<tr class="memdesc:ga95455eccee62a6658b0485202ed4ff44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which the property value is returned to the user.  <a href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">More...</a><br /></td></tr>
<tr class="separator:ga95455eccee62a6658b0485202ed4ff44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04c3e6e45f55dd362dd3f12d1d6d437"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab04c3e6e45f55dd362dd3f12d1d6d437">regina::StoreConstPtr&lt; T &gt;::InitType</a></td></tr>
<tr class="memdesc:gab04c3e6e45f55dd362dd3f12d1d6d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which new values for the underlying property are passed.  <a href="group__utilities.html#gab04c3e6e45f55dd362dd3f12d1d6d437">More...</a><br /></td></tr>
<tr class="separator:gab04c3e6e45f55dd362dd3f12d1d6d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357adaaf14f89d15b68b2b33b7e86dde"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga357adaaf14f89d15b68b2b33b7e86dde">regina::StoreConstPtr&lt; T &gt;::QueryType</a></td></tr>
<tr class="memdesc:ga357adaaf14f89d15b68b2b33b7e86dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which the property value is returned to the user.  <a href="group__utilities.html#ga357adaaf14f89d15b68b2b33b7e86dde">More...</a><br /></td></tr>
<tr class="separator:ga357adaaf14f89d15b68b2b33b7e86dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6fa06368747d8c9860bc759c74bb982"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf6fa06368747d8c9860bc759c74bb982">regina::StoreManagedPtr&lt; T &gt;::InitType</a></td></tr>
<tr class="memdesc:gaf6fa06368747d8c9860bc759c74bb982"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which new values for the underlying property are passed.  <a href="group__utilities.html#gaf6fa06368747d8c9860bc759c74bb982">More...</a><br /></td></tr>
<tr class="separator:gaf6fa06368747d8c9860bc759c74bb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd358ef4b5e49466a472abe7d9e8a6b0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd358ef4b5e49466a472abe7d9e8a6b0">regina::StoreManagedPtr&lt; T &gt;::QueryType</a></td></tr>
<tr class="memdesc:gacd358ef4b5e49466a472abe7d9e8a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which the property value is returned to the user.  <a href="group__utilities.html#gacd358ef4b5e49466a472abe7d9e8a6b0">More...</a><br /></td></tr>
<tr class="separator:gacd358ef4b5e49466a472abe7d9e8a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26d3f924e8799504cad495bd1705e6e"><td class="memItemLeft" align="right" valign="top">typedef Storage&lt; T &gt;::<a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">InitType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">regina::Property&lt; T, Storage &gt;::InitType</a></td></tr>
<tr class="memdesc:gac26d3f924e8799504cad495bd1705e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which new values for the underlying property are passed.  <a href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">More...</a><br /></td></tr>
<tr class="separator:gac26d3f924e8799504cad495bd1705e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c7adbd6c3f9e75585c48d6d27b46c8"><td class="memItemLeft" align="right" valign="top">typedef Storage&lt; T &gt;::<a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga50c7adbd6c3f9e75585c48d6d27b46c8">regina::Property&lt; T, Storage &gt;::QueryType</a></td></tr>
<tr class="memdesc:ga50c7adbd6c3f9e75585c48d6d27b46c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type by which the property value is returned to the user.  <a href="group__utilities.html#ga50c7adbd6c3f9e75585c48d6d27b46c8">More...</a><br /></td></tr>
<tr class="separator:ga50c7adbd6c3f9e75585c48d6d27b46c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab149c9840796655df2fc505478fe770c"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab149c9840796655df2fc505478fe770c">regina::LessDeref&lt; T, Comp &gt;::first_argument_type</a></td></tr>
<tr class="memdesc:gab149c9840796655df2fc505478fe770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first argument type for this binary function.  <a href="group__utilities.html#gab149c9840796655df2fc505478fe770c">More...</a><br /></td></tr>
<tr class="separator:gab149c9840796655df2fc505478fe770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03becf53f1db5854d6d40087902e4bae"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga03becf53f1db5854d6d40087902e4bae">regina::LessDeref&lt; T, Comp &gt;::second_argument_type</a></td></tr>
<tr class="memdesc:ga03becf53f1db5854d6d40087902e4bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The second argument type for this binary function.  <a href="group__utilities.html#ga03becf53f1db5854d6d40087902e4bae">More...</a><br /></td></tr>
<tr class="separator:ga03becf53f1db5854d6d40087902e4bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd454858edeb97f9ca41375e6437ec9"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7fd454858edeb97f9ca41375e6437ec9">regina::LessDeref&lt; T, Comp &gt;::result_type</a></td></tr>
<tr class="memdesc:ga7fd454858edeb97f9ca41375e6437ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type for this binary comparison function.  <a href="group__utilities.html#ga7fd454858edeb97f9ca41375e6437ec9">More...</a><br /></td></tr>
<tr class="separator:ga7fd454858edeb97f9ca41375e6437ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bc959ede9feeded32f0e82d889287b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">regina::QitmaskLen8</a></td></tr>
<tr class="memdesc:ga99bc959ede9feeded32f0e82d889287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">More...</a><br /></td></tr>
<tr class="separator:ga99bc959ede9feeded32f0e82d889287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa396173f6b9d24d6e5f0412386813651"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">regina::QitmaskLen16</a></td></tr>
<tr class="memdesc:gaa396173f6b9d24d6e5f0412386813651"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">More...</a><br /></td></tr>
<tr class="separator:gaa396173f6b9d24d6e5f0412386813651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db96e54efcf3eda083368b3cc77abd3"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">regina::QitmaskLen32</a></td></tr>
<tr class="memdesc:ga2db96e54efcf3eda083368b3cc77abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">More...</a><br /></td></tr>
<tr class="separator:ga2db96e54efcf3eda083368b3cc77abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b4c70291965332b28e1891b86ea054"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">regina::QitmaskLen64</a></td></tr>
<tr class="memdesc:gaf4b4c70291965332b28e1891b86ea054"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">More...</a><br /></td></tr>
<tr class="separator:gaf4b4c70291965332b28e1891b86ea054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ba10ae389fb70970ed50bd88cd834e"><td class="memItemLeft" align="right" valign="top">typedef ReturnType_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga51ba10ae389fb70970ed50bd88cd834e">regina::Returns&lt; ReturnType_ &gt;::ReturnType</a></td></tr>
<tr class="memdesc:ga51ba10ae389fb70970ed50bd88cd834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the return type for a function object.  <a href="group__utilities.html#ga51ba10ae389fb70970ed50bd88cd834e">More...</a><br /></td></tr>
<tr class="separator:ga51ba10ae389fb70970ed50bd88cd834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2e4bacf91fc79a12ae3a02f4339ed034">regina::SafePointeeBase&lt; T &gt;::SafePointeeType</a></td></tr>
<tr class="memdesc:ga2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="group__utilities.html#ga2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br /></td></tr>
<tr class="separator:ga2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabac6c7ebbdfadab22b74bca62c900e5"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaabac6c7ebbdfadab22b74bca62c900e5">regina::SafePtr&lt; T &gt;::element_type</a></td></tr>
<tr class="memdesc:gaabac6c7ebbdfadab22b74bca62c900e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointee type.  <a href="group__utilities.html#gaabac6c7ebbdfadab22b74bca62c900e5">More...</a><br /></td></tr>
<tr class="separator:gaabac6c7ebbdfadab22b74bca62c900e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11786e34be796e7fd8ce05884be77a39"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">regina::LightweightSequence&lt; T &gt;::iterator</a></td></tr>
<tr class="memdesc:ga11786e34be796e7fd8ce05884be77a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type for read-write access to the elements of a sequence.  <a href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">More...</a><br /></td></tr>
<tr class="separator:ga11786e34be796e7fd8ce05884be77a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68708a91988e06ed2df5adcc22539144"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">regina::LightweightSequence&lt; T &gt;::const_iterator</a></td></tr>
<tr class="memdesc:ga68708a91988e06ed2df5adcc22539144"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type for read-only access to the elements of a sequence.  <a href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">More...</a><br /></td></tr>
<tr class="separator:ga68708a91988e06ed2df5adcc22539144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">regina::TritmaskLen8</a></td></tr>
<tr class="memdesc:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">More...</a><br /></td></tr>
<tr class="separator:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a71a872e94df27800252dbd7a105758"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">regina::TritmaskLen16</a></td></tr>
<tr class="memdesc:ga4a71a872e94df27800252dbd7a105758"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">More...</a><br /></td></tr>
<tr class="separator:ga4a71a872e94df27800252dbd7a105758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8ecc460b8fec9c1630a0830e57469eb"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">regina::TritmaskLen32</a></td></tr>
<tr class="memdesc:gae8ecc460b8fec9c1630a0830e57469eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">More...</a><br /></td></tr>
<tr class="separator:gae8ecc460b8fec9c1630a0830e57469eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">regina::TritmaskLen64</a></td></tr>
<tr class="memdesc:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">More...</a><br /></td></tr>
<tr class="separator:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga47e47aeb6aa562479893b2ba9fde8f86"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__utilities.html#gga47e47aeb6aa562479893b2ba9fde8f86a101af964ef1d282fe693f4eec55e8ca0">regina::BitManipulatorByType&lt; T &gt;::specialised</a> = 0
 }</td></tr>
<tr class="separator:ga47e47aeb6aa562479893b2ba9fde8f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5c7360ed9a884b5a4b823e0bc11d57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__utilities.html#ggaff5c7360ed9a884b5a4b823e0bc11d57ac4b50a31e844760e76735baf17df0370">regina::BitManipulatorBySize&lt; T, size &gt;::specialised</a> = 0
 }</td></tr>
<tr class="separator:gaff5c7360ed9a884b5a4b823e0bc11d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649e1316a2542f8f49fc0a77aebf0211"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__utilities.html#gga649e1316a2542f8f49fc0a77aebf0211af42cc480009a85742799aa5e84410a37">regina::BitManipulator&lt; T &gt;::specialised</a>
 }</td></tr>
<tr class="separator:ga649e1316a2542f8f49fc0a77aebf0211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27f3e545612357418930ee76b3307e59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__utilities.html#gga27f3e545612357418930ee76b3307e59a1f4670f6ee69e8a856f663b5c77ab240">regina::HasReturnType&lt; T &gt;::value</a> = (sizeof(test&lt;T&gt;(0)) == sizeof(yes))
 }</td></tr>
<tr class="separator:ga27f3e545612357418930ee76b3307e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">regina::base64Length</a> (size_t bytes)</td></tr>
<tr class="memdesc:gaa8d632b73943b5c52e395d56f8e03af2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes.  <a href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">More...</a><br /></td></tr>
<tr class="separator:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">regina::isBase64</a> (char ch)</td></tr>
<tr class="memdesc:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given character is a base64 printable character as used by the base64 routines in Regina.  <a href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">More...</a><br /></td></tr>
<tr class="separator:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d322bec8070a889aba14d5988ae80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">regina::base64Encode</a> (const char *in, size_t inlen, char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga081d322bec8070a889aba14d5988ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer.  <a href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">More...</a><br /></td></tr>
<tr class="separator:ga081d322bec8070a889aba14d5988ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541f612d6bb0f94db16da14169813e29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">regina::base64Encode</a> (const char *in, size_t inlen, char **out)</td></tr>
<tr class="memdesc:ga541f612d6bb0f94db16da14169813e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">More...</a><br /></td></tr>
<tr class="separator:ga541f612d6bb0f94db16da14169813e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">regina::base64Decode</a> (const char *in, size_t inlen, char *out, size_t *outlen)</td></tr>
<tr class="memdesc:ga6811ec511cb61bfc071467ba5d0e8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer.  <a href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">More...</a><br /></td></tr>
<tr class="separator:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d6c710ee070d88c4b670b48bec3878"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">regina::base64Decode</a> (const char *in, size_t inlen, char **out, size_t *outlen)</td></tr>
<tr class="memdesc:ga47d6c710ee070d88c4b670b48bec3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">More...</a><br /></td></tr>
<tr class="separator:ga47d6c710ee070d88c4b670b48bec3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b04c78ee6c4dc016194fe7f04a6d54"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga77b04c78ee6c4dc016194fe7f04a6d54">regina::BitManipulatorByType&lt; T &gt;::nextPermutation</a> (T x)</td></tr>
<tr class="memdesc:ga77b04c78ee6c4dc016194fe7f04a6d54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next largest integer with the same number of <code>true</code> bits as <em>x</em>.  <a href="group__utilities.html#ga77b04c78ee6c4dc016194fe7f04a6d54">More...</a><br /></td></tr>
<tr class="separator:ga77b04c78ee6c4dc016194fe7f04a6d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdd38837b2872b79c4cf27f304d8f838"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabdd38837b2872b79c4cf27f304d8f838">regina::BitManipulatorBySize&lt; T, size &gt;::bits</a> (T x)</td></tr>
<tr class="memdesc:gabdd38837b2872b79c4cf27f304d8f838"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits that are set to 1 in the given integer.  <a href="group__utilities.html#gabdd38837b2872b79c4cf27f304d8f838">More...</a><br /></td></tr>
<tr class="separator:gabdd38837b2872b79c4cf27f304d8f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae126bd472acad119bc3e8f2661c4ed29"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae126bd472acad119bc3e8f2661c4ed29">regina::BitManipulator&lt; T &gt;::firstBit</a> (T x)</td></tr>
<tr class="memdesc:gae126bd472acad119bc3e8f2661c4ed29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in the given integer, or -1 if the given integer is zero.  <a href="group__utilities.html#gae126bd472acad119bc3e8f2661c4ed29">More...</a><br /></td></tr>
<tr class="separator:gae126bd472acad119bc3e8f2661c4ed29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae81363831599dfc3e896e31e3901a51"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaae81363831599dfc3e896e31e3901a51">regina::BitManipulator&lt; T &gt;::lastBit</a> (T x)</td></tr>
<tr class="memdesc:gaae81363831599dfc3e896e31e3901a51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in the given integer, or -1 if the given integer is zero.  <a href="group__utilities.html#gaae81363831599dfc3e896e31e3901a51">More...</a><br /></td></tr>
<tr class="separator:gaae81363831599dfc3e896e31e3901a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b3974553c4c68a861724592166a4c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga63b3974553c4c68a861724592166a4c8">regina::Bitmask::Bitmask</a> ()</td></tr>
<tr class="memdesc:ga63b3974553c4c68a861724592166a4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new invalid bitmask.  <a href="group__utilities.html#ga63b3974553c4c68a861724592166a4c8">More...</a><br /></td></tr>
<tr class="separator:ga63b3974553c4c68a861724592166a4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a36a6f40f432a9c1f6e47590f191229"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9a36a6f40f432a9c1f6e47590f191229">regina::Bitmask::Bitmask</a> (size_t length)</td></tr>
<tr class="memdesc:ga9a36a6f40f432a9c1f6e47590f191229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask of the given length with all bits set to <code>false</code>.  <a href="group__utilities.html#ga9a36a6f40f432a9c1f6e47590f191229">More...</a><br /></td></tr>
<tr class="separator:ga9a36a6f40f432a9c1f6e47590f191229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a14612fe9264e5bbb9eb18f959ef2af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a14612fe9264e5bbb9eb18f959ef2af">regina::Bitmask::Bitmask</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga3a14612fe9264e5bbb9eb18f959ef2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given bitmask.  <a href="group__utilities.html#ga3a14612fe9264e5bbb9eb18f959ef2af">More...</a><br /></td></tr>
<tr class="separator:ga3a14612fe9264e5bbb9eb18f959ef2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7da7d39788ced60309788d45157a2ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7da7d39788ced60309788d45157a2ff2">regina::Bitmask::~Bitmask</a> ()</td></tr>
<tr class="memdesc:ga7da7d39788ced60309788d45157a2ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this bitmask.  <a href="group__utilities.html#ga7da7d39788ced60309788d45157a2ff2">More...</a><br /></td></tr>
<tr class="separator:ga7da7d39788ced60309788d45157a2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595e7706031ee52566b562a7c4573a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga595e7706031ee52566b562a7c4573a50">regina::Bitmask::get</a> (size_t index) const</td></tr>
<tr class="memdesc:ga595e7706031ee52566b562a7c4573a50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask.  <a href="group__utilities.html#ga595e7706031ee52566b562a7c4573a50">More...</a><br /></td></tr>
<tr class="separator:ga595e7706031ee52566b562a7c4573a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c90eddb88301ece1e984652f1993cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab6c90eddb88301ece1e984652f1993cc">regina::Bitmask::set</a> (size_t index, bool value)</td></tr>
<tr class="memdesc:gab6c90eddb88301ece1e984652f1993cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given bit of this bitmask to the given value.  <a href="group__utilities.html#gab6c90eddb88301ece1e984652f1993cc">More...</a><br /></td></tr>
<tr class="separator:gab6c90eddb88301ece1e984652f1993cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1cd2494dcfac16c229ed558770b05b7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gab1cd2494dcfac16c229ed558770b05b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1cd2494dcfac16c229ed558770b05b7">regina::Bitmask::set</a> (ForwardIterator indexBegin, ForwardIterator indexEnd, bool value)</td></tr>
<tr class="memdesc:gab1cd2494dcfac16c229ed558770b05b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the given sorted list to the given value.  <a href="group__utilities.html#gab1cd2494dcfac16c229ed558770b05b7">More...</a><br /></td></tr>
<tr class="separator:gab1cd2494dcfac16c229ed558770b05b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f54e460a4fe7ff7304fd27390d77340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1f54e460a4fe7ff7304fd27390d77340">regina::Bitmask::reset</a> ()</td></tr>
<tr class="memdesc:ga1f54e460a4fe7ff7304fd27390d77340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="group__utilities.html#ga1f54e460a4fe7ff7304fd27390d77340">More...</a><br /></td></tr>
<tr class="separator:ga1f54e460a4fe7ff7304fd27390d77340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5529fe127a3a6d4c47c93115efa43a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46">regina::Bitmask::reset</a> (size_t length)</td></tr>
<tr class="memdesc:ga5529fe127a3a6d4c47c93115efa43a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this bitmask to the given length and sets all bits to <code>false</code>.  <a href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46">More...</a><br /></td></tr>
<tr class="separator:ga5529fe127a3a6d4c47c93115efa43a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c206093e6c4a66b9086507586595797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8c206093e6c4a66b9086507586595797">regina::Bitmask::operator=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:ga8c206093e6c4a66b9086507586595797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this bitmask to a copy of the given bitmask.  <a href="group__utilities.html#ga8c206093e6c4a66b9086507586595797">More...</a><br /></td></tr>
<tr class="separator:ga8c206093e6c4a66b9086507586595797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c4ab5b72cca8ed16fa05dbca51731c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga53c4ab5b72cca8ed16fa05dbca51731c">regina::Bitmask::truncate</a> (size_t numBits)</td></tr>
<tr class="memdesc:ga53c4ab5b72cca8ed16fa05dbca51731c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>.  <a href="group__utilities.html#ga53c4ab5b72cca8ed16fa05dbca51731c">More...</a><br /></td></tr>
<tr class="separator:ga53c4ab5b72cca8ed16fa05dbca51731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480eca198478123a1df7a346521b2885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga480eca198478123a1df7a346521b2885">regina::Bitmask::operator&amp;=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:ga480eca198478123a1df7a346521b2885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the intersection of this and the given bitmask.  <a href="group__utilities.html#ga480eca198478123a1df7a346521b2885">More...</a><br /></td></tr>
<tr class="separator:ga480eca198478123a1df7a346521b2885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fc0370077988c012d239f8140a5d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga10fc0370077988c012d239f8140a5d0f">regina::Bitmask::operator|=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:ga10fc0370077988c012d239f8140a5d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and the given bitmask.  <a href="group__utilities.html#ga10fc0370077988c012d239f8140a5d0f">More...</a><br /></td></tr>
<tr class="separator:ga10fc0370077988c012d239f8140a5d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3a360a592c0f293a5dca36bd43195a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5d3a360a592c0f293a5dca36bd43195a">regina::Bitmask::operator^=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:ga5d3a360a592c0f293a5dca36bd43195a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the exclusive disjunction (XOR) of this and the given bitmask.  <a href="group__utilities.html#ga5d3a360a592c0f293a5dca36bd43195a">More...</a><br /></td></tr>
<tr class="separator:ga5d3a360a592c0f293a5dca36bd43195a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8941a3ce3fc72eb3b90c80e410f26f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7d8941a3ce3fc72eb3b90c80e410f26f">regina::Bitmask::operator-=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:ga7d8941a3ce3fc72eb3b90c80e410f26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the set difference of this and the given bitmask.  <a href="group__utilities.html#ga7d8941a3ce3fc72eb3b90c80e410f26f">More...</a><br /></td></tr>
<tr class="separator:ga7d8941a3ce3fc72eb3b90c80e410f26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912eae1af8637055cd516b179d73c040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga912eae1af8637055cd516b179d73c040">regina::Bitmask::flip</a> ()</td></tr>
<tr class="memdesc:ga912eae1af8637055cd516b179d73c040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every bit in this bitmask.  <a href="group__utilities.html#ga912eae1af8637055cd516b179d73c040">More...</a><br /></td></tr>
<tr class="separator:ga912eae1af8637055cd516b179d73c040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5ea92e31d07a86aa57ab5f07d92ca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3d5ea92e31d07a86aa57ab5f07d92ca6">regina::Bitmask::operator==</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const</td></tr>
<tr class="memdesc:ga3d5ea92e31d07a86aa57ab5f07d92ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given bitmask are identical.  <a href="group__utilities.html#ga3d5ea92e31d07a86aa57ab5f07d92ca6">More...</a><br /></td></tr>
<tr class="separator:ga3d5ea92e31d07a86aa57ab5f07d92ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026a973b46a3b950cd6d5f20d1733516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga026a973b46a3b950cd6d5f20d1733516">regina::Bitmask::lessThan</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const</td></tr>
<tr class="memdesc:ga026a973b46a3b950cd6d5f20d1733516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order.  <a href="group__utilities.html#ga026a973b46a3b950cd6d5f20d1733516">More...</a><br /></td></tr>
<tr class="separator:ga026a973b46a3b950cd6d5f20d1733516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6860308597cdb850d5e1ea49d3eab8d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6860308597cdb850d5e1ea49d3eab8d2">regina::Bitmask::operator&lt;=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const</td></tr>
<tr class="memdesc:ga6860308597cdb850d5e1ea49d3eab8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the given bitmask.  <a href="group__utilities.html#ga6860308597cdb850d5e1ea49d3eab8d2">More...</a><br /></td></tr>
<tr class="separator:ga6860308597cdb850d5e1ea49d3eab8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4257f99e264429d5e30a14792fc2ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad4257f99e264429d5e30a14792fc2ec6">regina::Bitmask::inUnion</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;x, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;y) const</td></tr>
<tr class="memdesc:gad4257f99e264429d5e30a14792fc2ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the union of the two given bitmasks.  <a href="group__utilities.html#gad4257f99e264429d5e30a14792fc2ec6">More...</a><br /></td></tr>
<tr class="separator:gad4257f99e264429d5e30a14792fc2ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a69447508fb3ce96f47363c264d1cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga83a69447508fb3ce96f47363c264d1cf">regina::Bitmask::containsIntn</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;x, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;y) const</td></tr>
<tr class="memdesc:ga83a69447508fb3ce96f47363c264d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask contains the intersection of the two given bitmasks.  <a href="group__utilities.html#ga83a69447508fb3ce96f47363c264d1cf">More...</a><br /></td></tr>
<tr class="separator:ga83a69447508fb3ce96f47363c264d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de6edc3e6bd3c2a95bf3da937989265"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9de6edc3e6bd3c2a95bf3da937989265">regina::Bitmask::bits</a> () const</td></tr>
<tr class="memdesc:ga9de6edc3e6bd3c2a95bf3da937989265"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask.  <a href="group__utilities.html#ga9de6edc3e6bd3c2a95bf3da937989265">More...</a><br /></td></tr>
<tr class="separator:ga9de6edc3e6bd3c2a95bf3da937989265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e6f8a09ba10b2cb44db84c3ff2a561"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga50e6f8a09ba10b2cb44db84c3ff2a561">regina::Bitmask::firstBit</a> () const</td></tr>
<tr class="memdesc:ga50e6f8a09ba10b2cb44db84c3ff2a561"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga50e6f8a09ba10b2cb44db84c3ff2a561">More...</a><br /></td></tr>
<tr class="separator:ga50e6f8a09ba10b2cb44db84c3ff2a561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e60765c8153d1f64287e3b3e24734b3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4e60765c8153d1f64287e3b3e24734b3">regina::Bitmask::lastBit</a> () const</td></tr>
<tr class="memdesc:ga4e60765c8153d1f64287e3b3e24734b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga4e60765c8153d1f64287e3b3e24734b3">More...</a><br /></td></tr>
<tr class="separator:ga4e60765c8153d1f64287e3b3e24734b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab27bcf5826fd27775a1c2198e7e4e76e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab27bcf5826fd27775a1c2198e7e4e76e">regina::Bitmask::atMostOneBit</a> () const</td></tr>
<tr class="memdesc:gab27bcf5826fd27775a1c2198e7e4e76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether at most one bit is set to <code>true</code> in this bitmask.  <a href="group__utilities.html#gab27bcf5826fd27775a1c2198e7e4e76e">More...</a><br /></td></tr>
<tr class="separator:gab27bcf5826fd27775a1c2198e7e4e76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687edae41955adbcf9e58c8cce90ea68"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:ga687edae41955adbcf9e58c8cce90ea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">More...</a><br /></td></tr>
<tr class="separator:ga687edae41955adbcf9e58c8cce90ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e53899b74d99054f31035492d5890a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42e53899b74d99054f31035492d5890a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga42e53899b74d99054f31035492d5890a">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga42e53899b74d99054f31035492d5890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga42e53899b74d99054f31035492d5890a">More...</a><br /></td></tr>
<tr class="separator:ga42e53899b74d99054f31035492d5890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2029c46c96683d6a388b38e8b4b0f9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab2029c46c96683d6a388b38e8b4b0f9b">regina::Bitmask1&lt; T &gt;::Bitmask1</a> ()</td></tr>
<tr class="memdesc:gab2029c46c96683d6a388b38e8b4b0f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask with all bits set to <code>false</code>.  <a href="group__utilities.html#gab2029c46c96683d6a388b38e8b4b0f9b">More...</a><br /></td></tr>
<tr class="separator:gab2029c46c96683d6a388b38e8b4b0f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d4be245982ab9bf1162383d3a1296a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae0d4be245982ab9bf1162383d3a1296a">regina::Bitmask1&lt; T &gt;::Bitmask1</a> (size_t)</td></tr>
<tr class="memdesc:gae0d4be245982ab9bf1162383d3a1296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask with all bits set to <code>false</code>.  <a href="group__utilities.html#gae0d4be245982ab9bf1162383d3a1296a">More...</a><br /></td></tr>
<tr class="separator:gae0d4be245982ab9bf1162383d3a1296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d7c8ece764a44d65b2051dae53ad08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga44d7c8ece764a44d65b2051dae53ad08">regina::Bitmask1&lt; T &gt;::Bitmask1</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga44d7c8ece764a44d65b2051dae53ad08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given bitmask.  <a href="group__utilities.html#ga44d7c8ece764a44d65b2051dae53ad08">More...</a><br /></td></tr>
<tr class="separator:ga44d7c8ece764a44d65b2051dae53ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81593e6006c05fe3a0a5ec37d469bce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga81593e6006c05fe3a0a5ec37d469bce0">regina::Bitmask1&lt; T &gt;::reset</a> ()</td></tr>
<tr class="memdesc:ga81593e6006c05fe3a0a5ec37d469bce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="group__utilities.html#ga81593e6006c05fe3a0a5ec37d469bce0">More...</a><br /></td></tr>
<tr class="separator:ga81593e6006c05fe3a0a5ec37d469bce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4233786770e1fb175876327804d8a1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4233786770e1fb175876327804d8a1ea">regina::Bitmask1&lt; T &gt;::reset</a> (size_t)</td></tr>
<tr class="memdesc:ga4233786770e1fb175876327804d8a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="group__utilities.html#ga4233786770e1fb175876327804d8a1ea">More...</a><br /></td></tr>
<tr class="separator:ga4233786770e1fb175876327804d8a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2d5050169f052b98f89d2437b2f4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0e2d5050169f052b98f89d2437b2f4f5">regina::Bitmask1&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other)=default</td></tr>
<tr class="memdesc:ga0e2d5050169f052b98f89d2437b2f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this bitmask to a copy of the given bitmask.  <a href="group__utilities.html#ga0e2d5050169f052b98f89d2437b2f4f5">More...</a><br /></td></tr>
<tr class="separator:ga0e2d5050169f052b98f89d2437b2f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c6efe33ae81b8d209be6b0126ef8cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9c6efe33ae81b8d209be6b0126ef8cf3">regina::Bitmask1&lt; T &gt;::truncate</a> (size_t numBits)</td></tr>
<tr class="memdesc:ga9c6efe33ae81b8d209be6b0126ef8cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>.  <a href="group__utilities.html#ga9c6efe33ae81b8d209be6b0126ef8cf3">More...</a><br /></td></tr>
<tr class="separator:ga9c6efe33ae81b8d209be6b0126ef8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61c56304383a01094f088b559347d32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa61c56304383a01094f088b559347d32">regina::Bitmask1&lt; T &gt;::get</a> (size_t index) const</td></tr>
<tr class="memdesc:gaa61c56304383a01094f088b559347d32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask.  <a href="group__utilities.html#gaa61c56304383a01094f088b559347d32">More...</a><br /></td></tr>
<tr class="separator:gaa61c56304383a01094f088b559347d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab786d10efbbfb9d3dfe8449cd83113df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab786d10efbbfb9d3dfe8449cd83113df">regina::Bitmask1&lt; T &gt;::set</a> (size_t index, bool value)</td></tr>
<tr class="memdesc:gab786d10efbbfb9d3dfe8449cd83113df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given bit of this bitmask to the given value.  <a href="group__utilities.html#gab786d10efbbfb9d3dfe8449cd83113df">More...</a><br /></td></tr>
<tr class="separator:gab786d10efbbfb9d3dfe8449cd83113df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92074d7aac61cedf9821549431096425"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga92074d7aac61cedf9821549431096425"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92074d7aac61cedf9821549431096425">regina::Bitmask1&lt; T &gt;::set</a> (ForwardIterator indexBegin, ForwardIterator indexEnd, bool value)</td></tr>
<tr class="memdesc:ga92074d7aac61cedf9821549431096425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the given sorted list to the given value.  <a href="group__utilities.html#ga92074d7aac61cedf9821549431096425">More...</a><br /></td></tr>
<tr class="separator:ga92074d7aac61cedf9821549431096425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918523286af9b7f539edd5db61810a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga918523286af9b7f539edd5db61810a42">regina::Bitmask1&lt; T &gt;::operator&amp;=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga918523286af9b7f539edd5db61810a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the intersection of this and the given bitmask.  <a href="group__utilities.html#ga918523286af9b7f539edd5db61810a42">More...</a><br /></td></tr>
<tr class="separator:ga918523286af9b7f539edd5db61810a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace764d52a777b69d26a42359b3832a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gace764d52a777b69d26a42359b3832a60">regina::Bitmask1&lt; T &gt;::operator|=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:gace764d52a777b69d26a42359b3832a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and the given bitmask.  <a href="group__utilities.html#gace764d52a777b69d26a42359b3832a60">More...</a><br /></td></tr>
<tr class="separator:gace764d52a777b69d26a42359b3832a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e1b6464665655c23c812d5833888a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga77e1b6464665655c23c812d5833888a6">regina::Bitmask1&lt; T &gt;::operator^=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga77e1b6464665655c23c812d5833888a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the exclusive disjunction (XOR) of this and the given bitmask.  <a href="group__utilities.html#ga77e1b6464665655c23c812d5833888a6">More...</a><br /></td></tr>
<tr class="separator:ga77e1b6464665655c23c812d5833888a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0faeab7b044c3cdac6f2ffa7b4f01bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac0faeab7b044c3cdac6f2ffa7b4f01bc">regina::Bitmask1&lt; T &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:gac0faeab7b044c3cdac6f2ffa7b4f01bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the set difference of this and the given bitmask.  <a href="group__utilities.html#gac0faeab7b044c3cdac6f2ffa7b4f01bc">More...</a><br /></td></tr>
<tr class="separator:gac0faeab7b044c3cdac6f2ffa7b4f01bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91fc2991a7e0d2f718a2a3f6bec1bbfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga91fc2991a7e0d2f718a2a3f6bec1bbfb">regina::Bitmask1&lt; T &gt;::flip</a> ()</td></tr>
<tr class="memdesc:ga91fc2991a7e0d2f718a2a3f6bec1bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every bit in this bitmask.  <a href="group__utilities.html#ga91fc2991a7e0d2f718a2a3f6bec1bbfb">More...</a><br /></td></tr>
<tr class="separator:ga91fc2991a7e0d2f718a2a3f6bec1bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0d688fc803b4b9b8c1131a6feb479f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabd0d688fc803b4b9b8c1131a6feb479f">regina::Bitmask1&lt; T &gt;::operator==</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:gabd0d688fc803b4b9b8c1131a6feb479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given bitmask are identical.  <a href="group__utilities.html#gabd0d688fc803b4b9b8c1131a6feb479f">More...</a><br /></td></tr>
<tr class="separator:gabd0d688fc803b4b9b8c1131a6feb479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96409a6adba0c43739fc4e7485779576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga96409a6adba0c43739fc4e7485779576">regina::Bitmask1&lt; T &gt;::lessThan</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga96409a6adba0c43739fc4e7485779576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order.  <a href="group__utilities.html#ga96409a6adba0c43739fc4e7485779576">More...</a><br /></td></tr>
<tr class="separator:ga96409a6adba0c43739fc4e7485779576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3a54782fa13a1e0bf358ace08f9aa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5f3a54782fa13a1e0bf358ace08f9aa1">regina::Bitmask1&lt; T &gt;::operator&lt;=</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga5f3a54782fa13a1e0bf358ace08f9aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the given bitmask.  <a href="group__utilities.html#ga5f3a54782fa13a1e0bf358ace08f9aa1">More...</a><br /></td></tr>
<tr class="separator:ga5f3a54782fa13a1e0bf358ace08f9aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873b254e6de092d5fea86d5af14593ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga873b254e6de092d5fea86d5af14593ea">regina::Bitmask1&lt; T &gt;::inUnion</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;x, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;y) const</td></tr>
<tr class="memdesc:ga873b254e6de092d5fea86d5af14593ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the union of the two given bitmasks.  <a href="group__utilities.html#ga873b254e6de092d5fea86d5af14593ea">More...</a><br /></td></tr>
<tr class="separator:ga873b254e6de092d5fea86d5af14593ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f20cd69216cb3949ec86388c310809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga83f20cd69216cb3949ec86388c310809">regina::Bitmask1&lt; T &gt;::containsIntn</a> (const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;x, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;y) const</td></tr>
<tr class="memdesc:ga83f20cd69216cb3949ec86388c310809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask contains the intersection of the two given bitmasks.  <a href="group__utilities.html#ga83f20cd69216cb3949ec86388c310809">More...</a><br /></td></tr>
<tr class="separator:ga83f20cd69216cb3949ec86388c310809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae0be718b171f87fc5cad162cf1667a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6ae0be718b171f87fc5cad162cf1667a">regina::Bitmask1&lt; T &gt;::bits</a> () const</td></tr>
<tr class="memdesc:ga6ae0be718b171f87fc5cad162cf1667a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask.  <a href="group__utilities.html#ga6ae0be718b171f87fc5cad162cf1667a">More...</a><br /></td></tr>
<tr class="separator:ga6ae0be718b171f87fc5cad162cf1667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e325dede0bac3b6596449d37853e99a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2e325dede0bac3b6596449d37853e99a">regina::Bitmask1&lt; T &gt;::firstBit</a> () const</td></tr>
<tr class="memdesc:ga2e325dede0bac3b6596449d37853e99a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga2e325dede0bac3b6596449d37853e99a">More...</a><br /></td></tr>
<tr class="separator:ga2e325dede0bac3b6596449d37853e99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a1a782eaba586f2dbc03dff7fef49"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga156a1a782eaba586f2dbc03dff7fef49">regina::Bitmask1&lt; T &gt;::lastBit</a> () const</td></tr>
<tr class="memdesc:ga156a1a782eaba586f2dbc03dff7fef49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga156a1a782eaba586f2dbc03dff7fef49">More...</a><br /></td></tr>
<tr class="separator:ga156a1a782eaba586f2dbc03dff7fef49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b9a3962337e0da8287ac15c972240e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga22b9a3962337e0da8287ac15c972240e">regina::Bitmask1&lt; T &gt;::atMostOneBit</a> () const</td></tr>
<tr class="memdesc:ga22b9a3962337e0da8287ac15c972240e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether at most one bit is set to <code>true</code> in this bitmask.  <a href="group__utilities.html#ga22b9a3962337e0da8287ac15c972240e">More...</a><br /></td></tr>
<tr class="separator:ga22b9a3962337e0da8287ac15c972240e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0dc9ea5844d6e3886aae7e101929e85e">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga0dc9ea5844d6e3886aae7e101929e85e">More...</a><br /></td></tr>
<tr class="separator:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50822529ad6099ef6b57b98fb9c7e4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga50822529ad6099ef6b57b98fb9c7e4e5">regina::Bitmask2&lt; T, U &gt;::Bitmask2</a> ()</td></tr>
<tr class="memdesc:ga50822529ad6099ef6b57b98fb9c7e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask with all bits set to <code>false</code>.  <a href="group__utilities.html#ga50822529ad6099ef6b57b98fb9c7e4e5">More...</a><br /></td></tr>
<tr class="separator:ga50822529ad6099ef6b57b98fb9c7e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d604ae216e3ced1aeadfac9af0bdf56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d604ae216e3ced1aeadfac9af0bdf56">regina::Bitmask2&lt; T, U &gt;::Bitmask2</a> (size_t)</td></tr>
<tr class="memdesc:ga6d604ae216e3ced1aeadfac9af0bdf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask with all bits set to <code>false</code>.  <a href="group__utilities.html#ga6d604ae216e3ced1aeadfac9af0bdf56">More...</a><br /></td></tr>
<tr class="separator:ga6d604ae216e3ced1aeadfac9af0bdf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3493fd652d0f855e33a0eba425b2e164"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3493fd652d0f855e33a0eba425b2e164">regina::Bitmask2&lt; T, U &gt;::Bitmask2</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga3493fd652d0f855e33a0eba425b2e164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given bitmask.  <a href="group__utilities.html#ga3493fd652d0f855e33a0eba425b2e164">More...</a><br /></td></tr>
<tr class="separator:ga3493fd652d0f855e33a0eba425b2e164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a015fb67f2612f02604c1e520ac0b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab3a015fb67f2612f02604c1e520ac0b1">regina::Bitmask2&lt; T, U &gt;::reset</a> ()</td></tr>
<tr class="memdesc:gab3a015fb67f2612f02604c1e520ac0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="group__utilities.html#gab3a015fb67f2612f02604c1e520ac0b1">More...</a><br /></td></tr>
<tr class="separator:gab3a015fb67f2612f02604c1e520ac0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a9ec7d484ed69b620787c4c9c86d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae8a9ec7d484ed69b620787c4c9c86d54">regina::Bitmask2&lt; T, U &gt;::reset</a> (size_t)</td></tr>
<tr class="memdesc:gae8a9ec7d484ed69b620787c4c9c86d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="group__utilities.html#gae8a9ec7d484ed69b620787c4c9c86d54">More...</a><br /></td></tr>
<tr class="separator:gae8a9ec7d484ed69b620787c4c9c86d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d496925797c6695c84c70c1d12641f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7d496925797c6695c84c70c1d12641f1">regina::Bitmask2&lt; T, U &gt;::operator=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other)=default</td></tr>
<tr class="memdesc:ga7d496925797c6695c84c70c1d12641f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this bitmask to a copy of the given bitmask.  <a href="group__utilities.html#ga7d496925797c6695c84c70c1d12641f1">More...</a><br /></td></tr>
<tr class="separator:ga7d496925797c6695c84c70c1d12641f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga139f8b0dbf0790e7fef07dcb1de5a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga139f8b0dbf0790e7fef07dcb1de5a33d">regina::Bitmask2&lt; T, U &gt;::truncate</a> (size_t numBits)</td></tr>
<tr class="memdesc:ga139f8b0dbf0790e7fef07dcb1de5a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>.  <a href="group__utilities.html#ga139f8b0dbf0790e7fef07dcb1de5a33d">More...</a><br /></td></tr>
<tr class="separator:ga139f8b0dbf0790e7fef07dcb1de5a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bda042c974a2fa330935cd9e2976212"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2bda042c974a2fa330935cd9e2976212">regina::Bitmask2&lt; T, U &gt;::get</a> (size_t index) const</td></tr>
<tr class="memdesc:ga2bda042c974a2fa330935cd9e2976212"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask.  <a href="group__utilities.html#ga2bda042c974a2fa330935cd9e2976212">More...</a><br /></td></tr>
<tr class="separator:ga2bda042c974a2fa330935cd9e2976212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aca7ed1d85bb568d00283e91e503e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1aca7ed1d85bb568d00283e91e503e8b">regina::Bitmask2&lt; T, U &gt;::set</a> (size_t index, bool value)</td></tr>
<tr class="memdesc:ga1aca7ed1d85bb568d00283e91e503e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given bit of this bitmask to the given value.  <a href="group__utilities.html#ga1aca7ed1d85bb568d00283e91e503e8b">More...</a><br /></td></tr>
<tr class="separator:ga1aca7ed1d85bb568d00283e91e503e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd06d74f1f2ea32d7042581bd1a027ed"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gacd06d74f1f2ea32d7042581bd1a027ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd06d74f1f2ea32d7042581bd1a027ed">regina::Bitmask2&lt; T, U &gt;::set</a> (ForwardIterator indexBegin, ForwardIterator indexEnd, bool value)</td></tr>
<tr class="memdesc:gacd06d74f1f2ea32d7042581bd1a027ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the given sorted list to the given value.  <a href="group__utilities.html#gacd06d74f1f2ea32d7042581bd1a027ed">More...</a><br /></td></tr>
<tr class="separator:gacd06d74f1f2ea32d7042581bd1a027ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0496c109f9799f86661d224b61af5053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0496c109f9799f86661d224b61af5053">regina::Bitmask2&lt; T, U &gt;::operator&amp;=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other)</td></tr>
<tr class="memdesc:ga0496c109f9799f86661d224b61af5053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the intersection of this and the given bitmask.  <a href="group__utilities.html#ga0496c109f9799f86661d224b61af5053">More...</a><br /></td></tr>
<tr class="separator:ga0496c109f9799f86661d224b61af5053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d130ef4b13333ac37492c38a97c9ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8d130ef4b13333ac37492c38a97c9ddc">regina::Bitmask2&lt; T, U &gt;::operator|=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other)</td></tr>
<tr class="memdesc:ga8d130ef4b13333ac37492c38a97c9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and the given bitmask.  <a href="group__utilities.html#ga8d130ef4b13333ac37492c38a97c9ddc">More...</a><br /></td></tr>
<tr class="separator:ga8d130ef4b13333ac37492c38a97c9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776aed118fc359f147a04485d528d79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga776aed118fc359f147a04485d528d79b">regina::Bitmask2&lt; T, U &gt;::operator^=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other)</td></tr>
<tr class="memdesc:ga776aed118fc359f147a04485d528d79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the exclusive disjunction (XOR) of this and the given bitmask.  <a href="group__utilities.html#ga776aed118fc359f147a04485d528d79b">More...</a><br /></td></tr>
<tr class="separator:ga776aed118fc359f147a04485d528d79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9780d2045dc0e846384404f09fbd420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf9780d2045dc0e846384404f09fbd420">regina::Bitmask2&lt; T, U &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other)</td></tr>
<tr class="memdesc:gaf9780d2045dc0e846384404f09fbd420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the set difference of this and the given bitmask.  <a href="group__utilities.html#gaf9780d2045dc0e846384404f09fbd420">More...</a><br /></td></tr>
<tr class="separator:gaf9780d2045dc0e846384404f09fbd420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5866b8e28c63cc3ea33901589441ef8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5866b8e28c63cc3ea33901589441ef8b">regina::Bitmask2&lt; T, U &gt;::flip</a> ()</td></tr>
<tr class="memdesc:ga5866b8e28c63cc3ea33901589441ef8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every bit in this bitmask.  <a href="group__utilities.html#ga5866b8e28c63cc3ea33901589441ef8b">More...</a><br /></td></tr>
<tr class="separator:ga5866b8e28c63cc3ea33901589441ef8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad180422f64fb3621628f130525d7eeec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad180422f64fb3621628f130525d7eeec">regina::Bitmask2&lt; T, U &gt;::operator==</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:gad180422f64fb3621628f130525d7eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given bitmask are identical.  <a href="group__utilities.html#gad180422f64fb3621628f130525d7eeec">More...</a><br /></td></tr>
<tr class="separator:gad180422f64fb3621628f130525d7eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279087abf96d05ff4b6426075cd36df0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga279087abf96d05ff4b6426075cd36df0">regina::Bitmask2&lt; T, U &gt;::lessThan</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga279087abf96d05ff4b6426075cd36df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order.  <a href="group__utilities.html#ga279087abf96d05ff4b6426075cd36df0">More...</a><br /></td></tr>
<tr class="separator:ga279087abf96d05ff4b6426075cd36df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f46a8e8142723df3f547745b5d2dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga89f46a8e8142723df3f547745b5d2dc4">regina::Bitmask2&lt; T, U &gt;::operator&lt;=</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga89f46a8e8142723df3f547745b5d2dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the given bitmask.  <a href="group__utilities.html#ga89f46a8e8142723df3f547745b5d2dc4">More...</a><br /></td></tr>
<tr class="separator:ga89f46a8e8142723df3f547745b5d2dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10fcc4b81aae1210375ab7ca50d7ea1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab10fcc4b81aae1210375ab7ca50d7ea1">regina::Bitmask2&lt; T, U &gt;::inUnion</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;x, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;y) const</td></tr>
<tr class="memdesc:gab10fcc4b81aae1210375ab7ca50d7ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the union of the two given bitmasks.  <a href="group__utilities.html#gab10fcc4b81aae1210375ab7ca50d7ea1">More...</a><br /></td></tr>
<tr class="separator:gab10fcc4b81aae1210375ab7ca50d7ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f97bb0f6c7c824e6baa5f85f829787"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf6f97bb0f6c7c824e6baa5f85f829787">regina::Bitmask2&lt; T, U &gt;::containsIntn</a> (const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;x, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;y) const</td></tr>
<tr class="memdesc:gaf6f97bb0f6c7c824e6baa5f85f829787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask contains the intersection of the two given bitmasks.  <a href="group__utilities.html#gaf6f97bb0f6c7c824e6baa5f85f829787">More...</a><br /></td></tr>
<tr class="separator:gaf6f97bb0f6c7c824e6baa5f85f829787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1da1d19268791e7b596430230338b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaaa1da1d19268791e7b596430230338b1">regina::Bitmask2&lt; T, U &gt;::bits</a> () const</td></tr>
<tr class="memdesc:gaaa1da1d19268791e7b596430230338b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask.  <a href="group__utilities.html#gaaa1da1d19268791e7b596430230338b1">More...</a><br /></td></tr>
<tr class="separator:gaaa1da1d19268791e7b596430230338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb407ab09711aebe50d87d78fd3d723"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9cb407ab09711aebe50d87d78fd3d723">regina::Bitmask2&lt; T, U &gt;::firstBit</a> () const</td></tr>
<tr class="memdesc:ga9cb407ab09711aebe50d87d78fd3d723"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga9cb407ab09711aebe50d87d78fd3d723">More...</a><br /></td></tr>
<tr class="separator:ga9cb407ab09711aebe50d87d78fd3d723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1b203ab48e2eeabd56a1d39c1817b3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9c1b203ab48e2eeabd56a1d39c1817b3">regina::Bitmask2&lt; T, U &gt;::lastBit</a> () const</td></tr>
<tr class="memdesc:ga9c1b203ab48e2eeabd56a1d39c1817b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="group__utilities.html#ga9c1b203ab48e2eeabd56a1d39c1817b3">More...</a><br /></td></tr>
<tr class="separator:ga9c1b203ab48e2eeabd56a1d39c1817b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8">regina::Bitmask2&lt; T, U &gt;::atMostOneBit</a> () const</td></tr>
<tr class="memdesc:ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether at most one bit is set to <code>true</code> in this bitmask.  <a href="group__utilities.html#ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8">More...</a><br /></td></tr>
<tr class="separator:ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dff9aca49e8854226dab71315e0236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61dff9aca49e8854226dab71315e0236">regina::BoolSet::BoolSet</a> ()</td></tr>
<tr class="memdesc:ga61dff9aca49e8854226dab71315e0236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty set.  <a href="group__utilities.html#ga61dff9aca49e8854226dab71315e0236">More...</a><br /></td></tr>
<tr class="separator:ga61dff9aca49e8854226dab71315e0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbd73845c38a952d7fe21319fb212af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaabbd73845c38a952d7fe21319fb212af">regina::BoolSet::BoolSet</a> (bool member)</td></tr>
<tr class="memdesc:gaabbd73845c38a952d7fe21319fb212af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set containing a single member as given.  <a href="group__utilities.html#gaabbd73845c38a952d7fe21319fb212af">More...</a><br /></td></tr>
<tr class="separator:gaabbd73845c38a952d7fe21319fb212af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15db1d32c1a13e5a9202fa566108335f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga15db1d32c1a13e5a9202fa566108335f">regina::BoolSet::BoolSet</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga15db1d32c1a13e5a9202fa566108335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set equal to the given set.  <a href="group__utilities.html#ga15db1d32c1a13e5a9202fa566108335f">More...</a><br /></td></tr>
<tr class="separator:ga15db1d32c1a13e5a9202fa566108335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e750814a8f0b0bb865b2f57999bf27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac9e750814a8f0b0bb865b2f57999bf27">regina::BoolSet::BoolSet</a> (bool <a class="el" href="group__utilities.html#ga2501b339c018f6398e2a108d13de873a">insertTrue</a>, bool <a class="el" href="group__utilities.html#ga2e463ebd4e012e7f91ac7070069a611d">insertFalse</a>)</td></tr>
<tr class="memdesc:gac9e750814a8f0b0bb865b2f57999bf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set specifying whether <code>true</code> and/or <code>false</code> should be a member.  <a href="group__utilities.html#gac9e750814a8f0b0bb865b2f57999bf27">More...</a><br /></td></tr>
<tr class="separator:gac9e750814a8f0b0bb865b2f57999bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92ac19a5e3d706cee6f97f415d40f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad92ac19a5e3d706cee6f97f415d40f70">regina::BoolSet::hasTrue</a> () const</td></tr>
<tr class="memdesc:gad92ac19a5e3d706cee6f97f415d40f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>true</code> is a member of this set.  <a href="group__utilities.html#gad92ac19a5e3d706cee6f97f415d40f70">More...</a><br /></td></tr>
<tr class="separator:gad92ac19a5e3d706cee6f97f415d40f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab854f3ca7fe75b9514235f4d96ff52fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab854f3ca7fe75b9514235f4d96ff52fc">regina::BoolSet::hasFalse</a> () const</td></tr>
<tr class="memdesc:gab854f3ca7fe75b9514235f4d96ff52fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>false</code> is a member of this set.  <a href="group__utilities.html#gab854f3ca7fe75b9514235f4d96ff52fc">More...</a><br /></td></tr>
<tr class="separator:gab854f3ca7fe75b9514235f4d96ff52fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0dfc05eb2a1f9ca030aae0bc619557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1d0dfc05eb2a1f9ca030aae0bc619557">regina::BoolSet::contains</a> (bool value) const</td></tr>
<tr class="memdesc:ga1d0dfc05eb2a1f9ca030aae0bc619557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given boolean is a member of this set.  <a href="group__utilities.html#ga1d0dfc05eb2a1f9ca030aae0bc619557">More...</a><br /></td></tr>
<tr class="separator:ga1d0dfc05eb2a1f9ca030aae0bc619557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2501b339c018f6398e2a108d13de873a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2501b339c018f6398e2a108d13de873a">regina::BoolSet::insertTrue</a> ()</td></tr>
<tr class="memdesc:ga2501b339c018f6398e2a108d13de873a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>true</code> into this set if it is not already present.  <a href="group__utilities.html#ga2501b339c018f6398e2a108d13de873a">More...</a><br /></td></tr>
<tr class="separator:ga2501b339c018f6398e2a108d13de873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e463ebd4e012e7f91ac7070069a611d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2e463ebd4e012e7f91ac7070069a611d">regina::BoolSet::insertFalse</a> ()</td></tr>
<tr class="memdesc:ga2e463ebd4e012e7f91ac7070069a611d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>false</code> into this set if it is not already present.  <a href="group__utilities.html#ga2e463ebd4e012e7f91ac7070069a611d">More...</a><br /></td></tr>
<tr class="separator:ga2e463ebd4e012e7f91ac7070069a611d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb6d2dcc0e2240ad00223deb31b4a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafeb6d2dcc0e2240ad00223deb31b4a88">regina::BoolSet::removeTrue</a> ()</td></tr>
<tr class="memdesc:gafeb6d2dcc0e2240ad00223deb31b4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>true</code> from this set if it is present.  <a href="group__utilities.html#gafeb6d2dcc0e2240ad00223deb31b4a88">More...</a><br /></td></tr>
<tr class="separator:gafeb6d2dcc0e2240ad00223deb31b4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92caac371f7faab4d34f87165eca8acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92caac371f7faab4d34f87165eca8acd">regina::BoolSet::removeFalse</a> ()</td></tr>
<tr class="memdesc:ga92caac371f7faab4d34f87165eca8acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>false</code> from this set if it is present.  <a href="group__utilities.html#ga92caac371f7faab4d34f87165eca8acd">More...</a><br /></td></tr>
<tr class="separator:ga92caac371f7faab4d34f87165eca8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39dbbacec01481a24963c129d259abe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga39dbbacec01481a24963c129d259abe4">regina::BoolSet::empty</a> ()</td></tr>
<tr class="memdesc:ga39dbbacec01481a24963c129d259abe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from this set.  <a href="group__utilities.html#ga39dbbacec01481a24963c129d259abe4">More...</a><br /></td></tr>
<tr class="separator:ga39dbbacec01481a24963c129d259abe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92586c9c3e0423b9b186debb448c558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab92586c9c3e0423b9b186debb448c558">regina::BoolSet::fill</a> ()</td></tr>
<tr class="memdesc:gab92586c9c3e0423b9b186debb448c558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places both <code>true</code> and <code>false</code> into this set if they are not already present.  <a href="group__utilities.html#gab92586c9c3e0423b9b186debb448c558">More...</a><br /></td></tr>
<tr class="separator:gab92586c9c3e0423b9b186debb448c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5963ab17d3d65ae2ed5643bbd2320312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5963ab17d3d65ae2ed5643bbd2320312">regina::BoolSet::operator==</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga5963ab17d3d65ae2ed5643bbd2320312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is equal to the given set.  <a href="group__utilities.html#ga5963ab17d3d65ae2ed5643bbd2320312">More...</a><br /></td></tr>
<tr class="separator:ga5963ab17d3d65ae2ed5643bbd2320312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c8f6dae4bd35dcc31151ce4983c0ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga07c8f6dae4bd35dcc31151ce4983c0ac">regina::BoolSet::operator!=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga07c8f6dae4bd35dcc31151ce4983c0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is not equal to the given set.  <a href="group__utilities.html#ga07c8f6dae4bd35dcc31151ce4983c0ac">More...</a><br /></td></tr>
<tr class="separator:ga07c8f6dae4bd35dcc31151ce4983c0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8480d66f57f776986426a0ac2612e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabd8480d66f57f776986426a0ac2612e5">regina::BoolSet::operator&lt;</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:gabd8480d66f57f776986426a0ac2612e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper subset of the given set.  <a href="group__utilities.html#gabd8480d66f57f776986426a0ac2612e5">More...</a><br /></td></tr>
<tr class="separator:gabd8480d66f57f776986426a0ac2612e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc0bc1b1a725b132b40e840cf1093a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2bc0bc1b1a725b132b40e840cf1093a6">regina::BoolSet::operator&gt;</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga2bc0bc1b1a725b132b40e840cf1093a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper superset of the given set.  <a href="group__utilities.html#ga2bc0bc1b1a725b132b40e840cf1093a6">More...</a><br /></td></tr>
<tr class="separator:ga2bc0bc1b1a725b132b40e840cf1093a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac413c91408103de5680beceab07bb0f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac413c91408103de5680beceab07bb0f0">regina::BoolSet::operator&lt;=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:gac413c91408103de5680beceab07bb0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a subset of (possibly equal to) the given set.  <a href="group__utilities.html#gac413c91408103de5680beceab07bb0f0">More...</a><br /></td></tr>
<tr class="separator:gac413c91408103de5680beceab07bb0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7795fcb6e7fd91b8dec0b9ea2836e068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7795fcb6e7fd91b8dec0b9ea2836e068">regina::BoolSet::operator&gt;=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga7795fcb6e7fd91b8dec0b9ea2836e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a superset of (possibly equal to) the given set.  <a href="group__utilities.html#ga7795fcb6e7fd91b8dec0b9ea2836e068">More...</a><br /></td></tr>
<tr class="separator:ga7795fcb6e7fd91b8dec0b9ea2836e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a222e12e943deddbd9c11b78f69020d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0a222e12e943deddbd9c11b78f69020d">regina::BoolSet::operator=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga0a222e12e943deddbd9c11b78f69020d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this set to be identical to the given set.  <a href="group__utilities.html#ga0a222e12e943deddbd9c11b78f69020d">More...</a><br /></td></tr>
<tr class="separator:ga0a222e12e943deddbd9c11b78f69020d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb7e3b01f78ec1047ae19bbff3a6e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2eb7e3b01f78ec1047ae19bbff3a6e01">regina::BoolSet::operator=</a> (bool member)</td></tr>
<tr class="memdesc:ga2eb7e3b01f78ec1047ae19bbff3a6e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this set to the single member set containing the given element.  <a href="group__utilities.html#ga2eb7e3b01f78ec1047ae19bbff3a6e01">More...</a><br /></td></tr>
<tr class="separator:ga2eb7e3b01f78ec1047ae19bbff3a6e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72593807529d07923bf50f0ac040dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf72593807529d07923bf50f0ac040dc7">regina::BoolSet::operator|=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other)</td></tr>
<tr class="memdesc:gaf72593807529d07923bf50f0ac040dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this set to be the union of this and the given set.  <a href="group__utilities.html#gaf72593807529d07923bf50f0ac040dc7">More...</a><br /></td></tr>
<tr class="separator:gaf72593807529d07923bf50f0ac040dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c40acd1ac7802074da229cab95071f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9c40acd1ac7802074da229cab95071f9">regina::BoolSet::operator&amp;=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other)</td></tr>
<tr class="memdesc:ga9c40acd1ac7802074da229cab95071f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this set to be the intersection of this and the given set.  <a href="group__utilities.html#ga9c40acd1ac7802074da229cab95071f9">More...</a><br /></td></tr>
<tr class="separator:ga9c40acd1ac7802074da229cab95071f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450e466ac9ddfd81c6ac528beceb13bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga450e466ac9ddfd81c6ac528beceb13bd">regina::BoolSet::operator^=</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other)</td></tr>
<tr class="memdesc:ga450e466ac9ddfd81c6ac528beceb13bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this set to be the symmetric difference of this and the given set.  <a href="group__utilities.html#ga450e466ac9ddfd81c6ac528beceb13bd">More...</a><br /></td></tr>
<tr class="separator:ga450e466ac9ddfd81c6ac528beceb13bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4b4067828ce6b2147fe37bf539174f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1d4b4067828ce6b2147fe37bf539174f">regina::BoolSet::operator|</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga1d4b4067828ce6b2147fe37bf539174f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the union of this set with the given set.  <a href="group__utilities.html#ga1d4b4067828ce6b2147fe37bf539174f">More...</a><br /></td></tr>
<tr class="separator:ga1d4b4067828ce6b2147fe37bf539174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7278049fcae718924e989c40712a772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf7278049fcae718924e989c40712a772">regina::BoolSet::operator&amp;</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:gaf7278049fcae718924e989c40712a772"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the intersection of this set with the given set.  <a href="group__utilities.html#gaf7278049fcae718924e989c40712a772">More...</a><br /></td></tr>
<tr class="separator:gaf7278049fcae718924e989c40712a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37bdbe4fadeef248ff935538f43fa2e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga37bdbe4fadeef248ff935538f43fa2e6">regina::BoolSet::operator^</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ga37bdbe4fadeef248ff935538f43fa2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the symmetric difference of this set and the given set.  <a href="group__utilities.html#ga37bdbe4fadeef248ff935538f43fa2e6">More...</a><br /></td></tr>
<tr class="separator:ga37bdbe4fadeef248ff935538f43fa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac382d5c166f202d9a54b831298dd239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaac382d5c166f202d9a54b831298dd239">regina::BoolSet::operator~</a> () const</td></tr>
<tr class="memdesc:gaac382d5c166f202d9a54b831298dd239"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complement of this set.  <a href="group__utilities.html#gaac382d5c166f202d9a54b831298dd239">More...</a><br /></td></tr>
<tr class="separator:gaac382d5c166f202d9a54b831298dd239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b4dbce39b90687e88117171c5ef8a2"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga26b4dbce39b90687e88117171c5ef8a2">regina::BoolSet::byteCode</a> () const</td></tr>
<tr class="memdesc:ga26b4dbce39b90687e88117171c5ef8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the byte code representing this boolean set.  <a href="group__utilities.html#ga26b4dbce39b90687e88117171c5ef8a2">More...</a><br /></td></tr>
<tr class="separator:ga26b4dbce39b90687e88117171c5ef8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf28ae1667cbb6ae1e09d9960aa9eb08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf28ae1667cbb6ae1e09d9960aa9eb08d">regina::BoolSet::setByteCode</a> (unsigned char code)</td></tr>
<tr class="memdesc:gaf28ae1667cbb6ae1e09d9960aa9eb08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this boolean set to that represented by the given byte code.  <a href="group__utilities.html#gaf28ae1667cbb6ae1e09d9960aa9eb08d">More...</a><br /></td></tr>
<tr class="separator:gaf28ae1667cbb6ae1e09d9960aa9eb08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e789e27390eeceeadd433840d95462"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga02e789e27390eeceeadd433840d95462">regina::BoolSet::fromByteCode</a> (unsigned char code)</td></tr>
<tr class="memdesc:ga02e789e27390eeceeadd433840d95462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a boolean set from the given byte code.  <a href="group__utilities.html#ga02e789e27390eeceeadd433840d95462">More...</a><br /></td></tr>
<tr class="separator:ga02e789e27390eeceeadd433840d95462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e140a57f469e663d87f1d3e14a90187"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7e140a57f469e663d87f1d3e14a90187">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;set)</td></tr>
<tr class="memdesc:ga7e140a57f469e663d87f1d3e14a90187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="group__utilities.html#ga7e140a57f469e663d87f1d3e14a90187">More...</a><br /></td></tr>
<tr class="separator:ga7e140a57f469e663d87f1d3e14a90187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2344a0c7e7faec0da6cb60c97709691b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2344a0c7e7faec0da6cb60c97709691b">regina::Flags&lt; T &gt;::Flags</a> ()</td></tr>
<tr class="memdesc:ga2344a0c7e7faec0da6cb60c97709691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty flag set, with no flags set at all.  <a href="group__utilities.html#ga2344a0c7e7faec0da6cb60c97709691b">More...</a><br /></td></tr>
<tr class="separator:ga2344a0c7e7faec0da6cb60c97709691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf983a5399d2b63f98dbe99297b21bcf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf983a5399d2b63f98dbe99297b21bcf6">regina::Flags&lt; T &gt;::Flags</a> (T init)</td></tr>
<tr class="memdesc:gaf983a5399d2b63f98dbe99297b21bcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a flag set initialised to the given value.  <a href="group__utilities.html#gaf983a5399d2b63f98dbe99297b21bcf6">More...</a><br /></td></tr>
<tr class="separator:gaf983a5399d2b63f98dbe99297b21bcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0316c98b2cd692da8838e25d9964044"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0316c98b2cd692da8838e25d9964044">regina::Flags&lt; T &gt;::Flags</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;init)=default</td></tr>
<tr class="memdesc:gad0316c98b2cd692da8838e25d9964044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given flag set.  <a href="group__utilities.html#gad0316c98b2cd692da8838e25d9964044">More...</a><br /></td></tr>
<tr class="separator:gad0316c98b2cd692da8838e25d9964044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed34629cfb48b9752734db89015b97d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaed34629cfb48b9752734db89015b97d2">regina::Flags&lt; T &gt;::intValue</a> () const</td></tr>
<tr class="memdesc:gaed34629cfb48b9752734db89015b97d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the integer representation of this set.  <a href="group__utilities.html#gaed34629cfb48b9752734db89015b97d2">More...</a><br /></td></tr>
<tr class="separator:gaed34629cfb48b9752734db89015b97d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfaa416e47d751155a554968e30ff42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1dfaa416e47d751155a554968e30ff42">regina::Flags&lt; T &gt;::fromInt</a> (int value)</td></tr>
<tr class="memdesc:ga1dfaa416e47d751155a554968e30ff42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set corresponding to the given integer value.  <a href="group__utilities.html#ga1dfaa416e47d751155a554968e30ff42">More...</a><br /></td></tr>
<tr class="separator:ga1dfaa416e47d751155a554968e30ff42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff55a29d2beff5e8d7010f6f18e02989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaff55a29d2beff5e8d7010f6f18e02989">regina::Flags&lt; T &gt;::has</a> (T flag) const</td></tr>
<tr class="memdesc:gaff55a29d2beff5e8d7010f6f18e02989"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the given flag is set.  <a href="group__utilities.html#gaff55a29d2beff5e8d7010f6f18e02989">More...</a><br /></td></tr>
<tr class="separator:gaff55a29d2beff5e8d7010f6f18e02989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac384aa3d6b9abc3eba4bf04836f2eb03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac384aa3d6b9abc3eba4bf04836f2eb03">regina::Flags&lt; T &gt;::has</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:gac384aa3d6b9abc3eba4bf04836f2eb03"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether all of the flags in the given set are set.  <a href="group__utilities.html#gac384aa3d6b9abc3eba4bf04836f2eb03">More...</a><br /></td></tr>
<tr class="separator:gac384aa3d6b9abc3eba4bf04836f2eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300db79cc50808037445a254712421f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga300db79cc50808037445a254712421f0">regina::Flags&lt; T &gt;::operator==</a> (T rhs) const</td></tr>
<tr class="memdesc:ga300db79cc50808037445a254712421f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this set is precisely equal to the given flag.  <a href="group__utilities.html#ga300db79cc50808037445a254712421f0">More...</a><br /></td></tr>
<tr class="separator:ga300db79cc50808037445a254712421f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3851b68542bf8267e5c437bd079b65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8a3851b68542bf8267e5c437bd079b65">regina::Flags&lt; T &gt;::operator==</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ga8a3851b68542bf8267e5c437bd079b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this set is precisely equal to the given flag set.  <a href="group__utilities.html#ga8a3851b68542bf8267e5c437bd079b65">More...</a><br /></td></tr>
<tr class="separator:ga8a3851b68542bf8267e5c437bd079b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f965de7f77768d0a42aebd19dc79c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga85f965de7f77768d0a42aebd19dc79c1">regina::Flags&lt; T &gt;::operator!=</a> (T rhs) const</td></tr>
<tr class="memdesc:ga85f965de7f77768d0a42aebd19dc79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this set is not equal to the given flag.  <a href="group__utilities.html#ga85f965de7f77768d0a42aebd19dc79c1">More...</a><br /></td></tr>
<tr class="separator:ga85f965de7f77768d0a42aebd19dc79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705cb6eb653d42906ebd4906e1c91fea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga705cb6eb653d42906ebd4906e1c91fea">regina::Flags&lt; T &gt;::operator!=</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ga705cb6eb653d42906ebd4906e1c91fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this set is not equal to the given flag set.  <a href="group__utilities.html#ga705cb6eb653d42906ebd4906e1c91fea">More...</a><br /></td></tr>
<tr class="separator:ga705cb6eb653d42906ebd4906e1c91fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb64d581a06018304159344d5f71ba6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb64d581a06018304159344d5f71ba6c">regina::Flags&lt; T &gt;::operator=</a> (T rhs)</td></tr>
<tr class="memdesc:gacb64d581a06018304159344d5f71ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this flag set to contain precisely the given flag only.  <a href="group__utilities.html#gacb64d581a06018304159344d5f71ba6c">More...</a><br /></td></tr>
<tr class="separator:gacb64d581a06018304159344d5f71ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1645ff76038359a31c8bee14d1fce15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1645ff76038359a31c8bee14d1fce15d">regina::Flags&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs)=default</td></tr>
<tr class="memdesc:ga1645ff76038359a31c8bee14d1fce15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this flag set to contain a copy of the given flag set.  <a href="group__utilities.html#ga1645ff76038359a31c8bee14d1fce15d">More...</a><br /></td></tr>
<tr class="separator:ga1645ff76038359a31c8bee14d1fce15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51bcad196e45e244672a043ead7c505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad51bcad196e45e244672a043ead7c505">regina::Flags&lt; T &gt;::operator|=</a> (T rhs)</td></tr>
<tr class="memdesc:gad51bcad196e45e244672a043ead7c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise OR with the given flag.  <a href="group__utilities.html#gad51bcad196e45e244672a043ead7c505">More...</a><br /></td></tr>
<tr class="separator:gad51bcad196e45e244672a043ead7c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5027e2ce0bf5fb514580fa851c7a38c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5027e2ce0bf5fb514580fa851c7a38c5">regina::Flags&lt; T &gt;::operator|=</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5027e2ce0bf5fb514580fa851c7a38c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise OR with the given flag set.  <a href="group__utilities.html#ga5027e2ce0bf5fb514580fa851c7a38c5">More...</a><br /></td></tr>
<tr class="separator:ga5027e2ce0bf5fb514580fa851c7a38c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164bcb94832ea7ec757db490c927df84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga164bcb94832ea7ec757db490c927df84">regina::Flags&lt; T &gt;::operator&amp;=</a> (T rhs)</td></tr>
<tr class="memdesc:ga164bcb94832ea7ec757db490c927df84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise AND with the given flag.  <a href="group__utilities.html#ga164bcb94832ea7ec757db490c927df84">More...</a><br /></td></tr>
<tr class="separator:ga164bcb94832ea7ec757db490c927df84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe37cdb1630f885493788e551136918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1fe37cdb1630f885493788e551136918">regina::Flags&lt; T &gt;::operator&amp;=</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1fe37cdb1630f885493788e551136918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise AND with the given flag set.  <a href="group__utilities.html#ga1fe37cdb1630f885493788e551136918">More...</a><br /></td></tr>
<tr class="separator:ga1fe37cdb1630f885493788e551136918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18d3d3f0b10217398d5262f5efe6990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae18d3d3f0b10217398d5262f5efe6990">regina::Flags&lt; T &gt;::operator^=</a> (T rhs)</td></tr>
<tr class="memdesc:gae18d3d3f0b10217398d5262f5efe6990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise XOR with the given flag.  <a href="group__utilities.html#gae18d3d3f0b10217398d5262f5efe6990">More...</a><br /></td></tr>
<tr class="separator:gae18d3d3f0b10217398d5262f5efe6990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09321f12b9771675813a8d32b2709a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga09321f12b9771675813a8d32b2709a73">regina::Flags&lt; T &gt;::operator^=</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga09321f12b9771675813a8d32b2709a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this flag set by taking a bitwise XOR with the given flag set.  <a href="group__utilities.html#ga09321f12b9771675813a8d32b2709a73">More...</a><br /></td></tr>
<tr class="separator:ga09321f12b9771675813a8d32b2709a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382b72837046a4a8a02bd6138539bd4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga382b72837046a4a8a02bd6138539bd4f">regina::Flags&lt; T &gt;::operator|</a> (T rhs) const</td></tr>
<tr class="memdesc:ga382b72837046a4a8a02bd6138539bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of this set and the given flag.  <a href="group__utilities.html#ga382b72837046a4a8a02bd6138539bd4f">More...</a><br /></td></tr>
<tr class="separator:ga382b72837046a4a8a02bd6138539bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53a9ace1c8cec9867f27469d2faf27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad53a9ace1c8cec9867f27469d2faf27e">regina::Flags&lt; T &gt;::operator|</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:gad53a9ace1c8cec9867f27469d2faf27e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of this and the given flag set.  <a href="group__utilities.html#gad53a9ace1c8cec9867f27469d2faf27e">More...</a><br /></td></tr>
<tr class="separator:gad53a9ace1c8cec9867f27469d2faf27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1faa44b5c7e8da126a094c42d1a386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a1faa44b5c7e8da126a094c42d1a386">regina::Flags&lt; T &gt;::operator&amp;</a> (T rhs) const</td></tr>
<tr class="memdesc:ga3a1faa44b5c7e8da126a094c42d1a386"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise AND of this set and the given flag.  <a href="group__utilities.html#ga3a1faa44b5c7e8da126a094c42d1a386">More...</a><br /></td></tr>
<tr class="separator:ga3a1faa44b5c7e8da126a094c42d1a386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e284c3fad711ece12c85949b9b4be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae6e284c3fad711ece12c85949b9b4be7">regina::Flags&lt; T &gt;::operator&amp;</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:gae6e284c3fad711ece12c85949b9b4be7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise AND of this and the given flag set.  <a href="group__utilities.html#gae6e284c3fad711ece12c85949b9b4be7">More...</a><br /></td></tr>
<tr class="separator:gae6e284c3fad711ece12c85949b9b4be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbec982386a0442a23fd2997f213fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7fbec982386a0442a23fd2997f213fe3">regina::Flags&lt; T &gt;::operator^</a> (T rhs) const</td></tr>
<tr class="memdesc:ga7fbec982386a0442a23fd2997f213fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise XOR of this set and the given flag.  <a href="group__utilities.html#ga7fbec982386a0442a23fd2997f213fe3">More...</a><br /></td></tr>
<tr class="separator:ga7fbec982386a0442a23fd2997f213fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9b5f8c9693df89efc7e7908988e139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9e9b5f8c9693df89efc7e7908988e139">regina::Flags&lt; T &gt;::operator^</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ga9e9b5f8c9693df89efc7e7908988e139"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise XOR of this and the given flag set.  <a href="group__utilities.html#ga9e9b5f8c9693df89efc7e7908988e139">More...</a><br /></td></tr>
<tr class="separator:ga9e9b5f8c9693df89efc7e7908988e139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cd858745928d367203c962071ad011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga44cd858745928d367203c962071ad011">regina::Flags&lt; T &gt;::clear</a> (T rhs)</td></tr>
<tr class="memdesc:ga44cd858745928d367203c962071ad011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all bits from this set that appear in the given flag.  <a href="group__utilities.html#ga44cd858745928d367203c962071ad011">More...</a><br /></td></tr>
<tr class="separator:ga44cd858745928d367203c962071ad011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204814b0dc212e66b45902bbbd3ef0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga204814b0dc212e66b45902bbbd3ef0a9">regina::Flags&lt; T &gt;::clear</a> (const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga204814b0dc212e66b45902bbbd3ef0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all bits from this set that appear in the given set.  <a href="group__utilities.html#ga204814b0dc212e66b45902bbbd3ef0a9">More...</a><br /></td></tr>
<tr class="separator:ga204814b0dc212e66b45902bbbd3ef0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abc7e5a319af8231874741c12c31562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7abc7e5a319af8231874741c12c31562">regina::Flags&lt; T &gt;::ensureOne</a> (T default_, T other)</td></tr>
<tr class="memdesc:ga7abc7e5a319af8231874741c12c31562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this set so that exactly one and only one of the two given flags are included.  <a href="group__utilities.html#ga7abc7e5a319af8231874741c12c31562">More...</a><br /></td></tr>
<tr class="separator:ga7abc7e5a319af8231874741c12c31562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633ea4e9bb6ffe283ae05b06c8f73d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga633ea4e9bb6ffe283ae05b06c8f73d02">regina::Flags&lt; T &gt;::ensureOne</a> (T default_, T second, T last)</td></tr>
<tr class="memdesc:ga633ea4e9bb6ffe283ae05b06c8f73d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this set so that exactly one and only one of the three given flags are included.  <a href="group__utilities.html#ga633ea4e9bb6ffe283ae05b06c8f73d02">More...</a><br /></td></tr>
<tr class="separator:ga633ea4e9bb6ffe283ae05b06c8f73d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01cdd0ccaaf98845f10fa2ab3b17852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa01cdd0ccaaf98845f10fa2ab3b17852">regina::Flags&lt; T &gt;::ensureOne</a> (T default_, T second, T third, T last)</td></tr>
<tr class="memdesc:gaa01cdd0ccaaf98845f10fa2ab3b17852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this set so that exactly one and only one of the four given flags are included.  <a href="group__utilities.html#gaa01cdd0ccaaf98845f10fa2ab3b17852">More...</a><br /></td></tr>
<tr class="separator:gaa01cdd0ccaaf98845f10fa2ab3b17852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3439925c61c42453159e0b50bdff960"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">regina::i18n::utf8ValidTo</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gad3439925c61c42453159e0b50bdff960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">More...</a><br /></td></tr>
<tr class="separator:gad3439925c61c42453159e0b50bdff960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9952c5bb8780ca8f54d450350cc640d7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9952c5bb8780ca8f54d450350cc640d7">regina::i18n::utf8ValidTo</a> (const char *s)</td></tr>
<tr class="memdesc:ga9952c5bb8780ca8f54d450350cc640d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#ga9952c5bb8780ca8f54d450350cc640d7">More...</a><br /></td></tr>
<tr class="separator:ga9952c5bb8780ca8f54d450350cc640d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2a96ed25fecca35188a79267f9d4f4ae">regina::i18n::Locale::codeset</a> ()</td></tr>
<tr class="memdesc:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character encoding used in the current locale.  <a href="group__utilities.html#ga2a96ed25fecca35188a79267f9d4f4ae">More...</a><br /></td></tr>
<tr class="separator:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3334747d42a32a95043a910a6dd173bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3334747d42a32a95043a910a6dd173bc">regina::i18n::IConvStreamBuffer::IConvStreamBuffer</a> ()</td></tr>
<tr class="memdesc:ga3334747d42a32a95043a910a6dd173bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stream buffer.  <a href="group__utilities.html#ga3334747d42a32a95043a910a6dd173bc">More...</a><br /></td></tr>
<tr class="separator:ga3334747d42a32a95043a910a6dd173bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61810bdda48b4a95ef66c577f62eadf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61810bdda48b4a95ef66c577f62eadf4">regina::i18n::IConvStreamBuffer::~IConvStreamBuffer</a> ()</td></tr>
<tr class="memdesc:ga61810bdda48b4a95ef66c577f62eadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this stream buffer.  <a href="group__utilities.html#ga61810bdda48b4a95ef66c577f62eadf4">More...</a><br /></td></tr>
<tr class="separator:ga61810bdda48b4a95ef66c577f62eadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8170e81f5d3a805161cc1ff9800e458f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8170e81f5d3a805161cc1ff9800e458f">regina::i18n::IConvStreamBuffer::open</a> (std::ostream &amp;dest, const char *srcCode, const char *destCode)</td></tr>
<tr class="memdesc:ga8170e81f5d3a805161cc1ff9800e458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new stream buffer that wraps around the given output stream.  <a href="group__utilities.html#ga8170e81f5d3a805161cc1ff9800e458f">More...</a><br /></td></tr>
<tr class="separator:ga8170e81f5d3a805161cc1ff9800e458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaec85de7b3e74749b1dd1d5d8b5f6c1aa">regina::i18n::IConvStreamBuffer::close</a> ()  throw ()</td></tr>
<tr class="memdesc:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this stream buffer.  <a href="group__utilities.html#gaec85de7b3e74749b1dd1d5d8b5f6c1aa">More...</a><br /></td></tr>
<tr class="separator:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga14a3b54d5a102597eb6abfbb173bce7b">regina::i18n::IConvStreamBuffer::overflow</a> (int_type c)</td></tr>
<tr class="memdesc:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends buffered data to the destination output stream, converting between character sets en route.  <a href="group__utilities.html#ga14a3b54d5a102597eb6abfbb173bce7b">More...</a><br /></td></tr>
<tr class="separator:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830d349d83cfdb64fee00d58d65f4aab"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga830d349d83cfdb64fee00d58d65f4aab">regina::i18n::IConvStreamBuffer::underflow</a> ()</td></tr>
<tr class="memdesc:ga830d349d83cfdb64fee00d58d65f4aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply returns EOF (since this is not an input stream).  <a href="group__utilities.html#ga830d349d83cfdb64fee00d58d65f4aab">More...</a><br /></td></tr>
<tr class="separator:ga830d349d83cfdb64fee00d58d65f4aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadd2ef9bdf704ed5c23eea6db04fb40e4">regina::i18n::IConvStreamBuffer::sync</a> ()</td></tr>
<tr class="memdesc:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all output buffers.  <a href="group__utilities.html#gadd2ef9bdf704ed5c23eea6db04fb40e4">More...</a><br /></td></tr>
<tr class="separator:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cf28d98ddd5269875d02dd4a0b0189"><td class="memItemLeft" align="right" valign="top"><a id="gae0cf28d98ddd5269875d02dd4a0b0189"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::i18n::IConvStreamBuffer::IConvStreamBuffer</b> (const <a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:gae0cf28d98ddd5269875d02dd4a0b0189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966c01eea5ec53e0b428bfd47696247c"><td class="memItemLeft" align="right" valign="top"><a id="ga966c01eea5ec53e0b428bfd47696247c"></a>
<a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::i18n::IConvStreamBuffer::operator=</b> (const <a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:ga966c01eea5ec53e0b428bfd47696247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08add9882e50e93fb34b4e420725d90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae08add9882e50e93fb34b4e420725d90">regina::i18n::IConvStream::IConvStream</a> (std::ostream &amp;dest, const char *srcCode, const char *destCode)</td></tr>
<tr class="memdesc:gae08add9882e50e93fb34b4e420725d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>; see the class notes for details.  <a href="group__utilities.html#gae08add9882e50e93fb34b4e420725d90">More...</a><br /></td></tr>
<tr class="separator:gae08add9882e50e93fb34b4e420725d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba460f1570369db5a186acdc716a9e9f"><td class="memItemLeft" align="right" valign="top"><a id="gaba460f1570369db5a186acdc716a9e9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::i18n::IConvStream::IConvStream</b> (const <a class="el" href="classregina_1_1i18n_1_1IConvStream.html">IConvStream</a> &amp;)=delete</td></tr>
<tr class="separator:gaba460f1570369db5a186acdc716a9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f300df6b84d045fa1236fbeac302be5"><td class="memItemLeft" align="right" valign="top"><a id="ga7f300df6b84d045fa1236fbeac302be5"></a>
<a class="el" href="classregina_1_1i18n_1_1IConvStream.html">IConvStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::i18n::IConvStream::operator=</b> (const <a class="el" href="classregina_1_1i18n_1_1IConvStream.html">IConvStream</a> &amp;)=delete</td></tr>
<tr class="separator:ga7f300df6b84d045fa1236fbeac302be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a> (IntType n)</td></tr>
<tr class="memdesc:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits required to store integers in the range 0,...,<em>n</em>-1.  <a href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">More...</a><br /></td></tr>
<tr class="separator:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">regina::nextPowerOfTwo</a> (IntType n)</td></tr>
<tr class="memdesc:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smallest integer power of two that is greater than or equal to the given argument <em>n</em>.  <a href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">More...</a><br /></td></tr>
<tr class="separator:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444c701a9ef2ec4972aa45d8a4063a8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga444c701a9ef2ec4972aa45d8a4063a8e">regina::ListOnCall&lt; T &gt;::ListOnCall</a> ()</td></tr>
<tr class="memdesc:ga444c701a9ef2ec4972aa45d8a4063a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list structure.  <a href="group__utilities.html#ga444c701a9ef2ec4972aa45d8a4063a8e">More...</a><br /></td></tr>
<tr class="separator:ga444c701a9ef2ec4972aa45d8a4063a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490bb9c1927c0b522ff4de33396f70a8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga490bb9c1927c0b522ff4de33396f70a8">regina::ListOnCall&lt; T &gt;::~ListOnCall</a> ()</td></tr>
<tr class="memdesc:ga490bb9c1927c0b522ff4de33396f70a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all of the items it contains.  <a href="group__utilities.html#ga490bb9c1927c0b522ff4de33396f70a8">More...</a><br /></td></tr>
<tr class="separator:ga490bb9c1927c0b522ff4de33396f70a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a2f4f57b37f515e433b039ce2257bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb">regina::ListOnCall&lt; T &gt;::begin</a> () const</td></tr>
<tr class="memdesc:ga76a2f4f57b37f515e433b039ce2257bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first item in this list.  <a href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb">More...</a><br /></td></tr>
<tr class="separator:ga76a2f4f57b37f515e433b039ce2257bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2717b68b2dc0d43087e52e59ebcc5d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf2717b68b2dc0d43087e52e59ebcc5d4">regina::ListOnCall&lt; T &gt;::end</a> () const</td></tr>
<tr class="memdesc:gaf2717b68b2dc0d43087e52e59ebcc5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing past the end of this list (i.e., just after the last item).  <a href="group__utilities.html#gaf2717b68b2dc0d43087e52e59ebcc5d4">More...</a><br /></td></tr>
<tr class="separator:gaf2717b68b2dc0d43087e52e59ebcc5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7608aebbb31f3eb07567e497109f59cd"><td class="memItemLeft" align="right" valign="top"><a id="ga7608aebbb31f3eb07567e497109f59cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ListOnCall&lt; T &gt;::ListOnCall</b> (const <a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a> &amp;)=delete</td></tr>
<tr class="separator:ga7608aebbb31f3eb07567e497109f59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994ea1af43d018e0495eba641946a1c6"><td class="memItemLeft" align="right" valign="top"><a id="ga994ea1af43d018e0495eba641946a1c6"></a>
<a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ListOnCall&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a> &amp;)=delete</td></tr>
<tr class="separator:ga994ea1af43d018e0495eba641946a1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea71dbb469a5a1c8a2b2b92fe9471061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaea71dbb469a5a1c8a2b2b92fe9471061">regina::ListOnCall&lt; T &gt;::insert</a> (T *item)</td></tr>
<tr class="memdesc:gaea71dbb469a5a1c8a2b2b92fe9471061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given item to the end of this list.  <a href="group__utilities.html#gaea71dbb469a5a1c8a2b2b92fe9471061">More...</a><br /></td></tr>
<tr class="separator:gaea71dbb469a5a1c8a2b2b92fe9471061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf28a5e3992fdfe5b552848fc2a644b2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf28a5e3992fdfe5b552848fc2a644b2e">regina::ListOnCall&lt; T &gt;::initialise</a> ()=0</td></tr>
<tr class="memdesc:gaf28a5e3992fdfe5b552848fc2a644b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this list with items.  <a href="group__utilities.html#gaf28a5e3992fdfe5b552848fc2a644b2e">More...</a><br /></td></tr>
<tr class="separator:gaf28a5e3992fdfe5b552848fc2a644b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5035a670e370a16699d1cf1c3649da8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf5035a670e370a16699d1cf1c3649da8">regina::MarkedElement::markedIndex</a> () const</td></tr>
<tr class="memdesc:gaf5035a670e370a16699d1cf1c3649da8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="group__utilities.html#gaf5035a670e370a16699d1cf1c3649da8">More...</a><br /></td></tr>
<tr class="separator:gaf5035a670e370a16699d1cf1c3649da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c60a092a49e41e22de0f22aa781322"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga27c60a092a49e41e22de0f22aa781322">regina::MarkedVector&lt; T &gt;::MarkedVector</a> ()</td></tr>
<tr class="memdesc:ga27c60a092a49e41e22de0f22aa781322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new empty vector.  <a href="group__utilities.html#ga27c60a092a49e41e22de0f22aa781322">More...</a><br /></td></tr>
<tr class="separator:ga27c60a092a49e41e22de0f22aa781322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6dc18d20d4f90644df074409a8185e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5f6dc18d20d4f90644df074409a8185e">regina::MarkedVector&lt; T &gt;::MarkedVector</a> (<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ga5f6dc18d20d4f90644df074409a8185e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given vector into this new vector.  <a href="group__utilities.html#ga5f6dc18d20d4f90644df074409a8185e">More...</a><br /></td></tr>
<tr class="separator:ga5f6dc18d20d4f90644df074409a8185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a206769cf7cf84ae780f4dfe53ce1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6a206769cf7cf84ae780f4dfe53ce1d5">regina::MarkedVector&lt; T &gt;::operator=</a> (<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ga6a206769cf7cf84ae780f4dfe53ce1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given vector into this vector.  <a href="group__utilities.html#ga6a206769cf7cf84ae780f4dfe53ce1d5">More...</a><br /></td></tr>
<tr class="separator:ga6a206769cf7cf84ae780f4dfe53ce1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a544d48d883723faea1781fa37f7e35"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4a544d48d883723faea1781fa37f7e35">regina::MarkedVector&lt; T &gt;::operator()</a> () const</td></tr>
<tr class="memdesc:ga4a544d48d883723faea1781fa37f7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts this vector to a const std::vector, thus providing access to the entire const functionality of std::vector.  <a href="group__utilities.html#ga4a544d48d883723faea1781fa37f7e35">More...</a><br /></td></tr>
<tr class="separator:ga4a544d48d883723faea1781fa37f7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9aea50a9fe46aa44b25d3413fb4d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0f9aea50a9fe46aa44b25d3413fb4d86">regina::MarkedVector&lt; T &gt;::push_back</a> (T *item)</td></tr>
<tr class="memdesc:ga0f9aea50a9fe46aa44b25d3413fb4d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given item onto the end of this vector.  <a href="group__utilities.html#ga0f9aea50a9fe46aa44b25d3413fb4d86">More...</a><br /></td></tr>
<tr class="separator:ga0f9aea50a9fe46aa44b25d3413fb4d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e455a24cd3ad0f167939f7e0f6f31e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae3e455a24cd3ad0f167939f7e0f6f31e">regina::MarkedVector&lt; T &gt;::erase</a> (typename std::vector&lt; T * &gt;::iterator pos)</td></tr>
<tr class="memdesc:gae3e455a24cd3ad0f167939f7e0f6f31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the item at the given position in this vector.  <a href="group__utilities.html#gae3e455a24cd3ad0f167939f7e0f6f31e">More...</a><br /></td></tr>
<tr class="separator:gae3e455a24cd3ad0f167939f7e0f6f31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06adea4622195052ba6470565c8dc8f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae06adea4622195052ba6470565c8dc8f">regina::MarkedVector&lt; T &gt;::erase</a> (typename std::vector&lt; T * &gt;::iterator first, typename std::vector&lt; T * &gt;::iterator last)</td></tr>
<tr class="memdesc:gae06adea4622195052ba6470565c8dc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all items in the given range in this vector.  <a href="group__utilities.html#gae06adea4622195052ba6470565c8dc8f">More...</a><br /></td></tr>
<tr class="separator:gae06adea4622195052ba6470565c8dc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15205ec8d11115bd87efabadf1bbb92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga15205ec8d11115bd87efabadf1bbb92c">regina::MarkedVector&lt; T &gt;::swap</a> (<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga15205ec8d11115bd87efabadf1bbb92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given vector.  <a href="group__utilities.html#ga15205ec8d11115bd87efabadf1bbb92c">More...</a><br /></td></tr>
<tr class="separator:ga15205ec8d11115bd87efabadf1bbb92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b63e99964f1d0705375512a31cb4e2d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga2b63e99964f1d0705375512a31cb4e2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2b63e99964f1d0705375512a31cb4e2d">regina::MarkedVector&lt; T &gt;::refill</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ga2b63e99964f1d0705375512a31cb4e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties this vector and refills it with the given range of items.  <a href="group__utilities.html#ga2b63e99964f1d0705375512a31cb4e2d">More...</a><br /></td></tr>
<tr class="separator:ga2b63e99964f1d0705375512a31cb4e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0133212115303f16c987f8e750d908"><td class="memItemLeft" align="right" valign="top"><a id="ga8c0133212115303f16c987f8e750d908"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::MarkedVector&lt; T &gt;::MarkedVector</b> (const <a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;)=delete</td></tr>
<tr class="separator:ga8c0133212115303f16c987f8e750d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25818cee40d6eb3e6e6be859cb566907"><td class="memItemLeft" align="right" valign="top"><a id="ga25818cee40d6eb3e6e6be859cb566907"></a>
<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::MarkedVector&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> &amp;)=delete</td></tr>
<tr class="separator:ga25818cee40d6eb3e6e6be859cb566907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa212f4ae28e5a29ffd13d9324512497a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa212f4ae28e5a29ffd13d9324512497a">regina::mem_istream::mem_istream</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:gaa212f4ae28e5a29ffd13d9324512497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialies an input stream that reads from the given array of characters.  <a href="group__utilities.html#gaa212f4ae28e5a29ffd13d9324512497a">More...</a><br /></td></tr>
<tr class="separator:gaa212f4ae28e5a29ffd13d9324512497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f6176bf93b895219b2da104e95f377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad2f6176bf93b895219b2da104e95f377">regina::mem_istream::~mem_istream</a> ()</td></tr>
<tr class="memdesc:gad2f6176bf93b895219b2da104e95f377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="group__utilities.html#gad2f6176bf93b895219b2da104e95f377">More...</a><br /></td></tr>
<tr class="separator:gad2f6176bf93b895219b2da104e95f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a46d5b53f75e24e9f3140f625d20a5"><td class="memItemLeft" align="right" valign="top"><a id="gaf9a46d5b53f75e24e9f3140f625d20a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_istream::mem_istream</b> (const <a class="el" href="classregina_1_1mem__istream.html">mem_istream</a> &amp;)=delete</td></tr>
<tr class="separator:gaf9a46d5b53f75e24e9f3140f625d20a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d16988e5aea8dc3a62aa8efea16ac55"><td class="memItemLeft" align="right" valign="top"><a id="ga1d16988e5aea8dc3a62aa8efea16ac55"></a>
<a class="el" href="classregina_1_1mem__istream.html">mem_istream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_istream::operator=</b> (const <a class="el" href="classregina_1_1mem__istream.html">mem_istream</a> &amp;)=delete</td></tr>
<tr class="separator:ga1d16988e5aea8dc3a62aa8efea16ac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5001473deb4ecba08fbd6997eafcae2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5001473deb4ecba08fbd6997eafcae2f">regina::mem_streambuf::mem_streambuf</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:ga5001473deb4ecba08fbd6997eafcae2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialies a read-only stream buffer that reads from the given array of characters.  <a href="group__utilities.html#ga5001473deb4ecba08fbd6997eafcae2f">More...</a><br /></td></tr>
<tr class="separator:ga5001473deb4ecba08fbd6997eafcae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44c0d976fc69ae01ce2907ccd5e7739"><td class="memItemLeft" align="right" valign="top"><a id="gad44c0d976fc69ae01ce2907ccd5e7739"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::mem_streambuf</b> (const <a class="el" href="classregina_1_1mem__streambuf.html">mem_streambuf</a> &amp;)=delete</td></tr>
<tr class="separator:gad44c0d976fc69ae01ce2907ccd5e7739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0473e2f6dc8882ce02ddfba2330661f"><td class="memItemLeft" align="right" valign="top"><a id="gad0473e2f6dc8882ce02ddfba2330661f"></a>
<a class="el" href="classregina_1_1mem__streambuf.html">mem_streambuf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::operator=</b> (const <a class="el" href="classregina_1_1mem__streambuf.html">mem_streambuf</a> &amp;)=delete</td></tr>
<tr class="separator:gad0473e2f6dc8882ce02ddfba2330661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc0787b0965764c6598ca5ef6e27100"><td class="memItemLeft" align="right" valign="top"><a id="ga2fc0787b0965764c6598ca5ef6e27100"></a>
int_type&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::underflow</b> () override</td></tr>
<tr class="separator:ga2fc0787b0965764c6598ca5ef6e27100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211fafff20d8533fccc7dca7dc55ee81"><td class="memItemLeft" align="right" valign="top"><a id="ga211fafff20d8533fccc7dca7dc55ee81"></a>
int_type&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::uflow</b> () override</td></tr>
<tr class="separator:ga211fafff20d8533fccc7dca7dc55ee81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083ecd818f0ce49aaae479a8732a1b1a"><td class="memItemLeft" align="right" valign="top"><a id="ga083ecd818f0ce49aaae479a8732a1b1a"></a>
int_type&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::pbackfail</b> (int_type ch) override</td></tr>
<tr class="separator:ga083ecd818f0ce49aaae479a8732a1b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a94f980c2a82d1f5487056edb36cca"><td class="memItemLeft" align="right" valign="top"><a id="ga40a94f980c2a82d1f5487056edb36cca"></a>
std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::xsgetn</b> (char *s, std::streamsize n) override</td></tr>
<tr class="separator:ga40a94f980c2a82d1f5487056edb36cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f379788e8971bb6eaf840f8e32e13f"><td class="memItemLeft" align="right" valign="top"><a id="gac7f379788e8971bb6eaf840f8e32e13f"></a>
std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::showmanyc</b> () override</td></tr>
<tr class="separator:gac7f379788e8971bb6eaf840f8e32e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b443630c185e3ba3f47808b14915e9d"><td class="memItemLeft" align="right" valign="top"><a id="ga5b443630c185e3ba3f47808b14915e9d"></a>
pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::seekpos</b> (pos_type pos, std::ios_base::openmode which) override</td></tr>
<tr class="separator:ga5b443630c185e3ba3f47808b14915e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7b4d55c5bef63b4fabe82bd4a36aa7"><td class="memItemLeft" align="right" valign="top"><a id="ga9c7b4d55c5bef63b4fabe82bd4a36aa7"></a>
pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>regina::mem_streambuf::seekoff</b> (off_type off, std::ios_base::seekdir dir, std::ios_base::openmode which) override</td></tr>
<tr class="separator:ga9c7b4d55c5bef63b4fabe82bd4a36aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876b6ba52fe55cc7fab8902dc3032a29"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga876b6ba52fe55cc7fab8902dc3032a29">regina::FuncNew&lt; T &gt;::operator()</a> () const</td></tr>
<tr class="memdesc:ga876b6ba52fe55cc7fab8902dc3032a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object using the default constructor.  <a href="group__utilities.html#ga876b6ba52fe55cc7fab8902dc3032a29">More...</a><br /></td></tr>
<tr class="separator:ga876b6ba52fe55cc7fab8902dc3032a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5643e0a8cd53df884e9b155554d6983"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab5643e0a8cd53df884e9b155554d6983">regina::FuncNewCopyPtr&lt; T &gt;::operator()</a> (const T *ptr) const</td></tr>
<tr class="memdesc:gab5643e0a8cd53df884e9b155554d6983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object using the copy constructor.  <a href="group__utilities.html#gab5643e0a8cd53df884e9b155554d6983">More...</a><br /></td></tr>
<tr class="separator:gab5643e0a8cd53df884e9b155554d6983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cd62b1684626a0e265cf187830af29"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga09cd62b1684626a0e265cf187830af29">regina::FuncNewCopyRef&lt; T &gt;::operator()</a> (const T &amp;obj) const</td></tr>
<tr class="memdesc:ga09cd62b1684626a0e265cf187830af29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object using the copy constructor.  <a href="group__utilities.html#ga09cd62b1684626a0e265cf187830af29">More...</a><br /></td></tr>
<tr class="separator:ga09cd62b1684626a0e265cf187830af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77e4e77654b684db01fa142fdf0b14f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae77e4e77654b684db01fa142fdf0b14f">regina::FuncNewClonePtr&lt; T &gt;::operator()</a> (const T *ptr) const</td></tr>
<tr class="memdesc:gae77e4e77654b684db01fa142fdf0b14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object using the <code>clone()</code> method.  <a href="group__utilities.html#gae77e4e77654b684db01fa142fdf0b14f">More...</a><br /></td></tr>
<tr class="separator:gae77e4e77654b684db01fa142fdf0b14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c6a4dd0202e67e7daf23d75b91b901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga64c6a4dd0202e67e7daf23d75b91b901">regina::FuncDelete&lt; T &gt;::operator()</a> (T *ptr) const</td></tr>
<tr class="memdesc:ga64c6a4dd0202e67e7daf23d75b91b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>delete</code> upon the given pointer.  <a href="group__utilities.html#ga64c6a4dd0202e67e7daf23d75b91b901">More...</a><br /></td></tr>
<tr class="separator:ga64c6a4dd0202e67e7daf23d75b91b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c8776c5329496a0b34c914706031e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga52c8776c5329496a0b34c914706031e4">regina::writeResUsage</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga52c8776c5329496a0b34c914706031e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes time and memory usage for the current process to the given output stream.  <a href="group__utilities.html#ga52c8776c5329496a0b34c914706031e4">More...</a><br /></td></tr>
<tr class="separator:ga52c8776c5329496a0b34c914706031e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2195b7064cc0a15ec1cf53a810b251b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2195b7064cc0a15ec1cf53a810b251b2">regina::StoreValue&lt; T &gt;::StoreValue</a> ()=default</td></tr>
<tr class="memdesc:ga2195b7064cc0a15ec1cf53a810b251b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised property value.  <a href="group__utilities.html#ga2195b7064cc0a15ec1cf53a810b251b2">More...</a><br /></td></tr>
<tr class="separator:ga2195b7064cc0a15ec1cf53a810b251b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa373bf5625f8f6ff525cffc0780ec532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa373bf5625f8f6ff525cffc0780ec532">regina::StoreValue&lt; T &gt;::StoreValue</a> (const <a class="el" href="classregina_1_1StoreValue.html">StoreValue</a> &amp;)=default</td></tr>
<tr class="memdesc:gaa373bf5625f8f6ff525cffc0780ec532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of the given property value.  <a href="group__utilities.html#gaa373bf5625f8f6ff525cffc0780ec532">More...</a><br /></td></tr>
<tr class="separator:gaa373bf5625f8f6ff525cffc0780ec532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0343a7f619fa6f2f7619614353642c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StoreValue.html">StoreValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0343a7f619fa6f2f7619614353642c04">regina::StoreValue&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1StoreValue.html">StoreValue</a> &amp;)=default</td></tr>
<tr class="memdesc:ga0343a7f619fa6f2f7619614353642c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given property value.  <a href="group__utilities.html#ga0343a7f619fa6f2f7619614353642c04">More...</a><br /></td></tr>
<tr class="separator:ga0343a7f619fa6f2f7619614353642c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b9eaec5bcdd31034e41967cf0902fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa2b9eaec5bcdd31034e41967cf0902fe">regina::StoreValue&lt; T &gt;::clear</a> ()</td></tr>
<tr class="memdesc:gaa2b9eaec5bcdd31034e41967cf0902fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up any currently held value before the property value is changed or cleared.  <a href="group__utilities.html#gaa2b9eaec5bcdd31034e41967cf0902fe">More...</a><br /></td></tr>
<tr class="separator:gaa2b9eaec5bcdd31034e41967cf0902fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b2334c9769b340dce136f127d6f1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga07b2334c9769b340dce136f127d6f1fc">regina::StoreValue&lt; T &gt;::swap</a> (<a class="el" href="classregina_1_1StoreValue.html">StoreValue</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga07b2334c9769b340dce136f127d6f1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this with the given value.  <a href="group__utilities.html#ga07b2334c9769b340dce136f127d6f1fc">More...</a><br /></td></tr>
<tr class="separator:ga07b2334c9769b340dce136f127d6f1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad051730c9a5cb575ab04257404db23bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad051730c9a5cb575ab04257404db23bf">regina::StoreConstPtr&lt; T &gt;::StoreConstPtr</a> ()</td></tr>
<tr class="memdesc:gad051730c9a5cb575ab04257404db23bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that sets the held pointer to <code>null</code>.  <a href="group__utilities.html#gad051730c9a5cb575ab04257404db23bf">More...</a><br /></td></tr>
<tr class="separator:gad051730c9a5cb575ab04257404db23bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc9afbfb48b039d7293950043a6df23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadbc9afbfb48b039d7293950043a6df23">regina::StoreConstPtr&lt; T &gt;::StoreConstPtr</a> (const <a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a> &amp;)=default</td></tr>
<tr class="memdesc:gadbc9afbfb48b039d7293950043a6df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of the given property value.  <a href="group__utilities.html#gadbc9afbfb48b039d7293950043a6df23">More...</a><br /></td></tr>
<tr class="separator:gadbc9afbfb48b039d7293950043a6df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178425fc5038c06ee090068af7d5e40c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga178425fc5038c06ee090068af7d5e40c">regina::StoreConstPtr&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a> &amp;)=default</td></tr>
<tr class="memdesc:ga178425fc5038c06ee090068af7d5e40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given property value.  <a href="group__utilities.html#ga178425fc5038c06ee090068af7d5e40c">More...</a><br /></td></tr>
<tr class="separator:ga178425fc5038c06ee090068af7d5e40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2fb21f29f18bac25d577ea11e835e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab2fb21f29f18bac25d577ea11e835e95">regina::StoreConstPtr&lt; T &gt;::clear</a> ()</td></tr>
<tr class="memdesc:gab2fb21f29f18bac25d577ea11e835e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up any currently held value before the property value is changed or cleared.  <a href="group__utilities.html#gab2fb21f29f18bac25d577ea11e835e95">More...</a><br /></td></tr>
<tr class="separator:gab2fb21f29f18bac25d577ea11e835e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834582f8a4b313cf25b6638ec316392c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga834582f8a4b313cf25b6638ec316392c">regina::StoreConstPtr&lt; T &gt;::swap</a> (<a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga834582f8a4b313cf25b6638ec316392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this with the given value.  <a href="group__utilities.html#ga834582f8a4b313cf25b6638ec316392c">More...</a><br /></td></tr>
<tr class="separator:ga834582f8a4b313cf25b6638ec316392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f14592870ec2129b9f5f45fc9262e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga14f14592870ec2129b9f5f45fc9262e0">regina::StoreManagedPtr&lt; T &gt;::StoreManagedPtr</a> ()</td></tr>
<tr class="memdesc:ga14f14592870ec2129b9f5f45fc9262e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that sets the held pointer to <code>null</code>.  <a href="group__utilities.html#ga14f14592870ec2129b9f5f45fc9262e0">More...</a><br /></td></tr>
<tr class="separator:ga14f14592870ec2129b9f5f45fc9262e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d6ba37500b4a648bba6ecc92505a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga46d6ba37500b4a648bba6ecc92505a05">regina::StoreManagedPtr&lt; T &gt;::clear</a> ()</td></tr>
<tr class="memdesc:ga46d6ba37500b4a648bba6ecc92505a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up any currently held value before the property value is changed or cleared.  <a href="group__utilities.html#ga46d6ba37500b4a648bba6ecc92505a05">More...</a><br /></td></tr>
<tr class="separator:ga46d6ba37500b4a648bba6ecc92505a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2786b6a706c131238f5bbf6f815ba492"><td class="memItemLeft" align="right" valign="top"><a id="ga2786b6a706c131238f5bbf6f815ba492"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StoreManagedPtr&lt; T &gt;::StoreManagedPtr</b> (const <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &amp;)=delete</td></tr>
<tr class="separator:ga2786b6a706c131238f5bbf6f815ba492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4048b4490a506324aa60ab29cfe5f1"><td class="memItemLeft" align="right" valign="top"><a id="ga1c4048b4490a506324aa60ab29cfe5f1"></a>
<a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StoreManagedPtr&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &amp;)=delete</td></tr>
<tr class="separator:ga1c4048b4490a506324aa60ab29cfe5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4d1def8bd3e965dc227475025c4671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2a4d1def8bd3e965dc227475025c4671">regina::StoreManagedPtr&lt; T &gt;::~StoreManagedPtr</a> ()</td></tr>
<tr class="memdesc:ga2a4d1def8bd3e965dc227475025c4671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the currently held value if one exists.  <a href="group__utilities.html#ga2a4d1def8bd3e965dc227475025c4671">More...</a><br /></td></tr>
<tr class="separator:ga2a4d1def8bd3e965dc227475025c4671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a001c1dfb31cef29d2642cdba7ff358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8a001c1dfb31cef29d2642cdba7ff358">regina::StoreManagedPtr&lt; T &gt;::swap</a> (<a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ga8a001c1dfb31cef29d2642cdba7ff358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this with the given value.  <a href="group__utilities.html#ga8a001c1dfb31cef29d2642cdba7ff358">More...</a><br /></td></tr>
<tr class="separator:ga8a001c1dfb31cef29d2642cdba7ff358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38706401f222b808a6d225047e2d1c3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga38706401f222b808a6d225047e2d1c3e">regina::Property&lt; T, Storage &gt;::Property</a> ()</td></tr>
<tr class="memdesc:ga38706401f222b808a6d225047e2d1c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__utilities.html#ga38706401f222b808a6d225047e2d1c3e">More...</a><br /></td></tr>
<tr class="separator:ga38706401f222b808a6d225047e2d1c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2acc5d3766e943036cde381d723d03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafc2acc5d3766e943036cde381d723d03">regina::Property&lt; T, Storage &gt;::Property</a> (const <a class="el" href="classregina_1_1Property.html">Property</a>&lt; T, Storage &gt; &amp;newValue)</td></tr>
<tr class="memdesc:gafc2acc5d3766e943036cde381d723d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new clone of the given property.  <a href="group__utilities.html#gafc2acc5d3766e943036cde381d723d03">More...</a><br /></td></tr>
<tr class="separator:gafc2acc5d3766e943036cde381d723d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8cba1c0b050e32df20cefca4e8a815"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafe8cba1c0b050e32df20cefca4e8a815">regina::Property&lt; T, Storage &gt;::known</a> () const</td></tr>
<tr class="memdesc:gafe8cba1c0b050e32df20cefca4e8a815"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this property is currently marked as known.  <a href="group__utilities.html#gafe8cba1c0b050e32df20cefca4e8a815">More...</a><br /></td></tr>
<tr class="separator:gafe8cba1c0b050e32df20cefca4e8a815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd67fe8acc7e676213cd1527066214fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd67fe8acc7e676213cd1527066214fc">regina::Property&lt; T, Storage &gt;::value</a> () const</td></tr>
<tr class="memdesc:gacd67fe8acc7e676213cd1527066214fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the current value of this property.  <a href="group__utilities.html#gacd67fe8acc7e676213cd1527066214fc">More...</a><br /></td></tr>
<tr class="separator:gacd67fe8acc7e676213cd1527066214fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7f6645cddb7e89f69009ff6b49529f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a7f6645cddb7e89f69009ff6b49529f">regina::Property&lt; T, Storage &gt;::clear</a> ()</td></tr>
<tr class="memdesc:ga3a7f6645cddb7e89f69009ff6b49529f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this property as unknown.  <a href="group__utilities.html#ga3a7f6645cddb7e89f69009ff6b49529f">More...</a><br /></td></tr>
<tr class="separator:ga3a7f6645cddb7e89f69009ff6b49529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66e8504a4a552ddd3715ea808f7f48b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad66e8504a4a552ddd3715ea808f7f48b">regina::Property&lt; T, Storage &gt;::operator=</a> (<a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">InitType</a> newValue)</td></tr>
<tr class="memdesc:gad66e8504a4a552ddd3715ea808f7f48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a new value to this property.  <a href="group__utilities.html#gad66e8504a4a552ddd3715ea808f7f48b">More...</a><br /></td></tr>
<tr class="separator:gad66e8504a4a552ddd3715ea808f7f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c868cf9c50bcf2eb5360b95f58aa6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa7c868cf9c50bcf2eb5360b95f58aa6b">regina::Property&lt; T, Storage &gt;::operator=</a> (const <a class="el" href="classregina_1_1Property.html">Property</a> &amp;newValue)</td></tr>
<tr class="memdesc:gaa7c868cf9c50bcf2eb5360b95f58aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given property into this property.  <a href="group__utilities.html#gaa7c868cf9c50bcf2eb5360b95f58aa6b">More...</a><br /></td></tr>
<tr class="separator:gaa7c868cf9c50bcf2eb5360b95f58aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bcfc6fe03b9e15de50e59b11d954b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga81bcfc6fe03b9e15de50e59b11d954b3">regina::Property&lt; T, Storage &gt;::swap</a> (<a class="el" href="classregina_1_1Property.html">Property</a>&lt; T, Storage &gt; &amp;other)</td></tr>
<tr class="memdesc:ga81bcfc6fe03b9e15de50e59b11d954b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this with the given property.  <a href="group__utilities.html#ga81bcfc6fe03b9e15de50e59b11d954b3">More...</a><br /></td></tr>
<tr class="separator:ga81bcfc6fe03b9e15de50e59b11d954b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a20ee136c5a257176ff117f0eafb4a0">regina::clonePtr</a> (T *cloneMe)</td></tr>
<tr class="memdesc:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="group__utilities.html#ga3a20ee136c5a257176ff117f0eafb4a0">More...</a><br /></td></tr>
<tr class="separator:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae9fe03c364fe26a4f0e93c59a198b267">regina::clonePtr</a> (const std::unique_ptr&lt; T &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gae9fe03c364fe26a4f0e93c59a198b267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="group__utilities.html#gae9fe03c364fe26a4f0e93c59a198b267">More...</a><br /></td></tr>
<tr class="separator:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed2b115d89b7072c51099a602c8c56c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9ed2b115d89b7072c51099a602c8c56c">regina::LessDeref&lt; T, Comp &gt;::operator()</a> (const T *ptr1, const T *ptr2) const</td></tr>
<tr class="memdesc:ga9ed2b115d89b7072c51099a602c8c56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the objects to which the given pointers are pointing.  <a href="group__utilities.html#ga9ed2b115d89b7072c51099a602c8c56c">More...</a><br /></td></tr>
<tr class="separator:ga9ed2b115d89b7072c51099a602c8c56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1fc8fedcb72b9db35901807c795486c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1fc8fedcb72b9db35901807c795486c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1fc8fedcb72b9db35901807c795486c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gab1fc8fedcb72b9db35901807c795486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#gab1fc8fedcb72b9db35901807c795486c">More...</a><br /></td></tr>
<tr class="separator:gab1fc8fedcb72b9db35901807c795486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aac762c42dd7e865046856639dfb125"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8aac762c42dd7e865046856639dfb125">regina::Qitmask1&lt; T &gt;::Qitmask1</a> ()</td></tr>
<tr class="memdesc:ga8aac762c42dd7e865046856639dfb125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new qitmask with all qits set to 0.  <a href="group__utilities.html#ga8aac762c42dd7e865046856639dfb125">More...</a><br /></td></tr>
<tr class="separator:ga8aac762c42dd7e865046856639dfb125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0607c0b9e71a43dca2bf3e8a62f06b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadf0607c0b9e71a43dca2bf3e8a62f06b">regina::Qitmask1&lt; T &gt;::Qitmask1</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gadf0607c0b9e71a43dca2bf3e8a62f06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given qitmask.  <a href="group__utilities.html#gadf0607c0b9e71a43dca2bf3e8a62f06b">More...</a><br /></td></tr>
<tr class="separator:gadf0607c0b9e71a43dca2bf3e8a62f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8f1dd47bcdd7dbc0074fd99335155e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafd8f1dd47bcdd7dbc0074fd99335155e">regina::Qitmask1&lt; T &gt;::reset</a> ()</td></tr>
<tr class="memdesc:gafd8f1dd47bcdd7dbc0074fd99335155e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all qits of this qitmask to 0.  <a href="group__utilities.html#gafd8f1dd47bcdd7dbc0074fd99335155e">More...</a><br /></td></tr>
<tr class="separator:gafd8f1dd47bcdd7dbc0074fd99335155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693f4df747e7ece678b2b81608bc7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga693f4df747e7ece678b2b81608bc7224">regina::Qitmask1&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;other)=default</td></tr>
<tr class="memdesc:ga693f4df747e7ece678b2b81608bc7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this qitmask to a copy of the given qitmask.  <a href="group__utilities.html#ga693f4df747e7ece678b2b81608bc7224">More...</a><br /></td></tr>
<tr class="separator:ga693f4df747e7ece678b2b81608bc7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a572cf75f5bcaed1bfa97dce7225d14"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4a572cf75f5bcaed1bfa97dce7225d14">regina::Qitmask1&lt; T &gt;::get</a> (unsigned index) const</td></tr>
<tr class="memdesc:ga4a572cf75f5bcaed1bfa97dce7225d14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given qit in this qitmask.  <a href="group__utilities.html#ga4a572cf75f5bcaed1bfa97dce7225d14">More...</a><br /></td></tr>
<tr class="separator:ga4a572cf75f5bcaed1bfa97dce7225d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10de71017305e728925cbe1a6b1128d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga10de71017305e728925cbe1a6b1128d4">regina::Qitmask1&lt; T &gt;::set</a> (unsigned index, char value)</td></tr>
<tr class="memdesc:ga10de71017305e728925cbe1a6b1128d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given qit of this qitmask to the given value.  <a href="group__utilities.html#ga10de71017305e728925cbe1a6b1128d4">More...</a><br /></td></tr>
<tr class="separator:ga10de71017305e728925cbe1a6b1128d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638ed603ac7452cfb9503a395c0e93ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga638ed603ac7452cfb9503a395c0e93ff">regina::Qitmask1&lt; T &gt;::empty</a> () const</td></tr>
<tr class="memdesc:ga638ed603ac7452cfb9503a395c0e93ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains all zeroes.  <a href="group__utilities.html#ga638ed603ac7452cfb9503a395c0e93ff">More...</a><br /></td></tr>
<tr class="separator:ga638ed603ac7452cfb9503a395c0e93ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5b06cbb4460371a18c18c5cc279a12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1c5b06cbb4460371a18c18c5cc279a12">regina::Qitmask1&lt; T &gt;::nonEmpty</a> () const</td></tr>
<tr class="memdesc:ga1c5b06cbb4460371a18c18c5cc279a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains at least one non-zero qit.  <a href="group__utilities.html#ga1c5b06cbb4460371a18c18c5cc279a12">More...</a><br /></td></tr>
<tr class="separator:ga1c5b06cbb4460371a18c18c5cc279a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d21694ed37af5f470e46e025b077d9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1d21694ed37af5f470e46e025b077d9a">regina::Qitmask1&lt; T &gt;::has3</a> () const</td></tr>
<tr class="memdesc:ga1d21694ed37af5f470e46e025b077d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains at least one qit with value 3.  <a href="group__utilities.html#ga1d21694ed37af5f470e46e025b077d9a">More...</a><br /></td></tr>
<tr class="separator:ga1d21694ed37af5f470e46e025b077d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e3007a16b086c30b6a0d8a4744d78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga06e3007a16b086c30b6a0d8a4744d78a">regina::Qitmask1&lt; T &gt;::operator+=</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga06e3007a16b086c30b6a0d8a4744d78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the sum of this and the given qitmask.  <a href="group__utilities.html#ga06e3007a16b086c30b6a0d8a4744d78a">More...</a><br /></td></tr>
<tr class="separator:ga06e3007a16b086c30b6a0d8a4744d78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cf4a042a22ac4d9aba8ea6aef12934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae4cf4a042a22ac4d9aba8ea6aef12934">regina::Qitmask1&lt; T &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae4cf4a042a22ac4d9aba8ea6aef12934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the difference of this and the given qitmask.  <a href="group__utilities.html#gae4cf4a042a22ac4d9aba8ea6aef12934">More...</a><br /></td></tr>
<tr class="separator:gae4cf4a042a22ac4d9aba8ea6aef12934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac436127cd2b90dd4a6d541ab49790729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac436127cd2b90dd4a6d541ab49790729">regina::Qitmask1&lt; T &gt;::operator==</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:gac436127cd2b90dd4a6d541ab49790729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given qitmask are identical.  <a href="group__utilities.html#gac436127cd2b90dd4a6d541ab49790729">More...</a><br /></td></tr>
<tr class="separator:gac436127cd2b90dd4a6d541ab49790729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cb0ddb01f4af90ab177f2637f2ce3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga47cb0ddb01f4af90ab177f2637f2ce3f">regina::Qitmask1&lt; T &gt;::hasNonZeroMatch</a> (const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga47cb0ddb01f4af90ab177f2637f2ce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether there is some index at which both this and the given qitmask both have non-zero qits.  <a href="group__utilities.html#ga47cb0ddb01f4af90ab177f2637f2ce3f">More...</a><br /></td></tr>
<tr class="separator:ga47cb0ddb01f4af90ab177f2637f2ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a04e46c3516672d83a09e6f07b85876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0a04e46c3516672d83a09e6f07b85876"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0a04e46c3516672d83a09e6f07b85876">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga0a04e46c3516672d83a09e6f07b85876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#ga0a04e46c3516672d83a09e6f07b85876">More...</a><br /></td></tr>
<tr class="separator:ga0a04e46c3516672d83a09e6f07b85876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9fc8c1873b3031e713af54c6168d74e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac9fc8c1873b3031e713af54c6168d74e">regina::Qitmask2&lt; T, U &gt;::Qitmask2</a> ()</td></tr>
<tr class="memdesc:gac9fc8c1873b3031e713af54c6168d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new qitmask with all qits set to 0.  <a href="group__utilities.html#gac9fc8c1873b3031e713af54c6168d74e">More...</a><br /></td></tr>
<tr class="separator:gac9fc8c1873b3031e713af54c6168d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc1ffc47323a01491484ac1b39ea081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacfc1ffc47323a01491484ac1b39ea081">regina::Qitmask2&lt; T, U &gt;::Qitmask2</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gacfc1ffc47323a01491484ac1b39ea081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given qitmask.  <a href="group__utilities.html#gacfc1ffc47323a01491484ac1b39ea081">More...</a><br /></td></tr>
<tr class="separator:gacfc1ffc47323a01491484ac1b39ea081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184cd38f75e3df9f2047a79f45be7eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga184cd38f75e3df9f2047a79f45be7eb3">regina::Qitmask2&lt; T, U &gt;::reset</a> ()</td></tr>
<tr class="memdesc:ga184cd38f75e3df9f2047a79f45be7eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all qits of this qitmask to 0.  <a href="group__utilities.html#ga184cd38f75e3df9f2047a79f45be7eb3">More...</a><br /></td></tr>
<tr class="separator:ga184cd38f75e3df9f2047a79f45be7eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f1f03dd01f60244b7d83338bce6f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga34f1f03dd01f60244b7d83338bce6f33">regina::Qitmask2&lt; T, U &gt;::operator=</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;other)=default</td></tr>
<tr class="memdesc:ga34f1f03dd01f60244b7d83338bce6f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this qitmask to a copy of the given qitmask.  <a href="group__utilities.html#ga34f1f03dd01f60244b7d83338bce6f33">More...</a><br /></td></tr>
<tr class="separator:ga34f1f03dd01f60244b7d83338bce6f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab639244c964a2af9b83877987779c03a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab639244c964a2af9b83877987779c03a">regina::Qitmask2&lt; T, U &gt;::get</a> (unsigned index) const</td></tr>
<tr class="memdesc:gab639244c964a2af9b83877987779c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given qit in this qitmask.  <a href="group__utilities.html#gab639244c964a2af9b83877987779c03a">More...</a><br /></td></tr>
<tr class="separator:gab639244c964a2af9b83877987779c03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9e402f178d8448653aa1509c2d694e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7b9e402f178d8448653aa1509c2d694e">regina::Qitmask2&lt; T, U &gt;::set</a> (unsigned index, char value)</td></tr>
<tr class="memdesc:ga7b9e402f178d8448653aa1509c2d694e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given qit of this qitmask to the given value.  <a href="group__utilities.html#ga7b9e402f178d8448653aa1509c2d694e">More...</a><br /></td></tr>
<tr class="separator:ga7b9e402f178d8448653aa1509c2d694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0523166fbf4f9a052389a2d836af561a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0523166fbf4f9a052389a2d836af561a">regina::Qitmask2&lt; T, U &gt;::empty</a> () const</td></tr>
<tr class="memdesc:ga0523166fbf4f9a052389a2d836af561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains all zeroes.  <a href="group__utilities.html#ga0523166fbf4f9a052389a2d836af561a">More...</a><br /></td></tr>
<tr class="separator:ga0523166fbf4f9a052389a2d836af561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea6c09f2da82fdee9b8ce86b7eaf684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6ea6c09f2da82fdee9b8ce86b7eaf684">regina::Qitmask2&lt; T, U &gt;::nonEmpty</a> () const</td></tr>
<tr class="memdesc:ga6ea6c09f2da82fdee9b8ce86b7eaf684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains at least one non-zero qit.  <a href="group__utilities.html#ga6ea6c09f2da82fdee9b8ce86b7eaf684">More...</a><br /></td></tr>
<tr class="separator:ga6ea6c09f2da82fdee9b8ce86b7eaf684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec7c6989ea9fbd66b68fc35aa7c141e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1ec7c6989ea9fbd66b68fc35aa7c141e">regina::Qitmask2&lt; T, U &gt;::has3</a> () const</td></tr>
<tr class="memdesc:ga1ec7c6989ea9fbd66b68fc35aa7c141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this qitmask contains at least one qit with value 3.  <a href="group__utilities.html#ga1ec7c6989ea9fbd66b68fc35aa7c141e">More...</a><br /></td></tr>
<tr class="separator:ga1ec7c6989ea9fbd66b68fc35aa7c141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de2c9955bf243995cbb53e691c3ee75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3de2c9955bf243995cbb53e691c3ee75">regina::Qitmask2&lt; T, U &gt;::operator+=</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3de2c9955bf243995cbb53e691c3ee75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the sum of this and the given qitmask.  <a href="group__utilities.html#ga3de2c9955bf243995cbb53e691c3ee75">More...</a><br /></td></tr>
<tr class="separator:ga3de2c9955bf243995cbb53e691c3ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8535c02e6c0b8c9961fcb617b0ce82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6e8535c02e6c0b8c9961fcb617b0ce82">regina::Qitmask2&lt; T, U &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6e8535c02e6c0b8c9961fcb617b0ce82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the difference of this and the given qitmask.  <a href="group__utilities.html#ga6e8535c02e6c0b8c9961fcb617b0ce82">More...</a><br /></td></tr>
<tr class="separator:ga6e8535c02e6c0b8c9961fcb617b0ce82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c798712b57c0ea0b00b4b384eeb375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga02c798712b57c0ea0b00b4b384eeb375">regina::Qitmask2&lt; T, U &gt;::operator==</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga02c798712b57c0ea0b00b4b384eeb375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given qitmask are identical.  <a href="group__utilities.html#ga02c798712b57c0ea0b00b4b384eeb375">More...</a><br /></td></tr>
<tr class="separator:ga02c798712b57c0ea0b00b4b384eeb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8676cc0860ce7cc9135ada44516aec0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad8676cc0860ce7cc9135ada44516aec0">regina::Qitmask2&lt; T, U &gt;::hasNonZeroMatch</a> (const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:gad8676cc0860ce7cc9135ada44516aec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether there is some index at which both this and the given qitmask both have non-zero qits.  <a href="group__utilities.html#gad8676cc0860ce7cc9135ada44516aec0">More...</a><br /></td></tr>
<tr class="separator:gad8676cc0860ce7cc9135ada44516aec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195d0c880dc42a14fd997612fe8fa327"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga195d0c880dc42a14fd997612fe8fa327">regina::RandomEngine::RandomEngine</a> ()</td></tr>
<tr class="memdesc:ga195d0c880dc42a14fd997612fe8fa327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that locks the internal mutex.  <a href="group__utilities.html#ga195d0c880dc42a14fd997612fe8fa327">More...</a><br /></td></tr>
<tr class="separator:ga195d0c880dc42a14fd997612fe8fa327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9274be75059680fab7d6dee5879d3b"><td class="memItemLeft" align="right" valign="top">std::default_random_engine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabe9274be75059680fab7d6dee5879d3b">regina::RandomEngine::engine</a> ()</td></tr>
<tr class="memdesc:gabe9274be75059680fab7d6dee5879d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to Regina's global uniform random bit generator (URBG).  <a href="group__utilities.html#gabe9274be75059680fab7d6dee5879d3b">More...</a><br /></td></tr>
<tr class="separator:gabe9274be75059680fab7d6dee5879d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6db55f93ed9723b2da068ebdfe2692"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:gacb6db55f93ed9723b2da068ebdfe2692"><td class="memTemplItemLeft" align="right" valign="top">static Int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb6db55f93ed9723b2da068ebdfe2692">regina::RandomEngine::rand</a> (Int range)</td></tr>
<tr class="memdesc:gacb6db55f93ed9723b2da068ebdfe2692"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function that returns a random integer modulo <em>range</em>, in a thread-safe manner.  <a href="group__utilities.html#gacb6db55f93ed9723b2da068ebdfe2692">More...</a><br /></td></tr>
<tr class="separator:gacb6db55f93ed9723b2da068ebdfe2692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65695f8761c422a85533289ae8bdf16b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga65695f8761c422a85533289ae8bdf16b">regina::RandomEngine::reseedWithHardware</a> ()</td></tr>
<tr class="memdesc:ga65695f8761c422a85533289ae8bdf16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reseeds the global uniform random bit generator using hardware entropy.  <a href="group__utilities.html#ga65695f8761c422a85533289ae8bdf16b">More...</a><br /></td></tr>
<tr class="separator:ga65695f8761c422a85533289ae8bdf16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab638db40d8e39c071328e10dee94b81a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab638db40d8e39c071328e10dee94b81a">regina::RandomEngine::reseedWithDefault</a> ()</td></tr>
<tr class="memdesc:gab638db40d8e39c071328e10dee94b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reseeds the global uniform random bit generator using the default seed.  <a href="group__utilities.html#gab638db40d8e39c071328e10dee94b81a">More...</a><br /></td></tr>
<tr class="separator:gab638db40d8e39c071328e10dee94b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabefa649b46a91fffa231e2226a367273"><td class="memTemplParams" colspan="2">template&lt;typename Info , typename... Args&gt; </td></tr>
<tr class="memitem:gabefa649b46a91fffa231e2226a367273"><td class="memTemplItemLeft" align="right" valign="top">Base *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabefa649b46a91fffa231e2226a367273">regina::NewFunction&lt; Base &gt;::operator()</a> (Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:gabefa649b46a91fffa231e2226a367273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object of the subclass Info::Class.  <a href="group__utilities.html#gabefa649b46a91fffa231e2226a367273">More...</a><br /></td></tr>
<tr class="separator:gabefa649b46a91fffa231e2226a367273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca00acf92239348375b90afddf164cb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaca00acf92239348375b90afddf164cb6">regina::SafePointeeBase&lt; T &gt;::SafePointeeBase</a> (const <a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:gaca00acf92239348375b90afddf164cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent derived classes from accidentally calling the copy constructor.  <a href="group__utilities.html#gaca00acf92239348375b90afddf164cb6">More...</a><br /></td></tr>
<tr class="separator:gaca00acf92239348375b90afddf164cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa228df50552bfebe61723bdfc76c7a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa228df50552bfebe61723bdfc76c7a88">regina::SafePointeeBase&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:gaa228df50552bfebe61723bdfc76c7a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent derived classes from accidentally calling the assignment operator.  <a href="group__utilities.html#gaa228df50552bfebe61723bdfc76c7a88">More...</a><br /></td></tr>
<tr class="separator:gaa228df50552bfebe61723bdfc76c7a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa724448326c5e5b0ba727fe6ce6d1233"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa724448326c5e5b0ba727fe6ce6d1233">regina::SafePointeeBase&lt; T &gt;::hasSafePtr</a> () const</td></tr>
<tr class="memdesc:gaa724448326c5e5b0ba727fe6ce6d1233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there one or more <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> currently pointing to this object?  <a href="group__utilities.html#gaa724448326c5e5b0ba727fe6ce6d1233">More...</a><br /></td></tr>
<tr class="separator:gaa724448326c5e5b0ba727fe6ce6d1233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10e603a3e56ad8a8ce3edaf5982d465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf10e603a3e56ad8a8ce3edaf5982d465">regina::SafePointeeBase&lt; T &gt;::SafePointeeBase</a> ()</td></tr>
<tr class="memdesc:gaf10e603a3e56ad8a8ce3edaf5982d465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__utilities.html#gaf10e603a3e56ad8a8ce3edaf5982d465">More...</a><br /></td></tr>
<tr class="separator:gaf10e603a3e56ad8a8ce3edaf5982d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33b066afbad6a25be00878c7cf3a7e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf33b066afbad6a25be00878c7cf3a7e6">regina::SafePtr&lt; T &gt;::SafePtr</a> ()</td></tr>
<tr class="memdesc:gaf33b066afbad6a25be00878c7cf3a7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new null pointer.  <a href="group__utilities.html#gaf33b066afbad6a25be00878c7cf3a7e6">More...</a><br /></td></tr>
<tr class="separator:gaf33b066afbad6a25be00878c7cf3a7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75651d857fbb4f708f91c06a4cc178dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga75651d857fbb4f708f91c06a4cc178dd">regina::SafePtr&lt; T &gt;::SafePtr</a> (T *object)</td></tr>
<tr class="memdesc:ga75651d857fbb4f708f91c06a4cc178dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new safe pointer that points to the given object.  <a href="group__utilities.html#ga75651d857fbb4f708f91c06a4cc178dd">More...</a><br /></td></tr>
<tr class="separator:ga75651d857fbb4f708f91c06a4cc178dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8eb187bbdad812403168457626247f8"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:gaa8eb187bbdad812403168457626247f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8eb187bbdad812403168457626247f8">regina::SafePtr&lt; T &gt;::SafePtr</a> (const <a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt; Y &gt; &amp;other)</td></tr>
<tr class="memdesc:gaa8eb187bbdad812403168457626247f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="group__utilities.html#gaa8eb187bbdad812403168457626247f8">More...</a><br /></td></tr>
<tr class="separator:gaa8eb187bbdad812403168457626247f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27b83072e5e62e6cfb7a263847cef81"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa27b83072e5e62e6cfb7a263847cef81">regina::SafePtr&lt; T &gt;::get</a> () const</td></tr>
<tr class="memdesc:gaa27b83072e5e62e6cfb7a263847cef81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a raw pointer to the pointee.  <a href="group__utilities.html#gaa27b83072e5e62e6cfb7a263847cef81">More...</a><br /></td></tr>
<tr class="separator:gaa27b83072e5e62e6cfb7a263847cef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329db8d529368e9df9a4db80a0c22206"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga329db8d529368e9df9a4db80a0c22206">regina::SafePtr&lt; T &gt;::operator bool</a> () const</td></tr>
<tr class="memdesc:ga329db8d529368e9df9a4db80a0c22206"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <code>true</code> if the pointee is non-null.  <a href="group__utilities.html#ga329db8d529368e9df9a4db80a0c22206">More...</a><br /></td></tr>
<tr class="separator:ga329db8d529368e9df9a4db80a0c22206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165989a691406469cf5132c4e5816ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga165989a691406469cf5132c4e5816ce4">regina::SafePtr&lt; T &gt;::reset</a> (T *object=nullptr)</td></tr>
<tr class="memdesc:ga165989a691406469cf5132c4e5816ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this to point to the given object.  <a href="group__utilities.html#ga165989a691406469cf5132c4e5816ce4">More...</a><br /></td></tr>
<tr class="separator:ga165989a691406469cf5132c4e5816ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30127ffda526093d6451ff8a5642994b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga30127ffda526093d6451ff8a5642994b">regina::SafePtr&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="memdesc:ga30127ffda526093d6451ff8a5642994b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the default assignment operator.  <a href="group__utilities.html#ga30127ffda526093d6451ff8a5642994b">More...</a><br /></td></tr>
<tr class="separator:ga30127ffda526093d6451ff8a5642994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846e0d6cfe168e127e70a8315f406afa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga846e0d6cfe168e127e70a8315f406afa">regina::LightweightSequence&lt; T &gt;::LightweightSequence</a> ()</td></tr>
<tr class="memdesc:ga846e0d6cfe168e127e70a8315f406afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty sequence; that is, a sequence of size zero.  <a href="group__utilities.html#ga846e0d6cfe168e127e70a8315f406afa">More...</a><br /></td></tr>
<tr class="separator:ga846e0d6cfe168e127e70a8315f406afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac032923d378946c9adedf8b299a66775"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac032923d378946c9adedf8b299a66775">regina::LightweightSequence&lt; T &gt;::LightweightSequence</a> (size_t <a class="el" href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe">size</a>)</td></tr>
<tr class="memdesc:gac032923d378946c9adedf8b299a66775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new sequence containing the given number of elements.  <a href="group__utilities.html#gac032923d378946c9adedf8b299a66775">More...</a><br /></td></tr>
<tr class="separator:gac032923d378946c9adedf8b299a66775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdae8fad58d9618d6d99e27e18c4119"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4fdae8fad58d9618d6d99e27e18c4119">regina::LightweightSequence&lt; T &gt;::LightweightSequence</a> (const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;src)</td></tr>
<tr class="memdesc:ga4fdae8fad58d9618d6d99e27e18c4119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the given sequence.  <a href="group__utilities.html#ga4fdae8fad58d9618d6d99e27e18c4119">More...</a><br /></td></tr>
<tr class="separator:ga4fdae8fad58d9618d6d99e27e18c4119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140db26f8fcf84358e4f86ff932c81b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga140db26f8fcf84358e4f86ff932c81b0">regina::LightweightSequence&lt; T &gt;::LightweightSequence</a> (<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ga140db26f8fcf84358e4f86ff932c81b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given sequence to this new sequence.  <a href="group__utilities.html#ga140db26f8fcf84358e4f86ff932c81b0">More...</a><br /></td></tr>
<tr class="separator:ga140db26f8fcf84358e4f86ff932c81b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1099690616a1c0d5943bce8c3f915a06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1099690616a1c0d5943bce8c3f915a06">regina::LightweightSequence&lt; T &gt;::~LightweightSequence</a> ()</td></tr>
<tr class="memdesc:ga1099690616a1c0d5943bce8c3f915a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this sequence and all of its elements.  <a href="group__utilities.html#ga1099690616a1c0d5943bce8c3f915a06">More...</a><br /></td></tr>
<tr class="separator:ga1099690616a1c0d5943bce8c3f915a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c716ebe16604586927a18a795942197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1c716ebe16604586927a18a795942197">regina::LightweightSequence&lt; T &gt;::init</a> (size_t <a class="el" href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe">size</a>=0)</td></tr>
<tr class="memdesc:ga1c716ebe16604586927a18a795942197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this sequence to contain the given number of elements.  <a href="group__utilities.html#ga1c716ebe16604586927a18a795942197">More...</a><br /></td></tr>
<tr class="separator:ga1c716ebe16604586927a18a795942197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe069cf7dc53da78a82b6d0fb8c0bbbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe">regina::LightweightSequence&lt; T &gt;::size</a> () const</td></tr>
<tr class="memdesc:gafe069cf7dc53da78a82b6d0fb8c0bbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of elements in this sequence.  <a href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe">More...</a><br /></td></tr>
<tr class="separator:gafe069cf7dc53da78a82b6d0fb8c0bbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b19ab4d75e4b847d1205ece56126420"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8b19ab4d75e4b847d1205ece56126420">regina::LightweightSequence&lt; T &gt;::operator[]</a> (size_t pos) const</td></tr>
<tr class="memdesc:ga8b19ab4d75e4b847d1205ece56126420"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a copy of the element at the given index in the sequence.  <a href="group__utilities.html#ga8b19ab4d75e4b847d1205ece56126420">More...</a><br /></td></tr>
<tr class="separator:ga8b19ab4d75e4b847d1205ece56126420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420d07f66ec9d7fa8bc2c04b41927cbe"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga420d07f66ec9d7fa8bc2c04b41927cbe">regina::LightweightSequence&lt; T &gt;::operator[]</a> (size_t pos)</td></tr>
<tr class="memdesc:ga420d07f66ec9d7fa8bc2c04b41927cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the element at the given index in the sequence.  <a href="group__utilities.html#ga420d07f66ec9d7fa8bc2c04b41927cbe">More...</a><br /></td></tr>
<tr class="separator:ga420d07f66ec9d7fa8bc2c04b41927cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0ebb883a3c9fbe3bca51055ef4816f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabc0ebb883a3c9fbe3bca51055ef4816f">regina::LightweightSequence&lt; T &gt;::begin</a> ()</td></tr>
<tr class="memdesc:gabc0ebb883a3c9fbe3bca51055ef4816f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write iterator that points to the first element of the sequence.  <a href="group__utilities.html#gabc0ebb883a3c9fbe3bca51055ef4816f">More...</a><br /></td></tr>
<tr class="separator:gabc0ebb883a3c9fbe3bca51055ef4816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99648cd7215e49953150fdc0ff68c66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf99648cd7215e49953150fdc0ff68c66">regina::LightweightSequence&lt; T &gt;::begin</a> () const</td></tr>
<tr class="memdesc:gaf99648cd7215e49953150fdc0ff68c66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only iterator that points to the first element of the sequence.  <a href="group__utilities.html#gaf99648cd7215e49953150fdc0ff68c66">More...</a><br /></td></tr>
<tr class="separator:gaf99648cd7215e49953150fdc0ff68c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6e14b2d8fcd8affcb218dabe754f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaef6e14b2d8fcd8affcb218dabe754f34">regina::LightweightSequence&lt; T &gt;::end</a> ()</td></tr>
<tr class="memdesc:gaef6e14b2d8fcd8affcb218dabe754f34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write iterator that points beyond the last element of the sequence.  <a href="group__utilities.html#gaef6e14b2d8fcd8affcb218dabe754f34">More...</a><br /></td></tr>
<tr class="separator:gaef6e14b2d8fcd8affcb218dabe754f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850bb0bcdb1efcfcf12633f020415705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga850bb0bcdb1efcfcf12633f020415705">regina::LightweightSequence&lt; T &gt;::end</a> () const</td></tr>
<tr class="memdesc:ga850bb0bcdb1efcfcf12633f020415705"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only iterator that points beyond the last element of the sequence.  <a href="group__utilities.html#ga850bb0bcdb1efcfcf12633f020415705">More...</a><br /></td></tr>
<tr class="separator:ga850bb0bcdb1efcfcf12633f020415705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef621a4ecbf76f27ea2c318cfa7fd11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5ef621a4ecbf76f27ea2c318cfa7fd11">regina::LightweightSequence&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;src)</td></tr>
<tr class="memdesc:ga5ef621a4ecbf76f27ea2c318cfa7fd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a copy of the given sequence.  <a href="group__utilities.html#ga5ef621a4ecbf76f27ea2c318cfa7fd11">More...</a><br /></td></tr>
<tr class="separator:ga5ef621a4ecbf76f27ea2c318cfa7fd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66220529b527562478852bec0ac128fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga66220529b527562478852bec0ac128fe">regina::LightweightSequence&lt; T &gt;::operator=</a> (<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ga66220529b527562478852bec0ac128fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given sequence to this sequence.  <a href="group__utilities.html#ga66220529b527562478852bec0ac128fe">More...</a><br /></td></tr>
<tr class="separator:ga66220529b527562478852bec0ac128fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7de7f119637c244f3efd6cefd66af47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac7de7f119637c244f3efd6cefd66af47">regina::LightweightSequence&lt; T &gt;::operator==</a> (const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gac7de7f119637c244f3efd6cefd66af47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given sequence are identical.  <a href="group__utilities.html#gac7de7f119637c244f3efd6cefd66af47">More...</a><br /></td></tr>
<tr class="separator:gac7de7f119637c244f3efd6cefd66af47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5">regina::LightweightSequence&lt; T &gt;::operator&lt;</a> (const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this sequence is lexicographically smaller than the given sequence.  <a href="group__utilities.html#gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5">More...</a><br /></td></tr>
<tr class="separator:gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60001582a0bf23f144c9e9ffe2e05bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga60001582a0bf23f144c9e9ffe2e05bef">regina::LightweightSequence&lt; T &gt;::Less::operator()</a> (const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> *a, const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> *b) const</td></tr>
<tr class="memdesc:ga60001582a0bf23f144c9e9ffe2e05bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two sequences lexicographically.  <a href="group__utilities.html#ga60001582a0bf23f144c9e9ffe2e05bef">More...</a><br /></td></tr>
<tr class="separator:ga60001582a0bf23f144c9e9ffe2e05bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b72cf5b5d55192be402c2b2c6d2f08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac1b72cf5b5d55192be402c2b2c6d2f08">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::SubsequenceCompareFirstPtr</a> (size_t nSub, const size_t *sub)</td></tr>
<tr class="memdesc:gac1b72cf5b5d55192be402c2b2c6d2f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new function object.  <a href="group__utilities.html#gac1b72cf5b5d55192be402c2b2c6d2f08">More...</a><br /></td></tr>
<tr class="separator:gac1b72cf5b5d55192be402c2b2c6d2f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b0d171526768d7d0b0d057aa14cce8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga48b0d171526768d7d0b0d057aa14cce8">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::SubsequenceCompareFirstPtr</a> (const <a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt; &amp;)=default</td></tr>
<tr class="memdesc:ga48b0d171526768d7d0b0d057aa14cce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given function object into this new object.  <a href="group__utilities.html#ga48b0d171526768d7d0b0d057aa14cce8">More...</a><br /></td></tr>
<tr class="separator:ga48b0d171526768d7d0b0d057aa14cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1aae7216300e6fdf158023c0478c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabe1aae7216300e6fdf158023c0478c9e">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::operator=</a> (const <a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt; &amp;)=default</td></tr>
<tr class="memdesc:gabe1aae7216300e6fdf158023c0478c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given function object into this object.  <a href="group__utilities.html#gabe1aae7216300e6fdf158023c0478c9e">More...</a><br /></td></tr>
<tr class="separator:gabe1aae7216300e6fdf158023c0478c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5335b8572c4d5fca85375f0a5a864a18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5335b8572c4d5fca85375f0a5a864a18">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::equal</a> (Iterator a, Iterator b) const</td></tr>
<tr class="memdesc:ga5335b8572c4d5fca85375f0a5a864a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the subsequences referred to by the given pair of iterators are identical.  <a href="group__utilities.html#ga5335b8572c4d5fca85375f0a5a864a18">More...</a><br /></td></tr>
<tr class="separator:ga5335b8572c4d5fca85375f0a5a864a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ef7e3d0cd8b70a6567394b042cb474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga10ef7e3d0cd8b70a6567394b042cb474">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::less</a> (Iterator a, Iterator b) const</td></tr>
<tr class="memdesc:ga10ef7e3d0cd8b70a6567394b042cb474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the subsequences referred to by the given pair of iterators.  <a href="group__utilities.html#ga10ef7e3d0cd8b70a6567394b042cb474">More...</a><br /></td></tr>
<tr class="separator:ga10ef7e3d0cd8b70a6567394b042cb474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d9389cdcc39355ff1dc7cb679ff496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga32d9389cdcc39355ff1dc7cb679ff496">regina::LightweightSequence&lt; T &gt;::SubsequenceCompareFirstPtr&lt; Iterator &gt;::operator()</a> (Iterator a, Iterator b) const</td></tr>
<tr class="memdesc:ga32d9389cdcc39355ff1dc7cb679ff496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the subsequences referred to by the given pair of iterators.  <a href="group__utilities.html#ga32d9389cdcc39355ff1dc7cb679ff496">More...</a><br /></td></tr>
<tr class="separator:ga32d9389cdcc39355ff1dc7cb679ff496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:gaa0c5c9157147686a6bfc401312b8d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given sequence to the given output stream.  <a href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">More...</a><br /></td></tr>
<tr class="separator:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga69b2411865af18bf506a1afb7d2bc2ca">regina::duplicate</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new C string that is a duplicate of the given C++ string.  <a href="group__utilities.html#ga69b2411865af18bf506a1afb7d2bc2ca">More...</a><br /></td></tr>
<tr class="separator:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4056bad007750e92b40959aca2c4f987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">regina::startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga4056bad007750e92b40959aca2c4f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given C++ string begins with the given prefix.  <a href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">More...</a><br /></td></tr>
<tr class="separator:ga4056bad007750e92b40959aca2c4f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa678d35fabfebccce72406d01076829c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">regina::stripWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa678d35fabfebccce72406d01076829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all whitespace from the beginning and end of the given C++ string.  <a href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">More...</a><br /></td></tr>
<tr class="separator:gaa678d35fabfebccce72406d01076829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c2e62bf0908919834ea10762def19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">regina::valueOf</a> (const std::string &amp;str, int8_t &amp;dest)</td></tr>
<tr class="memdesc:gae40c2e62bf0908919834ea10762def19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">More...</a><br /></td></tr>
<tr class="separator:gae40c2e62bf0908919834ea10762def19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">regina::valueOf</a> (const std::string &amp;str, uint8_t &amp;dest)</td></tr>
<tr class="memdesc:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">More...</a><br /></td></tr>
<tr class="separator:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384de19626353085bf20eedc89c3c30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">regina::valueOf</a> (const std::string &amp;str, short &amp;dest)</td></tr>
<tr class="memdesc:ga384de19626353085bf20eedc89c3c30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">More...</a><br /></td></tr>
<tr class="separator:ga384de19626353085bf20eedc89c3c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183ba5dd849f33e9153c3363323abf5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">regina::valueOf</a> (const std::string &amp;str, unsigned short &amp;dest)</td></tr>
<tr class="memdesc:ga183ba5dd849f33e9153c3363323abf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">More...</a><br /></td></tr>
<tr class="separator:ga183ba5dd849f33e9153c3363323abf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">regina::valueOf</a> (const std::string &amp;str, int &amp;dest)</td></tr>
<tr class="memdesc:ga896ae2c6783d6d6dc4081bddabb22518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">More...</a><br /></td></tr>
<tr class="separator:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a77f98013a0274540b1d0b06519f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">regina::valueOf</a> (const std::string &amp;str, unsigned &amp;dest)</td></tr>
<tr class="memdesc:ga974a77f98013a0274540b1d0b06519f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">More...</a><br /></td></tr>
<tr class="separator:ga974a77f98013a0274540b1d0b06519f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">regina::valueOf</a> (const std::string &amp;str, long &amp;dest)</td></tr>
<tr class="memdesc:gaad0bb367f8c8f4172e6a979751907c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">More...</a><br /></td></tr>
<tr class="separator:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007abfa18426eedc6277f644ded3e068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">regina::valueOf</a> (const std::string &amp;str, unsigned long &amp;dest)</td></tr>
<tr class="memdesc:ga007abfa18426eedc6277f644ded3e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">More...</a><br /></td></tr>
<tr class="separator:ga007abfa18426eedc6277f644ded3e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5eebbe6059d16231b0e41966e2056a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">regina::valueOf</a> (const std::string &amp;str, long long &amp;dest)</td></tr>
<tr class="memdesc:gacd5eebbe6059d16231b0e41966e2056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">More...</a><br /></td></tr>
<tr class="separator:gacd5eebbe6059d16231b0e41966e2056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bc034686407302e3ad597e39933a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">regina::valueOf</a> (const std::string &amp;str, unsigned long long &amp;dest)</td></tr>
<tr class="memdesc:gad0bc034686407302e3ad597e39933a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">More...</a><br /></td></tr>
<tr class="separator:gad0bc034686407302e3ad597e39933a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;dest)</td></tr>
<tr class="memdesc:ga4c91417b8ffbca35aa32c82532f5330f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">More...</a><br /></td></tr>
<tr class="separator:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">regina::valueOf</a> (const std::string &amp;str, double &amp;dest)</td></tr>
<tr class="memdesc:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a double precision real number and reports whether this conversion was successful.  <a href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">More...</a><br /></td></tr>
<tr class="separator:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e706f7f722922798776b74f9933bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">regina::valueOf</a> (const std::string &amp;str, bool &amp;dest)</td></tr>
<tr class="memdesc:ga17e706f7f722922798776b74f9933bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a boolean and reports whether this conversion was successful.  <a href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">More...</a><br /></td></tr>
<tr class="separator:ga17e706f7f722922798776b74f9933bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;dest)</td></tr>
<tr class="memdesc:ga6083d66d2dcac7dce8637e6282c6c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a set of booleans and reports whether this conversion was successful.  <a href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">More...</a><br /></td></tr>
<tr class="separator:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">regina::basicTokenise</a> (OutputIterator results, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes the given string into tokens.  <a href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">More...</a><br /></td></tr>
<tr class="separator:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga36927634ca1155f6e5fb60b3ce8f2278">regina::stringToToken</a> (const char *str)</td></tr>
<tr class="memdesc:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="group__utilities.html#ga36927634ca1155f6e5fb60b3ce8f2278">More...</a><br /></td></tr>
<tr class="separator:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c74082b6559d30c0073ff0a889e09e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga80c74082b6559d30c0073ff0a889e09e">regina::stringToToken</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga80c74082b6559d30c0073ff0a889e09e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="group__utilities.html#ga80c74082b6559d30c0073ff0a889e09e">More...</a><br /></td></tr>
<tr class="separator:ga80c74082b6559d30c0073ff0a889e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">regina::superscript</a> (T value)</td></tr>
<tr class="memdesc:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode superscript string.  <a href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">More...</a><br /></td></tr>
<tr class="separator:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">regina::subscript</a> (T value)</td></tr>
<tr class="memdesc:ga61ea966075c340b411ef07cc5aee1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode subscript string.  <a href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">More...</a><br /></td></tr>
<tr class="separator:ga61ea966075c340b411ef07cc5aee1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34961eca24ca18e8bc5ae976e58d6a79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga34961eca24ca18e8bc5ae976e58d6a79">regina::TrieSet&lt; T &gt;::TrieSet</a> ()</td></tr>
<tr class="memdesc:ga34961eca24ca18e8bc5ae976e58d6a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty collection of sets.  <a href="group__utilities.html#ga34961eca24ca18e8bc5ae976e58d6a79">More...</a><br /></td></tr>
<tr class="separator:ga34961eca24ca18e8bc5ae976e58d6a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabb80bec38d52734b0215c625aa3ac7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafabb80bec38d52734b0215c625aa3ac7">regina::TrieSet&lt; T &gt;::~TrieSet</a> ()</td></tr>
<tr class="memdesc:gafabb80bec38d52734b0215c625aa3ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this collection of sets.  <a href="group__utilities.html#gafabb80bec38d52734b0215c625aa3ac7">More...</a><br /></td></tr>
<tr class="separator:gafabb80bec38d52734b0215c625aa3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b27f0f00ef8f19560f14cd7faf6caea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2b27f0f00ef8f19560f14cd7faf6caea">regina::TrieSet&lt; T &gt;::insert</a> (const T &amp;entry)</td></tr>
<tr class="memdesc:ga2b27f0f00ef8f19560f14cd7faf6caea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given set into this collection.  <a href="group__utilities.html#ga2b27f0f00ef8f19560f14cd7faf6caea">More...</a><br /></td></tr>
<tr class="separator:ga2b27f0f00ef8f19560f14cd7faf6caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58741f6c93aeede75d8bba526cff3ed1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga58741f6c93aeede75d8bba526cff3ed1">regina::TrieSet&lt; T &gt;::hasSubset</a> (const T &amp;superset, unsigned long universeSize) const</td></tr>
<tr class="memdesc:ga58741f6c93aeede75d8bba526cff3ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this collection of sets contains any subset of the argument <em>superset</em>.  <a href="group__utilities.html#ga58741f6c93aeede75d8bba526cff3ed1">More...</a><br /></td></tr>
<tr class="separator:ga58741f6c93aeede75d8bba526cff3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a63d4102262eda00159858a6839f96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1a63d4102262eda00159858a6839f96">regina::TrieSet&lt; T &gt;::hasExtraSuperset</a> (const T &amp;subset, const T &amp;exc1, const T &amp;exc2, unsigned long universeSize) const</td></tr>
<tr class="memdesc:gab1a63d4102262eda00159858a6839f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the particular superset search required by the double description method.  <a href="group__utilities.html#gab1a63d4102262eda00159858a6839f96">More...</a><br /></td></tr>
<tr class="separator:gab1a63d4102262eda00159858a6839f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09015d05dbbcb17b4fa06cb22b432d32"><td class="memItemLeft" align="right" valign="top"><a id="ga09015d05dbbcb17b4fa06cb22b432d32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TrieSet&lt; T &gt;::TrieSet</b> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;)=delete</td></tr>
<tr class="separator:ga09015d05dbbcb17b4fa06cb22b432d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5358f0d5595ca6064d3e0610db3d61"><td class="memItemLeft" align="right" valign="top"><a id="ga3e5358f0d5595ca6064d3e0610db3d61"></a>
<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TrieSet&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;)=delete</td></tr>
<tr class="separator:ga3e5358f0d5595ca6064d3e0610db3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52f7e27267a3df7f91b55b7d71befdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa52f7e27267a3df7f91b55b7d71befdc">regina::Tritmask1&lt; T &gt;::Tritmask1</a> ()</td></tr>
<tr class="memdesc:gaa52f7e27267a3df7f91b55b7d71befdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tritmask with all trits set to 0.  <a href="group__utilities.html#gaa52f7e27267a3df7f91b55b7d71befdc">More...</a><br /></td></tr>
<tr class="separator:gaa52f7e27267a3df7f91b55b7d71befdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a424cc6883e3a067259f1a11e12eee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga03a424cc6883e3a067259f1a11e12eee">regina::Tritmask1&lt; T &gt;::Tritmask1</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga03a424cc6883e3a067259f1a11e12eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given tritmask.  <a href="group__utilities.html#ga03a424cc6883e3a067259f1a11e12eee">More...</a><br /></td></tr>
<tr class="separator:ga03a424cc6883e3a067259f1a11e12eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e47968d69fb5ed044a631aa37953344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1e47968d69fb5ed044a631aa37953344">regina::Tritmask1&lt; T &gt;::reset</a> ()</td></tr>
<tr class="memdesc:ga1e47968d69fb5ed044a631aa37953344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all trits of this tritmask to 0.  <a href="group__utilities.html#ga1e47968d69fb5ed044a631aa37953344">More...</a><br /></td></tr>
<tr class="separator:ga1e47968d69fb5ed044a631aa37953344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a825ecda67bf32e02a60c589597f7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1a825ecda67bf32e02a60c589597f7b8">regina::Tritmask1&lt; T &gt;::operator=</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;other)=default</td></tr>
<tr class="memdesc:ga1a825ecda67bf32e02a60c589597f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this tritmask to a copy of the given tritmask.  <a href="group__utilities.html#ga1a825ecda67bf32e02a60c589597f7b8">More...</a><br /></td></tr>
<tr class="separator:ga1a825ecda67bf32e02a60c589597f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37aa9be2ad761002c3b0898d5fcaf10"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab37aa9be2ad761002c3b0898d5fcaf10">regina::Tritmask1&lt; T &gt;::get</a> (unsigned index) const</td></tr>
<tr class="memdesc:gab37aa9be2ad761002c3b0898d5fcaf10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given trit in this tritmask.  <a href="group__utilities.html#gab37aa9be2ad761002c3b0898d5fcaf10">More...</a><br /></td></tr>
<tr class="separator:gab37aa9be2ad761002c3b0898d5fcaf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac82c214a1041434f0614829b9700e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaac82c214a1041434f0614829b9700e54">regina::Tritmask1&lt; T &gt;::set</a> (unsigned index, char value)</td></tr>
<tr class="memdesc:gaac82c214a1041434f0614829b9700e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given trit of this tritmask to the given value.  <a href="group__utilities.html#gaac82c214a1041434f0614829b9700e54">More...</a><br /></td></tr>
<tr class="separator:gaac82c214a1041434f0614829b9700e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cde32c1e71bc9ad400df49384ffe077"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7cde32c1e71bc9ad400df49384ffe077">regina::Tritmask1&lt; T &gt;::empty</a> () const</td></tr>
<tr class="memdesc:ga7cde32c1e71bc9ad400df49384ffe077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains all zeroes.  <a href="group__utilities.html#ga7cde32c1e71bc9ad400df49384ffe077">More...</a><br /></td></tr>
<tr class="separator:ga7cde32c1e71bc9ad400df49384ffe077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd75976c00392a6e1b427ff1b84d323"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3cd75976c00392a6e1b427ff1b84d323">regina::Tritmask1&lt; T &gt;::nonEmpty</a> () const</td></tr>
<tr class="memdesc:ga3cd75976c00392a6e1b427ff1b84d323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains at least one non-zero trit.  <a href="group__utilities.html#ga3cd75976c00392a6e1b427ff1b84d323">More...</a><br /></td></tr>
<tr class="separator:ga3cd75976c00392a6e1b427ff1b84d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ebce0c5e651337d7ec3e4975057be3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga03ebce0c5e651337d7ec3e4975057be3">regina::Tritmask1&lt; T &gt;::has2</a> () const</td></tr>
<tr class="memdesc:ga03ebce0c5e651337d7ec3e4975057be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains at least one trit with value 2.  <a href="group__utilities.html#ga03ebce0c5e651337d7ec3e4975057be3">More...</a><br /></td></tr>
<tr class="separator:ga03ebce0c5e651337d7ec3e4975057be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68414895383f7281c7e9920f93958c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga68414895383f7281c7e9920f93958c68">regina::Tritmask1&lt; T &gt;::minWith</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga68414895383f7281c7e9920f93958c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the minimum of this and the given tritmask.  <a href="group__utilities.html#ga68414895383f7281c7e9920f93958c68">More...</a><br /></td></tr>
<tr class="separator:ga68414895383f7281c7e9920f93958c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cf8251c56569a34367b9150ca32e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac1cf8251c56569a34367b9150ca32e4c">regina::Tritmask1&lt; T &gt;::maxWith</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac1cf8251c56569a34367b9150ca32e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the maximum of this and the given tritmask.  <a href="group__utilities.html#gac1cf8251c56569a34367b9150ca32e4c">More...</a><br /></td></tr>
<tr class="separator:gac1cf8251c56569a34367b9150ca32e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148855f3f979b4db22243fc5424ce2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga148855f3f979b4db22243fc5424ce2c5">regina::Tritmask1&lt; T &gt;::operator+=</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga148855f3f979b4db22243fc5424ce2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the sum of this and the given tritmask.  <a href="group__utilities.html#ga148855f3f979b4db22243fc5424ce2c5">More...</a><br /></td></tr>
<tr class="separator:ga148855f3f979b4db22243fc5424ce2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfcceea1ad2fc07672e0dc6b370a1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9cfcceea1ad2fc07672e0dc6b370a1c1">regina::Tritmask1&lt; T &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9cfcceea1ad2fc07672e0dc6b370a1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the difference of this and the given tritmask.  <a href="group__utilities.html#ga9cfcceea1ad2fc07672e0dc6b370a1c1">More...</a><br /></td></tr>
<tr class="separator:ga9cfcceea1ad2fc07672e0dc6b370a1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf542e23b9628478215c030ef1bee2842"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf542e23b9628478215c030ef1bee2842">regina::Tritmask1&lt; T &gt;::operator==</a> (const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:gaf542e23b9628478215c030ef1bee2842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given tritmask are identical.  <a href="group__utilities.html#gaf542e23b9628478215c030ef1bee2842">More...</a><br /></td></tr>
<tr class="separator:gaf542e23b9628478215c030ef1bee2842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabf61c8a34e52f0aeb02f200c88026c1c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#gabf61c8a34e52f0aeb02f200c88026c1c">More...</a><br /></td></tr>
<tr class="separator:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8bdd5494f5996421b0ab818eeabaac6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad8bdd5494f5996421b0ab818eeabaac6">regina::Tritmask2&lt; T, U &gt;::Tritmask2</a> ()</td></tr>
<tr class="memdesc:gad8bdd5494f5996421b0ab818eeabaac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tritmask with all trits set to 0.  <a href="group__utilities.html#gad8bdd5494f5996421b0ab818eeabaac6">More...</a><br /></td></tr>
<tr class="separator:gad8bdd5494f5996421b0ab818eeabaac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68be020c472dda03a9cd1a3d76e9641f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga68be020c472dda03a9cd1a3d76e9641f">regina::Tritmask2&lt; T, U &gt;::Tritmask2</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga68be020c472dda03a9cd1a3d76e9641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given tritmask.  <a href="group__utilities.html#ga68be020c472dda03a9cd1a3d76e9641f">More...</a><br /></td></tr>
<tr class="separator:ga68be020c472dda03a9cd1a3d76e9641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173e9350258f3241cd021a5784650aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga173e9350258f3241cd021a5784650aee">regina::Tritmask2&lt; T, U &gt;::reset</a> ()</td></tr>
<tr class="memdesc:ga173e9350258f3241cd021a5784650aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all trits of this tritmask to 0.  <a href="group__utilities.html#ga173e9350258f3241cd021a5784650aee">More...</a><br /></td></tr>
<tr class="separator:ga173e9350258f3241cd021a5784650aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c42c114f2688fe001d1e19072375eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab7c42c114f2688fe001d1e19072375eb">regina::Tritmask2&lt; T, U &gt;::operator=</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;other)=default</td></tr>
<tr class="memdesc:gab7c42c114f2688fe001d1e19072375eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this tritmask to a copy of the given tritmask.  <a href="group__utilities.html#gab7c42c114f2688fe001d1e19072375eb">More...</a><br /></td></tr>
<tr class="separator:gab7c42c114f2688fe001d1e19072375eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b897fbac2d36a17ef98adc840b1497"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad6b897fbac2d36a17ef98adc840b1497">regina::Tritmask2&lt; T, U &gt;::get</a> (unsigned index) const</td></tr>
<tr class="memdesc:gad6b897fbac2d36a17ef98adc840b1497"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given trit in this tritmask.  <a href="group__utilities.html#gad6b897fbac2d36a17ef98adc840b1497">More...</a><br /></td></tr>
<tr class="separator:gad6b897fbac2d36a17ef98adc840b1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476e935f3340a3adbf227a74e7b661ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga476e935f3340a3adbf227a74e7b661ab">regina::Tritmask2&lt; T, U &gt;::set</a> (unsigned index, char value)</td></tr>
<tr class="memdesc:ga476e935f3340a3adbf227a74e7b661ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given trit of this tritmask to the given value.  <a href="group__utilities.html#ga476e935f3340a3adbf227a74e7b661ab">More...</a><br /></td></tr>
<tr class="separator:ga476e935f3340a3adbf227a74e7b661ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e364f04f69366ddd7c4ba3f0abb64a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4e364f04f69366ddd7c4ba3f0abb64a0">regina::Tritmask2&lt; T, U &gt;::empty</a> () const</td></tr>
<tr class="memdesc:ga4e364f04f69366ddd7c4ba3f0abb64a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains all zeroes.  <a href="group__utilities.html#ga4e364f04f69366ddd7c4ba3f0abb64a0">More...</a><br /></td></tr>
<tr class="separator:ga4e364f04f69366ddd7c4ba3f0abb64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ad333cdd8b242cabb3faa080a5cfe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab3ad333cdd8b242cabb3faa080a5cfe1">regina::Tritmask2&lt; T, U &gt;::nonEmpty</a> () const</td></tr>
<tr class="memdesc:gab3ad333cdd8b242cabb3faa080a5cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains at least one non-zero trit.  <a href="group__utilities.html#gab3ad333cdd8b242cabb3faa080a5cfe1">More...</a><br /></td></tr>
<tr class="separator:gab3ad333cdd8b242cabb3faa080a5cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e64640f308cb456871f73469c504fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa0e64640f308cb456871f73469c504fc">regina::Tritmask2&lt; T, U &gt;::has2</a> () const</td></tr>
<tr class="memdesc:gaa0e64640f308cb456871f73469c504fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this tritmask contains at least one trit with value 2.  <a href="group__utilities.html#gaa0e64640f308cb456871f73469c504fc">More...</a><br /></td></tr>
<tr class="separator:gaa0e64640f308cb456871f73469c504fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7cbf01093ee954fe1ffe54a61cc025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0d7cbf01093ee954fe1ffe54a61cc025">regina::Tritmask2&lt; T, U &gt;::minWith</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0d7cbf01093ee954fe1ffe54a61cc025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the minimum of this and the given tritmask.  <a href="group__utilities.html#ga0d7cbf01093ee954fe1ffe54a61cc025">More...</a><br /></td></tr>
<tr class="separator:ga0d7cbf01093ee954fe1ffe54a61cc025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6eac6f596dc2b3af1fe14d4037ec4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf6eac6f596dc2b3af1fe14d4037ec4b3">regina::Tritmask2&lt; T, U &gt;::maxWith</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6eac6f596dc2b3af1fe14d4037ec4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the maximum of this and the given tritmask.  <a href="group__utilities.html#gaf6eac6f596dc2b3af1fe14d4037ec4b3">More...</a><br /></td></tr>
<tr class="separator:gaf6eac6f596dc2b3af1fe14d4037ec4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6a9b5ba8db23a01f40b6570c5e0254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaed6a9b5ba8db23a01f40b6570c5e0254">regina::Tritmask2&lt; T, U &gt;::operator+=</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaed6a9b5ba8db23a01f40b6570c5e0254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the sum of this and the given tritmask.  <a href="group__utilities.html#gaed6a9b5ba8db23a01f40b6570c5e0254">More...</a><br /></td></tr>
<tr class="separator:gaed6a9b5ba8db23a01f40b6570c5e0254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d35733a6f1f56a2331ad5f56abd947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga00d35733a6f1f56a2331ad5f56abd947">regina::Tritmask2&lt; T, U &gt;::operator-=</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga00d35733a6f1f56a2331ad5f56abd947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the difference of this and the given tritmask.  <a href="group__utilities.html#ga00d35733a6f1f56a2331ad5f56abd947">More...</a><br /></td></tr>
<tr class="separator:ga00d35733a6f1f56a2331ad5f56abd947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4a52252baf6d21858a1a4f6e9bde44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaeb4a52252baf6d21858a1a4f6e9bde44">regina::Tritmask2&lt; T, U &gt;::operator==</a> (const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;other) const</td></tr>
<tr class="memdesc:gaeb4a52252baf6d21858a1a4f6e9bde44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given tritmask are identical.  <a href="group__utilities.html#gaeb4a52252baf6d21858a1a4f6e9bde44">More...</a><br /></td></tr>
<tr class="separator:gaeb4a52252baf6d21858a1a4f6e9bde44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac720197cc16b77f2647c6cfdeccd8038"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac720197cc16b77f2647c6cfdeccd8038"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac720197cc16b77f2647c6cfdeccd8038">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gac720197cc16b77f2647c6cfdeccd8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#gac720197cc16b77f2647c6cfdeccd8038">More...</a><br /></td></tr>
<tr class="separator:gac720197cc16b77f2647c6cfdeccd8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdab881c1ccc9043c8b18bb12d736d92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabdab881c1ccc9043c8b18bb12d736d92">regina::xml::XMLPropertyDict::XMLPropertyDict</a> ()</td></tr>
<tr class="memdesc:gabdab881c1ccc9043c8b18bb12d736d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new map.  <a href="group__utilities.html#gabdab881c1ccc9043c8b18bb12d736d92">More...</a><br /></td></tr>
<tr class="separator:gabdab881c1ccc9043c8b18bb12d736d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005e9231afb2aeb9c8bbebbef9e16755"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga005e9231afb2aeb9c8bbebbef9e16755">regina::xml::XMLPropertyDict::lookup</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:ga005e9231afb2aeb9c8bbebbef9e16755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a value for the given key, or the empty string if the key does not exist in the map.  <a href="group__utilities.html#ga005e9231afb2aeb9c8bbebbef9e16755">More...</a><br /></td></tr>
<tr class="separator:ga005e9231afb2aeb9c8bbebbef9e16755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64026ed904d4f3f45e85c45f56b97397"><td class="memItemLeft" align="right" valign="top"><a id="ga64026ed904d4f3f45e85c45f56b97397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::xml::XMLPropertyDict::XMLPropertyDict</b> (const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">XMLPropertyDict</a> &amp;)=delete</td></tr>
<tr class="separator:ga64026ed904d4f3f45e85c45f56b97397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad109c00db9d850b173339ff3a94dd7"><td class="memItemLeft" align="right" valign="top"><a id="gacad109c00db9d850b173339ff3a94dd7"></a>
<a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">XMLPropertyDict</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::xml::XMLPropertyDict::operator=</b> (const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">XMLPropertyDict</a> &amp;)=delete</td></tr>
<tr class="separator:gacad109c00db9d850b173339ff3a94dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d28f5acb7b66ca51fe934a86f0ef41d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4d28f5acb7b66ca51fe934a86f0ef41d">regina::xml::XMLParserCallback::~XMLParserCallback</a> ()</td></tr>
<tr class="memdesc:ga4d28f5acb7b66ca51fe934a86f0ef41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor that does nothing.  <a href="group__utilities.html#ga4d28f5acb7b66ca51fe934a86f0ef41d">More...</a><br /></td></tr>
<tr class="separator:ga4d28f5acb7b66ca51fe934a86f0ef41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ecc57214fe2a50cfeaf33583a1984e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae5ecc57214fe2a50cfeaf33583a1984e">regina::xml::XMLParserCallback::start_document</a> (<a class="el" href="classregina_1_1xml_1_1XMLParser.html">XMLParser</a> *parser)</td></tr>
<tr class="memdesc:gae5ecc57214fe2a50cfeaf33583a1984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the start of the document.  <a href="group__utilities.html#gae5ecc57214fe2a50cfeaf33583a1984e">More...</a><br /></td></tr>
<tr class="separator:gae5ecc57214fe2a50cfeaf33583a1984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5097dbe352cd85dda7594a7e30eccf77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5097dbe352cd85dda7594a7e30eccf77">regina::xml::XMLParserCallback::end_document</a> ()</td></tr>
<tr class="memdesc:ga5097dbe352cd85dda7594a7e30eccf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the document is finalised.  <a href="group__utilities.html#ga5097dbe352cd85dda7594a7e30eccf77">More...</a><br /></td></tr>
<tr class="separator:ga5097dbe352cd85dda7594a7e30eccf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae250b751104ecc561d807a5c5d93c747"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae250b751104ecc561d807a5c5d93c747">regina::xml::XMLParserCallback::start_element</a> (const std::string &amp;n, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;p)</td></tr>
<tr class="memdesc:gae250b751104ecc561d807a5c5d93c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an element's opening tag is encountered.  <a href="group__utilities.html#gae250b751104ecc561d807a5c5d93c747">More...</a><br /></td></tr>
<tr class="separator:gae250b751104ecc561d807a5c5d93c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a621c7a0bc9fefd819aa1d3218eff5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga03a621c7a0bc9fefd819aa1d3218eff5">regina::xml::XMLParserCallback::end_element</a> (const std::string &amp;n)</td></tr>
<tr class="memdesc:ga03a621c7a0bc9fefd819aa1d3218eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an element's closing tag is encountered.  <a href="group__utilities.html#ga03a621c7a0bc9fefd819aa1d3218eff5">More...</a><br /></td></tr>
<tr class="separator:ga03a621c7a0bc9fefd819aa1d3218eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a6903d78fe63595d54d4b957464a91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa7a6903d78fe63595d54d4b957464a91">regina::xml::XMLParserCallback::characters</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gaa7a6903d78fe63595d54d4b957464a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when characters are encountered.  <a href="group__utilities.html#gaa7a6903d78fe63595d54d4b957464a91">More...</a><br /></td></tr>
<tr class="separator:gaa7a6903d78fe63595d54d4b957464a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c161ec316c3f4a280ea6a27a61f944"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga43c161ec316c3f4a280ea6a27a61f944">regina::xml::XMLParserCallback::comment</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ga43c161ec316c3f4a280ea6a27a61f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a comment is encountered.  <a href="group__utilities.html#ga43c161ec316c3f4a280ea6a27a61f944">More...</a><br /></td></tr>
<tr class="separator:ga43c161ec316c3f4a280ea6a27a61f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a8a4c7ca859e0f72674d893d0af909"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab2a8a4c7ca859e0f72674d893d0af909">regina::xml::XMLParserCallback::warning</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gab2a8a4c7ca859e0f72674d893d0af909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a parser warning occurs.  <a href="group__utilities.html#gab2a8a4c7ca859e0f72674d893d0af909">More...</a><br /></td></tr>
<tr class="separator:gab2a8a4c7ca859e0f72674d893d0af909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72cadd81cd594321c1ac4f862cc75a53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga72cadd81cd594321c1ac4f862cc75a53">regina::xml::XMLParserCallback::error</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ga72cadd81cd594321c1ac4f862cc75a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a parser error occurs.  <a href="group__utilities.html#ga72cadd81cd594321c1ac4f862cc75a53">More...</a><br /></td></tr>
<tr class="separator:ga72cadd81cd594321c1ac4f862cc75a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc22b3ceefd76f93297557d011faa18f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadc22b3ceefd76f93297557d011faa18f">regina::xml::XMLParserCallback::fatal_error</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gadc22b3ceefd76f93297557d011faa18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a parser fatal error occurs.  <a href="group__utilities.html#gadc22b3ceefd76f93297557d011faa18f">More...</a><br /></td></tr>
<tr class="separator:gadc22b3ceefd76f93297557d011faa18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c433d55f1002dcda968f0d6a31cc280"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4c433d55f1002dcda968f0d6a31cc280">regina::xml::XMLParser::XMLParser</a> (<a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">XMLParserCallback</a> &amp;callback)</td></tr>
<tr class="memdesc:ga4c433d55f1002dcda968f0d6a31cc280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new XML parser.  <a href="group__utilities.html#ga4c433d55f1002dcda968f0d6a31cc280">More...</a><br /></td></tr>
<tr class="separator:ga4c433d55f1002dcda968f0d6a31cc280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0dcdc33eb1c49183f810542606ca36b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0dcdc33eb1c49183f810542606ca36b">regina::xml::XMLParser::~XMLParser</a> ()</td></tr>
<tr class="memdesc:gad0dcdc33eb1c49183f810542606ca36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this XML parser.  <a href="group__utilities.html#gad0dcdc33eb1c49183f810542606ca36b">More...</a><br /></td></tr>
<tr class="separator:gad0dcdc33eb1c49183f810542606ca36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab060d4e56a2a79ad6acbb1911e28ec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab060d4e56a2a79ad6acbb1911e28ec1b">regina::xml::XMLParser::parse_chunk</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gab060d4e56a2a79ad6acbb1911e28ec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given chunk of XML.  <a href="group__utilities.html#gab060d4e56a2a79ad6acbb1911e28ec1b">More...</a><br /></td></tr>
<tr class="separator:gab060d4e56a2a79ad6acbb1911e28ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdd6fdd37147d44dcf134d6a7187de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6bdd6fdd37147d44dcf134d6a7187de5">regina::xml::XMLParser::finish</a> ()</td></tr>
<tr class="memdesc:ga6bdd6fdd37147d44dcf134d6a7187de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that there are no more XML chunks to parse.  <a href="group__utilities.html#ga6bdd6fdd37147d44dcf134d6a7187de5">More...</a><br /></td></tr>
<tr class="separator:ga6bdd6fdd37147d44dcf134d6a7187de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6565a33c4a2fb6eec4da4b8810823de2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6565a33c4a2fb6eec4da4b8810823de2">regina::xml::XMLParser::parse_stream</a> (<a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">XMLParserCallback</a> &amp;callback, std::istream &amp;file, unsigned chunkSize=1024)</td></tr>
<tr class="memdesc:ga6565a33c4a2fb6eec4da4b8810823de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an entire XML file.  <a href="group__utilities.html#ga6565a33c4a2fb6eec4da4b8810823de2">More...</a><br /></td></tr>
<tr class="separator:ga6565a33c4a2fb6eec4da4b8810823de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b07302d9e85576867da1cc4b1b778c"><td class="memItemLeft" align="right" valign="top"><a id="ga06b07302d9e85576867da1cc4b1b778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::xml::XMLParser::XMLParser</b> (const <a class="el" href="classregina_1_1xml_1_1XMLParser.html">XMLParser</a> &amp;)=delete</td></tr>
<tr class="separator:ga06b07302d9e85576867da1cc4b1b778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae882fb0593061a0faa9451c1578114d"><td class="memItemLeft" align="right" valign="top"><a id="gaae882fb0593061a0faa9451c1578114d"></a>
<a class="el" href="classregina_1_1xml_1_1XMLParser.html">XMLParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::xml::XMLParser::operator=</b> (const <a class="el" href="classregina_1_1xml_1_1XMLParser.html">XMLParser</a> &amp;)=delete</td></tr>
<tr class="separator:gaae882fb0593061a0faa9451c1578114d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabae034cbea5ca43c01df1f5a1696b9f3">regina::xml::xmlString</a> (xmlChar *str, bool free=true)</td></tr>
<tr class="memdesc:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given string from libxml into a C++ string, optionally deallocating the original libxml string.  <a href="group__utilities.html#gabae034cbea5ca43c01df1f5a1696b9f3">More...</a><br /></td></tr>
<tr class="separator:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">regina::xml::xmlEncodeSpecialChars</a> (const std::string &amp;original)</td></tr>
<tr class="memdesc:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities.  <a href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">More...</a><br /></td></tr>
<tr class="separator:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">regina::xml::xmlEncodeComment</a> (const std::string &amp;comment)</td></tr>
<tr class="memdesc:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment.  <a href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">More...</a><br /></td></tr>
<tr class="separator:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">regina::xml::xmlValueTag</a> (const std::string &amp;tagName, const T &amp;value)</td></tr>
<tr class="memdesc:gacb9d9d42e182de0dc67e4176414cb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value.  <a href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">More...</a><br /></td></tr>
<tr class="separator:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac99098499b5705ba13a480097906deed"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac99098499b5705ba13a480097906deed">regina::BoolSet::sNone</a></td></tr>
<tr class="memdesc:gac99098499b5705ba13a480097906deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty set.  <a href="group__utilities.html#gac99098499b5705ba13a480097906deed">More...</a><br /></td></tr>
<tr class="separator:gac99098499b5705ba13a480097906deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c3e258454984543cc66505c595b23f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga08c3e258454984543cc66505c595b23f">regina::BoolSet::sTrue</a></td></tr>
<tr class="memdesc:ga08c3e258454984543cc66505c595b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set containing only <code>true</code>.  <a href="group__utilities.html#ga08c3e258454984543cc66505c595b23f">More...</a><br /></td></tr>
<tr class="separator:ga08c3e258454984543cc66505c595b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f5f340a17bee0edb7f75c807a3cede"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga83f5f340a17bee0edb7f75c807a3cede">regina::BoolSet::sFalse</a></td></tr>
<tr class="memdesc:ga83f5f340a17bee0edb7f75c807a3cede"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set containing only <code>false</code>.  <a href="group__utilities.html#ga83f5f340a17bee0edb7f75c807a3cede">More...</a><br /></td></tr>
<tr class="separator:ga83f5f340a17bee0edb7f75c807a3cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7954dfd3369b62b6e695dd4e2aaf7b60"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7954dfd3369b62b6e695dd4e2aaf7b60">regina::BoolSet::sBoth</a></td></tr>
<tr class="memdesc:ga7954dfd3369b62b6e695dd4e2aaf7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set containing both <code>true</code> and <code>false</code>.  <a href="group__utilities.html#ga7954dfd3369b62b6e695dd4e2aaf7b60">More...</a><br /></td></tr>
<tr class="separator:ga7954dfd3369b62b6e695dd4e2aaf7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6aa2148614e7ce75134e7dd2149577"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3e6aa2148614e7ce75134e7dd2149577">regina::StoreValue&lt; T &gt;::value_</a></td></tr>
<tr class="memdesc:ga3e6aa2148614e7ce75134e7dd2149577"><td class="mdescLeft">&#160;</td><td class="mdescRight">The held property value.  <a href="group__utilities.html#ga3e6aa2148614e7ce75134e7dd2149577">More...</a><br /></td></tr>
<tr class="separator:ga3e6aa2148614e7ce75134e7dd2149577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1976534fd988695c6b6f6a4df726bf8"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae1976534fd988695c6b6f6a4df726bf8">regina::StoreConstPtr&lt; T &gt;::value_</a></td></tr>
<tr class="memdesc:gae1976534fd988695c6b6f6a4df726bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The held property value.  <a href="group__utilities.html#gae1976534fd988695c6b6f6a4df726bf8">More...</a><br /></td></tr>
<tr class="separator:gae1976534fd988695c6b6f6a4df726bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400e17c8cd860a90dfb0c5c9c2721edf"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga400e17c8cd860a90dfb0c5c9c2721edf">regina::StoreManagedPtr&lt; T &gt;::value_</a></td></tr>
<tr class="memdesc:ga400e17c8cd860a90dfb0c5c9c2721edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The held property value.  <a href="group__utilities.html#ga400e17c8cd860a90dfb0c5c9c2721edf">More...</a><br /></td></tr>
<tr class="separator:ga400e17c8cd860a90dfb0c5c9c2721edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga6b96c3d5421b076c7f20f34d339e8de1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b96c3d5421b076c7f20f34d339e8de1"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6b96c3d5421b076c7f20f34d339e8de1">regina::MarkedElement::MarkedVector</a></td></tr>
<tr class="memdesc:ga6b96c3d5421b076c7f20f34d339e8de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow only <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a> to edit the array index.  <a href="group__utilities.html#ga6b96c3d5421b076c7f20f34d339e8de1">More...</a><br /></td></tr>
<tr class="separator:ga6b96c3d5421b076c7f20f34d339e8de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac563c7e61d7f0465d4b656dcd7afe337"><td class="memTemplParams" colspan="2"><a id="gac563c7e61d7f0465d4b656dcd7afe337"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:gac563c7e61d7f0465d4b656dcd7afe337"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::SafePtr</b></td></tr>
<tr class="separator:gac563c7e61d7f0465d4b656dcd7afe337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a48856e7eb35fdde956d27063dd67b9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7a48856e7eb35fdde956d27063dd67b9">regina::Bitmask::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:ga7a48856e7eb35fdde956d27063dd67b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga7a48856e7eb35fdde956d27063dd67b9">More...</a><br /></td></tr>
<tr class="separator:ga7a48856e7eb35fdde956d27063dd67b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e189f4f289c74e659b4b0d90816e31"><td class="memItemLeft" align="right" valign="top"><a id="gad1e189f4f289c74e659b4b0d90816e31"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Bitmask1&lt; T &gt;::operator</b> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="separator:gad1e189f4f289c74e659b4b0d90816e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae2e73f0c241bd90214bff12bbbaca0"><td class="memItemLeft" align="right" valign="top"><a id="ga2ae2e73f0c241bd90214bff12bbbaca0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Bitmask2&lt; T, U &gt;::operator</b> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="separator:ga2ae2e73f0c241bd90214bff12bbbaca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3071bbc2b5d2fe0cbdb8e0635cff5525"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3071bbc2b5d2fe0cbdb8e0635cff5525">regina::BoolSet::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;set)</td></tr>
<tr class="memdesc:ga3071bbc2b5d2fe0cbdb8e0635cff5525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="group__utilities.html#ga3071bbc2b5d2fe0cbdb8e0635cff5525">More...</a><br /></td></tr>
<tr class="separator:ga3071bbc2b5d2fe0cbdb8e0635cff5525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf627606b5105239077b53634041b6b"><td class="memItemLeft" align="right" valign="top"><a id="ga8bf627606b5105239077b53634041b6b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Qitmask1&lt; T &gt;::operator</b> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="separator:ga8bf627606b5105239077b53634041b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0cc525e6cfd5b98ae9f03aaed70f98"><td class="memItemLeft" align="right" valign="top"><a id="gaec0cc525e6cfd5b98ae9f03aaed70f98"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Qitmask2&lt; T, U &gt;::operator</b> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="separator:gaec0cc525e6cfd5b98ae9f03aaed70f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9817604f20df72ec2c21a0003fc16147"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9817604f20df72ec2c21a0003fc16147">regina::Tritmask1&lt; T &gt;::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga9817604f20df72ec2c21a0003fc16147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#ga9817604f20df72ec2c21a0003fc16147">More...</a><br /></td></tr>
<tr class="separator:ga9817604f20df72ec2c21a0003fc16147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5eafba387135f9a7a7c529b2b622d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4c5eafba387135f9a7a7c529b2b622d2">regina::Tritmask2&lt; T, U &gt;::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga4c5eafba387135f9a7a7c529b2b622d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#ga4c5eafba387135f9a7a7c529b2b622d2">More...</a><br /></td></tr>
<tr class="separator:ga4c5eafba387135f9a7a7c529b2b622d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous helper classes and functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5ffec6ccec6eaaf2e875fd1533a50c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffec6ccec6eaaf2e875fd1533a50c05">&#9670;&nbsp;</a></span>INT128_AVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT128_AVAILABLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined if and only if native 128-bit arithmetic is available on this platform. </p>
<p>If this macro is defined, then you can access native signed and unsigned 128-bit integers through the types IntOfSize&lt;16&gt;::type and IntOfSize&lt;16&gt;::utype respectively.</p>
<p>If this macro is not defined, then the types IntOfSize&lt;16&gt;::type and IntOfSize&lt;16&gt;::utype will both be <code>void</code>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab5a9eae5d19a0251b4c8eca0cc1fdcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a9eae5d19a0251b4c8eca0cc1fdcef">&#9670;&nbsp;</a></span>argument_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gab5a9eae5d19a0251b4c8eca0cc1fdcef">argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument type for this unary function. </p>

</div>
</div>
<a id="ga7e0d77a56c39300bfd5cd4e803395d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0d77a56c39300bfd5cd4e803395d18">&#9670;&nbsp;</a></span>argument_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga7e0d77a56c39300bfd5cd4e803395d18">argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument type for this unary function. </p>

</div>
</div>
<a id="ga18b5f37135fc402ae122d093f64ad884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b5f37135fc402ae122d093f64ad884">&#9670;&nbsp;</a></span>argument_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga18b5f37135fc402ae122d093f64ad884">argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument type for this unary function. </p>

</div>
</div>
<a id="gacdc26f1f39beac07c5e4e250facde232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc26f1f39beac07c5e4e250facde232">&#9670;&nbsp;</a></span>argument_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gacdc26f1f39beac07c5e4e250facde232">argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument type for this unary function. </p>

</div>
</div>
<a id="ga79171eb0dd3165e733ca97b8240b861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79171eb0dd3165e733ca97b8240b861b">&#9670;&nbsp;</a></span>BitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">regina::BitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gadb60aab55cbe801e14a1654bccbeee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb60aab55cbe801e14a1654bccbeee20">&#9670;&nbsp;</a></span>BitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen32 ::Type <a class="el" href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">regina::BitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gaecadfef5ba587ad7030165a79b277ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecadfef5ba587ad7030165a79b277ec5">&#9670;&nbsp;</a></span>BitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen64 ::Type <a class="el" href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">regina::BitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or the template class <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga29eb3c97f12b01fc84bb5edfdcb9a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29eb3c97f12b01fc84bb5edfdcb9a09d">&#9670;&nbsp;</a></span>BitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">regina::BitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga68708a91988e06ed2df5adcc22539144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68708a91988e06ed2df5adcc22539144">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator type for read-only access to the elements of a sequence. </p>
<p>Such a type can be dereferenced (yielding a const reference to type <em>T</em>), and manipulated using the usual pointer arithmetic (such as <code>p++</code>, <code>&ndash;p</code>, <code>p += n</code>, and so on). </p>

</div>
</div>
<a id="gaabac6c7ebbdfadab22b74bca62c900e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabac6c7ebbdfadab22b74bca62c900e5">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gaabac6c7ebbdfadab22b74bca62c900e5">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pointee type. </p>
<p>This typedef is used by the pybind11 infrastructure. </p>

</div>
</div>
<a id="gabbdf90e8b84a918ef0de50ec862110ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbdf90e8b84a918ef0de50ec862110ad">&#9670;&nbsp;</a></span>Enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gabbdf90e8b84a918ef0de50ec862110ad">Enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying enumeration type. </p>

</div>
</div>
<a id="gab149c9840796655df2fc505478fe770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab149c9840796655df2fc505478fe770c">&#9670;&nbsp;</a></span>first_argument_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref</a>&lt; T, Comp &gt;::<a class="el" href="group__utilities.html#gab149c9840796655df2fc505478fe770c">first_argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first argument type for this binary function. </p>

</div>
</div>
<a id="ga949767b095cf660d16478a14b5628541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949767b095cf660d16478a14b5628541">&#9670;&nbsp;</a></span>InitType <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga949767b095cf660d16478a14b5628541">InitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which new values for the underlying property are passed. </p>

</div>
</div>
<a id="gab04c3e6e45f55dd362dd3f12d1d6d437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab04c3e6e45f55dd362dd3f12d1d6d437">&#9670;&nbsp;</a></span>InitType <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gab04c3e6e45f55dd362dd3f12d1d6d437">InitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which new values for the underlying property are passed. </p>

</div>
</div>
<a id="gaf6fa06368747d8c9860bc759c74bb982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6fa06368747d8c9860bc759c74bb982">&#9670;&nbsp;</a></span>InitType <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gaf6fa06368747d8c9860bc759c74bb982">InitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which new values for the underlying property are passed. </p>

</div>
</div>
<a id="gac26d3f924e8799504cad495bd1705e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26d3f924e8799504cad495bd1705e6e">&#9670;&nbsp;</a></span>InitType <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Storage&lt;T&gt;::<a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">InitType</a> <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::<a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">InitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which new values for the underlying property are passed. </p>

</div>
</div>
<a id="gad5c59ac14b7b95cee666f39804fa1580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c59ac14b7b95cee666f39804fa1580">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;const T*&gt;::const_iterator <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator over this list. </p>
<p>This operates as a forward iterator in a manner consistent with the standard C++ library. It does not allow either the list or its individual objects to be changed. </p>

</div>
</div>
<a id="ga11786e34be796e7fd8ce05884be77a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11786e34be796e7fd8ce05884be77a39">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator type for read-write access to the elements of a sequence. </p>
<p>Such a type can be dereferenced (yielding a reference to type <em>T</em>), and manipulated using the usual pointer arithmetic (such as <code>p++</code>, <code>&ndash;p</code>, <code>p += n</code>, and so on). </p>

</div>
</div>
<a id="gaa647c98d25c28ffc52757c31bfc3eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa647c98d25c28ffc52757c31bfc3eee6">&#9670;&nbsp;</a></span>NBoolSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> <a class="el" href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">regina::NBoolSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000232">Deprecated:</a></b></dt><dd>The class NBoolSet has now been renamed to <a class="el" href="classregina_1_1BoolSet.html" title="A set of booleans.">BoolSet</a>. </dd></dl>

</div>
</div>
<a id="gaa396173f6b9d24d6e5f0412386813651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa396173f6b9d24d6e5f0412386813651">&#9670;&nbsp;</a></span>QitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">regina::QitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga2db96e54efcf3eda083368b3cc77abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db96e54efcf3eda083368b3cc77abd3">&#9670;&nbsp;</a></span>QitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen32 ::Type <a class="el" href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">regina::QitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gaf4b4c70291965332b28e1891b86ea054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b4c70291965332b28e1891b86ea054">&#9670;&nbsp;</a></span>QitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen64 ::Type <a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">regina::QitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a> or the template class <a class="el" href="classregina_1_1Qitmask2.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U) ...">Qitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga99bc959ede9feeded32f0e82d889287b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99bc959ede9feeded32f0e82d889287b">&#9670;&nbsp;</a></span>QitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">regina::QitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga95455eccee62a6658b0485202ed4ff44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95455eccee62a6658b0485202ed4ff44">&#9670;&nbsp;</a></span>QueryType <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which the property value is returned to the user. </p>

</div>
</div>
<a id="ga357adaaf14f89d15b68b2b33b7e86dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga357adaaf14f89d15b68b2b33b7e86dde">&#9670;&nbsp;</a></span>QueryType <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga357adaaf14f89d15b68b2b33b7e86dde">QueryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which the property value is returned to the user. </p>

</div>
</div>
<a id="gacd358ef4b5e49466a472abe7d9e8a6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd358ef4b5e49466a472abe7d9e8a6b0">&#9670;&nbsp;</a></span>QueryType <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gacd358ef4b5e49466a472abe7d9e8a6b0">QueryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which the property value is returned to the user. </p>

</div>
</div>
<a id="ga50c7adbd6c3f9e75585c48d6d27b46c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50c7adbd6c3f9e75585c48d6d27b46c8">&#9670;&nbsp;</a></span>QueryType <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Storage&lt;T&gt;::<a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a> <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::<a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type by which the property value is returned to the user. </p>

</div>
</div>
<a id="ga245bb7f4aa8ace4704fdd054299dacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245bb7f4aa8ace4704fdd054299dacfd">&#9670;&nbsp;</a></span>result_type <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structregina_1_1FuncNew.html">regina::FuncNew</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga245bb7f4aa8ace4704fdd054299dacfd">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for this generator. </p>

</div>
</div>
<a id="ga6ffdeb10aece6ad482049b9b19bf12ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ffdeb10aece6ad482049b9b19bf12ee">&#9670;&nbsp;</a></span>result_type <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga6ffdeb10aece6ad482049b9b19bf12ee">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for this unary function. </p>

</div>
</div>
<a id="ga5d3e32dac13bd0df45d847ae9f8fbc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3e32dac13bd0df45d847ae9f8fbc44">&#9670;&nbsp;</a></span>result_type <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga5d3e32dac13bd0df45d847ae9f8fbc44">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for this unary function. </p>

</div>
</div>
<a id="gaffae5f2da82f58de4f8579a2d0e429a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffae5f2da82f58de4f8579a2d0e429a7">&#9670;&nbsp;</a></span>result_type <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gaffae5f2da82f58de4f8579a2d0e429a7">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for this unary function. </p>

</div>
</div>
<a id="gaa120de9d57db06de9469ad0b8a2367f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa120de9d57db06de9469ad0b8a2367f6">&#9670;&nbsp;</a></span>result_type <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete</a>&lt; T &gt;::<a class="el" href="group__utilities.html#gaa120de9d57db06de9469ad0b8a2367f6">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for this unary function. </p>

</div>
</div>
<a id="ga7fd454858edeb97f9ca41375e6437ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd454858edeb97f9ca41375e6437ec9">&#9670;&nbsp;</a></span>result_type <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref</a>&lt; T, Comp &gt;::<a class="el" href="group__utilities.html#ga7fd454858edeb97f9ca41375e6437ec9">result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result type for this binary comparison function. </p>

</div>
</div>
<a id="ga51ba10ae389fb70970ed50bd88cd834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ba10ae389fb70970ed50bd88cd834e">&#9670;&nbsp;</a></span>ReturnType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ReturnType_ <a class="el" href="structregina_1_1Returns.html">regina::Returns</a>&lt; ReturnType_ &gt;::<a class="el" href="group__utilities.html#ga51ba10ae389fb70970ed50bd88cd834e">ReturnType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the return type for a function object. </p>

</div>
</div>
<a id="ga2e4bacf91fc79a12ae3a02f4339ed034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4bacf91fc79a12ae3a02f4339ed034">&#9670;&nbsp;</a></span>SafePointeeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<a id="ga03becf53f1db5854d6d40087902e4bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03becf53f1db5854d6d40087902e4bae">&#9670;&nbsp;</a></span>second_argument_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref</a>&lt; T, Comp &gt;::<a class="el" href="group__utilities.html#ga03becf53f1db5854d6d40087902e4bae">second_argument_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The second argument type for this binary function. </p>

</div>
</div>
<a id="ga4a71a872e94df27800252dbd7a105758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a71a872e94df27800252dbd7a105758">&#9670;&nbsp;</a></span>TritmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">regina::TritmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gae8ecc460b8fec9c1630a0830e57469eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8ecc460b8fec9c1630a0830e57469eb">&#9670;&nbsp;</a></span>TritmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen32 ::Type <a class="el" href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">regina::TritmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">&#9670;&nbsp;</a></span>TritmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen64 ::Type <a class="el" href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">regina::TritmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a> or the template class <a class="el" href="classregina_1_1Tritmask2.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U)...">Tritmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">&#9670;&nbsp;</a></span>TritmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">regina::TritmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga15e439042b321fb0e4acd637f142e673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15e439042b321fb0e4acd637f142e673">&#9670;&nbsp;</a></span>type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize</a>&lt; bytes &gt;::<a class="el" href="group__utilities.html#ga15e439042b321fb0e4acd637f142e673">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native signed integer type with exactly <em>k</em> bytes, where <em>k</em> is the template parameter. </p>
<p>The default is <code>void</code>, which indicates that Regina does not know how to access an integer type of the requested size. </p>

</div>
</div>
<a id="ga6be809f5e841c27471510295afe33413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6be809f5e841c27471510295afe33413">&#9670;&nbsp;</a></span>type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1IntOfSize.html">IntOfSize</a>&lt;<a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">nextPowerOfTwo</a>(bytes)&gt;::<a class="el" href="group__utilities.html#ga6be809f5e841c27471510295afe33413">type</a> <a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize</a>&lt; bytes &gt;::<a class="el" href="group__utilities.html#ga6be809f5e841c27471510295afe33413">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native signed integer type with at least <em>k</em> bytes, where <em>k</em> is the template parameter. </p>
<p>The default is <code>void</code>, which indicates that Regina does not know how to access an integer type of the requested size. </p>

</div>
</div>
<a id="gaec6a3a2fd5eff7865bf401918d3399d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec6a3a2fd5eff7865bf401918d3399d0">&#9670;&nbsp;</a></span>utype <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize</a>&lt; bytes &gt;::<a class="el" href="group__utilities.html#gaec6a3a2fd5eff7865bf401918d3399d0">utype</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native unsigned integer type with exactly <em>k</em> bytes, where <em>k</em> is the template parameter. </p>
<p>The default is <code>void</code>, which indicates that Regina does not know how to access an integer type of the requested size. </p>

</div>
</div>
<a id="ga65305efb63d2daed6a8ce2e64c335163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65305efb63d2daed6a8ce2e64c335163">&#9670;&nbsp;</a></span>utype <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1IntOfSize.html">IntOfSize</a>&lt;<a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">nextPowerOfTwo</a>(bytes)&gt;::<a class="el" href="group__utilities.html#ga65305efb63d2daed6a8ce2e64c335163">utype</a> <a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize</a>&lt; bytes &gt;::<a class="el" href="group__utilities.html#ga65305efb63d2daed6a8ce2e64c335163">utype</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native unsigned integer type with at least <em>k</em> bytes, where <em>k</em> is the template parameter. </p>
<p>The default is <code>void</code>, which indicates that Regina does not know how to access an integer type of the requested size. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga27f3e545612357418930ee76b3307e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27f3e545612357418930ee76b3307e59">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga27f3e545612357418930ee76b3307e59a1f4670f6ee69e8a856f663b5c77ab240"></a>value&#160;</td><td class="fielddoc"><p>Evaluates to non-zero (true) or zero (false) according to whether or not the type <code>T::ReturnType</code> exists. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga47e47aeb6aa562479893b2ba9fde8f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e47aeb6aa562479893b2ba9fde8f86">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga47e47aeb6aa562479893b2ba9fde8f86a101af964ef1d282fe693f4eec55e8ca0"></a>specialised&#160;</td><td class="fielddoc"><p>Indicates whether this class is a template specialisation of <a class="el" href="classregina_1_1BitManipulatorByType.html" title="Contains implementation details for BitManipulator where we optimise according to the underlying data...">BitManipulatorByType</a> with extra optimisations. </p>
<p>This compile-time constant is set to 0 for the generic implementation of <a class="el" href="classregina_1_1BitManipulatorByType.html" title="Contains implementation details for BitManipulator where we optimise according to the underlying data...">BitManipulatorByType</a>, and 1 for all specialisations. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaff5c7360ed9a884b5a4b823e0bc11d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5c7360ed9a884b5a4b823e0bc11d57">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned size = sizeof(T)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaff5c7360ed9a884b5a4b823e0bc11d57ac4b50a31e844760e76735baf17df0370"></a>specialised&#160;</td><td class="fielddoc"><p>Indicates whether this class is a template specialisation of <a class="el" href="classregina_1_1BitManipulatorBySize.html" title="Contains implementation details for BitManipulator where we optimise according to the size of the und...">BitManipulatorBySize</a> with extra optimisations. </p>
<p>This compile-time constant is set to 0 for the generic implementation of <a class="el" href="classregina_1_1BitManipulatorBySize.html" title="Contains implementation details for BitManipulator where we optimise according to the size of the und...">BitManipulatorBySize</a>, and 1 for all specialisations. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga649e1316a2542f8f49fc0a77aebf0211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga649e1316a2542f8f49fc0a77aebf0211">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga649e1316a2542f8f49fc0a77aebf0211af42cc480009a85742799aa5e84410a37"></a>specialised&#160;</td><td class="fielddoc"><p>Indicates whether this class is a template specialisation of <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> with extra optimisations. </p>
<p>This compile-time constant is set to 0 for the generic implementation of <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a>, and 1 for all specialisations. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab27bcf5826fd27775a1c2198e7e4e76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab27bcf5826fd27775a1c2198e7e4e76e">&#9670;&nbsp;</a></span>atMostOneBit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::atMostOneBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether at most one bit is set to <code>true</code> in this bitmask. </p>
<p>If this bitmask is entirely <code>false</code> or if only one bit is set to <code>true</code>, then this routine will return <code>true</code>. Otherwise this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if at most one bit is set to <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga22b9a3962337e0da8287ac15c972240e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22b9a3962337e0da8287ac15c972240e">&#9670;&nbsp;</a></span>atMostOneBit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::atMostOneBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether at most one bit is set to <code>true</code> in this bitmask. </p>
<p>If this bitmask is entirely <code>false</code> or if only one bit is set to <code>true</code>, then this routine will return <code>true</code>. Otherwise this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if at most one bit is set to <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e5e1cc3ae0e8a3d5fcaa97ccd72eb8">&#9670;&nbsp;</a></span>atMostOneBit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::atMostOneBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether at most one bit is set to <code>true</code> in this bitmask. </p>
<p>If this bitmask is entirely <code>false</code> or if only one bit is set to <code>true</code>, then this routine will return <code>true</code>. Otherwise this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if at most one bit is set to <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga47d6c710ee070d88c4b670b48bec3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d6c710ee070d88c4b670b48bec3878">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, and <em>outlen</em> will be set to the number of raw bytes in this output array. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found or the output buffer is exhausted, this routine will return <code>false</code>, set <em>out</em> to <code>null</code>, and leave <em>outlen</em> undefined. Otherwise (on success) it will return <code>true</code> and set <em>outlen</em> to the total number of output bytes.</p>
<p>If the user is not interested in the length of the output array, a null pointer may be passed in the <em>outlen</em> argument. Note however that the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of raw bytes (or which will be set to <code>null</code> on failure). </td></tr>
    <tr><td class="paramname">outlen</td><td>the address of an integer which will be set to the length of the output array (or which will be left undefined on failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if an unexpected input character was found or some other error occurred.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga6811ec511cb61bfc071467ba5d0e8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6811ec511cb61bfc071467ba5d0e8076">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer. </p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found, or the output buffer is exhausted, this routine will write as many output bytes as it can and then return <code>false</code>. Otherwise (on success) it will return <code>true</code>. Either way, it will reset <em>outlen</em> to the total number of bytes that were written.</p>
<p>The total number of output bytes is important to know, since the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting raw bytes will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>must contain the length of the output buffer on entry, and on exit contains the number of output bytes that were successfully written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if the output buffer was exhausted or an unexpected input character was found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga541f612d6bb0f94db16da14169813e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541f612d6bb0f94db16da14169813e29">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, which will be null-terminated. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>If the output array is too large (in particular, the expected size will overflow a <code>size_t</code>), the <em>out</em> pointer will be set to <code>null</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of base64 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output array, not counting the terminating null.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga081d322bec8070a889aba14d5988ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081d322bec8070a889aba14d5988ae80">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer. </p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If the number of base64 characters required is less than <em>outlen</em>, a terminating <code>null</code> will be written to the end of the output sequence. If the number of base64 characters is <em>outlen</em> or greater, this routine will output as many base64 characters as possible, up to a maximum of <em>outlen</em>.</p>
<p>The routine <a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2" title="Returns the number of base64 characters required to encode the given number of bytes.">base64Length()</a> can be used to precalculate precisely how many output characters will be required.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting base64 characters will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>the length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="gaa8d632b73943b5c52e395d56f8e03af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d632b73943b5c52e395d56f8e03af2">&#9670;&nbsp;</a></span>base64Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes. </p>
<p>This is the number of characters used (excluding the null terminator) by the routine <a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29" title="Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing...">base64Encode(const char*, size_t, char**)</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the number of raw input bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding number of base64 printable output characters. </dd></dl>

</div>
</div>
<a id="ga032b26a588e2bdbcc5a74e05f8c37fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032b26a588e2bdbcc5a74e05f8c37fa9">&#9670;&nbsp;</a></span>basicTokenise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the given string into tokens. </p>
<p>This is an extremely simple tokeniser; tokens are defined to be separated by whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting tokens will be written; this must accept objects of type <code>const std::string&amp;</code>. </td></tr>
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tokens found. </dd></dl>

</div>
</div>
<a id="gabc0ebb883a3c9fbe3bca51055ef4816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0ebb883a3c9fbe3bca51055ef4816f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">iterator</a> <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write iterator that points to the first element of the sequence. </p>
<p>Note that an iterator is simply a pointer to an element of the sequence, and so by dereferencing an iterator you can change the corresponding element of the sequence directly.</p>
<dl class="section return"><dt>Returns</dt><dd>a read-write begin iterator. </dd></dl>

</div>
</div>
<a id="ga76a2f4f57b37f515e433b039ce2257bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76a2f4f57b37f515e433b039ce2257bb">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">iterator</a> <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first item in this list. </p>
<p>If the list has not yet been filled with items, this will take place now. Thus the first call to <a class="el" href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb" title="Returns an iterator pointing to the first item in this list.">begin()</a> will be expensive, but subsequent calls will be extremely cheap.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first item. </dd></dl>

</div>
</div>
<a id="gaf99648cd7215e49953150fdc0ff68c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf99648cd7215e49953150fdc0ff68c66">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">const_iterator</a> <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only iterator that points to the first element of the sequence. </p>
<p>Note that a const_iterator is simply a const pointer to an element of the sequence, and so by dereferencing a const_iterator you can access (but not change) the corresponding element of the sequence.</p>
<dl class="section return"><dt>Returns</dt><dd>a read-only begin iterator. </dd></dl>

</div>
</div>
<a id="ga63b3974553c4c68a861724592166a4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63b3974553c4c68a861724592166a4c8">&#9670;&nbsp;</a></span>Bitmask() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new invalid bitmask. </p>
<p>You must call the one-argument <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or use the assignment operator to give the bitmask a length before it can be used.</p>
<p>Use of this default constructor is discouraged. The only reason it exists is to support arrays and containers of bitmasks, where the bitmasks must be created in bulk and then individually assigned lengths.</p>
<dl class="section warning"><dt>Warning</dt><dd>No other routines can be used with this bitmask until it has been assigned a length via <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or the assignment operator. As the single exception, the class destructor is safe to use even if a bitmask has never been initialised. </dd></dl>

</div>
</div>
<a id="ga3a14612fe9264e5bbb9eb18f959ef2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a14612fe9264e5bbb9eb18f959ef2af">&#9670;&nbsp;</a></span>Bitmask() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given bitmask. </p>
<p>It is fine if the given bitmask is invalid (but in this case, the new bitmask will be invalid also). Invalid bitmasks must be assigned a length using <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or the assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a36a6f40f432a9c1f6e47590f191229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a36a6f40f432a9c1f6e47590f191229">&#9670;&nbsp;</a></span>Bitmask() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask of the given length with all bits set to <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of bits stored in this bitmask; this must be at least one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2029c46c96683d6a388b38e8b4b0f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2029c46c96683d6a388b38e8b4b0f9b">&#9670;&nbsp;</a></span>Bitmask1() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask with all bits set to <code>false</code>. </p>

</div>
</div>
<a id="ga44d7c8ece764a44d65b2051dae53ad08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d7c8ece764a44d65b2051dae53ad08">&#9670;&nbsp;</a></span>Bitmask1() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0d4be245982ab9bf1162383d3a1296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d4be245982ab9bf1162383d3a1296a">&#9670;&nbsp;</a></span>Bitmask1() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask with all bits set to <code>false</code>. </p>
<p>The integer argument is merely for compatibility with the <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a> constructor, and will be ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> a constructor that initialises the bitmask to a given pattern. </dd></dl>

</div>
</div>
<a id="ga50822529ad6099ef6b57b98fb9c7e4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50822529ad6099ef6b57b98fb9c7e4e5">&#9670;&nbsp;</a></span>Bitmask2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask with all bits set to <code>false</code>. </p>

</div>
</div>
<a id="ga3493fd652d0f855e33a0eba425b2e164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3493fd652d0f855e33a0eba425b2e164">&#9670;&nbsp;</a></span>Bitmask2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d604ae216e3ced1aeadfac9af0bdf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d604ae216e3ced1aeadfac9af0bdf56">&#9670;&nbsp;</a></span>Bitmask2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask with all bits set to <code>false</code>. </p>
<p>The integer argument is merely for compatibility with the <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a> constructor, and will be ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> a constructor that initialises the bitmask to a given pattern. </dd></dl>

</div>
</div>
<a id="ga9de6edc3e6bd3c2a95bf3da937989265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de6edc3e6bd3c2a95bf3da937989265">&#9670;&nbsp;</a></span>bits() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Bitmask::bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <code>true</code> bits. </dd></dl>

</div>
</div>
<a id="ga6ae0be718b171f87fc5cad162cf1667a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae0be718b171f87fc5cad162cf1667a">&#9670;&nbsp;</a></span>bits() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <code>true</code> bits. </dd></dl>

</div>
</div>
<a id="gaaa1da1d19268791e7b596430230338b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1da1d19268791e7b596430230338b1">&#9670;&nbsp;</a></span>bits() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <code>true</code> bits. </dd></dl>

</div>
</div>
<a id="gabdd38837b2872b79c4cf27f304d8f838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd38837b2872b79c4cf27f304d8f838">&#9670;&nbsp;</a></span>bits() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned size = sizeof(T)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classregina_1_1BitManipulatorBySize.html">regina::BitManipulatorBySize</a>&lt; T, size &gt;::bits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits that are set to 1 in the given integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the integer of type <em>T</em> to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bits that are set. </dd></dl>

</div>
</div>
<a id="gaf3cfd88109df8473b8ae9647ff96d35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3cfd88109df8473b8ae9647ff96d35a">&#9670;&nbsp;</a></span>bitsRequired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int regina::bitsRequired </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits required to store integers in the range 0,...,<em>n</em>-1. </p>
<p>This is simply the number of bits in the binary expansion of <em>n</em>-1.</p>
<p>If <em>n</em> is non-positive then this function will return 0.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bits required to store 0,...,<em>n</em>-1.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61dff9aca49e8854226dab71315e0236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61dff9aca49e8854226dab71315e0236">&#9670;&nbsp;</a></span>BoolSet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BoolSet::BoolSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty set. </p>

</div>
</div>
<a id="gac9e750814a8f0b0bb865b2f57999bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e750814a8f0b0bb865b2f57999bf27">&#9670;&nbsp;</a></span>BoolSet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BoolSet::BoolSet </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertTrue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertFalse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a set specifying whether <code>true</code> and/or <code>false</code> should be a member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertTrue</td><td>should the new set include the element <code>true</code>? </td></tr>
    <tr><td class="paramname">insertFalse</td><td>should the new set include the element <code>false</code>? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabbd73845c38a952d7fe21319fb212af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbd73845c38a952d7fe21319fb212af">&#9670;&nbsp;</a></span>BoolSet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BoolSet::BoolSet </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a set containing a single member as given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>the single element to include in this set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15db1d32c1a13e5a9202fa566108335f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15db1d32c1a13e5a9202fa566108335f">&#9670;&nbsp;</a></span>BoolSet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BoolSet::BoolSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a set equal to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the set upon which we will base the new set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26b4dbce39b90687e88117171c5ef8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26b4dbce39b90687e88117171c5ef8a2">&#9670;&nbsp;</a></span>byteCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char regina::BoolSet::byteCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the byte code representing this boolean set. </p>
<p>The byte code is sufficient to reconstruct the set and is thus a useful means for passing boolean sets to and from the engine.</p>
<p>The lowest order bit of the byte code is 1 if and only if <code>true</code> is in the set. The next lowest order bit is 1 if and only if <code>false</code> is in the set. All other bits are 0. Thus sets <a class="el" href="group__utilities.html#gac99098499b5705ba13a480097906deed" title="The empty set.">BoolSet::sNone</a>, <a class="el" href="group__utilities.html#ga08c3e258454984543cc66505c595b23f" title="The set containing only true.">BoolSet::sTrue</a>, <a class="el" href="group__utilities.html#ga83f5f340a17bee0edb7f75c807a3cede" title="The set containing only false.">BoolSet::sFalse</a> and <a class="el" href="group__utilities.html#ga7954dfd3369b62b6e695dd4e2aaf7b60" title="The set containing both true and false.">BoolSet::sBoth</a> have byte codes 0, 1, 2 and 3 respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>the byte code representing this set. </dd></dl>

</div>
</div>
<a id="gaa7a6903d78fe63595d54d4b957464a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a6903d78fe63595d54d4b957464a91">&#9670;&nbsp;</a></span>characters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::characters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when characters are encountered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the characters encountered. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#gab1558707cb612819ff8c15292f7c299b">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="gaa2b9eaec5bcdd31034e41967cf0902fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b9eaec5bcdd31034e41967cf0902fe">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up any currently held value before the property value is changed or cleared. </p>
<p>This implementation does nothing. </p>

</div>
</div>
<a id="gab2fb21f29f18bac25d577ea11e835e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2fb21f29f18bac25d577ea11e835e95">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up any currently held value before the property value is changed or cleared. </p>
<p>This implementation resets the held pointer to <code>null</code>. </p>

</div>
</div>
<a id="ga46d6ba37500b4a648bba6ecc92505a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d6ba37500b4a648bba6ecc92505a05">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up any currently held value before the property value is changed or cleared. </p>
<p>This implementation resets the held pointer to <code>null</code> and destroys the previously held value if any exists. </p>

</div>
</div>
<a id="ga3a7f6645cddb7e89f69009ff6b49529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a7f6645cddb7e89f69009ff6b49529f">&#9670;&nbsp;</a></span>clear() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this property as unknown. </p>

</div>
</div>
<a id="ga204814b0dc212e66b45902bbbd3ef0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204814b0dc212e66b45902bbbd3ef0a9">&#9670;&nbsp;</a></span>clear() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all bits from this set that appear in the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>identifies the bits to clear from this set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44cd858745928d367203c962071ad011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44cd858745928d367203c962071ad011">&#9670;&nbsp;</a></span>clear() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all bits from this set that appear in the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to clear from this set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9fe03c364fe26a4f0e93c59a198b267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9fe03c364fe26a4f0e93c59a198b267">&#9670;&nbsp;</a></span>clonePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>Note that, even though this routine takes a std::unique_ptr, it returns a raw pointer. The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a id="ga3a20ee136c5a257176ff117f0eafb4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a20ee136c5a257176ff117f0eafb4a0">&#9670;&nbsp;</a></span>clonePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a id="gaec85de7b3e74749b1dd1d5d8b5f6c1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec85de7b3e74749b1dd1d5d8b5f6c1aa">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a>* regina::i18n::IConvStreamBuffer::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes this stream buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>this stream buffer on success, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga2a96ed25fecca35188a79267f9d4f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a96ed25fecca35188a79267f9d4f4ae">&#9670;&nbsp;</a></span>codeset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* regina::i18n::Locale::codeset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character encoding used in the current locale. </p>
<p>This is a plain string, such as "UTF-8" or "ISO-8859-1".</p>
<dl class="section return"><dt>Returns</dt><dd>the character encoding for the current locale. </dd></dl>

</div>
</div>
<a id="ga43c161ec316c3f4a280ea6a27a61f944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c161ec316c3f4a280ea6a27a61f944">&#9670;&nbsp;</a></span>comment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a comment is encountered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the comment string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d0dfc05eb2a1f9ca030aae0bc619557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0dfc05eb2a1f9ca030aae0bc619557">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::contains </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given boolean is a member of this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the boolean to search for in this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given boolean is a member of this set. </dd></dl>

</div>
</div>
<a id="ga83a69447508fb3ce96f47363c264d1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a69447508fb3ce96f47363c264d1cf">&#9670;&nbsp;</a></span>containsIntn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::containsIntn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask contains the intersection of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in <em>both</em> <em>x</em> and <em>y</em> must be set in this bitmask also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>x</em> and <em>y</em> are the same length as this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the intersection. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask entirely contains the intersection of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga83f20cd69216cb3949ec86388c310809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f20cd69216cb3949ec86388c310809">&#9670;&nbsp;</a></span>containsIntn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::containsIntn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask contains the intersection of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in <em>both</em> <em>x</em> and <em>y</em> must be set in this bitmask also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the intersection. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask entirely contains the intersection of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="gaf6f97bb0f6c7c824e6baa5f85f829787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f97bb0f6c7c824e6baa5f85f829787">&#9670;&nbsp;</a></span>containsIntn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::containsIntn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask contains the intersection of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in <em>both</em> <em>x</em> and <em>y</em> must be set in this bitmask also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the intersection. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask entirely contains the intersection of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga69b2411865af18bf506a1afb7d2bc2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b2411865af18bf506a1afb7d2bc2ca">&#9670;&nbsp;</a></span>duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* regina::duplicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new C string that is a duplicate of the given C++ string. </p>
<p>The deallocation of the new C string is the responsibility of the caller of this routine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the C++ string to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new duplicate C string. </dd></dl>

</div>
</div>
<a id="ga39dbbacec01481a24963c129d259abe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39dbbacec01481a24963c129d259abe4">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from this set. </p>

</div>
</div>
<a id="ga638ed603ac7452cfb9503a395c0e93ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga638ed603ac7452cfb9503a395c0e93ff">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains all zeroes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every qit is zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0523166fbf4f9a052389a2d836af561a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0523166fbf4f9a052389a2d836af561a">&#9670;&nbsp;</a></span>empty() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains all zeroes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every qit is zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga7cde32c1e71bc9ad400df49384ffe077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cde32c1e71bc9ad400df49384ffe077">&#9670;&nbsp;</a></span>empty() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains all zeroes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every trit is zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4e364f04f69366ddd7c4ba3f0abb64a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e364f04f69366ddd7c4ba3f0abb64a0">&#9670;&nbsp;</a></span>empty() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains all zeroes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every trit is zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaef6e14b2d8fcd8affcb218dabe754f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef6e14b2d8fcd8affcb218dabe754f34">&#9670;&nbsp;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga11786e34be796e7fd8ce05884be77a39">iterator</a> <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write iterator that points beyond the last element of the sequence. </p>
<p>Note that, because this iterator is past-the-end, it must not be dereferenced.</p>
<dl class="section return"><dt>Returns</dt><dd>a read-write past-the-end iterator. </dd></dl>

</div>
</div>
<a id="gaf2717b68b2dc0d43087e52e59ebcc5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2717b68b2dc0d43087e52e59ebcc5d4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gad5c59ac14b7b95cee666f39804fa1580">iterator</a> <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing past the end of this list (i.e., just after the last item). </p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb" title="Returns an iterator pointing to the first item in this list.">begin()</a> routine has been called at least once (otherwise the list will not yet have been filled).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a past-the-end iterator. </dd></dl>

</div>
</div>
<a id="ga850bb0bcdb1efcfcf12633f020415705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850bb0bcdb1efcfcf12633f020415705">&#9670;&nbsp;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt;::<a class="el" href="group__utilities.html#ga68708a91988e06ed2df5adcc22539144">const_iterator</a> <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only iterator that points beyond the last element of the sequence. </p>
<p>Note that, because this iterator is past-the-end, it must not be dereferenced.</p>
<dl class="section return"><dt>Returns</dt><dd>a read-only past-the-end iterator. </dd></dl>

</div>
</div>
<a id="ga5097dbe352cd85dda7594a7e30eccf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5097dbe352cd85dda7594a7e30eccf77">&#9670;&nbsp;</a></span>end_document()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::end_document </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the document is finalised. </p>

<p>Reimplemented in <a class="el" href="group__file.html#ga5d09cb47678f7771f02e39a102c27212">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="ga03a621c7a0bc9fefd819aa1d3218eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a621c7a0bc9fefd819aa1d3218eff5">&#9670;&nbsp;</a></span>end_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::end_element </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an element's closing tag is encountered. </p>
<p>This is called immediately after <a class="el" href="group__utilities.html#gae250b751104ecc561d807a5c5d93c747" title="Called when an element&#39;s opening tag is encountered.">start_element()</a> if the opening tag is in <code>&lt;tag/&gt;</code> format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the name of the tag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#gaee163d3330c80c99d98c20f0fce2ddb8">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="gabe9274be75059680fab7d6dee5879d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe9274be75059680fab7d6dee5879d3b">&#9670;&nbsp;</a></span>engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::default_random_engine &amp; regina::RandomEngine::engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to Regina's global uniform random bit generator (URBG). </p>
<p>As described in the class notes, you should pass <a class="el" href="group__utilities.html#gabe9274be75059680fab7d6dee5879d3b" title="Provides access to Regina&#39;s global uniform random bit generator (URBG).">engine()</a> directly to other random number generation functions as you use them, and not store a reference to it for later use.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the global URBG. </dd></dl>

</div>
</div>
<a id="ga7abc7e5a319af8231874741c12c31562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abc7e5a319af8231874741c12c31562">&#9670;&nbsp;</a></span>ensureOne() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::ensureOne </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust this set so that exactly one and only one of the two given flags are included. </p>
<p>If neither flag is present or both flags are present, this set will be adjusted so that <em>default_</em> is present and <em>other</em> is not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>default_</em> and <em>other</em> are each single-bit flags.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_</td><td>the flag that will be set if any adjustments need to be made. </td></tr>
    <tr><td class="paramname">other</td><td>the flag that will be cleared if any adjustments need to be made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga633ea4e9bb6ffe283ae05b06c8f73d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633ea4e9bb6ffe283ae05b06c8f73d02">&#9670;&nbsp;</a></span>ensureOne() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::ensureOne </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust this set so that exactly one and only one of the three given flags are included. </p>
<p>If neither flag is present, then <em>default_</em> will be used. If multiple flags are present, then the flag that appears <em>earlier</em> in the argument list for this routine will be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given flags is single-bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_</td><td>the highest-priority flag. </td></tr>
    <tr><td class="paramname">second</td><td>the second-highest-priority flag. </td></tr>
    <tr><td class="paramname">last</td><td>the lowest-priority flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa01cdd0ccaaf98845f10fa2ab3b17852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa01cdd0ccaaf98845f10fa2ab3b17852">&#9670;&nbsp;</a></span>ensureOne() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::ensureOne </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>third</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust this set so that exactly one and only one of the four given flags are included. </p>
<p>If neither flag is present, then <em>default_</em> will be used. If multiple flags are present, then the flag that appears <em>earlier</em> in the argument list for this routine will be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given flags is single-bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_</td><td>the highest-priority flag. </td></tr>
    <tr><td class="paramname">second</td><td>the second-highest-priority flag. </td></tr>
    <tr><td class="paramname">third</td><td>the third-highest-priority flag. </td></tr>
    <tr><td class="paramname">last</td><td>the lowest-priority flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5335b8572c4d5fca85375f0a5a864a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5335b8572c4d5fca85375f0a5a864a18">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the subsequences referred to by the given pair of iterators are identical. </p>
<p>See the class notes for details on how each iterator is converted into a subsequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an iterator indicating the first of the two subsequences to compare. </td></tr>
    <tr><td class="paramname">b</td><td>an iterator indicating the second of the two subsequences to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two subsequences are identical. </dd></dl>

</div>
</div>
<a id="gae06adea4622195052ba6470565c8dc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06adea4622195052ba6470565c8dc8f">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt;::iterator <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; T * &gt;::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T * &gt;::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all items in the given range in this vector. </p>
<p>The items will not be destroyed, and the (now irrelevant) indices stored inside them will not be modified.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given iterators describe a valid range in this vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>an iterator pointing to the first element to erase. </td></tr>
    <tr><td class="paramname">last</td><td>an iterator pointing just beyond the last element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the element immediately after the elements that were erased. </dd></dl>

</div>
</div>
<a id="gae3e455a24cd3ad0f167939f7e0f6f31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e455a24cd3ad0f167939f7e0f6f31e">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt;::iterator <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; T * &gt;::iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the item at the given position in this vector. </p>
<p>The item will not be destroyed, and the (now irrelevant) index stored inside it will not be modified.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given iterator points to an element of this vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>an iterator pointing to the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the element immediately after the element that was erased. </dd></dl>

</div>
</div>
<a id="ga72cadd81cd594321c1ac4f862cc75a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72cadd81cd594321c1ac4f862cc75a53">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a parser error occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#ga63edd21c3e6c4cffdb72e56384215cd1">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="gadc22b3ceefd76f93297557d011faa18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc22b3ceefd76f93297557d011faa18f">&#9670;&nbsp;</a></span>fatal_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::fatal_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a parser fatal error occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#gad9795c8eeee8cc014fea9ec5136baf50">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="gab92586c9c3e0423b9b186debb448c558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92586c9c3e0423b9b186debb448c558">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places both <code>true</code> and <code>false</code> into this set if they are not already present. </p>

</div>
</div>
<a id="ga6bdd6fdd37147d44dcf134d6a7187de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdd6fdd37147d44dcf134d6a7187de5">&#9670;&nbsp;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParser::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals that there are no more XML chunks to parse. </p>

</div>
</div>
<a id="ga50e6f8a09ba10b2cb44db84c3ff2a561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e6f8a09ba10b2cb44db84c3ff2a561">&#9670;&nbsp;</a></span>firstBit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Bitmask::firstBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="ga2e325dede0bac3b6596449d37853e99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e325dede0bac3b6596449d37853e99a">&#9670;&nbsp;</a></span>firstBit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::firstBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="ga9cb407ab09711aebe50d87d78fd3d723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb407ab09711aebe50d87d78fd3d723">&#9670;&nbsp;</a></span>firstBit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::firstBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="gae126bd472acad119bc3e8f2661c4ed29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae126bd472acad119bc3e8f2661c4ed29">&#9670;&nbsp;</a></span>firstBit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classregina_1_1BitManipulator.html">regina::BitManipulator</a>&lt; T &gt;::firstBit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in the given integer, or -1 if the given integer is zero. </p>
<p>Bits are indexed from 0 upwards, starting at the least significant bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the integer of type <em>T</em> to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the first <code>true</code> bit, or -1 if there are no <code>true</code> bits. </dd></dl>

</div>
</div>
<a id="ga2344a0c7e7faec0da6cb60c97709691b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2344a0c7e7faec0da6cb60c97709691b">&#9670;&nbsp;</a></span>Flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::<a class="el" href="classregina_1_1Flags.html">Flags</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty flag set, with no flags set at all. </p>

</div>
</div>
<a id="gad0316c98b2cd692da8838e25d9964044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0316c98b2cd692da8838e25d9964044">&#9670;&nbsp;</a></span>Flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::<a class="el" href="classregina_1_1Flags.html">Flags</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>the flag set to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf983a5399d2b63f98dbe99297b21bcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf983a5399d2b63f98dbe99297b21bcf6">&#9670;&nbsp;</a></span>Flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::<a class="el" href="classregina_1_1Flags.html">Flags</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a flag set initialised to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>the initial value of this flag set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga912eae1af8637055cd516b179d73c040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912eae1af8637055cd516b179d73c040">&#9670;&nbsp;</a></span>flip() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every bit in this bitmask. </p>
<p>All <code>true</code> bits will be set to <code>false</code> and vice versa.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because this class may increase the bitmask length (rounding up to the next unit of storage), <a class="el" href="group__utilities.html#ga912eae1af8637055cd516b179d73c040" title="Negates every bit in this bitmask.">flip()</a> may set additional <code>true</code> bits in the "dead space" between the intended length and the actual length. This may cause unexpected results for routines such as subset testing, bit counting and so on. Be careful! </dd></dl>

</div>
</div>
<a id="ga91fc2991a7e0d2f718a2a3f6bec1bbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91fc2991a7e0d2f718a2a3f6bec1bbfb">&#9670;&nbsp;</a></span>flip() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every bit in this bitmask. </p>
<p>All <code>true</code> bits will be set to <code>false</code> and vice versa.</p>
<p>Unlike the more generic <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, this optimised bitmask class does not store a length. This means that all 8 * sizeof(<em>T</em>) possible bits will be negated. </p>

</div>
</div>
<a id="ga5866b8e28c63cc3ea33901589441ef8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5866b8e28c63cc3ea33901589441ef8b">&#9670;&nbsp;</a></span>flip() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every bit in this bitmask. </p>
<p>All <code>true</code> bits will be set to <code>false</code> and vice versa.</p>
<p>Unlike the more generic <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, this optimised bitmask class does not store a length. This means that all 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) possible bits will be negated. </p>

</div>
</div>
<a id="ga02e789e27390eeceeadd433840d95462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02e789e27390eeceeadd433840d95462">&#9670;&nbsp;</a></span>fromByteCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::fromByteCode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a boolean set from the given byte code. </p>
<p>See <a class="el" href="group__utilities.html#ga26b4dbce39b90687e88117171c5ef8a2" title="Returns the byte code representing this boolean set.">byteCode()</a> for more information on byte codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>code</em> is 0, 1, 2 or 3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the byte code from which the new set will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1dfaa416e47d751155a554968e30ff42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dfaa416e47d751155a554968e30ff42">&#9670;&nbsp;</a></span>fromInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::fromInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set corresponding to the given integer value. </p>
<p>This is suitable for file input and/or output.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be used widely, since it effectively works around inbuilt type safety mechanisms.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set corresponding to the given integer value. </dd></dl>

</div>
</div>
<a id="gaa27b83072e5e62e6cfb7a263847cef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27b83072e5e62e6cfb7a263847cef81">&#9670;&nbsp;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::get</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a raw pointer to the pointee. </p>
<dl class="section return"><dt>Returns</dt><dd>the pointee. </dd></dl>

</div>
</div>
<a id="ga595e7706031ee52566b562a7c4573a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga595e7706031ee52566b562a7c4573a50">&#9670;&nbsp;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to query; this must be at least zero and strictly less than the length of this bitmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th bit. </dd></dl>

</div>
</div>
<a id="gaa61c56304383a01094f088b559347d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa61c56304383a01094f088b559347d32">&#9670;&nbsp;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to query; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th bit. </dd></dl>

</div>
</div>
<a id="ga2bda042c974a2fa330935cd9e2976212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bda042c974a2fa330935cd9e2976212">&#9670;&nbsp;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to query; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th bit. </dd></dl>

</div>
</div>
<a id="ga4a572cf75f5bcaed1bfa97dce7225d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a572cf75f5bcaed1bfa97dce7225d14">&#9670;&nbsp;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given qit in this qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which qit to query; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th qit; this will be either 0, 1, 2 or 3. </dd></dl>

</div>
</div>
<a id="gab639244c964a2af9b83877987779c03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab639244c964a2af9b83877987779c03a">&#9670;&nbsp;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given qit in this qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which qit to query; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th qit; this will be either 0, 1, 2 or 3. </dd></dl>

</div>
</div>
<a id="gab37aa9be2ad761002c3b0898d5fcaf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37aa9be2ad761002c3b0898d5fcaf10">&#9670;&nbsp;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given trit in this tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which trit to query; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th trit; this will be either 0, 1 or 2. </dd></dl>

</div>
</div>
<a id="gad6b897fbac2d36a17ef98adc840b1497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b897fbac2d36a17ef98adc840b1497">&#9670;&nbsp;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given trit in this tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which trit to query; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th trit; this will be either 0, 1 or 2. </dd></dl>

</div>
</div>
<a id="gac384aa3d6b9abc3eba4bf04836f2eb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac384aa3d6b9abc3eba4bf04836f2eb03">&#9670;&nbsp;</a></span>has() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether all of the flags in the given set are set. </p>
<p>This requires <em>all</em> of the bits of all of the flags in the given set to be present in this set. The test is equivalent to <code>(*this &amp; rhs) == rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the set whose presence will be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all of the bits of the given set are present in this set. </dd></dl>

</div>
</div>
<a id="gaff55a29d2beff5e8d7010f6f18e02989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff55a29d2beff5e8d7010f6f18e02989">&#9670;&nbsp;</a></span>has() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::has </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the given flag is set. </p>
<p>This requires <em>all</em> of the bits of the given flag to be set. The test is equivalent to <code>(*this &amp; flag) == flag</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>the flag whose presence will be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all of the bits of the given flag are set. </dd></dl>

</div>
</div>
<a id="ga03ebce0c5e651337d7ec3e4975057be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ebce0c5e651337d7ec3e4975057be3">&#9670;&nbsp;</a></span>has2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::has2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains at least one trit with value 2. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one trit is 2, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa0e64640f308cb456871f73469c504fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e64640f308cb456871f73469c504fc">&#9670;&nbsp;</a></span>has2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::has2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains at least one trit with value 2. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one trit is 2, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga1d21694ed37af5f470e46e025b077d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d21694ed37af5f470e46e025b077d9a">&#9670;&nbsp;</a></span>has3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::has3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains at least one qit with value 3. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one qit is 3, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga1ec7c6989ea9fbd66b68fc35aa7c141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec7c6989ea9fbd66b68fc35aa7c141e">&#9670;&nbsp;</a></span>has3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::has3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains at least one qit with value 3. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one qit is 3, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab1a63d4102262eda00159858a6839f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1a63d4102262eda00159858a6839f96">&#9670;&nbsp;</a></span>hasExtraSuperset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::hasExtraSuperset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the particular superset search required by the double description method. </p>
<p>This routine asks the following question: In this collection of sets, is there any superset of the argument <em>subset</em> <em>other</em> than <em>exc1</em> or <em>exc2</em>? Here the sets <em>exc1</em> and <em>exc2</em> are explicitly excluded from our search. Supersets need not be <em>proper</em> supersets (so if an exact copy of <em>subset</em> is found in the tree then this will suffice).</p>
<p>This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The sets <em>exc1</em> and <em>exc2</em> are distinct, and each is contained in this collection precisely once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>the object of the query: we are searching this collection for a (non-strict) superset of this argument. </td></tr>
    <tr><td class="paramname">exc1</td><td>the first set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">exc2</td><td>the second set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). Note that this is always less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a superset with the required properties was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab854f3ca7fe75b9514235f4d96ff52fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab854f3ca7fe75b9514235f4d96ff52fc">&#9670;&nbsp;</a></span>hasFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::hasFalse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if <code>false</code> is a member of this set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>false</code> is a member of this set. </dd></dl>

</div>
</div>
<a id="ga47cb0ddb01f4af90ab177f2637f2ce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47cb0ddb01f4af90ab177f2637f2ce3f">&#9670;&nbsp;</a></span>hasNonZeroMatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::hasNonZeroMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether there is some index at which both this and the given qitmask both have non-zero qits. </p>
<p>That is, there is some index <em>i</em> for which <code>get(i)</code> and <code>other.get(i)</code> are both non-zero.</p>
<p>Note that these two qits do not need to be equal; they just both need to be non-zero. Note also that this only needs to happen at one index; there may be <em>other</em> indices at which the qit is zero in one qitmask but not the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is some index at which this and <em>other</em> both have non-zero qits, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad8676cc0860ce7cc9135ada44516aec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8676cc0860ce7cc9135ada44516aec0">&#9670;&nbsp;</a></span>hasNonZeroMatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::hasNonZeroMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether there is some index at which both this and the given qitmask both have non-zero qits. </p>
<p>That is, there is some index <em>i</em> for which <code>get(i)</code> and <code>other.get(i)</code> are both non-zero.</p>
<p>Note that these two qits do not need to be equal; they just both need to be non-zero. Note also that this only needs to happen at one index; there may be <em>other</em> indices at which the qit is zero in one qitmask but not the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is some index at which this and <em>other</em> both have non-zero qits, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa724448326c5e5b0ba727fe6ce6d1233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa724448326c5e5b0ba727fe6ce6d1233">&#9670;&nbsp;</a></span>hasSafePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; T &gt;::hasSafePtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is there one or more <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> currently pointing to this object? </p>

</div>
</div>
<a id="ga58741f6c93aeede75d8bba526cff3ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58741f6c93aeede75d8bba526cff3ed1">&#9670;&nbsp;</a></span>hasSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::hasSubset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>superset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this collection of sets contains any subset of the argument <em>superset</em>. </p>
<p>Subsets need not be <em>proper</em> subsets (so if an exact copy of <em>superset</em> is found in the tree then this will suffice).</p>
<p>This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">superset</td><td>the object of the query: we are searching this collection for a (non-strict) subset of this argument. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). Note that this is always less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a subset was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad92ac19a5e3d706cee6f97f415d40f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92ac19a5e3d706cee6f97f415d40f70">&#9670;&nbsp;</a></span>hasTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::hasTrue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if <code>true</code> is a member of this set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>true</code> is a member of this set. </dd></dl>

</div>
</div>
<a id="gae08add9882e50e93fb34b4e420725d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08add9882e50e93fb34b4e420725d90">&#9670;&nbsp;</a></span>IConvStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStream::IConvStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>; see the class notes for details. </p>
<p>If the given encodings are invalid, this stream will still forward data to the given output stream but no conversion will take place.</p>
<p>See the <em>iconv</em> documentation for information on what encodings are supported. For the GNU C library implementation, valid encodings can be found by running <code>iconv &ndash;list</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination output stream is already open.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination output stream. </td></tr>
    <tr><td class="paramname">srcCode</td><td>the character encoding for data that is to be written into this <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>. </td></tr>
    <tr><td class="paramname">destCode</td><td>the character encoding for the translated data that will subsequently be written to the destination output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3334747d42a32a95043a910a6dd173bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3334747d42a32a95043a910a6dd173bc">&#9670;&nbsp;</a></span>IConvStreamBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStreamBuffer::IConvStreamBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new stream buffer. </p>

</div>
</div>
<a id="ga1c716ebe16604586927a18a795942197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c716ebe16604586927a18a795942197">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this sequence to contain the given number of elements. </p>
<p>All existing elements in this sequence will be destroyed, using the default destructor for type <em>T</em>. If the elements are pointers whose pointee objects need to be deleted also, you must do this separately before calling <a class="el" href="group__utilities.html#ga1c716ebe16604586927a18a795942197" title="Resizes this sequence to contain the given number of elements.">init()</a>.</p>
<p>The elements of the sequence after this routine is called will be initialised using the default constructor for type <em>T</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="group__utilities.html#ga1c716ebe16604586927a18a795942197" title="Resizes this sequence to contain the given number of elements.">init()</a> is an expensive operation, in that it will always force a reallocation of the underlying storage (even if the new size is smaller than the old).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of elements that the sequence will contain after this routine is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf28a5e3992fdfe5b552848fc2a644b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf28a5e3992fdfe5b552848fc2a644b2e">&#9670;&nbsp;</a></span>initialise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::initialise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills this list with items. </p>
<p>The particular set of items to use will typically depend on the particular subclass of <a class="el" href="classregina_1_1ListOnCall.html" title="Offers a hard-coded list of expensive objects that should only be created if they are required.">ListOnCall</a> that is being defined.</p>
<p>This routine will be run the first time that <a class="el" href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb" title="Returns an iterator pointing to the first item in this list.">begin()</a> is called on each list, and will not be run again. </p>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga52db0ca1eb1e56f93cf656dccb182db1">regina::SatBlockStarterSet</a>.</p>

</div>
</div>
<a id="ga2b27f0f00ef8f19560f14cd7faf6caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b27f0f00ef8f19560f14cd7faf6caea">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given set into this collection. </p>
<p>The same set may be insert into this collection multiple times (and this multiplicity will be recorded correctly).</p>
<p>Running time for insertion is O(<em>n</em>), where <em>n</em> is the bitmask length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the new set to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea71dbb469a5a1c8a2b2b92fe9471061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea71dbb469a5a1c8a2b2b92fe9471061">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given item to the end of this list. </p>
<p>This routine should only ever be called from within a subclass implementation of <a class="el" href="group__utilities.html#gaf28a5e3992fdfe5b552848fc2a644b2e" title="Fills this list with items.">initialise()</a>.</p>
<p>The given item will be owned by this list, and will be destroyed when this list is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>the new item to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e463ebd4e012e7f91ac7070069a611d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e463ebd4e012e7f91ac7070069a611d">&#9670;&nbsp;</a></span>insertFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::insertFalse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>false</code> into this set if it is not already present. </p>

</div>
</div>
<a id="ga2501b339c018f6398e2a108d13de873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2501b339c018f6398e2a108d13de873a">&#9670;&nbsp;</a></span>insertTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::insertTrue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>true</code> into this set if it is not already present. </p>

</div>
</div>
<a id="gaed34629cfb48b9752734db89015b97d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed34629cfb48b9752734db89015b97d2">&#9670;&nbsp;</a></span>intValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::intValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the integer representation of this set. </p>
<p>This is suitable for file input and/or output.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be used widely, since it effectively works around inbuilt type safety mechanisms.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the integer value of this set. </dd></dl>

</div>
</div>
<a id="gad4257f99e264429d5e30a14792fc2ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4257f99e264429d5e30a14792fc2ec6">&#9670;&nbsp;</a></span>inUnion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::inUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the union of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in either <em>x</em> or <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>x</em> and <em>y</em> are the same length as this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the union. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the union. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the union of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga873b254e6de092d5fea86d5af14593ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873b254e6de092d5fea86d5af14593ea">&#9670;&nbsp;</a></span>inUnion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::inUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the union of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in either <em>x</em> or <em>y</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the union. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the union. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the union of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="gab10fcc4b81aae1210375ab7ca50d7ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10fcc4b81aae1210375ab7ca50d7ea1">&#9670;&nbsp;</a></span>inUnion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::inUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the union of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in either <em>x</em> or <em>y</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the union. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the union. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the union of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga231a1c1fdf6cc37e09fbc77ea2cf14ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">&#9670;&nbsp;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given character is a base64 printable character as used by the base64 routines in Regina. </p>
<p>The base64 printable characters are the letters (both upper-case and lower-case), digits, plus (+), and forward slash (/).</p>
<p>Note that the equals sign (=) is padding, and is not considered by this routine to be a base64 printable character.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>any character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given character is one of the base64 printable characters used in Regina, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="gafe8cba1c0b050e32df20cefca4e8a815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe8cba1c0b050e32df20cefca4e8a815">&#9670;&nbsp;</a></span>known()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::known </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this property is currently marked as known. </p>
<dl class="section return"><dt>Returns</dt><dd>whether this property is marked as known. </dd></dl>

</div>
</div>
<a id="ga4e60765c8153d1f64287e3b3e24734b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e60765c8153d1f64287e3b3e24734b3">&#9670;&nbsp;</a></span>lastBit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Bitmask::lastBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="ga156a1a782eaba586f2dbc03dff7fef49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156a1a782eaba586f2dbc03dff7fef49">&#9670;&nbsp;</a></span>lastBit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::lastBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="ga9c1b203ab48e2eeabd56a1d39c1817b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1b203ab48e2eeabd56a1d39c1817b3">&#9670;&nbsp;</a></span>lastBit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::lastBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last <code>true</code> bit. </dd></dl>

</div>
</div>
<a id="gaae81363831599dfc3e896e31e3901a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae81363831599dfc3e896e31e3901a51">&#9670;&nbsp;</a></span>lastBit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classregina_1_1BitManipulator.html">regina::BitManipulator</a>&lt; T &gt;::lastBit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in the given integer, or -1 if the given integer is zero. </p>
<p>Bits are indexed from 0 upwards, starting at the least significant bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the integer of type <em>T</em> to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the last <code>true</code> bit, or -1 if there are no <code>true</code> bits. </dd></dl>

</div>
</div>
<a id="ga10ef7e3d0cd8b70a6567394b042cb474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ef7e3d0cd8b70a6567394b042cb474">&#9670;&nbsp;</a></span>less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::less </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares the subsequences referred to by the given pair of iterators. </p>
<p>See the class notes for details on how each iterator is converted into a subsequence.</p>
<p>This member function is identical to the bracket operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an iterator indicating the first of the two subsequences to compare. </td></tr>
    <tr><td class="paramname">b</td><td>an iterator indicating the second of the two subsequences to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the subsequence indicated by <em>a</em> is lexicographically smaller than the subsequence indicated by <em>b</em>. </dd></dl>

</div>
</div>
<a id="ga026a973b46a3b950cd6d5f20d1733516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga026a973b46a3b950cd6d5f20d1733516">&#9670;&nbsp;</a></span>lessThan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::lessThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order. </p>
<p>Here the bit at index 0 is least significant, and the bit at index <em>length-1</em> is most significant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>We do not use &lt; for this operation, since &lt;= represents the subset operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is lexicographically strictly smaller than the given bitmask. </dd></dl>

</div>
</div>
<a id="ga96409a6adba0c43739fc4e7485779576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96409a6adba0c43739fc4e7485779576">&#9670;&nbsp;</a></span>lessThan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::lessThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order. </p>
<p>Here the bit at index 0 is least significant, and the bit at index <em>length-1</em> is most significant.</p>
<dl class="section warning"><dt>Warning</dt><dd>We do not use &lt; for this operation, since &lt;= represents the subset operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is lexicographically strictly smaller than the given bitmask. </dd></dl>

</div>
</div>
<a id="ga279087abf96d05ff4b6426075cd36df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga279087abf96d05ff4b6426075cd36df0">&#9670;&nbsp;</a></span>lessThan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::lessThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order. </p>
<p>Here the bit at index 0 is least significant, and the bit at index <em>length-1</em> is most significant.</p>
<dl class="section warning"><dt>Warning</dt><dd>We do not use &lt; for this operation, since &lt;= represents the subset operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is lexicographically strictly smaller than the given bitmask. </dd></dl>

</div>
</div>
<a id="ga846e0d6cfe168e127e70a8315f406afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga846e0d6cfe168e127e70a8315f406afa">&#9670;&nbsp;</a></span>LightweightSequence() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty sequence; that is, a sequence of size zero. </p>
<p>This sequence can be resized by calling <a class="el" href="group__utilities.html#ga1c716ebe16604586927a18a795942197" title="Resizes this sequence to contain the given number of elements.">init()</a>. </p>

</div>
</div>
<a id="ga4fdae8fad58d9618d6d99e27e18c4119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fdae8fad58d9618d6d99e27e18c4119">&#9670;&nbsp;</a></span>LightweightSequence() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the given sequence. </p>
<p>This induces a deep copy of <em>src</em>, in that all of the elements of <em>src</em> will be copied into the new sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the sequence to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga140db26f8fcf84358e4f86ff932c81b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140db26f8fcf84358e4f86ff932c81b0">&#9670;&nbsp;</a></span>LightweightSequence() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given sequence to this new sequence. </p>
<p>This is a fast (constant time) operation.</p>
<p>The sequence that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the sequence to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac032923d378946c9adedf8b299a66775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac032923d378946c9adedf8b299a66775">&#9670;&nbsp;</a></span>LightweightSequence() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new sequence containing the given number of elements. </p>
<p>The elements themselves will be initialised using the default constructor for type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of elements in the new sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga444c701a9ef2ec4972aa45d8a4063a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga444c701a9ef2ec4972aa45d8a4063a8e">&#9670;&nbsp;</a></span>ListOnCall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::<a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new list structure. </p>
<p>The list will not be filled with items; this does not happen until the first time that <a class="el" href="group__utilities.html#ga76a2f4f57b37f515e433b039ce2257bb" title="Returns an iterator pointing to the first item in this list.">begin()</a> is called. </p>

</div>
</div>
<a id="ga005e9231afb2aeb9c8bbebbef9e16755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005e9231afb2aeb9c8bbebbef9e16755">&#9670;&nbsp;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::xml::XMLPropertyDict::lookup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a value for the given key, or the empty string if the key does not exist in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value associated with the given key, or the empty string if the key does not exist in the map. </dd></dl>

</div>
</div>
<a id="gaf5035a670e370a16699d1cf1c3649da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5035a670e370a16699d1cf1c3649da8">&#9670;&nbsp;</a></span>markedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedElement::markedIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>. </p>
<p>If this object does not belong to an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>, the return value is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the index at which this object is stored. </dd></dl>

</div>
</div>
<a id="ga27c60a092a49e41e22de0f22aa781322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c60a092a49e41e22de0f22aa781322">&#9670;&nbsp;</a></span>MarkedVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new empty vector. </p>

</div>
</div>
<a id="ga5f6dc18d20d4f90644df074409a8185e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6dc18d20d4f90644df074409a8185e">&#9670;&nbsp;</a></span>MarkedVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given vector into this new vector. </p>
<p>The vector that was passed will no longer be usable. </p>

</div>
</div>
<a id="gac1cf8251c56569a34367b9150ca32e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cf8251c56569a34367b9150ca32e4c">&#9670;&nbsp;</a></span>maxWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::maxWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the maximum of this and the given tritmask. </p>
<p>That is, the ith trit will be set to the maximum of the ith trit in this tritmask and the ith trit in <em>other</em>.</p>
<p>This is a "trit" version of boolean OR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to "max" with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gaf6eac6f596dc2b3af1fe14d4037ec4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6eac6f596dc2b3af1fe14d4037ec4b3">&#9670;&nbsp;</a></span>maxWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::maxWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the maximum of this and the given tritmask. </p>
<p>That is, the ith trit will be set to the maximum of the ith trit in this tritmask and the ith trit in <em>other</em>.</p>
<p>This is a "trit" version of boolean OR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to "max" with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gaa212f4ae28e5a29ffd13d9324512497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa212f4ae28e5a29ffd13d9324512497a">&#9670;&nbsp;</a></span>mem_istream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::mem_istream::mem_istream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialies an input stream that reads from the given array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>a pointer to the beginning of the array to read. </td></tr>
    <tr><td class="paramname">end</td><td>a pointer past-the-end of the array to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5001473deb4ecba08fbd6997eafcae2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5001473deb4ecba08fbd6997eafcae2f">&#9670;&nbsp;</a></span>mem_streambuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::mem_streambuf::mem_streambuf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialies a read-only stream buffer that reads from the given array of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>a pointer to the beginning of the array to read. </td></tr>
    <tr><td class="paramname">end</td><td>a pointer past-the-end of the array to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68414895383f7281c7e9920f93958c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68414895383f7281c7e9920f93958c68">&#9670;&nbsp;</a></span>minWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::minWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the minimum of this and the given tritmask. </p>
<p>That is, the ith trit will be set to the minimum of the ith trit in this tritmask and the ith trit in <em>other</em>.</p>
<p>This is a "trit" version of boolean AND.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to "min" with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="ga0d7cbf01093ee954fe1ffe54a61cc025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d7cbf01093ee954fe1ffe54a61cc025">&#9670;&nbsp;</a></span>minWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::minWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the minimum of this and the given tritmask. </p>
<p>That is, the ith trit will be set to the minimum of the ith trit in this tritmask and the ith trit in <em>other</em>.</p>
<p>This is a "trit" version of boolean AND.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to "min" with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="ga77b04c78ee6c4dc016194fe7f04a6d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b04c78ee6c4dc016194fe7f04a6d54">&#9670;&nbsp;</a></span>nextPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classregina_1_1BitManipulatorByType.html">regina::BitManipulatorByType</a>&lt; T &gt;::nextPermutation </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next largest integer with the same number of <code>true</code> bits as <em>x</em>. </p>
<p>If <em>x</em> is the largest such integer (i.e., <em>x</em> is of the form 111...1000...0), then this routine returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the integer of type <em>T</em> to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next largrst integer with the same number of <code>true</code> bits, or 0 if this is the largest such integer. </dd></dl>

</div>
</div>
<a id="gaf8ad7790348b617ffd8fdf50736cd9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ad7790348b617ffd8fdf50736cd9cf">&#9670;&nbsp;</a></span>nextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::nextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smallest integer power of two that is greater than or equal to the given argument <em>n</em>. </p>
<p>If <em>n</em> is non-positive then this function will return 1.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the return value is the same type as the argument <em>n</em>, this routine may still overflow. For example, if <em>IntType</em> is a signed char then nextPowerOfTwo(127) will return -128, and if <em>IntType</em> is an unsigned char then nextPowerOfTwo(255) will return 0. Be sure that <em>IntType</em> is large enough for your requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest integer power of two that is &ge; <em>n</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c5b06cbb4460371a18c18c5cc279a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c5b06cbb4460371a18c18c5cc279a12">&#9670;&nbsp;</a></span>nonEmpty() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::nonEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains at least one non-zero qit. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one qit is non-zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6ea6c09f2da82fdee9b8ce86b7eaf684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea6c09f2da82fdee9b8ce86b7eaf684">&#9670;&nbsp;</a></span>nonEmpty() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::nonEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this qitmask contains at least one non-zero qit. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one qit is non-zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga3cd75976c00392a6e1b427ff1b84d323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd75976c00392a6e1b427ff1b84d323">&#9670;&nbsp;</a></span>nonEmpty() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::nonEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains at least one non-zero trit. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one trit is non-zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab3ad333cdd8b242cabb3faa080a5cfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ad333cdd8b242cabb3faa080a5cfe1">&#9670;&nbsp;</a></span>nonEmpty() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::nonEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this tritmask contains at least one non-zero trit. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one trit is non-zero, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga8170e81f5d3a805161cc1ff9800e458f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8170e81f5d3a805161cc1ff9800e458f">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">IConvStreamBuffer</a>* regina::i18n::IConvStreamBuffer::open </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a new stream buffer that wraps around the given output stream. </p>
<p>If this stream buffer is already open, it will be closed and then reopened with the given parameters.</p>
<p>Any data that is sent to this stream buffer will be translated from <em>srcCode</em> to <em>destCode</em> and passed on to the given output stream.</p>
<p>If the given encodings are invalid, this stream will still forward data to the given output stream but no conversion will take place.</p>
<p>See the <em>iconv</em> documentation for information on what encodings are supported. For the GNU C library implementation, valid encodings can be found by running <code>iconv &ndash;list</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination output stream is already open.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination output stream. </td></tr>
    <tr><td class="paramname">srcCode</td><td>the character encoding for data that is to be written into this stream buffer. </td></tr>
    <tr><td class="paramname">destCode</td><td>the character encoding for the translated data that will subsequently be written to the destination output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this stream buffer on success, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga329db8d529368e9df9a4db80a0c22206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329db8d529368e9df9a4db80a0c22206">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::operator bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <code>true</code> if the pointee is non-null. </p>
<p>This is equivalent to testing whether <a class="el" href="group__utilities.html#gaa27b83072e5e62e6cfb7a263847cef81" title="Returns a raw pointer to the pointee.">get()</a> is not <code>null</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the pointee is non-null. </dd></dl>

</div>
</div>
<a id="ga07c8f6dae4bd35dcc31151ce4983c0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c8f6dae4bd35dcc31151ce4983c0ac">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is not equal to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given set are not equal. </dd></dl>

</div>
</div>
<a id="ga705cb6eb653d42906ebd4906e1c91fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga705cb6eb653d42906ebd4906e1c91fea">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this set is not equal to the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to test this against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given flag set are not identical. </dd></dl>

</div>
</div>
<a id="ga85f965de7f77768d0a42aebd19dc79c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f965de7f77768d0a42aebd19dc79c1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this set is not equal to the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to test this against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given flag are not identical. </dd></dl>

</div>
</div>
<a id="gaf7278049fcae718924e989c40712a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7278049fcae718924e989c40712a772">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the intersection of this set with the given set. </p>
<p>The result is a set containing precisely the elements that belong to both original sets. This set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to intersect with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection of this and the given set. </dd></dl>

</div>
</div>
<a id="gae6e284c3fad711ece12c85949b9b4be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6e284c3fad711ece12c85949b9b4be7">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise AND of this and the given flag set. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this and the given flag set. </dd></dl>

</div>
</div>
<a id="ga3a1faa44b5c7e8da126a094c42d1a386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a1faa44b5c7e8da126a094c42d1a386">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise AND of this set and the given flag. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this set and the given flag. </dd></dl>

</div>
</div>
<a id="ga480eca198478123a1df7a346521b2885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480eca198478123a1df7a346521b2885">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the intersection of this and the given bitmask. </p>
<p>Every bit that is unset in <em>other</em> will be unset in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to intersect with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga918523286af9b7f539edd5db61810a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918523286af9b7f539edd5db61810a42">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the intersection of this and the given bitmask. </p>
<p>Every bit that is unset in <em>other</em> will be unset in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to intersect with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga0496c109f9799f86661d224b61af5053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0496c109f9799f86661d224b61af5053">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the intersection of this and the given bitmask. </p>
<p>Every bit that is unset in <em>other</em> will be unset in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to intersect with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga9c40acd1ac7802074da229cab95071f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c40acd1ac7802074da229cab95071f9">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp; regina::BoolSet::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this set to be the intersection of this and the given set. </p>
<p>The result is a set containing precisely the elements that belong to both original sets. Note that this set will be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to intersect with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this set. </dd></dl>

</div>
</div>
<a id="ga1fe37cdb1630f885493788e551136918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe37cdb1630f885493788e551136918">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise AND with the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="ga164bcb94832ea7ec757db490c927df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164bcb94832ea7ec757db490c927df84">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise AND with the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="ga4a544d48d883723faea1781fa37f7e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a544d48d883723faea1781fa37f7e35">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;T*&gt;&amp; <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts this vector to a const std::vector, thus providing access to the entire const functionality of std::vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector, cast as a const std::vector. </dd></dl>

</div>
</div>
<a id="ga876b6ba52fe55cc7fab8902dc3032a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876b6ba52fe55cc7fab8902dc3032a29">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structregina_1_1FuncNew.html">regina::FuncNew</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object using the default constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>the newly created object. </dd></dl>

</div>
</div>
<a id="gabefa649b46a91fffa231e2226a367273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabefa649b46a91fffa231e2226a367273">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base &gt; </div>
<div class="memtemplate">
template&lt;typename Info , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Base* <a class="el" href="structregina_1_1NewFunction.html">regina::NewFunction</a>&lt; Base &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object of the subclass Info::Class. </p>
<dl class="section pre"><dt>Precondition</dt><dd>It is known in advance that Info::Class will be a subclass of <em>Base</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the Info::Class constructor. These will be copied/moved, so if you wish to pass a reference then you should wrap it in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object of the subclass Info::Class. </dd></dl>

</div>
</div>
<a id="ga60001582a0bf23f144c9e9ffe2e05bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60001582a0bf23f144c9e9ffe2e05bef">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::Less::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two sequences lexicographically. </p>
<p>The sequences need not be the same size.</p>
<p>This routine is identical to testing <code>(*a) &lt; (*b)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a pointer to the first of the two sequences to compare. </td></tr>
    <tr><td class="paramname">b</td><td>a pointer to the second of the two sequences to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if sequence <em>a</em> is strictly lexicographically smaller than sequence <em>b</em>, or <code>false</code> if <em>a</em> is either lexicographically greater than or equal to <em>b</em>. </dd></dl>

</div>
</div>
<a id="ga09cd62b1684626a0e265cf187830af29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cd62b1684626a0e265cf187830af29">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object using the copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object whose data should be passed to the copy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created object. </dd></dl>

</div>
</div>
<a id="gab5643e0a8cd53df884e9b155554d6983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5643e0a8cd53df884e9b155554d6983">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object using the copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer whose data should (after dereferencing) be passed to the copy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created object. </dd></dl>

</div>
</div>
<a id="gae77e4e77654b684db01fa142fdf0b14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77e4e77654b684db01fa142fdf0b14f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object using the <code>clone()</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer whose corresponding object should be cloned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created clone. </dd></dl>

</div>
</div>
<a id="ga9ed2b115d89b7072c51099a602c8c56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed2b115d89b7072c51099a602c8c56c">&#9670;&nbsp;</a></span>operator()() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comp  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref</a>&lt; T, Comp &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the objects to which the given pointers are pointing. </p>
<p>The two pointers are dereferenced, and then a function of type <em>Comp</em> (the second template argument) is used to compare the dereferenced objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr1</td><td>a pointer to the first object under examination. </td></tr>
    <tr><td class="paramname">ptr2</td><td>a pointer to the second object under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the first dereferenced object is less than the second, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga32d9389cdcc39355ff1dc7cb679ff496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d9389cdcc39355ff1dc7cb679ff496">&#9670;&nbsp;</a></span>operator()() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares the subsequences referred to by the given pair of iterators. </p>
<p>See the class notes for details on how each iterator is converted into a subsequence.</p>
<p>This bracket operator is identical to the <a class="el" href="group__utilities.html#ga10ef7e3d0cd8b70a6567394b042cb474" title="Lexicographically compares the subsequences referred to by the given pair of iterators.">less()</a> member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an iterator indicating the first of the two subsequences to compare. </td></tr>
    <tr><td class="paramname">b</td><td>an iterator indicating the second of the two subsequences to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the subsequence indicated by <em>a</em> is lexicographically smaller than the subsequence indicated by <em>b</em>. </dd></dl>

</div>
</div>
<a id="ga64c6a4dd0202e67e7daf23d75b91b901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c6a4dd0202e67e7daf23d75b91b901">&#9670;&nbsp;</a></span>operator()() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code>delete</code> upon the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer whose data should be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06e3007a16b086c30b6a0d8a4744d78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e3007a16b086c30b6a0d8a4744d78a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the sum of this and the given qitmask. </p>
<p>Each pair of qits is added modulo 4 (so, for instance, 2 + 3 = 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the qitmask to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="ga3de2c9955bf243995cbb53e691c3ee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3de2c9955bf243995cbb53e691c3ee75">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the sum of this and the given qitmask. </p>
<p>Each pair of qits is added modulo 4 (so, for instance, 2 + 3 = 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the qitmask to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="ga148855f3f979b4db22243fc5424ce2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148855f3f979b4db22243fc5424ce2c5">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the sum of this and the given tritmask. </p>
<p>When adding trits, any digit greater than 2 will simply be replaced with 2. That is:</p>
<ul>
<li>2+2 = 1+2 = 1+1 = 2;</li>
<li>0+x = x for any <em>x</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gaed6a9b5ba8db23a01f40b6570c5e0254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6a9b5ba8db23a01f40b6570c5e0254">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the sum of this and the given tritmask. </p>
<p>When adding trits, any digit greater than 2 will simply be replaced with 2. That is:</p>
<ul>
<li>2+2 = 1+2 = 1+1 = 2;</li>
<li>0+x = x for any <em>x</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="ga7d8941a3ce3fc72eb3b90c80e410f26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8941a3ce3fc72eb3b90c80e410f26f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the set difference of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be cleared in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="gac0faeab7b044c3cdac6f2ffa7b4f01bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0faeab7b044c3cdac6f2ffa7b4f01bc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the set difference of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be cleared in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="gaf9780d2045dc0e846384404f09fbd420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9780d2045dc0e846384404f09fbd420">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the set difference of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be cleared in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="gae4cf4a042a22ac4d9aba8ea6aef12934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4cf4a042a22ac4d9aba8ea6aef12934">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the difference of this and the given qitmask. </p>
<p>Each pair of qits is subtracted modulo 4 (so, for instance, 1 - 3 = 2).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the qitmask to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="ga6e8535c02e6c0b8c9961fcb617b0ce82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8535c02e6c0b8c9961fcb617b0ce82">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the difference of this and the given qitmask. </p>
<p>Each pair of qits is subtracted modulo 4 (so, for instance, 1 - 3 = 2).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the qitmask to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="ga9cfcceea1ad2fc07672e0dc6b370a1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfcceea1ad2fc07672e0dc6b370a1c1">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the difference of this and the given tritmask. </p>
<p>When subtracting trits, any "negative digit" will simply be replaced with zero. That is:</p>
<ul>
<li>2-0 = 2, 2-1 = 1, and 2-2 = 0;</li>
<li>1-0 = 1, and 1-1 = 1-2 = 0;</li>
<li>0-x = 0 for any <em>x</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="ga00d35733a6f1f56a2331ad5f56abd947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d35733a6f1f56a2331ad5f56abd947">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the difference of this and the given tritmask. </p>
<p>When subtracting trits, any "negative digit" will simply be replaced with zero. That is:</p>
<ul>
<li>2-0 = 2, 2-1 = 1, and 2-2 = 0;</li>
<li>1-0 = 1, and 1-1 = 1-2 = 0;</li>
<li>0-x = 0 for any <em>x</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the tritmask to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gabd8480d66f57f776986426a0ac2612e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8480d66f57f776986426a0ac2612e5">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is a proper subset of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a proper subset of the given set. </dd></dl>

</div>
</div>
<a id="gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2cf8ddaca05e1c3c7b1ec5dbca28cb5">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this sequence is lexicographically smaller than the given sequence. </p>
<p>The sequences need not be the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the sequence to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is strictly lexicographically smaller than <em>rhs</em>, or <code>false</code> if this is either lexicographically greater than or equal to <em>rhs</em>. </dd></dl>

</div>
</div>
<a id="ga687edae41955adbcf9e58c8cce90ea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687edae41955adbcf9e58c8cce90ea68">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga42e53899b74d99054f31035492d5890a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e53899b74d99054f31035492d5890a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0dc9ea5844d6e3886aae7e101929e85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc9ea5844d6e3886aae7e101929e85e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga7e140a57f469e663d87f1d3e14a90187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e140a57f469e663d87f1d3e14a90187">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p>The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gaa0c5c9157147686a6bfc401312b8d90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c5c9157147686a6bfc401312b8d90c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given sequence to the given output stream. </p>
<p>No newline will be written.</p>
<p>The sequence will be written in the form <code>(a, b, c, ...)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An object <em>x</em> of type <em>T</em> can be written to an output stream using the syntax <code>out &lt;&lt; x</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the sequence to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gab1fc8fedcb72b9db35901807c795486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fc8fedcb72b9db35901807c795486c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0a04e46c3516672d83a09e6f07b85876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a04e46c3516672d83a09e6f07b85876">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gabf61c8a34e52f0aeb02f200c88026c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf61c8a34e52f0aeb02f200c88026c1c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gac720197cc16b77f2647c6cfdeccd8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac720197cc16b77f2647c6cfdeccd8038">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga6860308597cdb850d5e1ea49d3eab8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6860308597cdb850d5e1ea49d3eab8d2">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the given bitmask. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in the given bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation does not compare bitmasks lexicographically; moreover, it only describes a partial order, not a total order. To compare bitmasks lexicographically, use <a class="el" href="group__utilities.html#ga026a973b46a3b950cd6d5f20d1733516" title="Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in...">lessThan()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the given bitmask. </dd></dl>

</div>
</div>
<a id="ga5f3a54782fa13a1e0bf358ace08f9aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3a54782fa13a1e0bf358ace08f9aa1">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the given bitmask. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in the given bitmask.</p>
<dl class="section warning"><dt>Warning</dt><dd>This operation does not compare bitmasks lexicographically; moreover, it only describes a partial order, not a total order. To compare bitmasks lexicographically, use <a class="el" href="group__utilities.html#ga96409a6adba0c43739fc4e7485779576" title="Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in...">lessThan()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the given bitmask. </dd></dl>

</div>
</div>
<a id="ga89f46a8e8142723df3f547745b5d2dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f46a8e8142723df3f547745b5d2dc4">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the given bitmask. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in the given bitmask.</p>
<dl class="section warning"><dt>Warning</dt><dd>This operation does not compare bitmasks lexicographically; moreover, it only describes a partial order, not a total order. To compare bitmasks lexicographically, use <a class="el" href="group__utilities.html#ga279087abf96d05ff4b6426075cd36df0" title="Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in...">lessThan()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the given bitmask. </dd></dl>

</div>
</div>
<a id="gac413c91408103de5680beceab07bb0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac413c91408103de5680beceab07bb0f0">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is a subset of (possibly equal to) the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a subset of the given set. </dd></dl>

</div>
</div>
<a id="ga2eb7e3b01f78ec1047ae19bbff3a6e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eb7e3b01f78ec1047ae19bbff3a6e01">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp; regina::BoolSet::operator= </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this set to the single member set containing the given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>the single element to include in this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this set. </dd></dl>

</div>
</div>
<a id="ga8c206093e6c4a66b9086507586595797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c206093e6c4a66b9086507586595797">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this bitmask to a copy of the given bitmask. </p>
<p>If this bitmask is invalid, this assignment operator can be used to initialise it with a length.</p>
<p>If this bitmask has already been initialised to a different length from that of the given bitmask, the length of this bitmask will be changed accordingly.</p>
<p>If the given bitmask is invalid, this bitmask will become invalid also. Invalid bitmasks must be assigned a length using <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or this assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga0e2d5050169f052b98f89d2437b2f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e2d5050169f052b98f89d2437b2f4f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this bitmask to a copy of the given bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga7d496925797c6695c84c70c1d12641f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d496925797c6695c84c70c1d12641f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this bitmask to a copy of the given bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga0a222e12e943deddbd9c11b78f69020d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a222e12e943deddbd9c11b78f69020d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&amp; regina::BoolSet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this set to be identical to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the set whose value this set will take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this set. </dd></dl>

</div>
</div>
<a id="ga1645ff76038359a31c8bee14d1fce15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1645ff76038359a31c8bee14d1fce15d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this flag set to contain a copy of the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the new value of this flag set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="ga5ef621a4ecbf76f27ea2c318cfa7fd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ef621a4ecbf76f27ea2c318cfa7fd11">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this into a copy of the given sequence. </p>
<p>Any existing elements of this sequence will be deleted.</p>
<p>This induces a deep copy of <em>src</em>, in that all of the elements of <em>src</em> will be copied into the new sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the sequence to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this sequence. </dd></dl>

</div>
</div>
<a id="gaa7c868cf9c50bcf2eb5360b95f58aa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c868cf9c50bcf2eb5360b95f58aa6b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&amp; <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Property.html">Property</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given property into this property. </p>
<p>If the given property is marked as known, its value will be copied and this property will also be marked as known. Otherwise this property will be marked as unknown.</p>
<p>For storage policies that do not allow copying (such as <a class="el" href="classregina_1_1StoreManagedPtr.html" title="A Property storage policy indicating that the property should be held by pointer and that the propert...">StoreManagedPtr</a>), any attempt to use this assignment operator will generate a compile error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValue</td><td>the property to copy into this property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this property. </dd></dl>

</div>
</div>
<a id="ga693f4df747e7ece678b2b81608bc7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693f4df747e7ece678b2b81608bc7224">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this qitmask to a copy of the given qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="ga34f1f03dd01f60244b7d83338bce6f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f1f03dd01f60244b7d83338bce6f33">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this qitmask to a copy of the given qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this qitmask. </dd></dl>

</div>
</div>
<a id="gaa228df50552bfebe61723bdfc76c7a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa228df50552bfebe61723bdfc76c7a88">&#9670;&nbsp;</a></span>operator=() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a>&amp; <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevent derived classes from accidentally calling the assignment operator. </p>

</div>
</div>
<a id="ga30127ffda526093d6451ff8a5642994b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30127ffda526093d6451ff8a5642994b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the default assignment operator. </p>

</div>
</div>
<a id="ga178425fc5038c06ee090068af7d5e40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga178425fc5038c06ee090068af7d5e40c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a>&amp; <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given property value. </p>
<p>This clones the given property's pointer, regardless of whether the property is known or unknown. </p>

</div>
</div>
<a id="ga0343a7f619fa6f2f7619614353642c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0343a7f619fa6f2f7619614353642c04">&#9670;&nbsp;</a></span>operator=() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreValue.html">StoreValue</a>&amp; <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StoreValue.html">StoreValue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given property value. </p>
<p>This clones the given property's value, regardless of whether the property is uninitialised and/or unknown. </p>

</div>
</div>
<a id="gabe1aae7216300e6fdf158023c0478c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe1aae7216300e6fdf158023c0478c9e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt;Iterator&gt;&amp; <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given function object into this object. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this function object. </dd></dl>

</div>
</div>
<a id="ga1a825ecda67bf32e02a60c589597f7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a825ecda67bf32e02a60c589597f7b8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this tritmask to a copy of the given tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tritmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gab7c42c114f2688fe001d1e19072375eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c42c114f2688fe001d1e19072375eb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this tritmask to a copy of the given tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tritmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tritmask. </dd></dl>

</div>
</div>
<a id="gad66e8504a4a552ddd3715ea808f7f48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad66e8504a4a552ddd3715ea808f7f48b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a> <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utilities.html#gac26d3f924e8799504cad495bd1705e6e">InitType</a>&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a new value to this property. </p>
<p>The property will be marked as known.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValue</td><td>the new value to assign to this property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new value of this property. </dd></dl>

</div>
</div>
<a id="ga66220529b527562478852bec0ac128fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66220529b527562478852bec0ac128fe">&#9670;&nbsp;</a></span>operator=() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given sequence to this sequence. </p>
<p>This is a fast (constant time) operation.</p>
<p>The sequence that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the sequence to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this sequence. </dd></dl>

</div>
</div>
<a id="ga6a206769cf7cf84ae780f4dfe53ce1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a206769cf7cf84ae780f4dfe53ce1d5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&amp; <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given vector into this vector. </p>
<p>The vector that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector. </dd></dl>

</div>
</div>
<a id="gacb64d581a06018304159344d5f71ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb64d581a06018304159344d5f71ba6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this flag set to contain precisely the given flag only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the new value of this flag set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="ga3d5ea92e31d07a86aa57ab5f07d92ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d5ea92e31d07a86aa57ab5f07d92ca6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given bitmask are identical. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given bitmask are identical. </dd></dl>

</div>
</div>
<a id="gabd0d688fc803b4b9b8c1131a6feb479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd0d688fc803b4b9b8c1131a6feb479f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given bitmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given bitmask are identical. </dd></dl>

</div>
</div>
<a id="gad180422f64fb3621628f130525d7eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad180422f64fb3621628f130525d7eeec">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given bitmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given bitmask are identical. </dd></dl>

</div>
</div>
<a id="ga5963ab17d3d65ae2ed5643bbd2320312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5963ab17d3d65ae2ed5643bbd2320312">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is equal to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given set are equal. </dd></dl>

</div>
</div>
<a id="ga8a3851b68542bf8267e5c437bd079b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3851b68542bf8267e5c437bd079b65">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this set is precisely equal to the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to test this against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given flag set are identical. </dd></dl>

</div>
</div>
<a id="gac7de7f119637c244f3efd6cefd66af47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7de7f119637c244f3efd6cefd66af47">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given sequence are identical. </p>
<p>The sequences need not be the same size, though if the sizes are different then this routine will return <code>false</code> immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the sequence to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given sequence are identical. </dd></dl>

</div>
</div>
<a id="gac436127cd2b90dd4a6d541ab49790729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac436127cd2b90dd4a6d541ab49790729">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given qitmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given qitmask are identical. </dd></dl>

</div>
</div>
<a id="ga02c798712b57c0ea0b00b4b384eeb375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02c798712b57c0ea0b00b4b384eeb375">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given qitmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the qitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given qitmask are identical. </dd></dl>

</div>
</div>
<a id="gaf542e23b9628478215c030ef1bee2842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf542e23b9628478215c030ef1bee2842">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given tritmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tritmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given tritmask are identical. </dd></dl>

</div>
</div>
<a id="gaeb4a52252baf6d21858a1a4f6e9bde44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4a52252baf6d21858a1a4f6e9bde44">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given tritmask are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tritmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given tritmask are identical. </dd></dl>

</div>
</div>
<a id="ga300db79cc50808037445a254712421f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga300db79cc50808037445a254712421f0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this set is precisely equal to the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to test this against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given flag are identical. </dd></dl>

</div>
</div>
<a id="ga2bc0bc1b1a725b132b40e840cf1093a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc0bc1b1a725b132b40e840cf1093a6">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is a proper superset of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a proper superset of the given set. </dd></dl>

</div>
</div>
<a id="ga7795fcb6e7fd91b8dec0b9ea2836e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7795fcb6e7fd91b8dec0b9ea2836e068">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BoolSet::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this set is a superset of (possibly equal to) the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a superset of the given set. </dd></dl>

</div>
</div>
<a id="ga420d07f66ec9d7fa8bc2c04b41927cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420d07f66ec9d7fa8bc2c04b41927cbe">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the element at the given index in the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the requested element; this must be between 0 and <a class="el" href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe" title="Returns the number of elements in this sequence.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested element. </dd></dl>

</div>
</div>
<a id="ga8b19ab4d75e4b847d1205ece56126420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b19ab4d75e4b847d1205ece56126420">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a copy of the element at the given index in the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the requested element; this must be between 0 and <a class="el" href="group__utilities.html#gafe069cf7dc53da78a82b6d0fb8c0bbbe" title="Returns the number of elements in this sequence.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the requested element. </dd></dl>

</div>
</div>
<a id="ga37bdbe4fadeef248ff935538f43fa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37bdbe4fadeef248ff935538f43fa2e6">&#9670;&nbsp;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the symmetric difference of this set and the given set. </p>
<p>The result is a set containing precisely the elements that belong to one but not both of the original sets. This set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set whose symmetric difference with this set is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symmetric difference of this and the given set. </dd></dl>

</div>
</div>
<a id="ga9e9b5f8c9693df89efc7e7908988e139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e9b5f8c9693df89efc7e7908988e139">&#9670;&nbsp;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise XOR of this and the given flag set. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this and the given flag set. </dd></dl>

</div>
</div>
<a id="ga7fbec982386a0442a23fd2997f213fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbec982386a0442a23fd2997f213fe3">&#9670;&nbsp;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise XOR of this set and the given flag. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this set and the given flag. </dd></dl>

</div>
</div>
<a id="ga5d3a360a592c0f293a5dca36bd43195a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3a360a592c0f293a5dca36bd43195a">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the exclusive disjunction (XOR) of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be flipped in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga77e1b6464665655c23c812d5833888a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e1b6464665655c23c812d5833888a6">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the exclusive disjunction (XOR) of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be flipped in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga776aed118fc359f147a04485d528d79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga776aed118fc359f147a04485d528d79b">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the exclusive disjunction (XOR) of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be flipped in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga450e466ac9ddfd81c6ac528beceb13bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga450e466ac9ddfd81c6ac528beceb13bd">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp; regina::BoolSet::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this set to be the symmetric difference of this and the given set. </p>
<p>The result is a set containing precisely the elements that belong to one but not both of the original sets. Note that this set will be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set whose symmetric difference with this set is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this set. </dd></dl>

</div>
</div>
<a id="ga09321f12b9771675813a8d32b2709a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09321f12b9771675813a8d32b2709a73">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise XOR with the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="gae18d3d3f0b10217398d5262f5efe6990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae18d3d3f0b10217398d5262f5efe6990">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise XOR with the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="ga1d4b4067828ce6b2147fe37bf539174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4b4067828ce6b2147fe37bf539174f">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the union of this set with the given set. </p>
<p>The result is a set containing precisely the elements that belong to either of the original sets. This set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to union with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the union of this and the given set. </dd></dl>

</div>
</div>
<a id="gad53a9ace1c8cec9867f27469d2faf27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad53a9ace1c8cec9867f27469d2faf27e">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of this and the given flag set. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this and the given flag set. </dd></dl>

</div>
</div>
<a id="ga382b72837046a4a8a02bd6138539bd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382b72837046a4a8a02bd6138539bd4f">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of this set and the given flag. </p>
<p>This flag set is not changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of this set and the given flag. </dd></dl>

</div>
</div>
<a id="ga10fc0370077988c012d239f8140a5d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10fc0370077988c012d239f8140a5d0f">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the union of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be set in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to union with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="gace764d52a777b69d26a42359b3832a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace764d52a777b69d26a42359b3832a60">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the union of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be set in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to union with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="ga8d130ef4b13333ac37492c38a97c9ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d130ef4b13333ac37492c38a97c9ddc">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt;T, U&gt;&amp; <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the union of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be set in this bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to union with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a id="gaf72593807529d07923bf50f0ac040dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf72593807529d07923bf50f0ac040dc7">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp; regina::BoolSet::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this set to be the union of this and the given set. </p>
<p>The result is a set containing precisely the elements that belong to either of the original sets. Note that this set will be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set to union with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this set. </dd></dl>

</div>
</div>
<a id="ga5027e2ce0bf5fb514580fa851c7a38c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5027e2ce0bf5fb514580fa851c7a38c5">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise OR with the given flag set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag set to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="gad51bcad196e45e244672a043ead7c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad51bcad196e45e244672a043ead7c505">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;T&gt;&amp; <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; T &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes this flag set by taking a bitwise OR with the given flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the flag to combine with this set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this flag set. </dd></dl>

</div>
</div>
<a id="gaac382d5c166f202d9a54b831298dd239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac382d5c166f202d9a54b831298dd239">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complement of this set. </p>
<p>The result is a set containing precisely the elements that this set does not contain. This set is not changed.</p>
<dl class="section return"><dt>Returns</dt><dd>the complement of this set. </dd></dl>

</div>
</div>
<a id="ga14a3b54d5a102597eb6abfbb173bce7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a3b54d5a102597eb6abfbb173bce7b">&#9670;&nbsp;</a></span>overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_type regina::i18n::IConvStreamBuffer::overflow </td>
          <td>(</td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends buffered data to the destination output stream, converting between character sets en route. </p>
<p>The buffer will be flushed as far as possible, and any invalid characters will be replaced with one or more question marks. If the buffer ends in an incomplete multibyte character, this incomplete character will be held back (since it presumably needs to be combined with later input).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an extra character to send that did not fit in the internal buffer, or EOF if we simply wish to flush the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or EOF on error. </dd></dl>

</div>
</div>
<a id="gab060d4e56a2a79ad6acbb1911e28ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab060d4e56a2a79ad6acbb1911e28ec1b">&#9670;&nbsp;</a></span>parse_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParser::parse_chunk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the given chunk of XML. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the chunk of XML to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6565a33c4a2fb6eec4da4b8810823de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6565a33c4a2fb6eec4da4b8810823de2">&#9670;&nbsp;</a></span>parse_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::xml::XMLParser::parse_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">XMLParserCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>chunkSize</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses an entire XML file. </p>
<p>The given stream will be read from until end-of-file is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>the object providing the routines to call when particular XML components are encountered during parsing. </td></tr>
    <tr><td class="paramname">file</td><td>the stream from which the raw XML will be read. </td></tr>
    <tr><td class="paramname">chunkSize</td><td>the number of characters to read and process at a time (this is the size of each string that will be passed to <a class="el" href="group__utilities.html#gab060d4e56a2a79ad6acbb1911e28ec1b" title="Parses the given chunk of XML.">parse_chunk()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38706401f222b808a6d225047e2d1c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38706401f222b808a6d225047e2d1c3e">&#9670;&nbsp;</a></span>Property() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::<a class="el" href="classregina_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This property is initially marked as unknown. </p>

</div>
</div>
<a id="gafc2acc5d3766e943036cde381d723d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2acc5d3766e943036cde381d723d03">&#9670;&nbsp;</a></span>Property() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::<a class="el" href="classregina_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Property.html">Property</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new clone of the given property. </p>
<p>If the given property is marked as known, its value will be copied and this property will also be marked as known. Otherwise this property will be marked as unknown.</p>
<p>This copy constructor is slightly inefficient, in that it first default-constructs its own held value, and then if <em>newValue</em> is known it will copy that value across.</p>
<p>For storage policies that do not allow copying (such as <a class="el" href="classregina_1_1StoreManagedPtr.html" title="A Property storage policy indicating that the property should be held by pointer and that the propert...">StoreManagedPtr</a>), any attempt to use this copy constructor will generate a compile error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValue</td><td>the property to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f9aea50a9fe46aa44b25d3413fb4d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f9aea50a9fe46aa44b25d3413fb4d86">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given item onto the end of this vector. </p>
<p>The array index stored inside <em>item</em> will be modified accordingly.</p>
<p>The caller retains reponsibility for the ownership of <em>item</em>. This class will make no attempt to deallocate <em>item</em> when it is removed or when this vector is eventually destroyed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given item does not already belong to some other <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>the item to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aac762c42dd7e865046856639dfb125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aac762c42dd7e865046856639dfb125">&#9670;&nbsp;</a></span>Qitmask1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new qitmask with all qits set to 0. </p>

</div>
</div>
<a id="gadf0607c0b9e71a43dca2bf3e8a62f06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0607c0b9e71a43dca2bf3e8a62f06b">&#9670;&nbsp;</a></span>Qitmask1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the qitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9fc8c1873b3031e713af54c6168d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9fc8c1873b3031e713af54c6168d74e">&#9670;&nbsp;</a></span>Qitmask2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new qitmask with all qits set to 0. </p>

</div>
</div>
<a id="gacfc1ffc47323a01491484ac1b39ea081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfc1ffc47323a01491484ac1b39ea081">&#9670;&nbsp;</a></span>Qitmask2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given qitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the qitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb6db55f93ed9723b2da068ebdfe2692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6db55f93ed9723b2da068ebdfe2692">&#9670;&nbsp;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int regina::RandomEngine::rand </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience function that returns a random integer modulo <em>range</em>, in a thread-safe manner. </p>
<p>The result will be between 0 and (<em>range</em> - 1) inclusive, and all such integers should be returned with equal probability.</p>
<p>This is expensive because it locks and unlocks the internal mutex. If you need to create many random numbers in quick succession, consider creating a single <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> object and accessing <a class="el" href="group__utilities.html#gabe9274be75059680fab7d6dee5879d3b" title="Provides access to Regina&#39;s global uniform random bit generator (URBG).">engine()</a> directly using the standard C++ randomness functions.</p>
<dl class="section user"><dt>Python</dt><dd>The integer type <em>Int</em> will be treated as <code>long</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>a native integer type (e.g., <code>int</code>, <code>long</code>, <code>size_t</code>, <code>long long</code>, etc.); this may be either signed or unsigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the size of the range of possible results; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random integer between 0 and (<em>range</em> - 1) inclusive. </dd></dl>

</div>
</div>
<a id="ga195d0c880dc42a14fd997612fe8fa327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga195d0c880dc42a14fd997612fe8fa327">&#9670;&nbsp;</a></span>RandomEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::RandomEngine::RandomEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that locks the internal mutex. </p>
<p>The mutex will be unlocked when this object is destroyed.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga2b63e99964f1d0705375512a31cb4e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b63e99964f1d0705375512a31cb4e2d">&#9670;&nbsp;</a></span>refill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::refill </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties this vector and refills it with the given range of items. </p>
<p>Calling this routine is equivalent to calling clear() followed by <a class="el" href="group__utilities.html#ga0f9aea50a9fe46aa44b25d3413fb4d86" title="Pushes the given item onto the end of this vector.">push_back()</a> for each item in the range from <em>begin</em> to <em>end</em>. Its implementation, however, is a little more efficient.</p>
<p>The algorithm only makes a single pass through the given range of iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>an input iterator type, whose dereference operator returns a pointer of type <code>T*</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the range of items with which to refill this vector. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the range of items with which to refill this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92caac371f7faab4d34f87165eca8acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92caac371f7faab4d34f87165eca8acd">&#9670;&nbsp;</a></span>removeFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::removeFalse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>false</code> from this set if it is present. </p>

</div>
</div>
<a id="gafeb6d2dcc0e2240ad00223deb31b4a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb6d2dcc0e2240ad00223deb31b4a88">&#9670;&nbsp;</a></span>removeTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::removeTrue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>true</code> from this set if it is present. </p>

</div>
</div>
<a id="gab638db40d8e39c071328e10dee94b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab638db40d8e39c071328e10dee94b81a">&#9670;&nbsp;</a></span>reseedWithDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::RandomEngine::reseedWithDefault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reseeds the global uniform random bit generator using the default seed. </p>
<p>This should make the sequence of random bits completely predictable between runs of the same program on the same machine. (Note that even when using the same seed, different operating systems, architectures and/or compilers may produce different random bits).</p>
<p>Regina seeds the global uniform random bit generator in this way on startup, and so typically you would not need to call this routine yourself.</p>
<p>This routine is thread-safe, and it locks the internal mutex while it runs. </p>

</div>
</div>
<a id="ga65695f8761c422a85533289ae8bdf16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65695f8761c422a85533289ae8bdf16b">&#9670;&nbsp;</a></span>reseedWithHardware()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::RandomEngine::reseedWithHardware </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reseeds the global uniform random bit generator using hardware entropy. </p>
<p>This should make the sequence of random bits unpredictable (and, in particular, different between runs of your program).</p>
<p>Regina does <em>not</em> do this by default.</p>
<p>This routine is thread-safe, and it locks the internal mutex while it runs. </p>

</div>
</div>
<a id="ga1f54e460a4fe7ff7304fd27390d77340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f54e460a4fe7ff7304fd27390d77340">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The length of this bitmask must already have been initialised. In particular, if the default constructor was used, you must call the one-argument <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> before you can use this routine. </dd></dl>

</div>
</div>
<a id="ga81593e6006c05fe3a0a5ec37d469bce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81593e6006c05fe3a0a5ec37d469bce0">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>

</div>
</div>
<a id="gab3a015fb67f2612f02604c1e520ac0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a015fb67f2612f02604c1e520ac0b1">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>

</div>
</div>
<a id="gafd8f1dd47bcdd7dbc0074fd99335155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8f1dd47bcdd7dbc0074fd99335155e">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all qits of this qitmask to 0. </p>

</div>
</div>
<a id="ga184cd38f75e3df9f2047a79f45be7eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184cd38f75e3df9f2047a79f45be7eb3">&#9670;&nbsp;</a></span>reset() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all qits of this qitmask to 0. </p>

</div>
</div>
<a id="ga1e47968d69fb5ed044a631aa37953344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e47968d69fb5ed044a631aa37953344">&#9670;&nbsp;</a></span>reset() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all trits of this tritmask to 0. </p>

</div>
</div>
<a id="ga173e9350258f3241cd021a5784650aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173e9350258f3241cd021a5784650aee">&#9670;&nbsp;</a></span>reset() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all trits of this tritmask to 0. </p>

</div>
</div>
<a id="ga5529fe127a3a6d4c47c93115efa43a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5529fe127a3a6d4c47c93115efa43a46">&#9670;&nbsp;</a></span>reset() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this bitmask to the given length and sets all bits to <code>false</code>. </p>
<p>This routine can be used to change the length (number of bits) of the bitmask if desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of bits to store in this bitmask; this must be at least one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4233786770e1fb175876327804d8a1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4233786770e1fb175876327804d8a1ea">&#9670;&nbsp;</a></span>reset() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>
<p>The integer argument is merely for compatibility with <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">Bitmask::reset(size_t)</a>, and will be ignored. </p>

</div>
</div>
<a id="gae8a9ec7d484ed69b620787c4c9c86d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8a9ec7d484ed69b620787c4c9c86d54">&#9670;&nbsp;</a></span>reset() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>
<p>The integer argument is merely for compatibility with <a class="el" href="group__utilities.html#ga5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">Bitmask::reset(size_t)</a>, and will be ignored. </p>

</div>
</div>
<a id="ga165989a691406469cf5132c4e5816ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga165989a691406469cf5132c4e5816ce4">&#9670;&nbsp;</a></span>reset() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets this to point to the given object. </p>
<p>This behaves in a similar manner to destroying the old safe pointer and constructing a new one: in particular, the old pointee may be destroyed if it meets the conditions outlined in the class notes above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>the new pointee. This may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf10e603a3e56ad8a8ce3edaf5982d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10e603a3e56ad8a8ce3edaf5982d465">&#9670;&nbsp;</a></span>SafePointeeBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; T &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="gaca00acf92239348375b90afddf164cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca00acf92239348375b90afddf164cb6">&#9670;&nbsp;</a></span>SafePointeeBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; T &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SafePointeeBase.html">SafePointeeBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevent derived classes from accidentally calling the copy constructor. </p>
<p>A derived class' copy constructor by default calls the protected default constructor, which it should because it sets the refCount_ to zero on the copied object. </p>

</div>
</div>
<a id="gaf33b066afbad6a25be00878c7cf3a7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf33b066afbad6a25be00878c7cf3a7e6">&#9670;&nbsp;</a></span>SafePtr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1SafePtr.html">SafePtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new null pointer. </p>

</div>
</div>
<a id="gaa8eb187bbdad812403168457626247f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8eb187bbdad812403168457626247f8">&#9670;&nbsp;</a></span>SafePtr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1SafePtr.html">SafePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SafePtr.html">SafePtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>This constructor can also be used to cast a <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> for a derived class <em>Y</em> to a <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> for a base class <em>T</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the class <em>T</em> (whose constructor is called) is a base class of <em>Y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the pointer to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75651d857fbb4f708f91c06a4cc178dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75651d857fbb4f708f91c06a4cc178dd">&#9670;&nbsp;</a></span>SafePtr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1SafePtr.html">SafePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new safe pointer that points to the given object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>the pointee. This may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1cd2494dcfac16c229ed558770b05b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1cd2494dcfac16c229ed558770b05b7">&#9670;&nbsp;</a></span>set() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::set </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits in the given sorted list to the given value. </p>
<p>This is a convenience routine for setting many bits at once. The indices of the bits to set should be sorted and stored in some container, such as a std::set or a C-style array. This routine takes iterators over this container, and sets the bits at the corresponding indices to the given value.</p>
<p>For example, the following code would set bits 3, 5 and 6 to <code>true:</code> </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned&gt; indices;</div>
<div class="line">indices.push(3); indices.push(5); indices.push(6);</div>
<div class="line">bitmask.set(indices.begin(), indices.end(), <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Likewise, the following code would set bits 1, 4 and 7 to <code>false:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> indices[3] = { 1, 4, 7 };</div>
<div class="line">bitmask.set(indices, indices + 3, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>All other bits of this bitmask are unaffected by this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>ForwardIterator</em> is a forward iterator type that iterates over integer values. </dd>
<dd>
The list of indices described by these iterators is in <em>sorted</em> order. This is to allow optimisations for larger bitmask types. </dd>
<dd>
All indices in the given list are at least zero and strictly less than the length of this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBegin</td><td>the beginning of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">indexEnd</td><td>the end of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to each of the corresponding bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92074d7aac61cedf9821549431096425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92074d7aac61cedf9821549431096425">&#9670;&nbsp;</a></span>set() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits in the given sorted list to the given value. </p>
<p>This is a convenience routine for setting many bits at once. The indices of the bits to set should be sorted and stored in some container, such as a std::set or a C-style array. This routine takes iterators over this container, and sets the bits at the corresponding indices to the given value.</p>
<p>For example, the following code would set bits 3, 5 and 6 to <code>true:</code> </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned&gt; indices;</div>
<div class="line">indices.push(3); indices.push(5); indices.push(6);</div>
<div class="line">bitmask.set(indices.begin(), indices.end(), <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Likewise, the following code would set bits 1, 4 and 7 to <code>false:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> indices[3] = { 1, 4, 7 };</div>
<div class="line">bitmask.set(indices, indices + 3, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>All other bits of this bitmask are unaffected by this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>ForwardIterator</em> is a forward iterator type that iterates over integer values. </dd>
<dd>
The list of indices described by these iterators is in <em>sorted</em> order. This is to allow optimisations for larger bitmask types. </dd>
<dd>
All indices in the given list are between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBegin</td><td>the beginning of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">indexEnd</td><td>the end of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to each of the corresponding bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd06d74f1f2ea32d7042581bd1a027ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd06d74f1f2ea32d7042581bd1a027ed">&#9670;&nbsp;</a></span>set() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::set </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits in the given sorted list to the given value. </p>
<p>This is a convenience routine for setting many bits at once. The indices of the bits to set should be sorted and stored in some container, such as a std::set or a C-style array. This routine takes iterators over this container, and sets the bits at the corresponding indices to the given value.</p>
<p>For example, the following code would set bits 3, 5 and 6 to <code>true:</code> </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned&gt; indices;</div>
<div class="line">indices.push(3); indices.push(5); indices.push(6);</div>
<div class="line">bitmask.set(indices.begin(), indices.end(), <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Likewise, the following code would set bits 1, 4 and 7 to <code>false:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> indices[3] = { 1, 4, 7 };</div>
<div class="line">bitmask.set(indices, indices + 3, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>All other bits of this bitmask are unaffected by this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>ForwardIterator</em> is a forward iterator type that iterates over integer values. </dd>
<dd>
The list of indices described by these iterators is in <em>sorted</em> order. This is to allow optimisations for larger bitmask types. </dd>
<dd>
All indices in the given list are between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBegin</td><td>the beginning of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">indexEnd</td><td>the end of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to each of the corresponding bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6c90eddb88301ece1e984652f1993cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6c90eddb88301ece1e984652f1993cc">&#9670;&nbsp;</a></span>set() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given bit of this bitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to set; this must be at least zero and strictly less than the length of this bitmask. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab786d10efbbfb9d3dfe8449cd83113df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab786d10efbbfb9d3dfe8449cd83113df">&#9670;&nbsp;</a></span>set() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given bit of this bitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to set; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1aca7ed1d85bb568d00283e91e503e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aca7ed1d85bb568d00283e91e503e8b">&#9670;&nbsp;</a></span>set() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given bit of this bitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to set; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga10de71017305e728925cbe1a6b1128d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10de71017305e728925cbe1a6b1128d4">&#9670;&nbsp;</a></span>set() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given qit of this qitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which qit to set; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th qit; this must be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b9e402f178d8448653aa1509c2d694e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b9e402f178d8448653aa1509c2d694e">&#9670;&nbsp;</a></span>set() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2</a>&lt; T, U &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given qit of this qitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which qit to set; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th qit; this must be 0, 1, 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac82c214a1041434f0614829b9700e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac82c214a1041434f0614829b9700e54">&#9670;&nbsp;</a></span>set() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given trit of this tritmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which trit to set; this must be between 0 and (8 * sizeof(<em>T</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th trit; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga476e935f3340a3adbf227a74e7b661ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476e935f3340a3adbf227a74e7b661ab">&#9670;&nbsp;</a></span>set() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given trit of this tritmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which trit to set; this must be between 0 and (8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) - 1) inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th trit; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf28ae1667cbb6ae1e09d9960aa9eb08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf28ae1667cbb6ae1e09d9960aa9eb08d">&#9670;&nbsp;</a></span>setByteCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BoolSet::setByteCode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this boolean set to that represented by the given byte code. </p>
<p>See <a class="el" href="group__utilities.html#ga26b4dbce39b90687e88117171c5ef8a2" title="Returns the byte code representing this boolean set.">byteCode()</a> for more information on byte codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>code</em> is 0, 1, 2 or 3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the byte code that will determine the new value of this set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe069cf7dc53da78a82b6d0fb8c0bbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe069cf7dc53da78a82b6d0fb8c0bbbe">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of elements in this sequence. </p>
<p>This can be changed (in a destructive way) by calling <a class="el" href="group__utilities.html#ga1c716ebe16604586927a18a795942197" title="Resizes this sequence to contain the given number of elements.">init()</a>. </p>

</div>
</div>
<a id="gae5ecc57214fe2a50cfeaf33583a1984e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ecc57214fe2a50cfeaf33583a1984e">&#9670;&nbsp;</a></span>start_document()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::start_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1xml_1_1XMLParser.html">XMLParser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called at the start of the document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>the XML parser that is currently parsing this document. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#gaee7d93505de821060e42e74af919a1a1">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="gae250b751104ecc561d807a5c5d93c747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae250b751104ecc561d807a5c5d93c747">&#9670;&nbsp;</a></span>start_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::start_element </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an element's opening tag is encountered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the name of the tag. </td></tr>
    <tr><td class="paramname">p</td><td>a dictionary of all the properties of the tag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#gaa3e5cd8e3ce4ad20a578ab073bb87abe">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="ga4056bad007750e92b40959aca2c4f987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4056bad007750e92b40959aca2c4f987">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given C++ string begins with the given prefix. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the full C++ string to examine. </td></tr>
    <tr><td class="paramname">prefix</td><td>the prefix whose presence we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>str</em> begins with <em>prefix</em>. </dd></dl>

</div>
</div>
<a id="gad051730c9a5cb575ab04257404db23bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad051730c9a5cb575ab04257404db23bf">&#9670;&nbsp;</a></span>StoreConstPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that sets the held pointer to <code>null</code>. </p>

</div>
</div>
<a id="gadbc9afbfb48b039d7293950043a6df23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc9afbfb48b039d7293950043a6df23">&#9670;&nbsp;</a></span>StoreConstPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a clone of the given property value. </p>
<p>This clones the given property's pointer, regardless of whether the property is known or unknown. </p>

</div>
</div>
<a id="ga14f14592870ec2129b9f5f45fc9262e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f14592870ec2129b9f5f45fc9262e0">&#9670;&nbsp;</a></span>StoreManagedPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::<a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that sets the held pointer to <code>null</code>. </p>

</div>
</div>
<a id="ga2195b7064cc0a15ec1cf53a810b251b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2195b7064cc0a15ec1cf53a810b251b2">&#9670;&nbsp;</a></span>StoreValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::<a class="el" href="classregina_1_1StoreValue.html">StoreValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised property value. </p>

</div>
</div>
<a id="gaa373bf5625f8f6ff525cffc0780ec532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa373bf5625f8f6ff525cffc0780ec532">&#9670;&nbsp;</a></span>StoreValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::<a class="el" href="classregina_1_1StoreValue.html">StoreValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StoreValue.html">StoreValue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a clone of the given property value. </p>
<p>This clones the given property's value, regardless of whether the property is uninitialised and/or unknown. </p>

</div>
</div>
<a id="ga36927634ca1155f6e5fb60b3ce8f2278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36927634ca1155f6e5fb60b3ce8f2278">&#9670;&nbsp;</a></span>stringToToken() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="ga80c74082b6559d30c0073ff0a889e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c74082b6559d30c0073ff0a889e09e">&#9670;&nbsp;</a></span>stringToToken() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="gaa678d35fabfebccce72406d01076829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa678d35fabfebccce72406d01076829c">&#9670;&nbsp;</a></span>stripWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips all whitespace from the beginning and end of the given C++ string. </p>
<p>The new stripped string is returned; the original string is not altered.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be stripped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting stripped string. </dd></dl>

</div>
</div>
<a id="ga61ea966075c340b411ef07cc5aee1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ea966075c340b411ef07cc5aee1213">&#9670;&nbsp;</a></span>subscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::subscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode subscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga48b0d171526768d7d0b0d057aa14cce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b0d171526768d7d0b0d057aa14cce8">&#9670;&nbsp;</a></span>SubsequenceCompareFirstPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given function object into this new object. </p>

</div>
</div>
<a id="gac1b72cf5b5d55192be402c2b2c6d2f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b72cf5b5d55192be402c2b2c6d2f08">&#9670;&nbsp;</a></span>SubsequenceCompareFirstPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a>&lt; Iterator &gt;::<a class="el" href="classregina_1_1LightweightSequence_1_1SubsequenceCompareFirstPtr.html">SubsequenceCompareFirstPtr</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new function object. </p>
<p>As explained in the class notes, this object compares just some, not necessarily all, elements of two sequences. The indices of the elements to compare should be passed to this constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class merely copies the pointer <em>sub</em>, and does not take a deep copy. The caller of this routine must ensure that the array <em>sub</em> has a lifespan at least as long as this function object and any function objects that are copied from it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSub</td><td>the number of elements to compare from each sequence. </td></tr>
    <tr><td class="paramname">sub</td><td>the indices of the elements to compare from each sequence; that is, the indices <em>i0</em>, <em>i1</em>, ..., as described in the class notes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92f5f4f8be21a36101e67ed4b461ba19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f5f4f8be21a36101e67ed4b461ba19">&#9670;&nbsp;</a></span>superscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::superscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode superscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga15205ec8d11115bd87efabadf1bbb92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15205ec8d11115bd87efabadf1bbb92c">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81bcfc6fe03b9e15de50e59b11d954b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bcfc6fe03b9e15de50e59b11d954b3">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this with the given property. </p>
<p>Both the known status and the values (if known) will swapped in the most efficient manner that the compiler is aware of.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the property to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga834582f8a4b313cf25b6638ec316392c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834582f8a4b313cf25b6638ec316392c">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StoreConstPtr.html">StoreConstPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the value to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a001c1dfb31cef29d2642cdba7ff358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a001c1dfb31cef29d2642cdba7ff358">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the value to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07b2334c9769b340dce136f127d6f1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b2334c9769b340dce136f127d6f1fc">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StoreValue.html">StoreValue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the value to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd2ef9bdf704ed5c23eea6db04fb40e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd2ef9bdf704ed5c23eea6db04fb40e4">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::i18n::IConvStreamBuffer::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all output buffers. </p>
<p>The buffers for both this stream and the destination output stream will be flushed.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
<a id="ga34961eca24ca18e8bc5ae976e58d6a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34961eca24ca18e8bc5ae976e58d6a79">&#9670;&nbsp;</a></span>TrieSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty collection of sets. </p>

</div>
</div>
<a id="gaa52f7e27267a3df7f91b55b7d71befdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52f7e27267a3df7f91b55b7d71befdc">&#9670;&nbsp;</a></span>Tritmask1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tritmask with all trits set to 0. </p>

</div>
</div>
<a id="ga03a424cc6883e3a067259f1a11e12eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a424cc6883e3a067259f1a11e12eee">&#9670;&nbsp;</a></span>Tritmask1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1</a>&lt; T &gt;::<a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the tritmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8bdd5494f5996421b0ab818eeabaac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8bdd5494f5996421b0ab818eeabaac6">&#9670;&nbsp;</a></span>Tritmask2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tritmask with all trits set to 0. </p>

</div>
</div>
<a id="ga68be020c472dda03a9cd1a3d76e9641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68be020c472dda03a9cd1a3d76e9641f">&#9670;&nbsp;</a></span>Tritmask2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2</a>&lt; T, U &gt;::<a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given tritmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the tritmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53c4ab5b72cca8ed16fa05dbca51731c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c4ab5b72cca8ed16fa05dbca51731c">&#9670;&nbsp;</a></span>truncate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::truncate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>. </p>
<p>In other words, this routine "truncates" this bitmask to the given number of bits.</p>
<p>This routine does not change the <em>length</em> of this bitmask (as passed to the contructor or to <a class="el" href="group__utilities.html#ga1f54e460a4fe7ff7304fd27390d77340" title="Sets all bits of this bitmask to false.">reset()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>numBits</em> is at most the length of this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numBits</td><td>the number of bits that will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c6efe33ae81b8d209be6b0126ef8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c6efe33ae81b8d209be6b0126ef8cf3">&#9670;&nbsp;</a></span>truncate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1</a>&lt; T &gt;::truncate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>. </p>
<p>In other words, this routine "truncates" this bitmask to the given number of bits.</p>
<p>This routine does not change the <em>length</em> of this bitmask (as passed to the contructor or to <a class="el" href="group__utilities.html#ga81593e6006c05fe3a0a5ec37d469bce0" title="Sets all bits of this bitmask to false.">reset()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numBits</td><td>the number of bits that will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga139f8b0dbf0790e7fef07dcb1de5a33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga139f8b0dbf0790e7fef07dcb1de5a33d">&#9670;&nbsp;</a></span>truncate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2</a>&lt; T, U &gt;::truncate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>. </p>
<p>In other words, this routine "truncates" this bitmask to the given number of bits.</p>
<p>This routine does not change the <em>length</em> of this bitmask (as passed to the contructor or to <a class="el" href="group__utilities.html#gab3a015fb67f2612f02604c1e520ac0b1" title="Sets all bits of this bitmask to false.">reset()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numBits</td><td>the number of bits that will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga830d349d83cfdb64fee00d58d65f4aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830d349d83cfdb64fee00d58d65f4aab">&#9670;&nbsp;</a></span>underflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IConvStreamBuffer::int_type regina::i18n::IConvStreamBuffer::underflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply returns EOF (since this is not an input stream). </p>
<dl class="section return"><dt>Returns</dt><dd>EOF. </dd></dl>

</div>
</div>
<a id="ga9952c5bb8780ca8f54d450350cc640d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9952c5bb8780ca8f54d450350cc640d7">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p>The substring from <em>s</em> until just before the pointer that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return a pointer to the null terminator of <em>s</em>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="gad3439925c61c42453159e0b50bdff960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3439925c61c42453159e0b50bdff960">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p>The substring from <code>s.begin()</code> to the iterator that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return <code>s.end()</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="gacd67fe8acc7e676213cd1527066214fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd67fe8acc7e676213cd1527066214fc">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename Stored &gt; class Storage = StoreValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga95455eccee62a6658b0485202ed4ff44">QueryType</a> <a class="el" href="classregina_1_1Property.html">regina::Property</a>&lt; T, Storage &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the current value of this property. </p>
<p>If this property is marked as unknown then the results are undefined.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This property is currently marked as known.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current value of this property. </dd></dl>

</div>
</div>
<a id="ga17e706f7f722922798776b74f9933bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e706f7f722922798776b74f9933bd0">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a boolean and reports whether this conversion was successful. </p>
<p>If the given string begins with <code>T</code>, <code>t</code> or <code>1</code>, then the string will be successfully converted to <code>true</code>. If the given string begins with <code>F</code>, <code>f</code> or <code>0</code>, then the string will be successfully converted to <code>false</code>. Otherwise the conversion will be unsuccessful and argument <em>dest</em> will be set to <code>false</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6083d66d2dcac7dce8637e6282c6c679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6083d66d2dcac7dce8637e6282c6c679">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a set of booleans and reports whether this conversion was successful. </p>
<p>A set of booleans is represented by one of the four strings <code>&ndash;</code>, <code>T-</code>, <code>-F</code> or <code>TF</code>. If the conversion is unsuccessful, argument <em>dest</em> will be set to <a class="el" href="group__utilities.html#gac99098499b5705ba13a480097906deed" title="The empty set.">BoolSet::sNone</a> and <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting set of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d3266c3fb5264747ed7af53464ac7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3266c3fb5264747ed7af53464ac7a9">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a double precision real number and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the real number that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga896ae2c6783d6d6dc4081bddabb22518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896ae2c6783d6d6dc4081bddabb22518">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae40c2e62bf0908919834ea10762def19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c2e62bf0908919834ea10762def19">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4c91417b8ffbca35aa32c82532f5330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c91417b8ffbca35aa32c82532f5330f">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting arbitrary precision integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaad0bb367f8c8f4172e6a979751907c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0bb367f8c8f4172e6a979751907c6c">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gacd5eebbe6059d16231b0e41966e2056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5eebbe6059d16231b0e41966e2056a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga384de19626353085bf20eedc89c3c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga384de19626353085bf20eedc89c3c30a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf9eaa1f183454edc0db4f915d98c0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9eaa1f183454edc0db4f915d98c0a73">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga974a77f98013a0274540b1d0b06519f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a77f98013a0274540b1d0b06519f3">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga007abfa18426eedc6277f644ded3e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007abfa18426eedc6277f644ded3e068">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad0bc034686407302e3ad597e39933a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0bc034686407302e3ad597e39933a99">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga183ba5dd849f33e9153c3363323abf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183ba5dd849f33e9153c3363323abf5a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab2a8a4c7ca859e0f72674d893d0af909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a8a4c7ca859e0f72674d893d0af909">&#9670;&nbsp;</a></span>warning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::xml::XMLParserCallback::warning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a parser warning occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the warning message. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__file.html#ga1c5db9df2ae90c103ddb5de7aff8b6e9">regina::XMLCallback</a>.</p>

</div>
</div>
<a id="ga52c8776c5329496a0b34c914706031e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c8776c5329496a0b34c914706031e4">&#9670;&nbsp;</a></span>writeResUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::writeResUsage </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes time and memory usage for the current process to the given output stream. </p>
<p>Information is gathered from the <code>/proc</code> filesystem, which means that this routine will only write meaningful information under a Linux system where <code>/proc</code> is mounted.</p>
<p>Specifically, this routine reads information on the running process from <code>/proc/self/stat</code>, and writes a short string to the given output stream of the form:</p>
<div class="fragment"><div class="line">utime=..., stime=..., vsize=...</div>
</div><!-- fragment --><p>The three ellipses in the example above will be replaced with integers, representing:</p>
<ul>
<li>the number jiffies that this process has been scheduled in user mode (the <em>utime</em> field);</li>
<li>the number jiffies that this process has been scheduled in kernel mode (the <em>stime</em> field);</li>
<li>the the virtual memory size in bytes (the <em>vsize</em> field).</li>
</ul>
<p>The description of these three fields is taken directly from the <code>proc(5)</code> manpage. Note that the length of a jiffy can differ from system to system; see the <code>time(7)</code> manpage for details.</p>
<p>The output will not contain a newline, and the given output stream will not be flushed.</p>
<p>If <code>/proc/self/stat</code> cannot be read, this routine will write a short message to that effect to the given output stream (which means that this utility is safe to call under non-Linux operating systems, although it will of course be useless in such scenarios).</p>
<p>If <code>/proc/self/stat</code> can be read but contains unexpected information, the behaviour of this routine is undefined.</p>
<dl class="section user"><dt>Python</dt><dd>This routine does not take any arguments; instead the stream <em>out</em> is assumed to be standard output.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine allows at most 255 characters for the <em>comm</em> field in <code>/proc/self/stat</code> (which stores the executable filename along with surrounding parentheses). If the <em>comm</em> field is too long (i.e., the executable filename is too long), then this routine will not be able to parse <code>/proc/self/stat</code>, and will write a note to this effect to the given output stream. If you encounter this problem, you should be able to fix it by renaming your executable to something shorter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which usage information will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d9135c01a79c7fcfa32caafd8bb4652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9135c01a79c7fcfa32caafd8bb4652">&#9670;&nbsp;</a></span>xmlEncodeComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment. </p>
<p>As well as converting special characters to XML entities, this routine will replace dashes with underscores to avoid double-hyphens (which are illegal in XML comments).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string converted to be usable inside an XML comment. </dd></dl>

</div>
</div>
<a id="ga3a9273b1e8e9c18b33d73012b77c1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9273b1e8e9c18b33d73012b77c1b3f">&#9670;&nbsp;</a></span>xmlEncodeSpecialChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeSpecialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities. </p>
<p>For instance, the string <code>"a \&lt; b"</code> would be converted to <code>"a \&amp;lt; b"</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string with special characters replaced by XML entities. </dd></dl>

</div>
</div>
<a id="ga4c433d55f1002dcda968f0d6a31cc280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c433d55f1002dcda968f0d6a31cc280">&#9670;&nbsp;</a></span>XMLParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::xml::XMLParser::XMLParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">XMLParserCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new XML parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>the object providing the routines to call when particular XML components are encountered during parsing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdab881c1ccc9043c8b18bb12d736d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdab881c1ccc9043c8b18bb12d736d92">&#9670;&nbsp;</a></span>XMLPropertyDict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::xml::XMLPropertyDict::XMLPropertyDict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new map. </p>

</div>
</div>
<a id="gabae034cbea5ca43c01df1f5a1696b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae034cbea5ca43c01df1f5a1696b9f3">&#9670;&nbsp;</a></span>xmlString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlString </td>
          <td>(</td>
          <td class="paramtype">xmlChar *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given string from libxml into a C++ string, optionally deallocating the original libxml string. </p>
<p>The given libxml string <em>str</em> may be <code>null</code>, in which case the resulting C++ string will be the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">free</td><td><code>true</code> if the original libxml string <em>str</em> should be deallocated, or <code>false</code> if it should be preserved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given string as a C++ string. </dd></dl>

</div>
</div>
<a id="gacb9d9d42e182de0dc67e4176414cb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9d9d42e182de0dc67e4176414cb07d">&#9670;&nbsp;</a></span>xmlValueTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlValueTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value. </p>
<p>The tag will be of the form <code>&lt;tagName value="..."/&gt;</code>.</p>
<p>The value itself will be written to the tag string using the standard output stream operator &lt;&lt;.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The property value when written to an output stream does not contain any special characters (such as <code>&lt;</code> or <code>&amp;</code>) that need to be encoded as XML entities.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the XML tag to create. </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to the <em>value</em> property of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding XML tag. </dd></dl>

</div>
</div>
<a id="ga7da7d39788ced60309788d45157a2ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7da7d39788ced60309788d45157a2ff2">&#9670;&nbsp;</a></span>~Bitmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::~Bitmask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this bitmask. </p>

</div>
</div>
<a id="ga61810bdda48b4a95ef66c577f62eadf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61810bdda48b4a95ef66c577f62eadf4">&#9670;&nbsp;</a></span>~IConvStreamBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStreamBuffer::~IConvStreamBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this stream buffer. </p>
<p>This stream buffer will be closed, but the destination output stream will not be. </p>

</div>
</div>
<a id="ga1099690616a1c0d5943bce8c3f915a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1099690616a1c0d5943bce8c3f915a06">&#9670;&nbsp;</a></span>~LightweightSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence</a>&lt; T &gt;::~<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this sequence and all of its elements. </p>
<p>All elements of the sequence will be destroyed using the destructor for type <em>T</em>. If the elements are pointers whose pointee objects need to be deleted also, you must do this separately before destroying the sequence itself. </p>

</div>
</div>
<a id="ga490bb9c1927c0b522ff4de33396f70a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga490bb9c1927c0b522ff4de33396f70a8">&#9670;&nbsp;</a></span>~ListOnCall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall</a>&lt; T &gt;::~<a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all of the items it contains. </p>

</div>
</div>
<a id="gad2f6176bf93b895219b2da104e95f377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f6176bf93b895219b2da104e95f377">&#9670;&nbsp;</a></span>~mem_istream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::mem_istream::~mem_istream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that this does <em>not</em> deallocate the array of characters being read. </p>

</div>
</div>
<a id="ga2a4d1def8bd3e965dc227475025c4671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a4d1def8bd3e965dc227475025c4671">&#9670;&nbsp;</a></span>~StoreManagedPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::~<a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the currently held value if one exists. </p>

</div>
</div>
<a id="gafabb80bec38d52734b0215c625aa3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafabb80bec38d52734b0215c625aa3ac7">&#9670;&nbsp;</a></span>~TrieSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::~<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this collection of sets. </p>

</div>
</div>
<a id="gad0dcdc33eb1c49183f810542606ca36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0dcdc33eb1c49183f810542606ca36b">&#9670;&nbsp;</a></span>~XMLParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::xml::XMLParser::~XMLParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this XML parser. </p>

</div>
</div>
<a id="ga4d28f5acb7b66ca51fe934a86f0ef41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d28f5acb7b66ca51fe934a86f0ef41d">&#9670;&nbsp;</a></span>~XMLParserCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::xml::XMLParserCallback::~XMLParserCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor that does nothing. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga7954dfd3369b62b6e695dd4e2aaf7b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7954dfd3369b62b6e695dd4e2aaf7b60">&#9670;&nbsp;</a></span>sBoth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::sBoth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set containing both <code>true</code> and <code>false</code>. </p>

</div>
</div>
<a id="ga83f5f340a17bee0edb7f75c807a3cede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f5f340a17bee0edb7f75c807a3cede">&#9670;&nbsp;</a></span>sFalse</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::sFalse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set containing only <code>false</code>. </p>

</div>
</div>
<a id="gac99098499b5705ba13a480097906deed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99098499b5705ba13a480097906deed">&#9670;&nbsp;</a></span>sNone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::sNone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The empty set. </p>

</div>
</div>
<a id="ga08c3e258454984543cc66505c595b23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c3e258454984543cc66505c595b23f">&#9670;&nbsp;</a></span>sTrue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::BoolSet::sTrue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set containing only <code>true</code>. </p>

</div>
</div>
<a id="ga3e6aa2148614e7ce75134e7dd2149577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6aa2148614e7ce75134e7dd2149577">&#9670;&nbsp;</a></span>value_ <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue</a>&lt; T &gt;::value_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The held property value. </p>

</div>
</div>
<a id="gae1976534fd988695c6b6f6a4df726bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1976534fd988695c6b6f6a4df726bf8">&#9670;&nbsp;</a></span>value_ <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr</a>&lt; T &gt;::value_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The held property value. </p>

</div>
</div>
<a id="ga400e17c8cd860a90dfb0c5c9c2721edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga400e17c8cd860a90dfb0c5c9c2721edf">&#9670;&nbsp;</a></span>value_ <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr</a>&lt; T &gt;::value_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The held property value. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga6b96c3d5421b076c7f20f34d339e8de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b96c3d5421b076c7f20f34d339e8de1">&#9670;&nbsp;</a></span>MarkedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow only <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a> to edit the array index. </p>

</div>
</div>
<a id="ga7a48856e7eb35fdde956d27063dd67b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a48856e7eb35fdde956d27063dd67b9">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga3071bbc2b5d2fe0cbdb8e0635cff5525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3071bbc2b5d2fe0cbdb8e0635cff5525">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p>The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga9817604f20df72ec2c21a0003fc16147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9817604f20df72ec2c21a0003fc16147">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga4c5eafba387135f9a7a7c529b2b622d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5eafba387135f9a7a7c529b2b622d2">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
