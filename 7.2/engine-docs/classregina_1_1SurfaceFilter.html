<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::SurfaceFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classregina_1_1SurfaceFilter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SurfaceFilter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A packet that accepts or rejects normal surfaces.  
 <a href="classregina_1_1SurfaceFilter.html#details">More...</a></p>

<p><code>#include &lt;surface/surfacefilter.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SurfaceFilter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SurfaceFilter.png" usemap="#regina::SurfaceFilter_map" alt=""/>
  <map id="regina::SurfaceFilter_map" name="regina::SurfaceFilter_map">
<area href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::Packet" shape="rect" coords="124,56,362,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Packet &gt;" shape="rect" coords="248,0,486,24"/>
<area href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters." alt="regina::SurfaceFilterCombination" shape="rect" coords="0,168,238,192"/>
<area href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface." alt="regina::SurfaceFilterProperties" shape="rect" coords="248,168,486,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c8ebf5a91c028d00eaf486abab4fc50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html#a3c8ebf5a91c028d00eaf486abab4fc50">accept</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface) const =0</td></tr>
<tr class="memdesc:a3c8ebf5a91c028d00eaf486abab4fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether or not the given normal surface is accepted by this filter.  <a href="classregina_1_1SurfaceFilter.html#a3c8ebf5a91c028d00eaf486abab4fc50">More...</a><br /></td></tr>
<tr class="separator:a3c8ebf5a91c028d00eaf486abab4fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56188febfaaaae69c8b4efbdc64dd36f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html#a56188febfaaaae69c8b4efbdc64dd36f">filterType</a> () const =0</td></tr>
<tr class="memdesc:a56188febfaaaae69c8b4efbdc64dd36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique integer ID corresponding to the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.  <a href="classregina_1_1SurfaceFilter.html#a56188febfaaaae69c8b4efbdc64dd36f">More...</a><br /></td></tr>
<tr class="separator:a56188febfaaaae69c8b4efbdc64dd36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe3c5725180948ca88dd5f949c94c1d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html#a7fe3c5725180948ca88dd5f949c94c1d">filterTypeName</a> () const =0</td></tr>
<tr class="memdesc:a7fe3c5725180948ca88dd5f949c94c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string description of the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.  <a href="classregina_1_1SurfaceFilter.html#a7fe3c5725180948ca88dd5f949c94c1d">More...</a><br /></td></tr>
<tr class="separator:a7fe3c5725180948ca88dd5f949c94c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:a11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a> () const =0</td></tr>
<tr class="memdesc:a11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique integer ID representing this type of packet.  <a href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:a11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4">typeName</a> () const =0</td></tr>
<tr class="memdesc:a787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an English name for this type of packet.  <a href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:a787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#afd05b16f0990a54ac7f95bc32cf1483e">label</a> () const</td></tr>
<tr class="memdesc:afd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the label associated with this individual packet.  <a href="classregina_1_1Packet.html#afd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:afd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adfaee615502b79cbeef31628a1186dc4">humanLabel</a> () const</td></tr>
<tr class="memdesc:adfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="classregina_1_1Packet.html#adfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:adfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae1cd6eea63e8cd41d7517f86b8c7776d">adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:ae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the label of this packet adorned with the given string.  <a href="classregina_1_1Packet.html#ae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:ae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adfd869991cbf664891629f21a5432b02">setLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#afd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:adfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="classregina_1_1Packet.html#adfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:adfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a29f5775c175a56d06da14444b391ed3a">fullName</a> () const</td></tr>
<tr class="memdesc:a29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive text string for the packet.  <a href="classregina_1_1Packet.html#a29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:a29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:af4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af4315a8b8ebcf47e781c204927f8845f">hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:af4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="classregina_1_1Packet.html#af4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:af4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a4404beade84983a4f1c051cd64035ddf">hasTags</a> () const</td></tr>
<tr class="memdesc:a4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="classregina_1_1Packet.html#a4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:a4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a982b9936f9e9dc11ce932d4e8c7402de">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="classregina_1_1Packet.html#a982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:a982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acb9880c0189b8f60827cd0ce9a2bb32c">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="classregina_1_1Packet.html#acb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aee2405989e058dbfddf7ae445d47ddcf">removeAllTags</a> ()</td></tr>
<tr class="memdesc:aee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="classregina_1_1Packet.html#aee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:aee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a06d41356ff086d078b04f34919aac26d">tags</a> () const</td></tr>
<tr class="memdesc:a06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all tags associated with this packet.  <a href="classregina_1_1Packet.html#a06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:a06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:aa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa504cfa813a3190c00337743915ffef5">listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:aa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="classregina_1_1Packet.html#aa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:aa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acd2dc2dee3396afb9dbf07c38fe10d63">isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="classregina_1_1Packet.html#acd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae71b40cd2416de174bba61db2ec92f1d">unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:ae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="classregina_1_1Packet.html#ae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:ae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:a381fa20979fb976c4cfc0ba6fc38f1c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a381fa20979fb976c4cfc0ba6fc38f1c1">samePacket</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;other) const</td></tr>
<tr class="memdesc:a381fa20979fb976c4cfc0ba6fc38f1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object refer to the same packet.  <a href="classregina_1_1Packet.html#a381fa20979fb976c4cfc0ba6fc38f1c1">More...</a><br /></td></tr>
<tr class="separator:a381fa20979fb976c4cfc0ba6fc38f1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdb6f7d6fe978254498d42b0b05ecbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a1bdb6f7d6fe978254498d42b0b05ecbd">hasParent</a> () const</td></tr>
<tr class="memdesc:a1bdb6f7d6fe978254498d42b0b05ecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet has a parent in the tree structure.  <a href="classregina_1_1Packet.html#a1bdb6f7d6fe978254498d42b0b05ecbd">More...</a><br /></td></tr>
<tr class="separator:a1bdb6f7d6fe978254498d42b0b05ecbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cfc82357f74190fc01644aaee62a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a> () const</td></tr>
<tr class="memdesc:a315cfc82357f74190fc01644aaee62a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">More...</a><br /></td></tr>
<tr class="separator:a315cfc82357f74190fc01644aaee62a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cbbc738d6e98902316a671432db147"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a47cbbc738d6e98902316a671432db147">firstChild</a> () const</td></tr>
<tr class="memdesc:a47cbbc738d6e98902316a671432db147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="classregina_1_1Packet.html#a47cbbc738d6e98902316a671432db147">More...</a><br /></td></tr>
<tr class="separator:a47cbbc738d6e98902316a671432db147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a11b90e380cf26e82a059b11ba3f363"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a8a11b90e380cf26e82a059b11ba3f363">lastChild</a> () const</td></tr>
<tr class="memdesc:a8a11b90e380cf26e82a059b11ba3f363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="classregina_1_1Packet.html#a8a11b90e380cf26e82a059b11ba3f363">More...</a><br /></td></tr>
<tr class="separator:a8a11b90e380cf26e82a059b11ba3f363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dfc77b354a21357c3429798113899f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a55dfc77b354a21357c3429798113899f">nextSibling</a> () const</td></tr>
<tr class="memdesc:a55dfc77b354a21357c3429798113899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="classregina_1_1Packet.html#a55dfc77b354a21357c3429798113899f">More...</a><br /></td></tr>
<tr class="separator:a55dfc77b354a21357c3429798113899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e171383f2f89d69f77f8e8cf911c04c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a6e171383f2f89d69f77f8e8cf911c04c">prevSibling</a> () const</td></tr>
<tr class="memdesc:a6e171383f2f89d69f77f8e8cf911c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="classregina_1_1Packet.html#a6e171383f2f89d69f77f8e8cf911c04c">More...</a><br /></td></tr>
<tr class="separator:a6e171383f2f89d69f77f8e8cf911c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7a103b34cfe75eea6c186cdcefc739"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adf7a103b34cfe75eea6c186cdcefc739">root</a> () const</td></tr>
<tr class="memdesc:adf7a103b34cfe75eea6c186cdcefc739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="classregina_1_1Packet.html#adf7a103b34cfe75eea6c186cdcefc739">More...</a><br /></td></tr>
<tr class="separator:adf7a103b34cfe75eea6c186cdcefc739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed0665b08bc2a58b57ff6425c386ff"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a86ed0665b08bc2a58b57ff6425c386ff">levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;descendant) const</td></tr>
<tr class="memdesc:a86ed0665b08bc2a58b57ff6425c386ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="classregina_1_1Packet.html#a86ed0665b08bc2a58b57ff6425c386ff">More...</a><br /></td></tr>
<tr class="separator:a86ed0665b08bc2a58b57ff6425c386ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff1765d043194debd8899a2ebc241e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#afbff1765d043194debd8899a2ebc241e">levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;ancestor) const</td></tr>
<tr class="memdesc:afbff1765d043194debd8899a2ebc241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="classregina_1_1Packet.html#afbff1765d043194debd8899a2ebc241e">More...</a><br /></td></tr>
<tr class="separator:afbff1765d043194debd8899a2ebc241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696ec3fdc87e2bc8cdc0d88848b02aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a8696ec3fdc87e2bc8cdc0d88848b02aa">isAncestorOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;descendant) const</td></tr>
<tr class="memdesc:a8696ec3fdc87e2bc8cdc0d88848b02aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="classregina_1_1Packet.html#a8696ec3fdc87e2bc8cdc0d88848b02aa">More...</a><br /></td></tr>
<tr class="separator:a8696ec3fdc87e2bc8cdc0d88848b02aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae2df11b3b1cecdfbce1a4c53bd1a0395">countChildren</a> () const</td></tr>
<tr class="memdesc:ae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of immediate children of this packet.  <a href="classregina_1_1Packet.html#ae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:ae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a33da88ebed1a4ceccdf70172eff4e3f1">countDescendants</a> () const</td></tr>
<tr class="memdesc:a33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of strict descendants of this packet.  <a href="classregina_1_1Packet.html#a33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:a33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae2519c2dac8e039b7acd5df8373c608d">totalTreeSize</a> () const</td></tr>
<tr class="memdesc:ae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="classregina_1_1Packet.html#ae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:ae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:a2ae199aef20c94d0da16e9f681fd6360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2ae199aef20c94d0da16e9f681fd6360">prepend</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; child)</td></tr>
<tr class="memdesc:a2ae199aef20c94d0da16e9f681fd6360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="classregina_1_1Packet.html#a2ae199aef20c94d0da16e9f681fd6360">More...</a><br /></td></tr>
<tr class="separator:a2ae199aef20c94d0da16e9f681fd6360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad326301f9e851cb9d51510080d63413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aad326301f9e851cb9d51510080d63413">insertChildFirst</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; child)</td></tr>
<tr class="memdesc:aad326301f9e851cb9d51510080d63413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that inserts the given packet as the first child of this packet.  <a href="classregina_1_1Packet.html#aad326301f9e851cb9d51510080d63413">More...</a><br /></td></tr>
<tr class="separator:aad326301f9e851cb9d51510080d63413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1765cf059113d2ad509bbfde7986c68f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a1765cf059113d2ad509bbfde7986c68f">append</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; child)</td></tr>
<tr class="memdesc:a1765cf059113d2ad509bbfde7986c68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="classregina_1_1Packet.html#a1765cf059113d2ad509bbfde7986c68f">More...</a><br /></td></tr>
<tr class="separator:a1765cf059113d2ad509bbfde7986c68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153ba0ebb1a3733b7c533f911120cf5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a153ba0ebb1a3733b7c533f911120cf5f">insertChildLast</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; child)</td></tr>
<tr class="memdesc:a153ba0ebb1a3733b7c533f911120cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that inserts the given packet as the last child of this packet.  <a href="classregina_1_1Packet.html#a153ba0ebb1a3733b7c533f911120cf5f">More...</a><br /></td></tr>
<tr class="separator:a153ba0ebb1a3733b7c533f911120cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515131779fdfa5a1ebe23fc5465b4b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a515131779fdfa5a1ebe23fc5465b4b78">insert</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; newChild, std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; prevChild)</td></tr>
<tr class="memdesc:a515131779fdfa5a1ebe23fc5465b4b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="classregina_1_1Packet.html#a515131779fdfa5a1ebe23fc5465b4b78">More...</a><br /></td></tr>
<tr class="separator:a515131779fdfa5a1ebe23fc5465b4b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4a10bc4bdcdccc18da3e669b7023f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a56c4a10bc4bdcdccc18da3e669b7023f">insertChildAfter</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; newChild, std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; prevChild)</td></tr>
<tr class="memdesc:a56c4a10bc4bdcdccc18da3e669b7023f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="classregina_1_1Packet.html#a56c4a10bc4bdcdccc18da3e669b7023f">More...</a><br /></td></tr>
<tr class="separator:a56c4a10bc4bdcdccc18da3e669b7023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc">makeOrphan</a> ()</td></tr>
<tr class="memdesc:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it the root of its own tree.  <a href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84f7026712d5d736e499429ae11881a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa84f7026712d5d736e499429ae11881a">reparent</a> (const std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; &amp;newParent, bool first=false)</td></tr>
<tr class="memdesc:aa84f7026712d5d736e499429ae11881a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="classregina_1_1Packet.html#aa84f7026712d5d736e499429ae11881a">More...</a><br /></td></tr>
<tr class="separator:aa84f7026712d5d736e499429ae11881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3918c6630587e91954c28a3d770e4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae3918c6630587e91954c28a3d770e4bb">transferChildren</a> (const std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; &amp;newParent)</td></tr>
<tr class="memdesc:ae3918c6630587e91954c28a3d770e4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="classregina_1_1Packet.html#ae3918c6630587e91954c28a3d770e4bb">More...</a><br /></td></tr>
<tr class="separator:ae3918c6630587e91954c28a3d770e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a765186c1742fe402922433b77e5f439a">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:a765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="classregina_1_1Packet.html#a765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:a765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae02f6b3ad3a7816cde5d7df456763aaf">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="classregina_1_1Packet.html#ae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a59adc13b6143cf994779796077aed731">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:a59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="classregina_1_1Packet.html#a59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:a59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab4d7730c57940444bf7d3085459449e8">moveToFirst</a> ()</td></tr>
<tr class="memdesc:ab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="classregina_1_1Packet.html#ab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:ab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a7fcff38ccb62b62d28bed83d2a3a28d5">moveToLast</a> ()</td></tr>
<tr class="memdesc:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="classregina_1_1Packet.html#a7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af91bc951714dc60db12810affb266b8a">sortChildren</a> ()</td></tr>
<tr class="memdesc:af91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="classregina_1_1Packet.html#af91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:af91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:ac42c8b89e24258d9edef60f3d66d5746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746">begin</a> ()</td></tr>
<tr class="memdesc:ac42c8b89e24258d9edef60f3d66d5746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746">More...</a><br /></td></tr>
<tr class="separator:ac42c8b89e24258d9edef60f3d66d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc789ee9e303e4613142e3ca0bbe1f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adc789ee9e303e4613142e3ca0bbe1f01">begin</a> () const</td></tr>
<tr class="memdesc:adc789ee9e303e4613142e3ca0bbe1f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ const iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="classregina_1_1Packet.html#adc789ee9e303e4613142e3ca0bbe1f01">More...</a><br /></td></tr>
<tr class="separator:adc789ee9e303e4613142e3ca0bbe1f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a3d4b07df76700302d7946756c80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d">end</a> ()</td></tr>
<tr class="memdesc:acb7a3d4b07df76700302d7946756c80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d">More...</a><br /></td></tr>
<tr class="separator:acb7a3d4b07df76700302d7946756c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33fcbe16a5214d134affb1c33f4f433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad33fcbe16a5214d134affb1c33f4f433">end</a> () const</td></tr>
<tr class="memdesc:ad33fcbe16a5214d134affb1c33f4f433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ const iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="classregina_1_1Packet.html#ad33fcbe16a5214d134affb1c33f4f433">More...</a><br /></td></tr>
<tr class="separator:ad33fcbe16a5214d134affb1c33f4f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65311eca1aa655e0bcba89fd34609921"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a65311eca1aa655e0bcba89fd34609921">__iter__</a> () const</td></tr>
<tr class="memdesc:a65311eca1aa655e0bcba89fd34609921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over the packets in the subtree rooted at this packet.  <a href="classregina_1_1Packet.html#a65311eca1aa655e0bcba89fd34609921">More...</a><br /></td></tr>
<tr class="separator:a65311eca1aa655e0bcba89fd34609921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95170e745227f4d171e8850510f18eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed">descendants</a> ()</td></tr>
<tr class="memdesc:a95170e745227f4d171e8850510f18eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed">More...</a><br /></td></tr>
<tr class="separator:a95170e745227f4d171e8850510f18eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b48bdca39d9d94ec006777f7e7a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2a3b48bdca39d9d94ec006777f7e7a93">descendants</a> () const</td></tr>
<tr class="memdesc:a2a3b48bdca39d9d94ec006777f7e7a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="classregina_1_1Packet.html#a2a3b48bdca39d9d94ec006777f7e7a93">More...</a><br /></td></tr>
<tr class="separator:a2a3b48bdca39d9d94ec006777f7e7a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cdf3858610404e396a8e49b960bd73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73">children</a> ()</td></tr>
<tr class="memdesc:a24cdf3858610404e396a8e49b960bd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight object for iterating through the immediate children of this packet.  <a href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73">More...</a><br /></td></tr>
<tr class="separator:a24cdf3858610404e396a8e49b960bd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30df9ea25cd1d998caf4baebd0c4ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a1e30df9ea25cd1d998caf4baebd0c4ec">children</a> () const</td></tr>
<tr class="memdesc:a1e30df9ea25cd1d998caf4baebd0c4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight object for iterating through the immediate children of this packet.  <a href="classregina_1_1Packet.html#a1e30df9ea25cd1d998caf4baebd0c4ec">More...</a><br /></td></tr>
<tr class="separator:a1e30df9ea25cd1d998caf4baebd0c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c2cf1cd78f0ea966f6d573b92626d6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a67c2cf1cd78f0ea966f6d573b92626d6">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:a67c2cf1cd78f0ea966f6d573b92626d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="classregina_1_1Packet.html#a67c2cf1cd78f0ea966f6d573b92626d6">More...</a><br /></td></tr>
<tr class="separator:a67c2cf1cd78f0ea966f6d573b92626d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b5e5018b7b913e2a4fc4d76d913e89"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab9b5e5018b7b913e2a4fc4d76d913e89">nextTreePacket</a> () const</td></tr>
<tr class="memdesc:ab9b5e5018b7b913e2a4fc4d76d913e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="classregina_1_1Packet.html#ab9b5e5018b7b913e2a4fc4d76d913e89">More...</a><br /></td></tr>
<tr class="separator:ab9b5e5018b7b913e2a4fc4d76d913e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad48d147bf58a7a56dd5b5f60d63057a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aad48d147bf58a7a56dd5b5f60d63057a">nextTreePacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> <a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:aad48d147bf58a7a56dd5b5f60d63057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="classregina_1_1Packet.html#aad48d147bf58a7a56dd5b5f60d63057a">More...</a><br /></td></tr>
<tr class="separator:aad48d147bf58a7a56dd5b5f60d63057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7c74a584533689c179e704c669983"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad2b7c74a584533689c179e704c669983">nextTreePacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> <a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ad2b7c74a584533689c179e704c669983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="classregina_1_1Packet.html#ad2b7c74a584533689c179e704c669983">More...</a><br /></td></tr>
<tr class="separator:ad2b7c74a584533689c179e704c669983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f11c6518807ab210a59b3a9e6c819be"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2f11c6518807ab210a59b3a9e6c819be">firstTreePacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> <a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:a2f11c6518807ab210a59b3a9e6c819be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="classregina_1_1Packet.html#a2f11c6518807ab210a59b3a9e6c819be">More...</a><br /></td></tr>
<tr class="separator:a2f11c6518807ab210a59b3a9e6c819be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9745017b9b1128ecef8661044e7e0bad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a9745017b9b1128ecef8661044e7e0bad">firstTreePacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> <a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:a9745017b9b1128ecef8661044e7e0bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="classregina_1_1Packet.html#a9745017b9b1128ecef8661044e7e0bad">More...</a><br /></td></tr>
<tr class="separator:a9745017b9b1128ecef8661044e7e0bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9b4beb26272c8d4c86a5c97e3eb708"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a6d9b4beb26272c8d4c86a5c97e3eb708">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#afd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:a6d9b4beb26272c8d4c86a5c97e3eb708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="classregina_1_1Packet.html#a6d9b4beb26272c8d4c86a5c97e3eb708">More...</a><br /></td></tr>
<tr class="separator:a6d9b4beb26272c8d4c86a5c97e3eb708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d08727caf5cc853269f905bb20301f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a65d08727caf5cc853269f905bb20301f">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#afd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:a65d08727caf5cc853269f905bb20301f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="classregina_1_1Packet.html#a65d08727caf5cc853269f905bb20301f">More...</a><br /></td></tr>
<tr class="separator:a65d08727caf5cc853269f905bb20301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:aa5ed5bd9a94119d141d3acfd591d9198"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa5ed5bd9a94119d141d3acfd591d9198">cloneAsSibling</a> (bool cloneDescendants=false, bool <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d">end</a>=true) const</td></tr>
<tr class="memdesc:aa5ed5bd9a94119d141d3acfd591d9198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="classregina_1_1Packet.html#aa5ed5bd9a94119d141d3acfd591d9198">More...</a><br /></td></tr>
<tr class="separator:aa5ed5bd9a94119d141d3acfd591d9198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f4f487f5a2545548351db6995532f4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html#a4f4f487f5a2545548351db6995532f4f">SurfaceFilter</a> ()=default</td></tr>
<tr class="memdesc:a4f4f487f5a2545548351db6995532f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classregina_1_1SurfaceFilter.html#a4f4f487f5a2545548351db6995532f4f">More...</a><br /></td></tr>
<tr class="separator:a4f4f487f5a2545548351db6995532f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8009b98256b59ebb440c86768f657245"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html#a8009b98256b59ebb440c86768f657245">SurfaceFilter</a> (const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;)=default</td></tr>
<tr class="memdesc:a8009b98256b59ebb440c86768f657245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that does not actually copy anything.  <a href="classregina_1_1SurfaceFilter.html#a8009b98256b59ebb440c86768f657245">More...</a><br /></td></tr>
<tr class="separator:a8009b98256b59ebb440c86768f657245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">File I/O</h2></td></tr>
<tr class="memitem:a14b88f9cd7be7d9fc2b0d4e47ffa25c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a14b88f9cd7be7d9fc2b0d4e47ffa25c5">save</a> (const char *filename, bool compressed=true, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format=<a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a>) const</td></tr>
<tr class="memdesc:a14b88f9cd7be7d9fc2b0d4e47ffa25c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="classregina_1_1Packet.html#a14b88f9cd7be7d9fc2b0d4e47ffa25c5">More...</a><br /></td></tr>
<tr class="separator:a14b88f9cd7be7d9fc2b0d4e47ffa25c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023eb2b649a9e50036be3022506c38a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a023eb2b649a9e50036be3022506c38a4">save</a> (std::ostream &amp;s, bool compressed=true, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format=<a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a>) const</td></tr>
<tr class="memdesc:a023eb2b649a9e50036be3022506c38a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="classregina_1_1Packet.html#a023eb2b649a9e50036be3022506c38a4">More...</a><br /></td></tr>
<tr class="separator:a023eb2b649a9e50036be3022506c38a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ecf17816bd965f96c87be522069257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab2ecf17816bd965f96c87be522069257">writeXMLFile</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format=<a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a>) const</td></tr>
<tr class="memdesc:ab2ecf17816bd965f96c87be522069257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="classregina_1_1Packet.html#ab2ecf17816bd965f96c87be522069257">More...</a><br /></td></tr>
<tr class="separator:ab2ecf17816bd965f96c87be522069257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f">internalID</a> () const</td></tr>
<tr class="memdesc:a0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique string ID that identifies this packet.  <a href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:a0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54930e66829e2b832b2b8d5b6813e55d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a54930e66829e2b832b2b8d5b6813e55d">writeTextShort</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:a54930e66829e2b832b2b8d5b6813e55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Packet.html#a54930e66829e2b832b2b8d5b6813e55d">More...</a><br /></td></tr>
<tr class="separator:a54930e66829e2b832b2b8d5b6813e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a044a5c8d80d5aeb0e13a335bfc9b4ed3">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1Packet.html#a044a5c8d80d5aeb0e13a335bfc9b4ed3">More...</a><br /></td></tr>
<tr class="separator:a044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89967da8bc792be792b6ccbed9cf1cc0"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a89967da8bc792be792b6ccbed9cf1cc0">internalClonePacket</a> () const =0</td></tr>
<tr class="memdesc:a89967da8bc792be792b6ccbed9cf1cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new copy of this packet.  <a href="classregina_1_1Packet.html#a89967da8bc792be792b6ccbed9cf1cc0">More...</a><br /></td></tr>
<tr class="separator:a89967da8bc792be792b6ccbed9cf1cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429634f90207822426df4923a62e3c28"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a429634f90207822426df4923a62e3c28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a429634f90207822426df4923a62e3c28">writeXMLHeader</a> (std::ostream &amp;out, const char *element, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, bool anon, <a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;refs, bool newline, std::pair&lt; const char *, Args &gt;... attr) const</td></tr>
<tr class="memdesc:a429634f90207822426df4923a62e3c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the opening XML tag for this packet.  <a href="classregina_1_1Packet.html#a429634f90207822426df4923a62e3c28">More...</a><br /></td></tr>
<tr class="separator:a429634f90207822426df4923a62e3c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a461c2301166fc295714d6a5cec84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adb7a461c2301166fc295714d6a5cec84">writeXMLTreeData</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, <a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;refs) const</td></tr>
<tr class="memdesc:adb7a461c2301166fc295714d6a5cec84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes any generic XML sub-elements for this packet that come from the packet tree.  <a href="classregina_1_1Packet.html#adb7a461c2301166fc295714d6a5cec84">More...</a><br /></td></tr>
<tr class="separator:adb7a461c2301166fc295714d6a5cec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8839bbf59d0a384810fb92e94c498a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a8839bbf59d0a384810fb92e94c498a20">writeXMLFooter</a> (std::ostream &amp;out, const char *element, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format) const</td></tr>
<tr class="memdesc:a8839bbf59d0a384810fb92e94c498a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the closing XML tag for this packet.  <a href="classregina_1_1Packet.html#a8839bbf59d0a384810fb92e94c498a20">More...</a><br /></td></tr>
<tr class="separator:a8839bbf59d0a384810fb92e94c498a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0983d128ef04f5b6f1d9124477bba88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad0983d128ef04f5b6f1d9124477bba88">writeXMLAnon</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, <a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;refs, const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;p) const</td></tr>
<tr class="memdesc:ad0983d128ef04f5b6f1d9124477bba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given packet inside its own anonymous block.  <a href="classregina_1_1Packet.html#ad0983d128ef04f5b6f1d9124477bba88">More...</a><br /></td></tr>
<tr class="separator:ad0983d128ef04f5b6f1d9124477bba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3727387cff93e0a9f9481a1826da1e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4">writeXMLPacketData</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, bool anon, <a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;refs) const =0</td></tr>
<tr class="memdesc:ae3727387cff93e0a9f9481a1826da1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the full subtree with this packet as matriarch.  <a href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4">More...</a><br /></td></tr>
<tr class="separator:ae3727387cff93e0a9f9481a1826da1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea53f3494a475853b39d78dc3b8d327"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a9ea53f3494a475853b39d78dc3b8d327">addPacketRefs</a> (<a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;refs) const</td></tr>
<tr class="memdesc:a9ea53f3494a475853b39d78dc3b8d327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records which other packets this packet refers to within the overall packet tree.  <a href="classregina_1_1Packet.html#a9ea53f3494a475853b39d78dc3b8d327">More...</a><br /></td></tr>
<tr class="separator:a9ea53f3494a475853b39d78dc3b8d327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0016eb8ba8d58c769b7b2a2489134"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> = std::map&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> *, bool &gt;</td></tr>
<tr class="memdesc:acba0016eb8ba8d58c769b7b2a2489134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used during the XML output routines to manage references between packets in an XML data file.  <a href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">More...</a><br /></td></tr>
<tr class="separator:acba0016eb8ba8d58c769b7b2a2489134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A packet that accepts or rejects normal surfaces. </p>
<p >Different subclasses of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> represent different filtering methods.</p>
<p >When deriving classes from <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>:</p>
<ul>
<li>Add a new filter constant to the SurfaceFilterType enum;</li>
<li>Create a new subclass <em>C</em> of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>, which begins with the REGINA_SURFACE_FILTER macro;</li>
<li>Perform all tasks required for this new innate packet type <em>C</em>, as outlined in the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class documentation;</li>
<li>Override the virtual function <a class="el" href="classregina_1_1Packet.html#a54930e66829e2b832b2b8d5b6813e55d" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a>, as well as all pure virtual functions from both the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> and <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> base classes (except for those already provided by REGINA_PACKET and REGINA_SURFACE_FILTER).</li>
</ul>
<p >Like all packet types, Regina's filter types do not support C++ move semantics, since this would interfere with the structure of the packet tree. They do support copy construction, copy assignment and swaps, but only in the derived filter classes (e.g., you cannot assign from the polymorphic base class <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>). Moreover, these operations only copy/swap the filter content, not the packet infrastructure (e.g., they do not touch packet labels, or the packet tree, or event listeners). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acba0016eb8ba8d58c769b7b2a2489134" name="acba0016eb8ba8d58c769b7b2a2489134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba0016eb8ba8d58c769b7b2a2489134">&#9670;&nbsp;</a></span>PacketRefs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">regina::Packet::PacketRefs</a> =  std::map&lt;const <a class="el" href="classregina_1_1Packet.html">Packet</a>*, bool&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used during the XML output routines to manage references between packets in an XML data file. </p>
<p >If some packet needs to refer to a packet <em>P</em>, then <em>P</em> will appear as a key this map; the corresponding value will be <code>false</code> initially, and will change to <code>true</code> once <em>P</em> has been written to the XML file. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f4f487f5a2545548351db6995532f4f" name="a4f4f487f5a2545548351db6995532f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f487f5a2545548351db6995532f4f">&#9670;&nbsp;</a></span>SurfaceFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilter::SurfaceFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a8009b98256b59ebb440c86768f657245" name="a8009b98256b59ebb440c86768f657245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8009b98256b59ebb440c86768f657245">&#9670;&nbsp;</a></span>SurfaceFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilter::SurfaceFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor that does not actually copy anything. </p>
<p >This is provided so that derived classes can use it implicitly in their own copy constructors. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65311eca1aa655e0bcba89fd34609921" name="a65311eca1aa655e0bcba89fd34609921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65311eca1aa655e0bcba89fd34609921">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Packet::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Python iterator over the packets in the subtree rooted at this packet. </p>
<p >Subtree iteration is depth-first, where a parent packet is always processed before its descendants. In particular, this packet (as the root of the subtree) will be processed first.</p>
<p >In Python, each packet can be treated as an iterable object, with the effect of iterating through the corresponding subtree:</p>
<div class="fragment"><div class="line">subtree = ...</div>
<div class="line"><span class="keywordflow">for</span> p <span class="keywordflow">in</span> subtree:</div>
<div class="line">    ...</div>
</div><!-- fragment --><p >Regina also supplies Python users with a member function <code>Packet.subtree()</code>, which returns an iterable object. Iterating over <code>Packet.subtree()</code> is exactly the same as iterating the packet itself; the <code>subtree()</code> function is offered because the intention may be clearer for readers.</p>
<p >See also <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a> for iterating through just the strict descendants in the subtree (i.e., excluding this packet itself), and <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating just through the immediate children of this packet (not the full subtree).</p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> provides the usual <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> functions instead. In particular, you can iterate over a packet subtree in the usual C++ way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the subtree rooted at this packet. </dd></dl>

</div>
</div>
<a id="a3c8ebf5a91c028d00eaf486abab4fc50" name="a3c8ebf5a91c028d00eaf486abab4fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8ebf5a91c028d00eaf486abab4fc50">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::SurfaceFilter::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides whether or not the given normal surface is accepted by this filter. </p>
<p >The default implementation simply returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given surface is accepted by this filter. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a722256169f87ec6864be7a785248472d">regina::SurfaceFilterCombination</a>, and <a class="el" href="classregina_1_1SurfaceFilterProperties.html#ad0c09cff66157850c3aac1ad598810d3">regina::SurfaceFilterProperties</a>.</p>

</div>
</div>
<a id="a9ea53f3494a475853b39d78dc3b8d327" name="a9ea53f3494a475853b39d78dc3b8d327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea53f3494a475853b39d78dc3b8d327">&#9670;&nbsp;</a></span>addPacketRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::addPacketRefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;&#160;</td>
          <td class="paramname"><em>refs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records which other packets this packet refers to within the overall packet tree. </p>
<p >For each packet <em>p</em> that this packet refers to, this routine should insert the pair (<em>p</em>, <code>false</code>) into the given map.</p>
<p >This will be run before writing the packet tree to an XML data file. By recording that this packet refers to some other packet <em>p</em>, this will ensure that the XML header for <em>p</em> will include an explicit ID that this packet can then refer to.</p>
<p >Later on, as the XML is written, the value <code>refs[p]</code> will be changed from <code>false</code> to <code>true</code> once <em>p</em> has been written.</p>
<p >If your packet requires that the <em>contents</em> of <em>p</em> appear before this packet it the XML data file, then <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a> should check <em>refs</em> to see if <em>p</em> has already been written, and if not, it should write <em>p</em> in a new anonymous block.</p>
<p >It is fine if <em>p</em> does not actually belong to this packet tree. However, in this case <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a> <em>must</em> take responsibility to ensure that <em>p</em> is written to file. This would need to be done via <a class="el" href="classregina_1_1Packet.html#ad0983d128ef04f5b6f1d9124477bba88" title="Writes the given packet inside its own anonymous block.">writeXMLAnon()</a>; moreover, as before, it should only be done only after checking <em>refs</em> to ensure this <em>p</em> has not already been written.</p>
<p >The default implementation of this routine does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>the map in which any dependencies should be recorded. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1PacketOf.html#a2313e27e1fb7c3a4bb7400928af2ae3f">regina::PacketOf&lt; Held &gt;</a>, and <a class="el" href="classregina_1_1Script.html#a91b22b0710c3a578ee3c01e8cf5cd7fd">regina::Script</a>.</p>

</div>
</div>
<a id="a982b9936f9e9dc11ce932d4e8c7402de" name="a982b9936f9e9dc11ce932d4e8c7402de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982b9936f9e9dc11ce932d4e8c7402de">&#9670;&nbsp;</a></span>addTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the given tag with this packet. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tag is not the empty string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was successfully added, or <code>false</code> if the given tag was already present beforehand. </dd></dl>

</div>
</div>
<a id="ae1cd6eea63e8cd41d7517f86b8c7776d" name="ae1cd6eea63e8cd41d7517f86b8c7776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cd6eea63e8cd41d7517f86b8c7776d">&#9670;&nbsp;</a></span>adornedLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::adornedLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the label of this packet adorned with the given string. </p>
<p >An adornment typically shows how a packet has been created and/or modified. For instance, the <em>adornment</em> argument might be "Filled", or "Summand #1".</p>
<p >The way in which the packet label is adorned depends upon the label itself (in particular, an empty packet label will be handled in a sensible way). The way in which the packet label is adorned is subject to change in future versions of Regina.</p>
<p >Note that, whilst this routine returns a modified version of the packet label, the label itself will not be permamently changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adornment</td><td>the string that will be used to adorn this packet label. The adornment should just be a piece of English, ideally beginning with an upper-case letter. It should not contain any surrounding punctuation such as brackets or a dash (this will be added automatically by this routine as required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the packet label with the given adornment. </dd></dl>

</div>
</div>
<a id="a1765cf059113d2ad509bbfde7986c68f" name="a1765cf059113d2ad509bbfde7986c68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1765cf059113d2ad509bbfde7986c68f">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::append </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the last child of this packet. </p>
<p >This packet will take ownership of <em>child</em>, in the sense that every parent packet stores (either directly or indirectly) a shared_ptr to every one of its descendants in the packet tree.</p>
<p >In Regina 7.0 and earlier, this routine was called <a class="el" href="classregina_1_1Packet.html#a153ba0ebb1a3733b7c533f911120cf5f" title="Deprecated routine that inserts the given packet as the last child of this packet.">insertChildLast()</a>.</p>
<p >This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>child</em> already has a parent packet. Note that, although this tests <em>one</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42c8b89e24258d9edef60f3d66d5746" name="ac42c8b89e24258d9edef60f3d66d5746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42c8b89e24258d9edef60f3d66d5746">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; false &gt; regina::Packet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at this packet. </p>
<p >Subtree iteration is depth-first, where a parent packet is always processed before its descendants. In particular, the iterator returned by <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> will always point to this packet itself.</p>
<p >In C++, these <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> routines allow you to iterate through an entire packet subtree using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; subtree = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; p : *subtree) { ... }</div>
<div class="ttc" id="aclassregina_1_1Packet_html_ac7bc0465f8c16febe20fa72872a17575"><div class="ttname"><a href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">regina::Packet::Packet</a></div><div class="ttdeci">Packet()=default</div><div class="ttdoc">Constructor that initialises the packet to have no parent and no children.</div></div>
</div><!-- fragment --><p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned iterator.</p>
<p >See also <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a> for iterating through just the strict descendants in the subtree (i.e., excluding this packet itself), and <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating just through the immediate children of this packet (not the full subtree).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> implements the Python iterable interface. You can iterate over the packets in a subtree in the usual Python way, by treating the subtree root as you would any native Python container. See <b>iter</b>() for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this subtree. </dd></dl>

</div>
</div>
<a id="adc789ee9e303e4613142e3ca0bbe1f01" name="adc789ee9e303e4613142e3ca0bbe1f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc789ee9e303e4613142e3ca0bbe1f01">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; true &gt; regina::Packet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ const iterator at the beginning of the range of packets in the subtree rooted at this packet. </p>
<p >Subtree iteration is depth-first, where a parent packet is always processed before its descendants. In particular, the iterator returned by <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> will always point to this packet itself.</p>
<p >In C++, these <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> routines allow you to iterate through an entire packet subtree using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;const Packet&gt; subtree = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; p : *subtree) { ... }</div>
</div><!-- fragment --><p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned iterator.</p>
<p >See also <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a> for iterating through just the strict descendants in the subtree (i.e., excluding this packet itself), and <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating just through the immediate children of this packet (not the full subtree).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> implements the Python iterable interface. You can iterate over the packets in a subtree in the usual Python way, by treating the subtree root as you would any native Python container. See <b>iter</b>() for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this subtree. </dd></dl>

</div>
</div>
<a id="a24cdf3858610404e396a8e49b960bd73" name="a24cdf3858610404e396a8e49b960bd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cdf3858610404e396a8e49b960bd73">&#9670;&nbsp;</a></span>children() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; false &gt; regina::Packet::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight object for iterating through the immediate children of this packet. </p>
<p >This routine allows you to iterate through the immediate children of a given packet using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; child : <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a>-&gt;children()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Packet_html_a315cfc82357f74190fc01644aaee62a0"><div class="ttname"><a href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">regina::Packet::parent</a></div><div class="ttdeci">std::shared_ptr&lt; Packet &gt; parent() const</div><div class="ttdoc">Determines the parent packet in the tree structure.</div><div class="ttdef"><b>Definition:</b> packet.h:4039</div></div>
</div><!-- fragment --><p >In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> child <span class="keywordflow">in</span> parent.children():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p >This function returns a lightweight object in the sense that it does not generate a full list of children in advance, but instead just returns a small iterator that visits each child as required. In particular, this routine has small constant time and memory.</p>
<p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned object.</p>
<p >See <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a>, as well as <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a>, for iterating through the subtree rooted at this packet (not just the immediate children).</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the children of this packet. </dd></dl>

</div>
</div>
<a id="a1e30df9ea25cd1d998caf4baebd0c4ec" name="a1e30df9ea25cd1d998caf4baebd0c4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e30df9ea25cd1d998caf4baebd0c4ec">&#9670;&nbsp;</a></span>children() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; true &gt; regina::Packet::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight object for iterating through the immediate children of this packet. </p>
<p >This routine allows you to iterate through the immediate children of a given packet using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;const Packet&gt; <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; child : <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a>-&gt;children()) { ... }</div>
</div><!-- fragment --><p >This function returns a lightweight object in the sense that it does not generate a full list of children in advance, but instead just returns a small iterator that visits each child as required. In particular, this routine has small constant time and memory.</p>
<p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned object.</p>
<p >See <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a>, as well as <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a>, for iterating through the subtree rooted at this packet (not just the immediate children).</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the children of this packet. </dd></dl>

</div>
</div>
<a id="aa5ed5bd9a94119d141d3acfd591d9198" name="aa5ed5bd9a94119d141d3acfd591d9198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ed5bd9a94119d141d3acfd591d9198">&#9670;&nbsp;</a></span>cloneAsSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::cloneAsSibling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneDescendants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet. </p>
<p >Note that any string tags associated with this packet will <em>not</em> be cloned.</p>
<p >If this packet has no parent in the tree structure, no clone will be created and <code>null</code> will be returned.</p>
<p >In Regina 6.0.1 and earlier, this function was called clone(). It was renamed in Regina 7.0 to emphasise that this is not just a deep copy, and is not guaranteed to succeed.</p>
<dl class="section note"><dt>Note</dt><dd>Since Regina 7.0, if a normal surface/hypersurface or angle structure list is cloned, then the new clone will refer back to the <em>original</em> triangulation, even if we are cloning an entire packet tree. This is because there is no guarantee that the original triangulation was cloned also (it could live outside the cloned subtree, or might not be part of a packet tree at all).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneDescendants</td><td><code>true</code> if the descendants of this packet should also be cloned and inserted as descendants of the new packet. If this is passed as <code>false</code> (the default), only this packet will be cloned. </td></tr>
    <tr><td class="paramname">end</td><td><code>true</code> if the new packet should be inserted at the end of the parent's list of children (the default), or <code>false</code> if the new packet should be inserted as the sibling immediately after this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly inserted packet, or <code>null</code> if this packet has no parent. </dd></dl>

</div>
</div>
<a id="ae2df11b3b1cecdfbce1a4c53bd1a0395" name="ae2df11b3b1cecdfbce1a4c53bd1a0395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2df11b3b1cecdfbce1a4c53bd1a0395">&#9670;&nbsp;</a></span>countChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of immediate children of this packet. </p>
<p >Grandchildren and so on are not counted.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of immediate children. </dd></dl>

</div>
</div>
<a id="a33da88ebed1a4ceccdf70172eff4e3f1" name="a33da88ebed1a4ceccdf70172eff4e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33da88ebed1a4ceccdf70172eff4e3f1">&#9670;&nbsp;</a></span>countDescendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of strict descendants of this packet. </p>
<p >This includes children, grandchildren and so on. This packet is not included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of strict descendants. </dd></dl>

</div>
</div>
<a id="a95170e745227f4d171e8850510f18eed" name="a95170e745227f4d171e8850510f18eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95170e745227f4d171e8850510f18eed">&#9670;&nbsp;</a></span>descendants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; false &gt; regina::Packet::descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight object for iterating through all strict descendants of this packet in the packet tree. </p>
<p >The order of iteration is exactly the same as when iterating over the full subtree rooted at this packet (as offered by <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">Packet::begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">Packet::end()</a>), except that the iteration <em>excludes</em> this packet itself. In particular, the iteration is depth-first, and each packet in the subtree is processed before its own descendants.</p>
<p >This routine allows you to iterate through all strict descendants of a given packet using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; desc : <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a>-&gt;descendants()) { ... }</div>
</div><!-- fragment --><p >In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> desc <span class="keywordflow">in</span> parent.descendants():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p >This function returns a lightweight object in the sense that it does not generate a full list of descendants in advance, but instead just returns a small iterator that visits each descendant as required. In particular, this routine has small constant time and memory.</p>
<p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned object.</p>
<p >See also <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> for iterating through the entire subtree <em>including</em> this packet, and <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating over just this packet's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the strict descendants of this packet. </dd></dl>

</div>
</div>
<a id="a2a3b48bdca39d9d94ec006777f7e7a93" name="a2a3b48bdca39d9d94ec006777f7e7a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b48bdca39d9d94ec006777f7e7a93">&#9670;&nbsp;</a></span>descendants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; true &gt; regina::Packet::descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight object for iterating through all strict descendants of this packet in the packet tree. </p>
<p >The order of iteration is exactly the same as when iterating over the full subtree rooted at this packet (as offered by <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">Packet::begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">Packet::end()</a>), except that the iteration <em>excludes</em> this packet itself. In particular, the iteration is depth-first, and each packet in the subtree is processed before its own descendants.</p>
<p >This routine allows you to iterate through all strict descendants of a given packet using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;const Packet&gt; <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_function" href="classregina_1_1Packet.html#ac7bc0465f8c16febe20fa72872a17575">Packet</a>&amp; desc : <a class="code hl_function" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0">parent</a>-&gt;descendants()) { ... }</div>
</div><!-- fragment --><p >This function returns a lightweight object in the sense that it does not generate a full list of descendants in advance, but instead just returns a small iterator that visits each descendant as required. In particular, this routine has small constant time and memory.</p>
<p >Since Regina 7.0, the return type is templated in order to support both const and non-const iteration. It is recommended that you just use <code>auto</code> if you need to store a local copy of the returned object.</p>
<p >See also <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> for iterating through the entire subtree <em>including</em> this packet, and <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating over just this packet's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the strict descendants of this packet. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="acb7a3d4b07df76700302d7946756c80d" name="acb7a3d4b07df76700302d7946756c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7a3d4b07df76700302d7946756c80d">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; false &gt; regina::Packet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this packet. </p>
<p >In C++, these <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> routines allow you to iterate through an entire packet subtree using range-based <code>for</code> loops.</p>
<p >See the <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> implements the Python iterable interface. You can iterate over the packets in a subtree in the usual Python way, by treating the subtree root as you would any native Python container. See <b>iter</b>() for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this subtree. </dd></dl>

</div>
</div>
<a id="ad33fcbe16a5214d134affb1c33f4f433" name="ad33fcbe16a5214d134affb1c33f4f433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33fcbe16a5214d134affb1c33f4f433">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; true &gt; regina::Packet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ const iterator beyond the end of the range of packets in the subtree rooted at this packet. </p>
<p >In C++, these <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> and <a class="el" href="classregina_1_1Packet.html#acb7a3d4b07df76700302d7946756c80d" title="Returns a C++ non-const iterator beyond the end of the range of packets in the subtree rooted at this...">end()</a> routines allow you to iterate through an entire packet subtree using range-based <code>for</code> loops.</p>
<p >See the <a class="el" href="classregina_1_1Packet.html#ac42c8b89e24258d9edef60f3d66d5746" title="Returns a C++ non-const iterator at the beginning of the range of packets in the subtree rooted at th...">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> implements the Python iterable interface. You can iterate over the packets in a subtree in the usual Python way, by treating the subtree root as you would any native Python container. See <b>iter</b>() for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this subtree. </dd></dl>

</div>
</div>
<a id="a56188febfaaaae69c8b4efbdc64dd36f" name="a56188febfaaaae69c8b4efbdc64dd36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56188febfaaaae69c8b4efbdc64dd36f">&#9670;&nbsp;</a></span>filterType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> regina::SurfaceFilter::filterType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique integer ID corresponding to the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the unique integer filtering method ID. </dd></dl>

</div>
</div>
<a id="a7fe3c5725180948ca88dd5f949c94c1d" name="a7fe3c5725180948ca88dd5f949c94c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe3c5725180948ca88dd5f949c94c1d">&#9670;&nbsp;</a></span>filterTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::SurfaceFilter::filterTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string description of the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a string description of this filtering method. </dd></dl>

</div>
</div>
<a id="a6d9b4beb26272c8d4c86a5c97e3eb708" name="a6d9b4beb26272c8d4c86a5c97e3eb708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9b4beb26272c8d4c86a5c97e3eb708">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p >Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or <code>null</code> if there is no such packet. </dd></dl>

</div>
</div>
<a id="a65d08727caf5cc853269f905bb20301f" name="a65d08727caf5cc853269f905bb20301f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d08727caf5cc853269f905bb20301f">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p >Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or <code>null</code> if there is no such packet. </dd></dl>

</div>
</div>
<a id="a47cbbc738d6e98902316a671432db147" name="a47cbbc738d6e98902316a671432db147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cbbc738d6e98902316a671432db147">&#9670;&nbsp;</a></span>firstChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first child of this packet in the tree structure. </p>
<p >This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child packet, or <code>null</code> if there is none. </dd></dl>

</div>
</div>
<a id="a2f11c6518807ab210a59b3a9e6c819be" name="a2f11c6518807ab210a59b3a9e6c819be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f11c6518807ab210a59b3a9e6c819be">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p >Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p >A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or <code>null</code> if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="a9745017b9b1128ecef8661044e7e0bad" name="a9745017b9b1128ecef8661044e7e0bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9745017b9b1128ecef8661044e7e0bad">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p >Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p >A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or <code>null</code> if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="a29f5775c175a56d06da14444b391ed3a" name="a29f5775c175a56d06da14444b391ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f5775c175a56d06da14444b391ed3a">&#9670;&nbsp;</a></span>fullName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::fullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a descriptive text string for the packet. </p>
<p >The string is of the form <em>label (packet-type)</em>.</p>
<p >The packet label will be adjusted for human-readable output according to the behaviour of <a class="el" href="classregina_1_1Packet.html#adfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the descriptive text string. </dd></dl>

</div>
</div>
<a id="a1bdb6f7d6fe978254498d42b0b05ecbd" name="a1bdb6f7d6fe978254498d42b0b05ecbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdb6f7d6fe978254498d42b0b05ecbd">&#9670;&nbsp;</a></span>hasParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet has a parent in the tree structure. </p>
<p >This is equivalent to, but slightly faster than, testing whether <a class="el" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0" title="Determines the parent packet in the tree structure.">parent()</a> returns a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>if</code> and only if this packet has a parent. </dd></dl>

</div>
</div>
<a id="af4315a8b8ebcf47e781c204927f8845f" name="af4315a8b8ebcf47e781c204927f8845f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4315a8b8ebcf47e781c204927f8845f">&#9670;&nbsp;</a></span>hasTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4404beade84983a4f1c051cd64035ddf" name="a4404beade84983a4f1c051cd64035ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4404beade84983a4f1c051cd64035ddf">&#9670;&nbsp;</a></span>hasTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="adfaee615502b79cbeef31628a1186dc4" name="adfaee615502b79cbeef31628a1186dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaee615502b79cbeef31628a1186dc4">&#9670;&nbsp;</a></span>humanLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p >In particular, if the packet has no label assigned then this routine will return "(no label)", not the empty string.</p>
<dl class="section warning"><dt>Warning</dt><dd>The method by which this routine adjusts packet labels is subject to change in future versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="a515131779fdfa5a1ebe23fc5465b4b78" name="a515131779fdfa5a1ebe23fc5465b4b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515131779fdfa5a1ebe23fc5465b4b78">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insert </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<p >This packet will take ownership of <em>child</em>, in the sense that every parent packet stores (either directly or indirectly) a shared_ptr to every one of its descendants in the packet tree.</p>
<p >In Regina 7.0 and earlier, this routine was called <a class="el" href="classregina_1_1Packet.html#a56c4a10bc4bdcdccc18da3e669b7023f" title="Deprecated routine that inserts the given packet as a child of this packet at the given location in t...">insertChildAfter()</a>.</p>
<p >This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
This packet is already the parent of <em>prevChild</em>. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>newChild</em> already has a parent packet, and/or the argument <em>prevChild</em> is non-null and does not have this packet as its parent. Note that, although this tests <em>some</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or <code>null</code> if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c4a10bc4bdcdccc18da3e669b7023f" name="a56c4a10bc4bdcdccc18da3e669b7023f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c4a10bc4bdcdccc18da3e669b7023f">&#9670;&nbsp;</a></span>insertChildAfter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildAfter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1Packet.html#a515131779fdfa5a1ebe23fc5465b4b78" title="Inserts the given packet as a child of this packet at the given location in this packet&#39;s child list.">insert()</a>. See <a class="el" href="classregina_1_1Packet.html#a515131779fdfa5a1ebe23fc5465b4b78" title="Inserts the given packet as a child of this packet at the given location in this packet&#39;s child list.">insert()</a> for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
This packet is already the parent of <em>prevChild</em>. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>newChild</em> already has a parent packet, and/or the argument <em>prevChild</em> is non-null and does not have this packet as its parent. Note that, although this tests <em>some</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or <code>null</code> if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad326301f9e851cb9d51510080d63413" name="aad326301f9e851cb9d51510080d63413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad326301f9e851cb9d51510080d63413">&#9670;&nbsp;</a></span>insertChildFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildFirst </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that inserts the given packet as the first child of this packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1Packet.html#a2ae199aef20c94d0da16e9f681fd6360" title="Inserts the given packet as the first child of this packet.">prepend()</a>. See <a class="el" href="classregina_1_1Packet.html#a2ae199aef20c94d0da16e9f681fd6360" title="Inserts the given packet as the first child of this packet.">prepend()</a> for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>child</em> already has a parent packet. Note that, although this tests <em>one</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a153ba0ebb1a3733b7c533f911120cf5f" name="a153ba0ebb1a3733b7c533f911120cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153ba0ebb1a3733b7c533f911120cf5f">&#9670;&nbsp;</a></span>insertChildLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildLast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that inserts the given packet as the last child of this packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1Packet.html#a1765cf059113d2ad509bbfde7986c68f" title="Inserts the given packet as the last child of this packet.">append()</a>. See <a class="el" href="classregina_1_1Packet.html#a1765cf059113d2ad509bbfde7986c68f" title="Inserts the given packet as the last child of this packet.">append()</a> for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>child</em> already has a parent packet. Note that, although this tests <em>one</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89967da8bc792be792b6ccbed9cf1cc0" name="a89967da8bc792be792b6ccbed9cf1cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89967da8bc792be792b6ccbed9cf1cc0">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::internalClonePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new copy of this packet. </p>
<p >This routine should <em>not</em> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p >You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="section return"><dt>Returns</dt><dd>the newly created packet. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1Attachment.html#ab33d3c5816fde3a005f0cc63fb850c14">regina::Attachment</a>, <a class="el" href="classregina_1_1Container.html#a22fe287e8aa8e9f8682a491ba7114bdc">regina::Container</a>, <a class="el" href="classregina_1_1PacketOf.html#a35946b4c213408f378564ce2da822d61">regina::PacketOf&lt; Held &gt;</a>, <a class="el" href="classregina_1_1Script.html#ab48ba2a7864246cbe4e3e5a755527a3a">regina::Script</a>, <a class="el" href="classregina_1_1Text.html#adb76b352d35a86cc68900454f56fecbd">regina::Text</a>, <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a47a14243713daa9c77678a962ef27d51">regina::SurfaceFilterCombination</a>, and <a class="el" href="classregina_1_1SurfaceFilterProperties.html#a18d25ec14f7cb71dc1d8ea02bf3f3e7d">regina::SurfaceFilterProperties</a>.</p>

</div>
</div>
<a id="a0b6130ab1dda164f6c6a6158a854f79f" name="a0b6130ab1dda164f6c6a6158a854f79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6130ab1dda164f6c6a6158a854f79f">&#9670;&nbsp;</a></span>internalID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique string ID that identifies this packet. </p>
<p >The user has no control over this ID, and it is not human readable. It is guaranteed to remain fixed throughout the lifetime of the program for a given packet, and it is guaranteed not to clash with the ID of any other packet.</p>
<p >If you change the contents of a packet, its ID will not change.</p>
<p >If you clone a packet, the new clone will receive a different ID. If you save and then load a packet to/from file, the ID will change. These behaviours are necessary to ensure that IDs remain unique (since, for instance, you could load several copies of the same data file into memory simultaneously).</p>
<p >The ID is implemented as an encoding of the underlying C++ pointer. This encoding is subject to change in later versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a id="a8696ec3fdc87e2bc8cdc0d88848b02aa" name="a8696ec3fdc87e2bc8cdc0d88848b02aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8696ec3fdc87e2bc8cdc0d88848b02aa">&#9670;&nbsp;</a></span>isAncestorOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isAncestorOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet is equal to or an ancestor of the given packet in the tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the other packet whose relationships we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is equal to or an ancestor of <code>descendant</code>. </dd></dl>

</div>
</div>
<a id="acd2dc2dee3396afb9dbf07c38fe10d63" name="acd2dc2dee3396afb9dbf07c38fe10d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2dc2dee3396afb9dbf07c38fe10d63">&#9670;&nbsp;</a></span>isListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given packet listener is currently listening for events on this packet. </p>
<p >See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener is currently registered with this packet, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="afd05b16f0990a54ac7f95bc32cf1483e" name="afd05b16f0990a54ac7f95bc32cf1483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd05b16f0990a54ac7f95bc32cf1483e">&#9670;&nbsp;</a></span>label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Packet::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the label associated with this individual packet. </p>
<p >An example is <code>MyTriangulation</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="a8a11b90e380cf26e82a059b11ba3f363" name="a8a11b90e380cf26e82a059b11ba3f363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a11b90e380cf26e82a059b11ba3f363">&#9670;&nbsp;</a></span>lastChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::lastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the last child of this packet in the tree structure. </p>
<p >This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the last child packet, or <code>null</code> if there is none. </dd></dl>

</div>
</div>
<a id="a86ed0665b08bc2a58b57ff6425c386ff" name="a86ed0665b08bc2a58b57ff6425c386ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ed0665b08bc2a58b57ff6425c386ff">&#9670;&nbsp;</a></span>levelsDownTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsDownTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given descendant in the tree structure. </p>
<p >If <code>descendant</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>descendant</code>, or can be obtained from <code>descendant</code> using only child-to-parent steps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>The argument <em>descendant</em> is not equal to or a descendant of this packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="afbff1765d043194debd8899a2ebc241e" name="afbff1765d043194debd8899a2ebc241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbff1765d043194debd8899a2ebc241e">&#9670;&nbsp;</a></span>levelsUpTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsUpTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given ancestor in the tree structure. </p>
<p >If <code>ancestor</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>ancestor</code>, or can be obtained from <code>ancestor</code> using only parent-to-child steps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This packet is not equal to or a descendant of the argument <em>descendant</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="aa504cfa813a3190c00337743915ffef5" name="aa504cfa813a3190c00337743915ffef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa504cfa813a3190c00337743915ffef5">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the given packet listener to listen for events on this packet. </p>
<p >See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully registered, or <code>false</code> if the given listener was already registered beforehand. </dd></dl>

</div>
</div>
<a id="ad9aa0488b40a1f3ec702838b2a2ceecc" name="ad9aa0488b40a1f3ec702838b2a2ceecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aa0488b40a1f3ec702838b2a2ceecc">&#9670;&nbsp;</a></span>makeOrphan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::makeOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure and instead makes it the root of its own tree. </p>
<p >The tree information for both this packet and its parent will be updated.</p>
<p >The old parent will relinquish ownership of this packet. This means that, even if the old parent remains alive, once the last shared_ptr to this packet is destroyed then this packet itself will be destroyed also.</p>
<p >This <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it the root of its own ...">makeOrphan()</a> function is the preferred way to "delete" a packet <em>p</em> from a larger packet tree: simply orphan <em>p</em> and then dispose of any outstanding shared pointers to it (if you have any).</p>
<p >Even if you are not holding a shared_ptr to this packet yourself, this routine is still safe to use: it will keep an internal shared_ptr as a "guard" until <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it the root of its own ...">makeOrphan()</a> has completed its work, at which point the packet will be safely destroyed.</p>
<p >This routine takes small constant time. It is safe to use regardless of whether this packet currently has a parent or not. </p>

</div>
</div>
<a id="a59adc13b6143cf994779796077aed731" name="a59adc13b6143cf994779796077aed731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59adc13b6143cf994779796077aed731">&#9670;&nbsp;</a></span>moveDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveDown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the end of its sibling list. </p>
<p >If the number of steps is larger than the greatest possible movement, the packet will be moved to the very end of its sibling list.</p>
<p >This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>the number of steps down to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4d7730c57940444bf7d3085459449e8" name="ab4d7730c57940444bf7d3085459449e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d7730c57940444bf7d3085459449e8">&#9670;&nbsp;</a></span>moveToFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the first in its sibling list. </p>
<p >This routine takes small constant time. </p>

</div>
</div>
<a id="a7fcff38ccb62b62d28bed83d2a3a28d5" name="a7fcff38ccb62b62d28bed83d2a3a28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcff38ccb62b62d28bed83d2a3a28d5">&#9670;&nbsp;</a></span>moveToLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the last in its sibling list. </p>
<p >This routine takes small constant time. </p>

</div>
</div>
<a id="ae02f6b3ad3a7816cde5d7df456763aaf" name="ae02f6b3ad3a7816cde5d7df456763aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02f6b3ad3a7816cde5d7df456763aaf">&#9670;&nbsp;</a></span>moveUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveUp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the beginning of its sibling list. </p>
<p >If the number of steps is larger than the greatest possible movement, the packet will be moved to the very beginning of its sibling list.</p>
<p >This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>the number of steps up to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55dfc77b354a21357c3429798113899f" name="a55dfc77b354a21357c3429798113899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dfc77b354a21357c3429798113899f">&#9670;&nbsp;</a></span>nextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::nextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the next sibling of this packet in the tree structure. </p>
<p >This is the child of the parent that follows this packet.</p>
<p >This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this packet, or <code>null</code> if there is none. </dd></dl>

</div>
</div>
<a id="a67c2cf1cd78f0ea966f6d573b92626d6" name="a67c2cf1cd78f0ea966f6d573b92626d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c2cf1cd78f0ea966f6d573b92626d6">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p >Note that this packet need not be the tree matriarch.</p>
<p >A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or <code>null</code> if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="ab9b5e5018b7b913e2a4fc4d76d913e89" name="ab9b5e5018b7b913e2a4fc4d76d913e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b5e5018b7b913e2a4fc4d76d913e89">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p >Note that this packet need not be the tree matriarch.</p>
<p >A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or <code>null</code> if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="aad48d147bf58a7a56dd5b5f60d63057a" name="aad48d147bf58a7a56dd5b5f60d63057a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad48d147bf58a7a56dd5b5f60d63057a">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p >Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1Packet.html#a2f11c6518807ab210a59b3a9e6c819be" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or <code>null</code> if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="ad2b7c74a584533689c179e704c669983" name="ad2b7c74a584533689c179e704c669983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7c74a584533689c179e704c669983">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p >Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1Packet.html#a2f11c6518807ab210a59b3a9e6c819be" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or <code>null</code> if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="a315cfc82357f74190fc01644aaee62a0" name="a315cfc82357f74190fc01644aaee62a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cfc82357f74190fc01644aaee62a0">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the parent packet in the tree structure. </p>
<p >This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent packet, or <code>null</code> if there is none. </dd></dl>

</div>
</div>
<a id="a2ae199aef20c94d0da16e9f681fd6360" name="a2ae199aef20c94d0da16e9f681fd6360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae199aef20c94d0da16e9f681fd6360">&#9670;&nbsp;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::prepend </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the first child of this packet. </p>
<p >This packet will take ownership of <em>child</em>, in the sense that every parent packet stores (either directly or indirectly) a shared_ptr to every one of its descendants in the packet tree.</p>
<p >In Regina 7.0 and earlier, this routine was called <a class="el" href="classregina_1_1Packet.html#aad326301f9e851cb9d51510080d63413" title="Deprecated routine that inserts the given packet as the first child of this packet.">insertChildFirst()</a>.</p>
<p >This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>child</em> already has a parent packet. Note that, although this tests <em>one</em> of our preconditions, there are other preconditions that are <em>not</em> tested, and for which no exceptions are thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e171383f2f89d69f77f8e8cf911c04c" name="a6e171383f2f89d69f77f8e8cf911c04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e171383f2f89d69f77f8e8cf911c04c">&#9670;&nbsp;</a></span>prevSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::prevSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the previous sibling of this packet in the tree structure. </p>
<p >This is the child of the parent that precedes this packet.</p>
<p >This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous sibling of this packet, or <code>null</code> if there is none. </dd></dl>

</div>
</div>
<a id="aee2405989e058dbfddf7ae445d47ddcf" name="aee2405989e058dbfddf7ae445d47ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2405989e058dbfddf7ae445d47ddcf">&#9670;&nbsp;</a></span>removeAllTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::removeAllTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all associated tags from this packet. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet. </p>

</div>
</div>
<a id="acb9880c0189b8f60827cd0ce9a2bb32c" name="acb9880c0189b8f60827cd0ce9a2bb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9880c0189b8f60827cd0ce9a2bb32c">&#9670;&nbsp;</a></span>removeTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the association of the given tag with this packet. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was removed, or <code>false</code> if the given tag was not actually associated with this packet. </dd></dl>

</div>
</div>
<a id="aa84f7026712d5d736e499429ae11881a" name="aa84f7026712d5d736e499429ae11881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84f7026712d5d736e499429ae11881a">&#9670;&nbsp;</a></span>reparent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::reparent </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead. </p>
<p >This routine is essentially a combination of <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it the root of its own ...">makeOrphan()</a> followed by either <a class="el" href="classregina_1_1Packet.html#a2ae199aef20c94d0da16e9f681fd6360" title="Inserts the given packet as the first child of this packet.">prepend()</a> or <a class="el" href="classregina_1_1Packet.html#a1765cf059113d2ad509bbfde7986c68f" title="Inserts the given packet as the last child of this packet.">append()</a>.</p>
<p >Even if you are not holding a shared_ptr to this packet yourself, this routine is still safe to use: it will maintain a shared_ptr as a "guard" so that this packet is not inadvertently destroyed during the transfer.</p>
<p >You may pass <em>newParent</em> as <code>null</code>, in which case this routine behaves in the same way as <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it the root of its own ...">makeOrphan()</a> (and is similarly safe to use even if there are no other shared pointers to this packet).</p>
<p >This routine takes small constant time. It is safe to use regardless of whether this packet currently has a parent or not.</p>
<p >If you wish to reparent <em>all</em> of the children of a given packet, see <a class="el" href="classregina_1_1Packet.html#ae3918c6630587e91954c28a3d770e4bb" title="Cuts all of this packet&#39;s children out of the packet tree, and reinserts them as children of the give...">transferChildren()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent of this packet, i.e., the packet beneath which this packet will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td><code>true</code> if this packet should be inserted as the first child of the given parent, or <code>false</code> (the default) if it should be inserted as the last child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf7a103b34cfe75eea6c186cdcefc739" name="adf7a103b34cfe75eea6c186cdcefc739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7a103b34cfe75eea6c186cdcefc739">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; regina::Packet::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the root of the tree to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the matriarch of the packet tree. </dd></dl>

</div>
</div>
<a id="a381fa20979fb976c4cfc0ba6fc38f1c1" name="a381fa20979fb976c4cfc0ba6fc38f1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381fa20979fb976c4cfc0ba6fc38f1c1">&#9670;&nbsp;</a></span>samePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::samePacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object refer to the same packet. </p>
<p >This is exactly the same as testing whether the underlying <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> pointers are equal, and so this routine is unnecessary for C++ users.</p>
<p >Instead, this routine is designed for Python users, since:</p>
<ul>
<li>the Python keyword <code>is</code> will not work, because there could be many different Python wrappers all pointing to the same C++ object;</li>
<li>the Python equality test (==) will not work, since as of Regina 7.0 this compares objects by value (i.e., it tests whether their contents are equal).</li>
</ul>
<p >A use case for this function could be (for example) iterating through a packet tree and identifying when a particular known packet has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the packet to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object refer to the same underlying packet. </dd></dl>

</div>
</div>
<a id="a14b88f9cd7be7d9fc2b0d4e47ffa25c5" name="a14b88f9cd7be7d9fc2b0d4e47ffa25c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b88f9cd7be7d9fc2b0d4e47ffa25c5">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format. </p>
<p >The XML file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p >This is the preferred way of saving a Regina data file. Typically this will be called from the root of the packet tree, which will save the entire packet tree to file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to write to. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. You should use the default (REGINA_CURRENT_FILE_FORMAT) unless you need your file to be readable by older versions of Regina. This must not be REGINA_BINARY_GEN_1, which is no longer supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="a023eb2b649a9e50036be3022506c38a4" name="a023eb2b649a9e50036be3022506c38a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023eb2b649a9e50036be3022506c38a4">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file. </p>
<p >The data file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p >Typically this will be called from the root of the packet tree, which will write the entire packet tree to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for writing. </dd>
<dd>
The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. This is not available in Python to avoid confusion with the filename-based <a class="el" href="classregina_1_1Packet.html#a14b88f9cd7be7d9fc2b0d4e47ffa25c5" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>. However, if you wish to write a Regina XML data file directly to an open Python file, you can still use <a class="el" href="classregina_1_1Packet.html#ab2ecf17816bd965f96c87be522069257" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> for this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. You should use the default (REGINA_CURRENT_FILE_FORMAT) unless you need your file to be readable by older versions of Regina. This must not be REGINA_BINARY_GEN_1, which is no longer supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the data was successfully written. </dd></dl>

</div>
</div>
<a id="adfd869991cbf664891629f21a5432b02" name="adfd869991cbf664891629f21a5432b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd869991cbf664891629f21a5432b02">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the label associated with this individual packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the new label to give this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af91bc951714dc60db12810affb266b8a" name="af91bc951714dc60db12810affb266b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91bc951714dc60db12810affb266b8a">&#9670;&nbsp;</a></span>sortChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::sortChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the immediate children of this packet according to their packet labels. </p>
<p >Note that this routine is not recursive (for instance, grandchildren will not be sorted within each child packet).</p>
<p >This routine takes quadratic time in the number of immediate children (and it's slow quadratic at that). </p>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a765186c1742fe402922433b77e5f439a" name="a765186c1742fe402922433b77e5f439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765186c1742fe402922433b77e5f439a">&#9670;&nbsp;</a></span>swapWithNextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::swapWithNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this packet with its next sibling in the sequence of children beneath their common parent packet. </p>
<p >Calling this routine is equivalent to calling <a class="el" href="classregina_1_1Packet.html#a59adc13b6143cf994779796077aed731" title="Moves this packet the given number of steps towards the end of its sibling list.">moveDown()</a>.</p>
<p >This routine takes small constant time.</p>
<p >If this packet has no next sibling then this routine safely does nothing. </p>

</div>
</div>
<a id="a06d41356ff086d078b04f34919aac26d" name="a06d41356ff086d078b04f34919aac26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d41356ff086d078b04f34919aac26d">&#9670;&nbsp;</a></span>tags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::Packet::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all tags associated with this packet. </p>
<p >Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p >Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a id="ae2519c2dac8e039b7acd5df8373c608d" name="ae2519c2dac8e039b7acd5df8373c608d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2519c2dac8e039b7acd5df8373c608d">&#9670;&nbsp;</a></span>totalTreeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::totalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<p >This packet is included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total tree or subtree size. </dd></dl>

</div>
</div>
<a id="ae3918c6630587e91954c28a3d770e4bb" name="ae3918c6630587e91954c28a3d770e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3918c6630587e91954c28a3d770e4bb">&#9670;&nbsp;</a></span>transferChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::transferChildren </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead. </p>
<p >The children of this packet will be appended to the end of the new parent's child list, in the same order as they were previously.</p>
<p >This is equivalent to calling <a class="el" href="classregina_1_1Packet.html#aa84f7026712d5d736e499429ae11881a" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> on each child, but should be somewhat faster if there are many children to move.</p>
<p >Even if you are not holding a shared_ptr to any of this packet's children, this routine is still safe to use: it will ensure there is always some shared_ptr to guard against any children being inadvertently destroyed during the transfer.</p>
<p >You may pass <em>newParent</em> as <code>null</code>, in which case this routine is equivalent to calling <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it the root of its own ...">makeOrphan()</a> on each child (and is similarly safe to use even if there are no other shared pointers to this packet).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent beneath which the children will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11e183185ea0a33e67e2574fc93c7469" name="a11e183185ea0a33e67e2574fc93c7469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e183185ea0a33e67e2574fc93c7469">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::Packet::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique integer ID representing this type of packet. </p>
<p >This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type ID. </dd></dl>

</div>
</div>
<a id="a787a09ec531988778fcfb0bc87effdd4" name="a787a09ec531988778fcfb0bc87effdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787a09ec531988778fcfb0bc87effdd4">&#9670;&nbsp;</a></span>typeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::Packet::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an English name for this type of packet. </p>
<p >An example is <code>Triangulation3</code>. This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type name. </dd></dl>

</div>
</div>
<a id="ae71b40cd2416de174bba61db2ec92f1d" name="ae71b40cd2416de174bba61db2ec92f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71b40cd2416de174bba61db2ec92f1d">&#9670;&nbsp;</a></span>unlisten()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters the given packet listener so that it no longer listens for events on this packet. </p>
<p >See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully unregistered, or <code>false</code> if the given listener was not registered in the first place. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a044a5c8d80d5aeb0e13a335bfc9b4ed3" name="a044a5c8d80d5aeb0e13a335bfc9b4ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044a5c8d80d5aeb0e13a335bfc9b4ed3">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p >This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1PacketOf.html#af3506a860bb88115baf17e144f676ca8">regina::PacketOf&lt; Held &gt;</a>, <a class="el" href="classregina_1_1Script.html#acd714e08cbdde1429990a867687fd1c6">regina::Script</a>, and <a class="el" href="classregina_1_1Text.html#afe65a9b4b9fc9430a6b161bae995f024">regina::Text</a>.</p>

</div>
</div>
<a id="a54930e66829e2b832b2b8d5b6813e55d" name="a54930e66829e2b832b2b8d5b6813e55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54930e66829e2b832b2b8d5b6813e55d">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p >This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a1cdb644d24c95413809cf27f87e40c49">regina::SurfaceFilterCombination</a>, <a class="el" href="classregina_1_1SurfaceFilterProperties.html#ab48ac343be11b8503534815c3c20de6b">regina::SurfaceFilterProperties</a>, <a class="el" href="classregina_1_1Attachment.html#a266b57ea05aef4e6227da9f5a3a6e8f9">regina::Attachment</a>, <a class="el" href="classregina_1_1Container.html#a0ab175cd8a5430641393166c9d6ff0d8">regina::Container</a>, <a class="el" href="classregina_1_1PacketOf.html#ad3b6003245846b9760ebf44ccd248d6a">regina::PacketOf&lt; Held &gt;</a>, <a class="el" href="classregina_1_1Script.html#a161bba5734a7675ae64dee54b8fd07ef">regina::Script</a>, and <a class="el" href="classregina_1_1Text.html#a0b5ade64bc08041b7bdf135ae6e65f16">regina::Text</a>.</p>

</div>
</div>
<a id="ad0983d128ef04f5b6f1d9124477bba88" name="ad0983d128ef04f5b6f1d9124477bba88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0983d128ef04f5b6f1d9124477bba88">&#9670;&nbsp;</a></span>writeXMLAnon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLAnon </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given packet inside its own anonymous block. </p>
<p >This could (for example) be called as the first step in <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a> if the packet needs some dependency <em>p</em> to have been explicitly written to file and this has not been done yet.</p>
<p >This function simply creates an <code>anon</code> XML block, and within it calls <code>p.writeXMLPacketData()</code> with the <em>anon</em> argument set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the anonymous block should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">refs</td><td>manages the necessary references between packets in the XML file; see the PacketRefs documentation for details. </td></tr>
    <tr><td class="paramname">p</td><td>the packet to write inside the anonymous block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2ecf17816bd965f96c87be522069257" name="ab2ecf17816bd965f96c87be522069257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ecf17816bd965f96c87be522069257">&#9670;&nbsp;</a></span>writeXMLFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68aceab2c59a151b4c9391d6a41e3bb9aa3">REGINA_CURRENT_FILE_FORMAT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format. </p>
<p >Ths is similar to calling <a class="el" href="classregina_1_1Packet.html#a14b88f9cd7be7d9fc2b0d4e47ffa25c5" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>, except that (i) the user has a more flexible choice of output stream, and (ii) the XML will always be written in plain text (i.e., it will not be compressed).</p>
<p >If you simply wish to save your data to a file on the filesystem, you should call <a class="el" href="classregina_1_1Packet.html#a14b88f9cd7be7d9fc2b0d4e47ffa25c5" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a> instead.</p>
<p >Typically this will be called from the root of the packet tree, which will write the entire packet tree to the output stream.</p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML data file should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. You should use the default (REGINA_CURRENT_FILE_FORMAT) unless you need your file to be readable by older versions of Regina. This must not be REGINA_BINARY_GEN_1, which is no longer supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8839bbf59d0a384810fb92e94c498a20" name="a8839bbf59d0a384810fb92e94c498a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8839bbf59d0a384810fb92e94c498a20">&#9670;&nbsp;</a></span>writeXMLFooter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLFooter </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the closing XML tag for this packet. </p>
<p >This is typically called at the end of <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a>.</p>
<p >There will be no whitespace before the closing XML tag. The tag will be followed by a newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the closing XML tag should be written. </td></tr>
    <tr><td class="paramname">element</td><td>the name of the XML tag. If we are writing to the REGINA_XML_GEN_2 format, then this will be ignored (and may be <code>null</code>), and the tag name <code>packet</code> will be used instead. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429634f90207822426df4923a62e3c28" name="a429634f90207822426df4923a62e3c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429634f90207822426df4923a62e3c28">&#9670;&nbsp;</a></span>writeXMLHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;&#160;</td>
          <td class="paramname"><em>refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; const char *, Args &gt;...&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the opening XML tag for this packet. </p>
<p >This is typically called at the beginning of <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a>.</p>
<p >The generic packet attributes (such as <code>label</code>, <code>id</code> if required, and <code>type</code> / <code>typeid</code> if we are writing to the second-generation format REGINA_XML_GEN_2) will be included.</p>
<p >If we are writing to the third-generation file format or newer, then any additional attributes specified in <em>attr</em> will also be included. If we are writing to the second-generation format REGINA_XML_GEN_2, then <em>attr</em> will be ignored.</p>
<p >If this packet appears as a key in the <em>refs</em> map, or if the <em>anon</em> argument indicates that we are in an anonymous block, then this routine will set <code>refs[this]</code> as <code>true</code> to record that this packet is now being written to XML.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the opening XML tag should be written. </td></tr>
    <tr><td class="paramname">element</td><td>the name of the XML tag. If we are writing to the REGINA_XML_GEN_2 format, then this will be ignored (and may be <code>null</code>), and the tag name <code>packet</code> will be used instead. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">anon</td><td><code>true</code> if this packet is being written within an anonymous block. If so, then the packet ID will always be written. </td></tr>
    <tr><td class="paramname">refs</td><td>manages the necessary references between packets in the XML file; see the PacketRefs documentation for details. </td></tr>
    <tr><td class="paramname">newline</td><td>indicates whether the opening XML tag should be followed by a newline. Normally this would be <code>true</code>, but if you need to avoid whitespace between the opening XML tag and the packet contents then you should pass <code>false</code> instead. </td></tr>
    <tr><td class="paramname">attr</td><td>any additional attributes to write to the XML tag; each attribute should a pair of the form (<em>attribute</em>, <em>value</em>). When writing to the REGINA_XML_GEN_2 format, this will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3727387cff93e0a9f9481a1826da1e4" name="ae3727387cff93e0a9f9481a1826da1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3727387cff93e0a9f9481a1826da1e4">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the full subtree with this packet as matriarch. </p>
<p >This should contain:</p>
<ul>
<li>any anonymous packets that need to be written before this packet (but first check <em>refs</em> to ensure these packets have not already been written);</li>
<li>the packet opening XML tag;</li>
<li>the packet contents;</li>
<li>any packet tags and/or child packets (but only if we are not inside an anonymous block);</li>
<li>a closing XML tag and a final newline.</li>
</ul>
<p >For native packet types, these five stages are typically implemented using:</p>
<ul>
<li>optional calls to <a class="el" href="classregina_1_1Packet.html#ad0983d128ef04f5b6f1d9124477bba88" title="Writes the given packet inside its own anonymous block.">writeXMLAnon()</a>;</li>
<li>a single call to <a class="el" href="classregina_1_1Packet.html#a429634f90207822426df4923a62e3c28" title="Writes the opening XML tag for this packet.">writeXMLHeader()</a>;</li>
<li>customised output;</li>
<li>a single call to <a class="el" href="classregina_1_1Packet.html#adb7a461c2301166fc295714d6a5cec84" title="Writes any generic XML sub-elements for this packet that come from the packet tree.">writeXMLTreeData()</a>, if <em>anon</em> is <code>false</code>;</li>
<li>a single call to <a class="el" href="classregina_1_1Packet.html#a8839bbf59d0a384810fb92e94c498a20" title="Writes the closing XML tag for this packet.">writeXMLFooter()</a>.</li>
</ul>
<p >For wrapped packet types that use a PacketOf&lt;Held&gt; wrapper, you should instead just specialise the routines from XMLWriter&lt;Held&gt;. The <a class="el" href="classregina_1_1PacketOf.html" title="A packet that stores a mathematical object of type Held.">PacketOf</a> wrapper will take care of the tree-specific code (in particular, it will handle the calls to <a class="el" href="classregina_1_1Packet.html#ad0983d128ef04f5b6f1d9124477bba88" title="Writes the given packet inside its own anonymous block.">writeXMLAnon()</a> and <a class="el" href="classregina_1_1Packet.html#adb7a461c2301166fc295714d6a5cec84" title="Writes any generic XML sub-elements for this packet that come from the packet tree.">writeXMLTreeData()</a>).</p>
<p >The output from this routine is only a piece of XML; it should not be used as a complete XML file. For a complete XML file, see routine <a class="el" href="classregina_1_1Packet.html#ab2ecf17816bd965f96c87be522069257" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">anon</td><td><code>true</code> if this packet is being written within an anonymous block. If so, then the packet ID must be included, and any packet tags and/or child packets must be excluded. </td></tr>
    <tr><td class="paramname">refs</td><td>manages the necessary references between packets in the XML file; see the PacketRefs documentation for details. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1Attachment.html#a4c5fac1edba41c179c38cb1dcc5619f3">regina::Attachment</a>, <a class="el" href="classregina_1_1Container.html#a8012564e1d1f4fbcae4b1da78da1ea1c">regina::Container</a>, <a class="el" href="classregina_1_1PacketOf.html#a7fd0d674184f3d96a22aa32d2ffe1530">regina::PacketOf&lt; Held &gt;</a>, <a class="el" href="classregina_1_1Script.html#a977e69c1f1b1aa5912d3db735a503b26">regina::Script</a>, <a class="el" href="classregina_1_1Text.html#ab87b69e1a3b10c9e797325a84fba666d">regina::Text</a>, <a class="el" href="classregina_1_1SurfaceFilterCombination.html#ad3e20b4c97f06d0f90f930e2f498bd9f">regina::SurfaceFilterCombination</a>, and <a class="el" href="classregina_1_1SurfaceFilterProperties.html#ae9e07037fc7cddfb9295b1427afd897d">regina::SurfaceFilterProperties</a>.</p>

</div>
</div>
<a id="adb7a461c2301166fc295714d6a5cec84" name="adb7a461c2301166fc295714d6a5cec84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a461c2301166fc295714d6a5cec84">&#9670;&nbsp;</a></span>writeXMLTreeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLTreeData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html#acba0016eb8ba8d58c769b7b2a2489134">PacketRefs</a> &amp;&#160;</td>
          <td class="paramname"><em>refs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes any generic XML sub-elements for this packet that come from the packet tree. </p>
<p >This is typically called towards the end of <a class="el" href="classregina_1_1Packet.html#ae3727387cff93e0a9f9481a1826da1e4" title="Writes a chunk of XML containing the full subtree with this packet as matriarch.">writeXMLPacketData()</a>, just before the final call to <a class="el" href="classregina_1_1Packet.html#a8839bbf59d0a384810fb92e94c498a20" title="Writes the closing XML tag for this packet.">writeXMLFooter()</a>.</p>
<p >The generic sub-elements include Regina's packet tags, as well as any child packets in the packet tree.</p>
<p >There will be no whitespace before the first sub-element (and so if there are no sub-elements at all then this routine will output nothing).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is not contained within an anonymous block.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the closing XML tag should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">refs</td><td>manages the necessary references between packets in the XML file; see the PacketRefs documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surface/<a class="el" href="surfacefilter_8h.html">surfacefilter.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
