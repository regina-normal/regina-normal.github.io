<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::AngleStructures Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1AngleStructures-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::AngleStructures Class Reference<div class="ingroups"><a class="el" href="group__angle.html">Angle Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A collection of angle structures on a 3-manifold triangulation.  
 <a href="classregina_1_1AngleStructures.html#details">More...</a></p>

<p><code>#include &lt;angle/anglestructures.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::AngleStructures:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1AngleStructures.png" usemap="#regina::AngleStructures_map" alt=""/>
  <map id="regina::AngleStructures_map" name="regina::AngleStructures_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; AngleStructures &gt;" shape="rect" coords="0,0,233,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; AngleStructures &gt;" shape="rect" coords="243,0,476,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ff76c90683858504a990bdacd60225b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a2ff76c90683858504a990bdacd60225b">AngleStructures</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="classregina_1_1AngleStructures.html#af604955e67680216432c2d9f523aa70c">triangulation</a>, bool tautOnly=false, <a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a> algHints=<a class="el" href="group__angle.html#ggae17d57a291131dc6631b3caa7eb559a3a1cf73110da70795bbea08c9b0543ed77">AS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a2ff76c90683858504a990bdacd60225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified constructor for enumerating various classes of angle structures on a given triangulation.  <a href="classregina_1_1AngleStructures.html#a2ff76c90683858504a990bdacd60225b">More...</a><br /></td></tr>
<tr class="separator:a2ff76c90683858504a990bdacd60225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa3bcc227bc29f8645c6aebe0360d0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a2fa3bcc227bc29f8645c6aebe0360d0d">AngleStructures</a> (const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;)=default</td></tr>
<tr class="memdesc:a2fa3bcc227bc29f8645c6aebe0360d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given list.  <a href="classregina_1_1AngleStructures.html#a2fa3bcc227bc29f8645c6aebe0360d0d">More...</a><br /></td></tr>
<tr class="separator:a2fa3bcc227bc29f8645c6aebe0360d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22feb56959b9da2d738b5c9918d4870e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a22feb56959b9da2d738b5c9918d4870e">AngleStructures</a> (<a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a22feb56959b9da2d738b5c9918d4870e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given list into this new list.  <a href="classregina_1_1AngleStructures.html#a22feb56959b9da2d738b5c9918d4870e">More...</a><br /></td></tr>
<tr class="separator:a22feb56959b9da2d738b5c9918d4870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ed20f387995860aaf9808524137601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a49ed20f387995860aaf9808524137601">operator=</a> (const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;src)</td></tr>
<tr class="memdesc:a49ed20f387995860aaf9808524137601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given list.  <a href="classregina_1_1AngleStructures.html#a49ed20f387995860aaf9808524137601">More...</a><br /></td></tr>
<tr class="separator:a49ed20f387995860aaf9808524137601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ffec2433004dc5dd103ac80d543d34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a41ffec2433004dc5dd103ac80d543d34">operator=</a> (<a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a41ffec2433004dc5dd103ac80d543d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given list into this list.  <a href="classregina_1_1AngleStructures.html#a41ffec2433004dc5dd103ac80d543d34">More...</a><br /></td></tr>
<tr class="separator:a41ffec2433004dc5dd103ac80d543d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5e6af9ba3dc97ef4fa6c33580ead3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#aaf5e6af9ba3dc97ef4fa6c33580ead3f">swap</a> (<a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;other)</td></tr>
<tr class="memdesc:aaf5e6af9ba3dc97ef4fa6c33580ead3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given list.  <a href="classregina_1_1AngleStructures.html#aaf5e6af9ba3dc97ef4fa6c33580ead3f">More...</a><br /></td></tr>
<tr class="separator:aaf5e6af9ba3dc97ef4fa6c33580ead3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af604955e67680216432c2d9f523aa70c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#af604955e67680216432c2d9f523aa70c">triangulation</a> () const</td></tr>
<tr class="memdesc:af604955e67680216432c2d9f523aa70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation on which these angle structures lie.  <a href="classregina_1_1AngleStructures.html#af604955e67680216432c2d9f523aa70c">More...</a><br /></td></tr>
<tr class="separator:af604955e67680216432c2d9f523aa70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d5492ed03fc096678261e6583d6c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a315d5492ed03fc096678261e6583d6c6">isTautOnly</a> () const</td></tr>
<tr class="memdesc:a315d5492ed03fc096678261e6583d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this list was produced by enumerating taut angle structures only.  <a href="classregina_1_1AngleStructures.html#a315d5492ed03fc096678261e6583d6c6">More...</a><br /></td></tr>
<tr class="separator:a315d5492ed03fc096678261e6583d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d453bfde8807b1cee9a2a555ca4c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ac0d453bfde8807b1cee9a2a555ca4c80">algorithm</a> () const</td></tr>
<tr class="memdesc:ac0d453bfde8807b1cee9a2a555ca4c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the algorithm that was used to enumerate this list.  <a href="classregina_1_1AngleStructures.html#ac0d453bfde8807b1cee9a2a555ca4c80">More...</a><br /></td></tr>
<tr class="separator:ac0d453bfde8807b1cee9a2a555ca4c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bfa1531d425a1c33b920d8f83586b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3">size</a> () const</td></tr>
<tr class="memdesc:a25bfa1531d425a1c33b920d8f83586b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of angle structures stored in this list.  <a href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3">More...</a><br /></td></tr>
<tr class="separator:a25bfa1531d425a1c33b920d8f83586b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa840e3e324d1beeb16e753622c697101"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#aa840e3e324d1beeb16e753622c697101">structure</a> (size_t index) const</td></tr>
<tr class="memdesc:aa840e3e324d1beeb16e753622c697101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle structure at the requested index in this list.  <a href="classregina_1_1AngleStructures.html#aa840e3e324d1beeb16e753622c697101">More...</a><br /></td></tr>
<tr class="separator:aa840e3e324d1beeb16e753622c697101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6213009a42a2dc988e9e8cee800ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a02f6213009a42a2dc988e9e8cee800ab">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a02f6213009a42a2dc988e9e8cee800ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle structure at the requested index in this list.  <a href="classregina_1_1AngleStructures.html#a02f6213009a42a2dc988e9e8cee800ab">More...</a><br /></td></tr>
<tr class="separator:a02f6213009a42a2dc988e9e8cee800ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d77e5ce462f298fe3e00d1b3ed5ac36"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36">begin</a> () const</td></tr>
<tr class="memdesc:a6d77e5ce462f298fe3e00d1b3ed5ac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator at the beginning of this list of angle structures.  <a href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36">More...</a><br /></td></tr>
<tr class="separator:a6d77e5ce462f298fe3e00d1b3ed5ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adcad4cf7ac19d3747f80c67efb9ac7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a2adcad4cf7ac19d3747f80c67efb9ac7">end</a> () const</td></tr>
<tr class="memdesc:a2adcad4cf7ac19d3747f80c67efb9ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator beyond the end of this list of angle structures.  <a href="classregina_1_1AngleStructures.html#a2adcad4cf7ac19d3747f80c67efb9ac7">More...</a><br /></td></tr>
<tr class="separator:a2adcad4cf7ac19d3747f80c67efb9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a13a6b9a3a2e95de45d8cc2ebca094"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#aa1a13a6b9a3a2e95de45d8cc2ebca094">__iter__</a> () const</td></tr>
<tr class="memdesc:aa1a13a6b9a3a2e95de45d8cc2ebca094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over the angle structures in this list.  <a href="classregina_1_1AngleStructures.html#aa1a13a6b9a3a2e95de45d8cc2ebca094">More...</a><br /></td></tr>
<tr class="separator:aa1a13a6b9a3a2e95de45d8cc2ebca094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c8446f4a8bbbb387104397bfde140d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ac4c8446f4a8bbbb387104397bfde140d">spansStrict</a> () const</td></tr>
<tr class="memdesc:ac4c8446f4a8bbbb387104397bfde140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any convex combination of the angle structures in this list is a strict angle structure.  <a href="classregina_1_1AngleStructures.html#ac4c8446f4a8bbbb387104397bfde140d">More...</a><br /></td></tr>
<tr class="separator:ac4c8446f4a8bbbb387104397bfde140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5a2614871da2375a68cdaca5fefa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ae0f5a2614871da2375a68cdaca5fefa8">spansTaut</a> () const</td></tr>
<tr class="memdesc:ae0f5a2614871da2375a68cdaca5fefa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any angle structure in this list is a taut structure.  <a href="classregina_1_1AngleStructures.html#ae0f5a2614871da2375a68cdaca5fefa8">More...</a><br /></td></tr>
<tr class="separator:ae0f5a2614871da2375a68cdaca5fefa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f5e368530646f30f0504c7bf40dd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a18f5e368530646f30f0504c7bf40dd30">operator==</a> (const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;other) const</td></tr>
<tr class="memdesc:a18f5e368530646f30f0504c7bf40dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain the same set of angle structures.  <a href="classregina_1_1AngleStructures.html#a18f5e368530646f30f0504c7bf40dd30">More...</a><br /></td></tr>
<tr class="separator:a18f5e368530646f30f0504c7bf40dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003948327d888936af60173ef5b6e719"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a003948327d888936af60173ef5b6e719">operator!=</a> (const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;other) const</td></tr>
<tr class="memdesc:a003948327d888936af60173ef5b6e719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain different sets of angle structures.  <a href="classregina_1_1AngleStructures.html#a003948327d888936af60173ef5b6e719">More...</a><br /></td></tr>
<tr class="separator:a003948327d888936af60173ef5b6e719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374aeed6014e27912337a9d98d5309e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a374aeed6014e27912337a9d98d5309e5">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a374aeed6014e27912337a9d98d5309e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1AngleStructures.html#a374aeed6014e27912337a9d98d5309e5">More...</a><br /></td></tr>
<tr class="separator:a374aeed6014e27912337a9d98d5309e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743e994c15a3fb78497f3ec61beea741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a743e994c15a3fb78497f3ec61beea741">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a743e994c15a3fb78497f3ec61beea741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1AngleStructures.html#a743e994c15a3fb78497f3ec61beea741">More...</a><br /></td></tr>
<tr class="separator:a743e994c15a3fb78497f3ec61beea741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae03d71f4dc9716d0a4f3b5792f3ba2a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ae03d71f4dc9716d0a4f3b5792f3ba2a1">AngleStructures</a> (bool tautOnly, <a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a> algHints, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="classregina_1_1AngleStructures.html#af604955e67680216432c2d9f523aa70c">triangulation</a>)</td></tr>
<tr class="memdesc:ae03d71f4dc9716d0a4f3b5792f3ba2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty angle structure list.  <a href="classregina_1_1AngleStructures.html#ae03d71f4dc9716d0a4f3b5792f3ba2a1">More...</a><br /></td></tr>
<tr class="separator:ae03d71f4dc9716d0a4f3b5792f3ba2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb315298423dc92a072462d9d9b6a110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#abb315298423dc92a072462d9d9b6a110">calculateSpanStrict</a> () const</td></tr>
<tr class="memdesc:abb315298423dc92a072462d9d9b6a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a strict angle structure.  <a href="classregina_1_1AngleStructures.html#abb315298423dc92a072462d9d9b6a110">More...</a><br /></td></tr>
<tr class="separator:abb315298423dc92a072462d9d9b6a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ad34f5f7ee0c4397353cf4edb4791ecd1">calculateSpanTaut</a> () const</td></tr>
<tr class="memdesc:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a taut structure.  <a href="classregina_1_1AngleStructures.html#ad34f5f7ee0c4397353cf4edb4791ecd1">More...</a><br /></td></tr>
<tr class="separator:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memItemLeft" align="right" valign="top"><a id="a7d43cee2f6d4a3a3ee51964ad7e3e7f4" name="a7d43cee2f6d4a3a3ee51964ad7e3e7f4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLAngleStructuresReader</b></td></tr>
<tr class="separator:a7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66f353c8a569a0c76831a4489631e9d"><td class="memItemLeft" align="right" valign="top"><a id="ad66f353c8a569a0c76831a4489631e9d" name="ad66f353c8a569a0c76831a4489631e9d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLLegacyAngleStructuresReader</b></td></tr>
<tr class="separator:ad66f353c8a569a0c76831a4489631e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984e7219f32db1a44a19f35d07d4fd18"><td class="memItemLeft" align="right" valign="top"><a id="a984e7219f32db1a44a19f35d07d4fd18" name="a984e7219f32db1a44a19f35d07d4fd18"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLWriter&lt; AngleStructures &gt;</b></td></tr>
<tr class="separator:a984e7219f32db1a44a19f35d07d4fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A collection of angle structures on a 3-manifold triangulation. </p>
<p >There are some important changes to this class as of Regina 7.0:</p>
<ul>
<li>An angle structure list does <em>not</em> need to be a child packet of the underlying triangulation, and indeed does not need to interact with the packet tree at all.</li>
<li>You are welcome to modify or even destroy the original triangulation; if you do then this list will automatically make a private copy of the original triangulation as an ongoing reference. Different angle structure lists (and normal surface lists) can all share the same private copy, so this is not an expensive process.</li>
<li>You should now create angle structure lists using the class constructor (but which, unlike the old enumerate(), does not insert the list into the packet tree). There is no need to use enumerate() any more.</li>
</ul>
<p >Since Regina 7.0, this is no longer a "packet type" that can be inserted directly into the packet tree. Instead an angle structure list is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> object, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include an <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> object in the packet tree, you must create a new PacketOf&lt;AngleStructures&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a>, and so inherits the full <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> interface.</li>
<li>If you are adding new functions to this class that edit the list, you must still remember to create a ChangeEventSpan. This will ensure that, if the list is being managed by a PacketOf&lt;AngleStructures&gt;, then the appropriate packet change events will be fired. All other events (aside from packetToBeChanged() and packetWasChanged() are managed directly by the PacketOf&lt;AngleStructures&gt; wrapper class.</li>
</ul>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ff76c90683858504a990bdacd60225b" name="a2ff76c90683858504a990bdacd60225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff76c90683858504a990bdacd60225b">&#9670;&nbsp;</a></span>AngleStructures() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__angle.html#ggae17d57a291131dc6631b3caa7eb559a3a1cf73110da70795bbea08c9b0543ed77">AS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified constructor for enumerating various classes of angle structures on a given triangulation. </p>
<p >If <em>tautOnly</em> is <code>false</code> (the default), then this new list will be filled with all vertices of the angle structure solution space. If <code>tautOnly</code> is <code>true</code>, then the list will be filled with only the taut angle structures (a subset of the vertex angle structures); these are usually much faster to enumerate.</p>
<p >The AngleAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default AS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p >Unlike the old enumerate() function, the new angle structure list will <em>not</em> be inserted into the packet tree. Moreover, the given triangulation may change or even be destroyed without causing problems. See the class notes for details.</p>
<p >If a progress tracker is passed, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p >This constructor will not return until the enumeration of angle structures is complete, regardless of whether a progress tracker was passed. If you need the behaviour of the old enumerate() (where passing a progress tracker caused the enumeration to start in the background), simply call this constructor in a new detached thread. Note that this enumeration can be extremely slow for larger triangulations, and so there could be good reasons to do this.</p>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this constructor runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation for which the vertex angle structures will be enumerated. </td></tr>
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated, or <code>false</code> if we should enumerate all vertices of the angle structure solution space. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa3bcc227bc29f8645c6aebe0360d0d" name="a2fa3bcc227bc29f8645c6aebe0360d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa3bcc227bc29f8645c6aebe0360d0d">&#9670;&nbsp;</a></span>AngleStructures() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given list. </p>

</div>
</div>
<a id="a22feb56959b9da2d738b5c9918d4870e" name="a22feb56959b9da2d738b5c9918d4870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22feb56959b9da2d738b5c9918d4870e">&#9670;&nbsp;</a></span>AngleStructures() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given list into this new list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this list is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03d71f4dc9716d0a4f3b5792f3ba2a1" name="ae03d71f4dc9716d0a4f3b5792f3ba2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03d71f4dc9716d0a4f3b5792f3ba2a1">&#9670;&nbsp;</a></span>AngleStructures() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty angle structure list. </p>
<p >All properties are marked as unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated (when the time comes for enumeration to be performed), or <code>false</code> if we should enumerate all vertices of the angle structure solution space. </td></tr>
    <tr><td class="paramname">algHints</td><td>contains requests for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">triangulation</td><td>the triangulation on which the angle structures will lie. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1a13a6b9a3a2e95de45d8cc2ebca094" name="aa1a13a6b9a3a2e95de45d8cc2ebca094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a13a6b9a3a2e95de45d8cc2ebca094">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::AngleStructures::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over the angle structures in this list. </p>
<p >In Python, an angle structure list can be treated as an iterable object:</p>
<div class="fragment"><div class="line">list = AngleStructures(...)</div>
<div class="line"><span class="keywordflow">for</span> s <span class="keywordflow">in</span> list:</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> provides the usual <a class="el" href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36" title="Returns a C++ iterator at the beginning of this list of angle structures.">begin()</a> and <a class="el" href="classregina_1_1AngleStructures.html#a2adcad4cf7ac19d3747f80c67efb9ac7" title="Returns a C++ iterator beyond the end of this list of angle structures.">end()</a> functions instead. In particular, you can iterate over the angle structures in this list in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the angle structures in this list. </dd></dl>

</div>
</div>
<a id="ac0d453bfde8807b1cee9a2a555ca4c80" name="ac0d453bfde8807b1cee9a2a555ca4c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d453bfde8807b1cee9a2a555ca4c80">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__angle.html#ga37368b55441c9d7bf40b47a25c01dadd">AngleAlg</a> regina::AngleStructures::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the algorithm that was used to enumerate this list. </p>
<p >These may not be the same AngleAlg flags that were passed to the class constructor. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="a6d77e5ce462f298fe3e00d1b3ed5ac36" name="a6d77e5ce462f298fe3e00d1b3ed5ac36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d77e5ce462f298fe3e00d1b3ed5ac36">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::AngleStructures::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator at the beginning of this list of angle structures. </p>
<p >These <a class="el" href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36" title="Returns a C++ iterator at the beginning of this list of angle structures.">begin()</a> and <a class="el" href="classregina_1_1AngleStructures.html#a2adcad4cf7ac19d3747f80c67efb9ac7" title="Returns a C++ iterator beyond the end of this list of angle structures.">end()</a> functions allow you to iterate through all angle structures in this list using a range-based <code>for</code> loop:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classregina_1_1AngleStructures.html#a2ff76c90683858504a990bdacd60225b">AngleStructures</a> list(...);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> AngleStructure&amp; s : list) { ... }</div>
<div class="ttc" id="aclassregina_1_1AngleStructures_html_a2ff76c90683858504a990bdacd60225b"><div class="ttname"><a href="classregina_1_1AngleStructures.html#a2ff76c90683858504a990bdacd60225b">regina::AngleStructures::AngleStructures</a></div><div class="ttdeci">AngleStructures(const Triangulation&lt; 3 &gt; &amp;triangulation, bool tautOnly=false, AngleAlg algHints=AS_ALG_DEFAULT, ProgressTracker *tracker=nullptr)</div><div class="ttdoc">A unified constructor for enumerating various classes of angle structures on a given triangulation.</div><div class="ttdef"><b>Definition:</b> anglestructures.h:588</div></div>
</div><!-- fragment --><p >The type that is returned will be a lightweight iterator type, guaranteed to satisfy the C++ LegacyRandomAccessIterator requirement. The precise C++ type of the iterator is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> implements the Python iterable interface. You can iterate over the angle structures in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this list. </dd></dl>

</div>
</div>
<a id="abb315298423dc92a072462d9d9b6a110" name="abb315298423dc92a072462d9d9b6a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb315298423dc92a072462d9d9b6a110">&#9670;&nbsp;</a></span>calculateSpanStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a strict angle structure. </p>

</div>
</div>
<a id="ad34f5f7ee0c4397353cf4edb4791ecd1" name="ad34f5f7ee0c4397353cf4edb4791ecd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34f5f7ee0c4397353cf4edb4791ecd1">&#9670;&nbsp;</a></span>calculateSpanTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a taut structure. </p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a2adcad4cf7ac19d3747f80c67efb9ac7" name="a2adcad4cf7ac19d3747f80c67efb9ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adcad4cf7ac19d3747f80c67efb9ac7">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::AngleStructures::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator beyond the end of this list of angle structures. </p>
<p >These <a class="el" href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36" title="Returns a C++ iterator at the beginning of this list of angle structures.">begin()</a> and <a class="el" href="classregina_1_1AngleStructures.html#a2adcad4cf7ac19d3747f80c67efb9ac7" title="Returns a C++ iterator beyond the end of this list of angle structures.">end()</a> functions allow you to iterate through all angle structures in this list using a range-based <code>for</code> loop. See the <a class="el" href="classregina_1_1AngleStructures.html#a6d77e5ce462f298fe3e00d1b3ed5ac36" title="Returns a C++ iterator at the beginning of this list of angle structures.">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> implements the Python iterable interface. You can iterate over the angle structures in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this list. </dd></dl>

</div>
</div>
<a id="a315d5492ed03fc096678261e6583d6c6" name="a315d5492ed03fc096678261e6583d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d5492ed03fc096678261e6583d6c6">&#9670;&nbsp;</a></span>isTautOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::isTautOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this list was produced by enumerating taut angle structures only. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was produced by enumerating taut angle structures only, or <code>false</code> if the enumeration procedure allowed for any angle structures. </dd></dl>

</div>
</div>
<a id="a003948327d888936af60173ef5b6e719" name="a003948327d888936af60173ef5b6e719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003948327d888936af60173ef5b6e719">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain different sets of angle structures. </p>
<p >The lists will be compared as multisets: the order of the angle structures in each list does not matter; however, in the unusual scenario where a list the same angle structure multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1AngleStructure.html" title="Represents an angle structure on a triangulation.">AngleStructure</a>, it does not matter whether the two lists work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare angle structures as though they were transplanted into the same triangulation using the same tetrahedron numbering and the same angle coordinates.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>true</code> (i.e., the lists will be considered different).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists do not represent the same multiset of angle structures, or <code>false</code> if they do. </dd></dl>

</div>
</div>
<a id="a41ffec2433004dc5dd103ac80d543d34" name="a41ffec2433004dc5dd103ac80d543d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ffec2433004dc5dd103ac80d543d34">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp; regina::AngleStructures::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given list into this list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this list which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a49ed20f387995860aaf9808524137601" name="a49ed20f387995860aaf9808524137601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ed20f387995860aaf9808524137601">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp; regina::AngleStructures::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a18f5e368530646f30f0504c7bf40dd30" name="a18f5e368530646f30f0504c7bf40dd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f5e368530646f30f0504c7bf40dd30">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain the same set of angle structures. </p>
<p >The lists will be compared as multisets: the order of the angle structures in each list does not matter; however, in the unusual scenario where a list the same angle structure multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1AngleStructure.html" title="Represents an angle structure on a triangulation.">AngleStructure</a>, it does not matter whether the two lists work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare angle structures as though they were transplanted into the same triangulation using the same tetrahedron numbering and the same angle coordinates.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>false</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists represent the same multiset of angle structures, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a02f6213009a42a2dc988e9e8cee800ab" name="a02f6213009a42a2dc988e9e8cee800ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f6213009a42a2dc988e9e8cee800ab">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp; regina::AngleStructures::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the angle structure at the requested index in this list. </p>
<p >This is identical to calling <a class="el" href="classregina_1_1AngleStructures.html#aa840e3e324d1beeb16e753622c697101" title="Returns the angle structure at the requested index in this list.">structure()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested angle structure in this list; this must be between 0 and <a class="el" href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3" title="Returns the number of angle structures stored in this list.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle structure at the requested index. </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a25bfa1531d425a1c33b920d8f83586b3" name="a25bfa1531d425a1c33b920d8f83586b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bfa1531d425a1c33b920d8f83586b3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AngleStructures::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of angle structures stored in this list. </p>
<dl class="section user"><dt>Python</dt><dd>This is also used to implement the Python special method <b>len</b>().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of angle structures. </dd></dl>

</div>
</div>
<a id="ac4c8446f4a8bbbb387104397bfde140d" name="ac4c8446f4a8bbbb387104397bfde140d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c8446f4a8bbbb387104397bfde140d">&#9670;&nbsp;</a></span>spansStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any convex combination of the angle structures in this list is a strict angle structure. </p>
<p >See <a class="el" href="classregina_1_1AngleStructure.html#aea6b3db616a85e5557a62996499b5994" title="Determines whether this is a strict angle structure.">AngleStructure::isStrict()</a> for details on strict angle structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a strict angle structure can be produced. </dd></dl>

</div>
</div>
<a id="ae0f5a2614871da2375a68cdaca5fefa8" name="ae0f5a2614871da2375a68cdaca5fefa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f5a2614871da2375a68cdaca5fefa8">&#9670;&nbsp;</a></span>spansTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any angle structure in this list is a taut structure. </p>
<p >Because taut structures always appear as vertices of the angle structure solution space, this routine is equivalent to testing whether any convex combination of the angle structures in this list is a taut structure.</p>
<p >See <a class="el" href="classregina_1_1AngleStructure.html#a41850883aa5d36f82a0ef708bd1e26ef" title="Determines whether this is a taut angle structure.">AngleStructure::isTaut()</a> for details on taut structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a taut structure can be produced. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa840e3e324d1beeb16e753622c697101" name="aa840e3e324d1beeb16e753622c697101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa840e3e324d1beeb16e753622c697101">&#9670;&nbsp;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp; regina::AngleStructures::structure </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the angle structure at the requested index in this list. </p>
<p >This is identical to using the square bracket operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested angle structure in this list; this must be between 0 and <a class="el" href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3" title="Returns the number of angle structures stored in this list.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle structure at the requested index. </dd></dl>

</div>
</div>
<a id="aaf5e6af9ba3dc97ef4fa6c33580ead3f" name="aaf5e6af9ba3dc97ef4fa6c33580ead3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5e6af9ba3dc97ef4fa6c33580ead3f">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given list. </p>
<p >This routine will behave correctly if <em>other</em> is in fact this list.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both lists which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af604955e67680216432c2d9f523aa70c" name="af604955e67680216432c2d9f523aa70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af604955e67680216432c2d9f523aa70c">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; regina::AngleStructures::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation on which these angle structures lie. </p>
<p >This will be a snapshot frozen in time of the triangulation that was originally passed to the <a class="el" href="classregina_1_1AngleStructures.html" title="A collection of angle structures on a 3-manifold triangulation.">AngleStructures</a> constructor.</p>
<p >This will return a correct result even if the original triangulation has since been modified or destroyed. However, in order to ensure this behaviour, it is possible that at different points in time this function may return references to different C++ objects.</p>
<p >The rules for using the <a class="el" href="classregina_1_1AngleStructures.html#af604955e67680216432c2d9f523aa70c" title="Returns the triangulation on which these angle structures lie.">triangulation()</a> reference are:</p>
<ul>
<li>Do not keep the resulting reference as a long-term reference or pointer of your own, since in time you may find yourself referring to the wrong object (see above). Just call this function again.</li>
<li>You must respect the read-only nature of the result (i.e., you must not cast the constness away). The snapshotting process detects modifications, and modifying the frozen snapshot may result in an exception being thrown.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>As of Regina 7.0, you <em>cannot</em> access this triangulation via the packet tree as <a class="el" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0" title="Determines the parent packet in the tree structure.">Packet::parent()</a>. This is because angle structure lists can now be kept anywhere in the packet tree, or can be kept as standalone objects outside the packet tree entirely.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a743e994c15a3fb78497f3ec61beea741" name="a743e994c15a3fb78497f3ec61beea741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743e994c15a3fb78497f3ec61beea741">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374aeed6014e27912337a9d98d5309e5" name="a374aeed6014e27912337a9d98d5309e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374aeed6014e27912337a9d98d5309e5">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>angle/<a class="el" href="anglestructures_8h.html">anglestructures.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
