<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::TypeTrie&lt; nTypes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1TypeTrie-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::TypeTrie&lt; nTypes &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A trie that stores a set of type vectors of a fixed length.  
 <a href="classregina_1_1TypeTrie.html#details">More...</a></p>

<p><code>#include &lt;enumerate/typetrie.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TypeTrie&lt; nTypes &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TypeTrie.png" usemap="#regina::TypeTrie_3C_20nTypes_20_3E_map" alt=""/>
  <map id="regina::TypeTrie_3C_20nTypes_20_3E_map" name="regina::TypeTrie_3C_20nTypes_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; TypeTrie&lt; nTypes &gt; &gt;" shape="rect" coords="0,0,230,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a105026fa0094cb4e1cf4a4caccd71577"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a105026fa0094cb4e1cf4a4caccd71577">TypeTrie</a> ()=default</td></tr>
<tr class="memdesc:a105026fa0094cb4e1cf4a4caccd71577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty trie.  <a href="classregina_1_1TypeTrie.html#a105026fa0094cb4e1cf4a4caccd71577">More...</a><br /></td></tr>
<tr class="separator:a105026fa0094cb4e1cf4a4caccd71577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17278ee6e93748cc95f1adf2936ad7c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a17278ee6e93748cc95f1adf2936ad7c5">TypeTrie</a> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;src)</td></tr>
<tr class="memdesc:a17278ee6e93748cc95f1adf2936ad7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given trie.  <a href="classregina_1_1TypeTrie.html#a17278ee6e93748cc95f1adf2936ad7c5">More...</a><br /></td></tr>
<tr class="separator:a17278ee6e93748cc95f1adf2936ad7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed3a6592737c747dc75aa9e2c336e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#afed3a6592737c747dc75aa9e2c336e69">TypeTrie</a> (<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:afed3a6592737c747dc75aa9e2c336e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given trie into this new trie.  <a href="classregina_1_1TypeTrie.html#afed3a6592737c747dc75aa9e2c336e69">More...</a><br /></td></tr>
<tr class="separator:afed3a6592737c747dc75aa9e2c336e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fbed1e24b20b004061747fe24aa5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a61fbed1e24b20b004061747fe24aa5a5">operator=</a> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;src)</td></tr>
<tr class="memdesc:a61fbed1e24b20b004061747fe24aa5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given trie.  <a href="classregina_1_1TypeTrie.html#a61fbed1e24b20b004061747fe24aa5a5">More...</a><br /></td></tr>
<tr class="separator:a61fbed1e24b20b004061747fe24aa5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab155d91c3041083eb96a9049a38992a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#ab155d91c3041083eb96a9049a38992a1">operator=</a> (<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ab155d91c3041083eb96a9049a38992a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given trie into this trie.  <a href="classregina_1_1TypeTrie.html#ab155d91c3041083eb96a9049a38992a1">More...</a><br /></td></tr>
<tr class="separator:ab155d91c3041083eb96a9049a38992a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641c9b156e5e02bf2d585d8f6421f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#af641c9b156e5e02bf2d585d8f6421f73">swap</a> (<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:af641c9b156e5e02bf2d585d8f6421f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given trie.  <a href="classregina_1_1TypeTrie.html#af641c9b156e5e02bf2d585d8f6421f73">More...</a><br /></td></tr>
<tr class="separator:af641c9b156e5e02bf2d585d8f6421f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0503ff98a1ce1d90b3ec427708cb041c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a0503ff98a1ce1d90b3ec427708cb041c">operator==</a> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;other) const</td></tr>
<tr class="memdesc:a0503ff98a1ce1d90b3ec427708cb041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given trie store exactly the same type vectors.  <a href="classregina_1_1TypeTrie.html#a0503ff98a1ce1d90b3ec427708cb041c">More...</a><br /></td></tr>
<tr class="separator:a0503ff98a1ce1d90b3ec427708cb041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9ba5b800de7b067db95622627db04b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a9d9ba5b800de7b067db95622627db04b">operator!=</a> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;other) const</td></tr>
<tr class="memdesc:a9d9ba5b800de7b067db95622627db04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given trie do not store exactly the same type vectors.  <a href="classregina_1_1TypeTrie.html#a9d9ba5b800de7b067db95622627db04b">More...</a><br /></td></tr>
<tr class="separator:a9d9ba5b800de7b067db95622627db04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17e1012c1c221ab783180e33ad40cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#af17e1012c1c221ab783180e33ad40cb7">clear</a> ()</td></tr>
<tr class="memdesc:af17e1012c1c221ab783180e33ad40cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this to the empty trie.  <a href="classregina_1_1TypeTrie.html#af17e1012c1c221ab783180e33ad40cb7">More...</a><br /></td></tr>
<tr class="separator:af17e1012c1c221ab783180e33ad40cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76682811098570fa3d5e0c5c883b6bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a76682811098570fa3d5e0c5c883b6bee">insert</a> (const char *entry, size_t len)</td></tr>
<tr class="memdesc:a76682811098570fa3d5e0c5c883b6bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given type vector into this trie.  <a href="classregina_1_1TypeTrie.html#a76682811098570fa3d5e0c5c883b6bee">More...</a><br /></td></tr>
<tr class="separator:a76682811098570fa3d5e0c5c883b6bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6300e5e34603dd9fa7f5c463e4ea93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a4c6300e5e34603dd9fa7f5c463e4ea93">dominates</a> (const char *vec, size_t len) const</td></tr>
<tr class="memdesc:a4c6300e5e34603dd9fa7f5c463e4ea93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type vector dominates any vector in this trie.  <a href="classregina_1_1TypeTrie.html#a4c6300e5e34603dd9fa7f5c463e4ea93">More...</a><br /></td></tr>
<tr class="separator:a4c6300e5e34603dd9fa7f5c463e4ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b29c7127d3144351347919c890f185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#a84b29c7127d3144351347919c890f185">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a84b29c7127d3144351347919c890f185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1TypeTrie.html#a84b29c7127d3144351347919c890f185">More...</a><br /></td></tr>
<tr class="separator:a84b29c7127d3144351347919c890f185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b6d070b0f10aa641095c417887f6e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html#af1b6d070b0f10aa641095c417887f6e2">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af1b6d070b0f10aa641095c417887f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1TypeTrie.html#af1b6d070b0f10aa641095c417887f6e2">More...</a><br /></td></tr>
<tr class="separator:af1b6d070b0f10aa641095c417887f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int nTypes&gt;<br />
class regina::TypeTrie&lt; nTypes &gt;</div><p >A trie that stores a set of type vectors of a fixed length. </p>
<p >This class forms part of the tree traversal algorithm for enumerating vertex normal surfaces, as described in "A tree traversal algorithm
for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801.</p>
<p >A type vector is a sequence of digits, each between 0 and <em>nTypes-1</em> inclusive. Type vectors are represented as arrays of characters: these are not strings, but simply sequences of one-byte integers. In particular, you cannot print them (since they use raw integer values, not ASCII digits). The length of a type vector must be passed alongside it (i.e., there is no special terminating character).</p>
<p >A type vector <em>v</em> is said to <em>dominate</em> <em>u</em> if, for each position <em>i</em>, either v[i] == u[i] or else u[i] == 0. So, for instance, (1,0,2,3) dominates (1,0,2,0), which in turn dominates (1,0,0,0). Domination is a partial order, not a total order: for instance, neither of (1,0,2,0) or (1,0,3,0) dominates the other.</p>
<p >We assume that all type vectors used in this trie have the same length. This is important, since we optimise the implementation by ignoring trailing zeroes, which means that this trie cannot distinguish between a vector <em>v</em> and the same vector with additional zeroes appended to its end.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. However, be aware that the cost of moving is linear in the template parameter <em>nTypes</em> (which, as noted below, is usually very small).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>nTypes</em> is between 1 and 256 inclusive. The typical value for <em>nTypes</em> for normal surface enumeration is either 4 or 7 (depending upon whether we are supporting almost normal surfaces).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This is available only for the template parameters <em>nTypes</em> = 4 and 7, under the names TypeTrie4 and TypeTrie7 respectively. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a105026fa0094cb4e1cf4a4caccd71577" name="a105026fa0094cb4e1cf4a4caccd71577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105026fa0094cb4e1cf4a4caccd71577">&#9670;&nbsp;</a></span>TypeTrie() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::TypeTrie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty trie. </p>

</div>
</div>
<a id="a17278ee6e93748cc95f1adf2936ad7c5" name="a17278ee6e93748cc95f1adf2936ad7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17278ee6e93748cc95f1adf2936ad7c5">&#9670;&nbsp;</a></span>TypeTrie() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::TypeTrie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given trie. </p>
<p >This will induce a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the trie to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afed3a6592737c747dc75aa9e2c336e69" name="afed3a6592737c747dc75aa9e2c336e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed3a6592737c747dc75aa9e2c336e69">&#9670;&nbsp;</a></span>TypeTrie() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::TypeTrie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given trie into this new trie. </p>
<p >This is operation is constant time in the size of the trie, but linear time in the template parameter <em>nTypes</em>.</p>
<p >The trie that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the trie whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af17e1012c1c221ab783180e33ad40cb7" name="af17e1012c1c221ab783180e33ad40cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17e1012c1c221ab783180e33ad40cb7">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets this to the empty trie. </p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a4c6300e5e34603dd9fa7f5c463e4ea93" name="a4c6300e5e34603dd9fa7f5c463e4ea93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6300e5e34603dd9fa7f5c463e4ea93">&#9670;&nbsp;</a></span>dominates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::dominates </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type vector dominates any vector in this trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given length <em>len</em> is non-zero, and is fixed throughout the life of this trie; that is, it is the same every time <a class="el" href="classregina_1_1TypeTrie.html#a76682811098570fa3d5e0c5c883b6bee" title="Inserts the given type vector into this trie.">insert()</a> or <a class="el" href="classregina_1_1TypeTrie.html#a4c6300e5e34603dd9fa7f5c463e4ea93" title="Determines whether the given type vector dominates any vector in this trie.">dominates()</a> is called.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the arguments <em>vec</em> and <em>len</em>, you should pass a single argument which is a python sequence of length <em>len</em>. This list should be a type vector, and each list element should be between 0 and (<em>nTypes</em> - 1) inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the type vector to test. </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the given type vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>vec</em> dominates some type vector stored in this trie. </dd></dl>

</div>
</div>
<a id="a76682811098570fa3d5e0c5c883b6bee" name="a76682811098570fa3d5e0c5c883b6bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76682811098570fa3d5e0c5c883b6bee">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given type vector into this trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given length <em>len</em> is non-zero, and is fixed throughout the life of this trie; that is, it is the same every time <a class="el" href="classregina_1_1TypeTrie.html#a76682811098570fa3d5e0c5c883b6bee" title="Inserts the given type vector into this trie.">insert()</a> or <a class="el" href="classregina_1_1TypeTrie.html#a4c6300e5e34603dd9fa7f5c463e4ea93" title="Determines whether the given type vector dominates any vector in this trie.">dominates()</a> is called.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the arguments <em>entry</em> and <em>len</em>, you should pass a single argument which is a python sequence of length <em>len</em>. This list should be a type vector, and each list element should be between 0 and (<em>nTypes</em> - 1) inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the type vector to insert. </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the given type vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d9ba5b800de7b067db95622627db04b" name="a9d9ba5b800de7b067db95622627db04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9ba5b800de7b067db95622627db04b">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given trie do not store exactly the same type vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the trie to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both tries do not store the same type vectors. </dd></dl>

</div>
</div>
<a id="a61fbed1e24b20b004061747fe24aa5a5" name="a61fbed1e24b20b004061747fe24aa5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fbed1e24b20b004061747fe24aa5a5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp; <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given trie. </p>
<p >This will induce a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the trie to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this trie. </dd></dl>

</div>
</div>
<a id="ab155d91c3041083eb96a9049a38992a1" name="ab155d91c3041083eb96a9049a38992a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab155d91c3041083eb96a9049a38992a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp; <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given trie into this trie. </p>
<p >This is operation is constant time in the size of the trie, but linear time in the template parameter <em>nTypes</em>.</p>
<p >The trie that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the trie whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this trie. </dd></dl>

</div>
</div>
<a id="a0503ff98a1ce1d90b3ec427708cb041c" name="a0503ff98a1ce1d90b3ec427708cb041c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0503ff98a1ce1d90b3ec427708cb041c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given trie store exactly the same type vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the trie to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both tries store the same type vectors. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="af641c9b156e5e02bf2d585d8f6421f73" name="af641c9b156e5e02bf2d585d8f6421f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641c9b156e5e02bf2d585d8f6421f73">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given trie. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the trie whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="af1b6d070b0f10aa641095c417887f6e2" name="af1b6d070b0f10aa641095c417887f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b6d070b0f10aa641095c417887f6e2">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84b29c7127d3144351347919c890f185" name="a84b29c7127d3144351347919c890f185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b29c7127d3144351347919c890f185">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>enumerate/<a class="el" href="typetrie_8h.html">typetrie.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
