<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::Laurent&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Laurent.html">Laurent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Laurent-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Laurent&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial with coefficients of type <em>T</em>.  
 <a href="classregina_1_1Laurent.html#details">More...</a></p>

<p><code>#include &lt;maths/laurent.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Laurent&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Laurent.png" usemap="#regina::Laurent_3C_20T_20_3E_map" alt=""/>
  <map id="regina::Laurent_3C_20T_20_3E_map" name="regina::Laurent_3C_20T_20_3E_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Laurent&lt; T &gt;, true &gt;" shape="rect" coords="0,56,268,80"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Laurent&lt; T &gt; &gt;" shape="rect" coords="278,56,546,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Laurent&lt; T &gt;, supportsUtf8 &gt;" shape="rect" coords="0,0,268,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac5415cf78943d61487a2e7b3992dc2d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ac5415cf78943d61487a2e7b3992dc2d0">Coefficient</a> = T</td></tr>
<tr class="memdesc:ac5415cf78943d61487a2e7b3992dc2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each coefficient of the polynomial.  <a href="classregina_1_1Laurent.html#ac5415cf78943d61487a2e7b3992dc2d0">More...</a><br /></td></tr>
<tr class="separator:ac5415cf78943d61487a2e7b3992dc2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63b4616a4b2aa8873366a89bf5dd11be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a63b4616a4b2aa8873366a89bf5dd11be">Laurent</a> ()</td></tr>
<tr class="memdesc:a63b4616a4b2aa8873366a89bf5dd11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the zero polynomial.  <a href="classregina_1_1Laurent.html#a63b4616a4b2aa8873366a89bf5dd11be">More...</a><br /></td></tr>
<tr class="separator:a63b4616a4b2aa8873366a89bf5dd11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5b2b285cec03e8be60cb4c27ba02e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a0a5b2b285cec03e8be60cb4c27ba02e2">Laurent</a> (long exponent)</td></tr>
<tr class="memdesc:a0a5b2b285cec03e8be60cb4c27ba02e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the polynomial <code>x^d</code> for the given exponent <em>d</em>.  <a href="classregina_1_1Laurent.html#a0a5b2b285cec03e8be60cb4c27ba02e2">More...</a><br /></td></tr>
<tr class="separator:a0a5b2b285cec03e8be60cb4c27ba02e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98443b527c50e3f0075657124ecde39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ae98443b527c50e3f0075657124ecde39">Laurent</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ae98443b527c50e3f0075657124ecde39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <a href="classregina_1_1Laurent.html#ae98443b527c50e3f0075657124ecde39">More...</a><br /></td></tr>
<tr class="separator:ae98443b527c50e3f0075657124ecde39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f998c80c610cacc4ea550889e1d19c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a21f998c80c610cacc4ea550889e1d19c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a21f998c80c610cacc4ea550889e1d19c">Laurent</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:a21f998c80c610cacc4ea550889e1d19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <a href="classregina_1_1Laurent.html#a21f998c80c610cacc4ea550889e1d19c">More...</a><br /></td></tr>
<tr class="separator:a21f998c80c610cacc4ea550889e1d19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efdfbb8205d73f70ad59555cb8c89f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a3efdfbb8205d73f70ad59555cb8c89f3">Laurent</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a3efdfbb8205d73f70ad59555cb8c89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this new polynomial.  <a href="classregina_1_1Laurent.html#a3efdfbb8205d73f70ad59555cb8c89f3">More...</a><br /></td></tr>
<tr class="separator:a3efdfbb8205d73f70ad59555cb8c89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a32be67cd921996e959bdc3e7732a6"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:a79a32be67cd921996e959bdc3e7732a6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a79a32be67cd921996e959bdc3e7732a6">Laurent</a> (long <a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59">minExp</a>, iterator begin, iterator end)</td></tr>
<tr class="memdesc:a79a32be67cd921996e959bdc3e7732a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from the given sequence of coefficients.  <a href="classregina_1_1Laurent.html#a79a32be67cd921996e959bdc3e7732a6">More...</a><br /></td></tr>
<tr class="separator:a79a32be67cd921996e959bdc3e7732a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6761bdb9554c028910deec5cc2fe12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a9e6761bdb9554c028910deec5cc2fe12">Laurent</a> (long <a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59">minExp</a>, std::initializer_list&lt; T &gt; coefficients)</td></tr>
<tr class="memdesc:a9e6761bdb9554c028910deec5cc2fe12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from a hard-coded sequence of coefficients.  <a href="classregina_1_1Laurent.html#a9e6761bdb9554c028910deec5cc2fe12">More...</a><br /></td></tr>
<tr class="separator:a9e6761bdb9554c028910deec5cc2fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b082789a1cfd1f3a9e5860240139c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a6e4b082789a1cfd1f3a9e5860240139c">~Laurent</a> ()</td></tr>
<tr class="memdesc:a6e4b082789a1cfd1f3a9e5860240139c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this polynomial.  <a href="classregina_1_1Laurent.html#a6e4b082789a1cfd1f3a9e5860240139c">More...</a><br /></td></tr>
<tr class="separator:a6e4b082789a1cfd1f3a9e5860240139c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f01dcede64d90314c8d9138a9a87de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ad8f01dcede64d90314c8d9138a9a87de">init</a> ()</td></tr>
<tr class="memdesc:ad8f01dcede64d90314c8d9138a9a87de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the zero polynomial.  <a href="classregina_1_1Laurent.html#ad8f01dcede64d90314c8d9138a9a87de">More...</a><br /></td></tr>
<tr class="separator:ad8f01dcede64d90314c8d9138a9a87de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f2a95338c49123859abb0e13810b69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a52f2a95338c49123859abb0e13810b69">init</a> (long exponent)</td></tr>
<tr class="memdesc:a52f2a95338c49123859abb0e13810b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the polynomial <code>x^d</code> for the given exponent <em>d</em>.  <a href="classregina_1_1Laurent.html#a52f2a95338c49123859abb0e13810b69">More...</a><br /></td></tr>
<tr class="separator:a52f2a95338c49123859abb0e13810b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e9b4875cce50a6591844c108ace08"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:a5d6e9b4875cce50a6591844c108ace08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a5d6e9b4875cce50a6591844c108ace08">init</a> (long <a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59">minExp</a>, iterator begin, iterator end)</td></tr>
<tr class="memdesc:a5d6e9b4875cce50a6591844c108ace08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the polynomial described by the given sequence of coefficients.  <a href="classregina_1_1Laurent.html#a5d6e9b4875cce50a6591844c108ace08">More...</a><br /></td></tr>
<tr class="separator:a5d6e9b4875cce50a6591844c108ace08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0815be3b6d0a8258ecb6178f52bed59"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59">minExp</a> () const</td></tr>
<tr class="memdesc:af0815be3b6d0a8258ecb6178f52bed59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest exponent that appears in this polynomial with a non-zero coefficient.  <a href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59">More...</a><br /></td></tr>
<tr class="separator:af0815be3b6d0a8258ecb6178f52bed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03bc71da56a6a1f80260698688951dc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ae03bc71da56a6a1f80260698688951dc">maxExp</a> () const</td></tr>
<tr class="memdesc:ae03bc71da56a6a1f80260698688951dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest exponent that appears in this polynomial with a non-zero coefficient.  <a href="classregina_1_1Laurent.html#ae03bc71da56a6a1f80260698688951dc">More...</a><br /></td></tr>
<tr class="separator:ae03bc71da56a6a1f80260698688951dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3aa9b0ebec34c2de2190c8fd1353a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#abb3aa9b0ebec34c2de2190c8fd1353a3">isZero</a> () const</td></tr>
<tr class="memdesc:abb3aa9b0ebec34c2de2190c8fd1353a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is the zero polynomial.  <a href="classregina_1_1Laurent.html#abb3aa9b0ebec34c2de2190c8fd1353a3">More...</a><br /></td></tr>
<tr class="separator:abb3aa9b0ebec34c2de2190c8fd1353a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b42d75b72b53af78eda746bd2d4aed"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a71b42d75b72b53af78eda746bd2d4aed">operator[]</a> (long exp) const</td></tr>
<tr class="memdesc:a71b42d75b72b53af78eda746bd2d4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given coefficient of this polynomial.  <a href="classregina_1_1Laurent.html#a71b42d75b72b53af78eda746bd2d4aed">More...</a><br /></td></tr>
<tr class="separator:a71b42d75b72b53af78eda746bd2d4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecbe74e6268dbbab5c7f6a41f4e0ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#adecbe74e6268dbbab5c7f6a41f4e0ea6">set</a> (long exp, const T &amp;value)</td></tr>
<tr class="memdesc:adecbe74e6268dbbab5c7f6a41f4e0ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the given coefficient of this polynomial.  <a href="classregina_1_1Laurent.html#adecbe74e6268dbbab5c7f6a41f4e0ea6">More...</a><br /></td></tr>
<tr class="separator:adecbe74e6268dbbab5c7f6a41f4e0ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66df5c8553be85b06aeaeccecba8151b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a66df5c8553be85b06aeaeccecba8151b">operator==</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a66df5c8553be85b06aeaeccecba8151b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given polynomial are equal.  <a href="classregina_1_1Laurent.html#a66df5c8553be85b06aeaeccecba8151b">More...</a><br /></td></tr>
<tr class="separator:a66df5c8553be85b06aeaeccecba8151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837ae1fab36a539549f32d080011c08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a837ae1fab36a539549f32d080011c08e">operator!=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a837ae1fab36a539549f32d080011c08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given polynomial are not equal.  <a href="classregina_1_1Laurent.html#a837ae1fab36a539549f32d080011c08e">More...</a><br /></td></tr>
<tr class="separator:a837ae1fab36a539549f32d080011c08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6d9b937f90bbb3479872ac5ac94b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a2b6d9b937f90bbb3479872ac5ac94b04">operator&lt;</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a2b6d9b937f90bbb3479872ac5ac94b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent.html#a2b6d9b937f90bbb3479872ac5ac94b04">More...</a><br /></td></tr>
<tr class="separator:a2b6d9b937f90bbb3479872ac5ac94b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae36349e8a7b435b322fc843100440c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#adae36349e8a7b435b322fc843100440c">operator&gt;</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:adae36349e8a7b435b322fc843100440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent.html#adae36349e8a7b435b322fc843100440c">More...</a><br /></td></tr>
<tr class="separator:adae36349e8a7b435b322fc843100440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4ee445c713a6a8e8153d019bd2d59b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#afb4ee445c713a6a8e8153d019bd2d59b">operator&lt;=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:afb4ee445c713a6a8e8153d019bd2d59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent.html#afb4ee445c713a6a8e8153d019bd2d59b">More...</a><br /></td></tr>
<tr class="separator:afb4ee445c713a6a8e8153d019bd2d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444c6720d63731754debf32d8f17a5fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a444c6720d63731754debf32d8f17a5fb">operator&gt;=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a444c6720d63731754debf32d8f17a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent.html#a444c6720d63731754debf32d8f17a5fb">More...</a><br /></td></tr>
<tr class="separator:a444c6720d63731754debf32d8f17a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780cc8457db13ba28a5fc10e218493d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a780cc8457db13ba28a5fc10e218493d1">operator=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a780cc8457db13ba28a5fc10e218493d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <a href="classregina_1_1Laurent.html#a780cc8457db13ba28a5fc10e218493d1">More...</a><br /></td></tr>
<tr class="separator:a780cc8457db13ba28a5fc10e218493d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2622abe5fb4ea67cb8eac02fbeac9b6"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa2622abe5fb4ea67cb8eac02fbeac9b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#aa2622abe5fb4ea67cb8eac02fbeac9b6">operator=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:aa2622abe5fb4ea67cb8eac02fbeac9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <a href="classregina_1_1Laurent.html#aa2622abe5fb4ea67cb8eac02fbeac9b6">More...</a><br /></td></tr>
<tr class="separator:aa2622abe5fb4ea67cb8eac02fbeac9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3b63c0f4e395c7401006669a937698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a1a3b63c0f4e395c7401006669a937698">operator=</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a1a3b63c0f4e395c7401006669a937698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this polynomial.  <a href="classregina_1_1Laurent.html#a1a3b63c0f4e395c7401006669a937698">More...</a><br /></td></tr>
<tr class="separator:a1a3b63c0f4e395c7401006669a937698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fd032076d422a88aca0c10284a69e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ae4fd032076d422a88aca0c10284a69e5">swap</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:ae4fd032076d422a88aca0c10284a69e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given polynomial.  <a href="classregina_1_1Laurent.html#ae4fd032076d422a88aca0c10284a69e5">More...</a><br /></td></tr>
<tr class="separator:ae4fd032076d422a88aca0c10284a69e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad23897e5db058379bde58a8c13aafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#abad23897e5db058379bde58a8c13aafe">shift</a> (long s)</td></tr>
<tr class="memdesc:abad23897e5db058379bde58a8c13aafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this polynomial by <code>x^s</code> for some integer <em>s</em>.  <a href="classregina_1_1Laurent.html#abad23897e5db058379bde58a8c13aafe">More...</a><br /></td></tr>
<tr class="separator:abad23897e5db058379bde58a8c13aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad152d0634b68b5d6df4692fb09ef47a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ad152d0634b68b5d6df4692fb09ef47a9">scaleUp</a> (long k)</td></tr>
<tr class="memdesc:ad152d0634b68b5d6df4692fb09ef47a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all exponents in this polynomial by <em>k</em> for some integer <em>k</em>.  <a href="classregina_1_1Laurent.html#ad152d0634b68b5d6df4692fb09ef47a9">More...</a><br /></td></tr>
<tr class="separator:ad152d0634b68b5d6df4692fb09ef47a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18d1efbb319d8b4ab9fa8402b594195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ad18d1efbb319d8b4ab9fa8402b594195">scaleDown</a> (long k)</td></tr>
<tr class="memdesc:ad18d1efbb319d8b4ab9fa8402b594195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all exponents in this polynomial by <em>k</em> for some integer <em>k</em>.  <a href="classregina_1_1Laurent.html#ad18d1efbb319d8b4ab9fa8402b594195">More...</a><br /></td></tr>
<tr class="separator:ad18d1efbb319d8b4ab9fa8402b594195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6bb2ccf393b0c2a8e3fa3a336d15c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a9d6bb2ccf393b0c2a8e3fa3a336d15c6">negate</a> ()</td></tr>
<tr class="memdesc:a9d6bb2ccf393b0c2a8e3fa3a336d15c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates this polynomial.  <a href="classregina_1_1Laurent.html#a9d6bb2ccf393b0c2a8e3fa3a336d15c6">More...</a><br /></td></tr>
<tr class="separator:a9d6bb2ccf393b0c2a8e3fa3a336d15c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48574eadf1ea1ab82a0bd7bbfa853325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a48574eadf1ea1ab82a0bd7bbfa853325">invertX</a> ()</td></tr>
<tr class="memdesc:a48574eadf1ea1ab82a0bd7bbfa853325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>x</code> with <code>x^-1</code> in this polynomial.  <a href="classregina_1_1Laurent.html#a48574eadf1ea1ab82a0bd7bbfa853325">More...</a><br /></td></tr>
<tr class="separator:a48574eadf1ea1ab82a0bd7bbfa853325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978e5c598bc8e4c667572c95e32fb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#aa978e5c598bc8e4c667572c95e32fb88">operator*=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:aa978e5c598bc8e4c667572c95e32fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this polynomial by the given constant.  <a href="classregina_1_1Laurent.html#aa978e5c598bc8e4c667572c95e32fb88">More...</a><br /></td></tr>
<tr class="separator:aa978e5c598bc8e4c667572c95e32fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7cd66e8cfd8b4ea813be5fcb1c3414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#adc7cd66e8cfd8b4ea813be5fcb1c3414">operator/=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:adc7cd66e8cfd8b4ea813be5fcb1c3414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this polynomial by the given constant.  <a href="classregina_1_1Laurent.html#adc7cd66e8cfd8b4ea813be5fcb1c3414">More...</a><br /></td></tr>
<tr class="separator:adc7cd66e8cfd8b4ea813be5fcb1c3414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c8a4317008b6e6ee4807ca0a478424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#aa2c8a4317008b6e6ee4807ca0a478424">operator+=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aa2c8a4317008b6e6ee4807ca0a478424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given polynomial to this.  <a href="classregina_1_1Laurent.html#aa2c8a4317008b6e6ee4807ca0a478424">More...</a><br /></td></tr>
<tr class="separator:aa2c8a4317008b6e6ee4807ca0a478424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11743c2ae66db923c2a54cd64f5b311a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a11743c2ae66db923c2a54cd64f5b311a">operator-=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a11743c2ae66db923c2a54cd64f5b311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given polynomial from this.  <a href="classregina_1_1Laurent.html#a11743c2ae66db923c2a54cd64f5b311a">More...</a><br /></td></tr>
<tr class="separator:a11743c2ae66db923c2a54cd64f5b311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24bd6c5d46ad8a002610825beea33d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#af24bd6c5d46ad8a002610825beea33d1">operator*=</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:af24bd6c5d46ad8a002610825beea33d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by the given polynomial.  <a href="classregina_1_1Laurent.html#af24bd6c5d46ad8a002610825beea33d1">More...</a><br /></td></tr>
<tr class="separator:af24bd6c5d46ad8a002610825beea33d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222949d4b018e949da5d72f8884b87a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a222949d4b018e949da5d72f8884b87a5">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="classregina_1_1Laurent.html#a7bc46f4943f0e97275fbad97415e9f46">utf8</a>=false, const char *variable=nullptr) const</td></tr>
<tr class="memdesc:a222949d4b018e949da5d72f8884b87a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this polynomial to the given output stream, using the given variable name instead of <code>x</code>.  <a href="classregina_1_1Laurent.html#a222949d4b018e949da5d72f8884b87a5">More...</a><br /></td></tr>
<tr class="separator:a222949d4b018e949da5d72f8884b87a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba407d6cdb53604413e4cd718099f3f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2">str</a> (const char *variable) const</td></tr>
<tr class="memdesc:aba407d6cdb53604413e4cd718099f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string, using the given variable name instead of <code>x</code>.  <a href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2">More...</a><br /></td></tr>
<tr class="separator:aba407d6cdb53604413e4cd718099f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc46f4943f0e97275fbad97415e9f46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a7bc46f4943f0e97275fbad97415e9f46">utf8</a> (const char *variable) const</td></tr>
<tr class="memdesc:a7bc46f4943f0e97275fbad97415e9f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string using unicode characters, using the given variable name instead of <code>x</code>.  <a href="classregina_1_1Laurent.html#a7bc46f4943f0e97275fbad97415e9f46">More...</a><br /></td></tr>
<tr class="separator:a7bc46f4943f0e97275fbad97415e9f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43543d127c64804a55b5a49758ef73a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#ad43543d127c64804a55b5a49758ef73a">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad43543d127c64804a55b5a49758ef73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this polynomial to the given output stream.  <a href="classregina_1_1Laurent.html#ad43543d127c64804a55b5a49758ef73a">More...</a><br /></td></tr>
<tr class="separator:ad43543d127c64804a55b5a49758ef73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <a href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">More...</a><br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a65188876596177c6ab6abe3785a7e459"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html#a65188876596177c6ab6abe3785a7e459">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a65188876596177c6ab6abe3785a7e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a polynomial from its given tight encoding.  <a href="classregina_1_1Laurent.html#a65188876596177c6ab6abe3785a7e459">More...</a><br /></td></tr>
<tr class="separator:a65188876596177c6ab6abe3785a7e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <a href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">More...</a><br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8413c6f9178f81721b8473995afa9123"><td class="memTemplParams" colspan="2"><a id="a8413c6f9178f81721b8473995afa9123" name="a8413c6f9178f81721b8473995afa9123"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a8413c6f9178f81721b8473995afa9123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a8413c6f9178f81721b8473995afa9123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f6fb6e96440153641e7f985f4fff86"><td class="memTemplParams" colspan="2"><a id="a00f6fb6e96440153641e7f985f4fff86" name="a00f6fb6e96440153641e7f985f4fff86"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a00f6fb6e96440153641e7f985f4fff86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&amp;, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&amp;)</td></tr>
<tr class="separator:a00f6fb6e96440153641e7f985f4fff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10518f6b2059e68bca8a5eeeb3c5b71d"><td class="memTemplParams" colspan="2"><a id="a10518f6b2059e68bca8a5eeeb3c5b71d" name="a10518f6b2059e68bca8a5eeeb3c5b71d"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a10518f6b2059e68bca8a5eeeb3c5b71d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a10518f6b2059e68bca8a5eeeb3c5b71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d6f8d32835a5389a06ee0da7712dc4"><td class="memTemplParams" colspan="2"><a id="a76d6f8d32835a5389a06ee0da7712dc4" name="a76d6f8d32835a5389a06ee0da7712dc4"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a76d6f8d32835a5389a06ee0da7712dc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&amp;)</td></tr>
<tr class="separator:a76d6f8d32835a5389a06ee0da7712dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845863980bd02c8c4836c46bca5562ba"><td class="memTemplParams" colspan="2"><a id="a845863980bd02c8c4836c46bca5562ba" name="a845863980bd02c8c4836c46bca5562ba"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a845863980bd02c8c4836c46bca5562ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&amp;, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&amp;)</td></tr>
<tr class="separator:a845863980bd02c8c4836c46bca5562ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae30c631129e3354587e10c14a98e317"><td class="memTemplParams" colspan="2"><a id="aae30c631129e3354587e10c14a98e317" name="aae30c631129e3354587e10c14a98e317"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:aae30c631129e3354587e10c14a98e317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:aae30c631129e3354587e10c14a98e317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class regina::Laurent&lt; T &gt;</div><p >Represents a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial with coefficients of type <em>T</em>. </p>
<p >A <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial differs from an ordinary polynomial in that it allows negative exponents (so, unlike the <a class="el" href="classregina_1_1Polynomial.html" title="Represents a single-variable polynomial with coefficients of type T.">Polynomial</a> class, you can represent both <code>2+3x</code> and <code>1+1/x</code>).</p>
<p >The type <em>T</em> must represent a ring with no zero divisors. In particular, it must:</p>
<ul>
<li>support basic arithmetic operations;</li>
<li>support assignments of the form <code>x = int</code> and tests of the form <code>x == int</code> and <code>x &lt; int</code>;</li>
<li>have a default constructor that assigns an explicit value of zero.</li>
</ul>
<p >This means that Regina's numerical types such as Integer and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a> are supported, but native data types such as int and long are not (since they have no zero-initialising default constructor).</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<p >The underlying storage method for this class is dense (i.e., all coefficients are explicitly stored, including zero coefficients).</p>
<p >See also the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>, which describes <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials in two variables.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, the class <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> refers to the specific template class Laurent&lt;Integer&gt;. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac5415cf78943d61487a2e7b3992dc2d0" name="ac5415cf78943d61487a2e7b3992dc2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5415cf78943d61487a2e7b3992dc2d0">&#9670;&nbsp;</a></span>Coefficient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Coefficient =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of each coefficient of the polynomial. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63b4616a4b2aa8873366a89bf5dd11be" name="a63b4616a4b2aa8873366a89bf5dd11be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b4616a4b2aa8873366a89bf5dd11be">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the zero polynomial. </p>

</div>
</div>
<a id="a0a5b2b285cec03e8be60cb4c27ba02e2" name="a0a5b2b285cec03e8be60cb4c27ba02e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5b2b285cec03e8be60cb4c27ba02e2">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the polynomial <code>x^d</code> for the given exponent <em>d</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>the exponent to use for the new polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae98443b527c50e3f0075657124ecde39" name="ae98443b527c50e3f0075657124ecde39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98443b527c50e3f0075657124ecde39">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p >This constructor induces a deep copy of <em>value</em>.</p>
<p >A note for developers: even though this routine is identical to the templated copy constructor, it must be declared and implemented separately. Otherwise the compiler might create its own (incorrect) copy constructor automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21f998c80c610cacc4ea550889e1d19c" name="a21f998c80c610cacc4ea550889e1d19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f998c80c610cacc4ea550889e1d19c">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p >This constructor induces a deep copy of <em>value</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values of type <em>U</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Python only supports <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials with one type of coefficient (the case where <em>T</em> is Integer). Therefore Python users can use the non-templated copy constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3efdfbb8205d73f70ad59555cb8c89f3" name="a3efdfbb8205d73f70ad59555cb8c89f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efdfbb8205d73f70ad59555cb8c89f3">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this new polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a32be67cd921996e959bdc3e7732a6" name="a79a32be67cd921996e959bdc3e7732a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a32be67cd921996e959bdc3e7732a6">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from the given sequence of coefficients. </p>
<p >The coefficients should be given in order from the smallest exponent term to the largest. The first coefficient in the sequence will be associated with the exponent <em>minExp</em>.</p>
<p >There is no problem if the first and/or last coefficient in the sequence is zero. An empty sequence will be treated as the zero polynomial.</p>
<p >This constructor induces a deep copy of the given range.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values from dereferenced iterators of type <em>iterator</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the iterators <em>begin</em> and <em>end</em>, this routine takes a python list of coefficients.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minExp</td><td>the exponent corresponding to the first coefficient in the sequence. </td></tr>
    <tr><td class="paramname">begin</td><td>the beginning of the sequence of coefficients. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the sequence of coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e6761bdb9554c028910deec5cc2fe12" name="a9e6761bdb9554c028910deec5cc2fe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6761bdb9554c028910deec5cc2fe12">&#9670;&nbsp;</a></span>Laurent() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::Laurent </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from a hard-coded sequence of coefficients. </p>
<p >The coefficients should be given in order from the smallest exponent term to the largest. The first coefficient in the sequence will be associated with the exponent <em>minExp</em>.</p>
<p >There is no problem if the first and/or last coefficient in the sequence is zero. An empty sequence will be treated as the zero polynomial.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the Python constructor that takes a list of coefficients (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minExp</td><td>the exponent corresponding to the first coefficient in the sequence. </td></tr>
    <tr><td class="paramname">coefficients</td><td>the full sequence of coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4b082789a1cfd1f3a9e5860240139c" name="a6e4b082789a1cfd1f3a9e5860240139c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b082789a1cfd1f3a9e5860240139c">&#9670;&nbsp;</a></span>~Laurent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::~<a class="el" href="classregina_1_1Laurent.html">Laurent</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this polynomial. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ad8f01dcede64d90314c8d9138a9a87de" name="ad8f01dcede64d90314c8d9138a9a87de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f01dcede64d90314c8d9138a9a87de">&#9670;&nbsp;</a></span>init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the zero polynomial. </p>

</div>
</div>
<a id="a52f2a95338c49123859abb0e13810b69" name="a52f2a95338c49123859abb0e13810b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f2a95338c49123859abb0e13810b69">&#9670;&nbsp;</a></span>init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the polynomial <code>x^d</code> for the given exponent <em>d</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>the new exponent to use for this polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d6e9b4875cce50a6591844c108ace08" name="a5d6e9b4875cce50a6591844c108ace08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e9b4875cce50a6591844c108ace08">&#9670;&nbsp;</a></span>init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>minExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to become the polynomial described by the given sequence of coefficients. </p>
<p >The coefficients should appear in order from the smallest exponent term to the largest. The first coefficient in the sequence will be associated with the exponent <em>minExp</em>.</p>
<p >There is no problem if the first and/or last coefficient in the sequence is zero. An empty sequence will be treated as the zero polynomial.</p>
<p >This routine induces a deep copy of the given range.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values from dereferenced iterators of type <em>iterator</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the iterators <em>begin</em> and <em>end</em>, this routine takes a python list of coefficients.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minExp</td><td>the exponent corresponding to the first coefficient in the sequence. </td></tr>
    <tr><td class="paramname">begin</td><td>the beginning of the sequence of coefficients. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the sequence of coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48574eadf1ea1ab82a0bd7bbfa853325" name="a48574eadf1ea1ab82a0bd7bbfa853325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48574eadf1ea1ab82a0bd7bbfa853325">&#9670;&nbsp;</a></span>invertX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::invertX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces <code>x</code> with <code>x^-1</code> in this polynomial. </p>
<p >This polynomial is changed directly.</p>
<p >Calling this routine is equivalent to calling <code>scaleUp(-1)</code>. </p>

</div>
</div>
<a id="abb3aa9b0ebec34c2de2190c8fd1353a3" name="abb3aa9b0ebec34c2de2190c8fd1353a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3aa9b0ebec34c2de2190c8fd1353a3">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::isZero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this is the zero polynomial. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the zero polynomial. </dd></dl>

</div>
</div>
<a id="ae03bc71da56a6a1f80260698688951dc" name="ae03bc71da56a6a1f80260698688951dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03bc71da56a6a1f80260698688951dc">&#9670;&nbsp;</a></span>maxExp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::maxExp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest exponent that appears in this polynomial with a non-zero coefficient. </p>
<p >If this is the zero polynomial, then this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the largest exponent. </dd></dl>

</div>
</div>
<a id="af0815be3b6d0a8258ecb6178f52bed59" name="af0815be3b6d0a8258ecb6178f52bed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0815be3b6d0a8258ecb6178f52bed59">&#9670;&nbsp;</a></span>minExp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::minExp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest exponent that appears in this polynomial with a non-zero coefficient. </p>
<p >If this is the zero polynomial, then this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the smallest exponent. </dd></dl>

</div>
</div>
<a id="a9d6bb2ccf393b0c2a8e3fa3a336d15c6" name="a9d6bb2ccf393b0c2a8e3fa3a336d15c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6bb2ccf393b0c2a8e3fa3a336d15c6">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::negate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates this polynomial. </p>
<p >This polynomial is changed directly. </p>

</div>
</div>
<a id="a837ae1fab36a539549f32d080011c08e" name="a837ae1fab36a539549f32d080011c08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ae1fab36a539549f32d080011c08e">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given polynomial are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given polynomial are not equal. </dd></dl>

</div>
</div>
<a id="af24bd6c5d46ad8a002610825beea33d1" name="af24bd6c5d46ad8a002610825beea33d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24bd6c5d46ad8a002610825beea33d1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this by the given polynomial. </p>
<p >The given polynomial need not have the same minimum and/or maximum exponents as this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to multiply this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="aa978e5c598bc8e4c667572c95e32fb88" name="aa978e5c598bc8e4c667572c95e32fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa978e5c598bc8e4c667572c95e32fb88">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this polynomial by the given constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="aa2c8a4317008b6e6ee4807ca0a478424" name="aa2c8a4317008b6e6ee4807ca0a478424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c8a4317008b6e6ee4807ca0a478424">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given polynomial to this. </p>
<p >The given polynomial need not have the same minimum and/or maximum exponents as this.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may trigger a deep copy (depending upon the range of exponents used in <em>other</em>). Consider using the binary <code>+</code> operator instead, which is better able to avoid this deep copy where possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a11743c2ae66db923c2a54cd64f5b311a" name="a11743c2ae66db923c2a54cd64f5b311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11743c2ae66db923c2a54cd64f5b311a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given polynomial from this. </p>
<p >The given polynomial need not have the same minimum and/or maximum exponents as this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="adc7cd66e8cfd8b4ea813be5fcb1c3414" name="adc7cd66e8cfd8b4ea813be5fcb1c3414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7cd66e8cfd8b4ea813be5fcb1c3414">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this polynomial by the given constant. </p>
<p >This uses the division operator /= for the coefficient type <em>T</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a2b6d9b937f90bbb3479872ac5ac94b04" name="a2b6d9b937f90bbb3479872ac5ac94b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6d9b937f90bbb3479872ac5ac94b04">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="afb4ee445c713a6a8e8153d019bd2d59b" name="afb4ee445c713a6a8e8153d019bd2d59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4ee445c713a6a8e8153d019bd2d59b">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than or equal to the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a780cc8457db13ba28a5fc10e218493d1" name="a780cc8457db13ba28a5fc10e218493d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780cc8457db13ba28a5fc10e218493d1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p >This and the given polynomial need not have the same minimum and/or maximum exponents.</p>
<p >This operator induces a deep copy of <em>value</em>.</p>
<p >A note to developers: although this is identical to the templated assignment operator, it must be declared and implemented separately. See the copy constructor for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="aa2622abe5fb4ea67cb8eac02fbeac9b6" name="aa2622abe5fb4ea67cb8eac02fbeac9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2622abe5fb4ea67cb8eac02fbeac9b6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a> &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p >This and the given polynomial need not have the same minimum and/or maximum exponents.</p>
<p >This operator induces a deep copy of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a1a3b63c0f4e395c7401006669a937698" name="a1a3b63c0f4e395c7401006669a937698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3b63c0f4e395c7401006669a937698">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >This and the given polynomial need not have the same minimum and/or maximum exponents.</p>
<p >The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a66df5c8553be85b06aeaeccecba8151b" name="a66df5c8553be85b06aeaeccecba8151b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66df5c8553be85b06aeaeccecba8151b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given polynomial are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given polynomial are equal. </dd></dl>

</div>
</div>
<a id="adae36349e8a7b435b322fc843100440c" name="adae36349e8a7b435b322fc843100440c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae36349e8a7b435b322fc843100440c">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a444c6720d63731754debf32d8f17a5fb" name="a444c6720d63731754debf32d8f17a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444c6720d63731754debf32d8f17a5fb">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all one-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than or equal to the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a71b42d75b72b53af78eda746bd2d4aed" name="a71b42d75b72b53af78eda746bd2d4aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b42d75b72b53af78eda746bd2d4aed">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given coefficient of this polynomial. </p>
<p >There are no restrictions on the exponent <em>exp</em>.</p>
<dl class="section user"><dt>Python</dt><dd>Python users can also use this operator to <em>set</em> cofficients; that is, you can write <code>poly[exp] = value</code>. However, when <em>getting</em> a coefficient this operator will return by value (to enforce constness), which means for example you cannot write something like <code>poly[exp].<a class="el" href="classregina_1_1Laurent.html#a9d6bb2ccf393b0c2a8e3fa3a336d15c6" title="Negates this polynomial.">negate()</a></code>.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>For C++ users, this operator is read-only. To <em>set</em> coefficients, you must use the separate routine <a class="el" href="classregina_1_1Laurent.html#adecbe74e6268dbbab5c7f6a41f4e0ea6" title="Changes the given coefficient of this polynomial.">set()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>the exponent of the term whose coefficient should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coefficient of the given term. </dd></dl>

</div>
</div>
<a id="ad18d1efbb319d8b4ab9fa8402b594195" name="ad18d1efbb319d8b4ab9fa8402b594195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18d1efbb319d8b4ab9fa8402b594195">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::scaleDown </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides all exponents in this polynomial by <em>k</em> for some integer <em>k</em>. </p>
<p >This is equivalent to replacing the variable <em>x</em> of the polynomial with <em>x</em><sup>1/<em>k</em></sup>.</p>
<p >Both positive and negative scaling factors <em>k</em> are allowed.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>k</em> is non-zero. </dd>
<dd>
All exponents in this polynomial with non-zero coefficients are multiples of <em>k</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scaling factor to divide exponents by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad152d0634b68b5d6df4692fb09ef47a9" name="ad152d0634b68b5d6df4692fb09ef47a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad152d0634b68b5d6df4692fb09ef47a9">&#9670;&nbsp;</a></span>scaleUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::scaleUp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all exponents in this polynomial by <em>k</em> for some integer <em>k</em>. </p>
<p >This is equivalent to replacing the variable <em>x</em> of the polynomial with <em>x</em><sup><em>k</em></sup>.</p>
<p >Both positive and negative scaling factors <em>k</em> are allowed.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>k</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scaling factor to multiply exponents by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adecbe74e6268dbbab5c7f6a41f4e0ea6" name="adecbe74e6268dbbab5c7f6a41f4e0ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecbe74e6268dbbab5c7f6a41f4e0ea6">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the given coefficient of this polynomial. </p>
<p >There are no restrictions on the exponent <em>exp</em>, and the new coefficient <em>value</em> may be zero.</p>
<p >Note, however, that it is expensive to set a non-zero coefficient whose exponent is larger than <a class="el" href="classregina_1_1Laurent.html#ae03bc71da56a6a1f80260698688951dc" title="Returns the largest exponent that appears in this polynomial with a non-zero coefficient.">maxExp()</a> or smaller than <a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59" title="Returns the smallest exponent that appears in this polynomial with a non-zero coefficient.">minExp()</a>, since this will typically require deallocating and reallocating the full list of coefficients.</p>
<p >In contrast, setting a zero coefficient for the exponent <a class="el" href="classregina_1_1Laurent.html#ae03bc71da56a6a1f80260698688951dc" title="Returns the largest exponent that appears in this polynomial with a non-zero coefficient.">maxExp()</a> or <a class="el" href="classregina_1_1Laurent.html#af0815be3b6d0a8258ecb6178f52bed59" title="Returns the smallest exponent that appears in this polynomial with a non-zero coefficient.">minExp()</a> is cheap, even though the range of non-zero coefficients changes as a result.</p>
<dl class="section user"><dt>Python</dt><dd>This <a class="el" href="classregina_1_1Laurent.html#adecbe74e6268dbbab5c7f6a41f4e0ea6" title="Changes the given coefficient of this polynomial.">set()</a> routine is available, but you can also set coefficients directly using syntax of the form <code>p[exp] = value</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>the exponent of the term whose coefficient should be changed. </td></tr>
    <tr><td class="paramname">value</td><td>the new value of this coefficient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad23897e5db058379bde58a8c13aafe" name="abad23897e5db058379bde58a8c13aafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad23897e5db058379bde58a8c13aafe">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this polynomial by <code>x^s</code> for some integer <em>s</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the power of <em>x</em> to multiply by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aba407d6cdb53604413e4cd718099f3f2" name="aba407d6cdb53604413e4cd718099f3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba407d6cdb53604413e4cd718099f3f2">&#9670;&nbsp;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string, using the given variable name instead of <code>x</code>. </p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2" title="Returns this polynomial as a human-readable string, using the given variable name instead of x.">str()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the symbol to use for the variable in this polynomial. This may be <code>null</code>, in which case the default variable <code>x</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a human-readable string. </dd></dl>

</div>
</div>
<a id="ae4fd032076d422a88aca0c10284a69e5" name="ae4fd032076d422a88aca0c10284a69e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fd032076d422a88aca0c10284a69e5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >This and the given polynomial do not need to have the same minimum and/or maximum exponents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65188876596177c6ab6abe3785a7e459" name="a65188876596177c6ab6abe3785a7e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65188876596177c6ab6abe3785a7e459">&#9670;&nbsp;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a polynomial from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding static <a class="el" href="classregina_1_1Laurent.html#a65188876596177c6ab6abe3785a7e459" title="Reconstructs a polynomial from its given tight encoding.">tightDecode()</a> function. This is true for Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c" title="Reconstructs an object of type T from its given tight encoding.">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polynomial represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&nbsp;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;  <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;  &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ad43543d127c64804a55b5a49758ef73a" name="ad43543d127c64804a55b5a49758ef73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43543d127c64804a55b5a49758ef73a">&#9670;&nbsp;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this polynomial to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding <a class="el" href="classregina_1_1Laurent.html#ad43543d127c64804a55b5a49758ef73a" title="Writes the tight encoding of this polynomial to the given output stream.">tightEncode()</a> function. This is true for Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d" title="Returns the tight encoding of this object.">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&nbsp;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;  &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function <a class="el" href="group__utilities.html#ga588cb4d07d97f9a53e86859e4e233aab" title="Writes the tight encoding of the given boolean to the given output stream.">T::tightEncode()</a>. See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2" title="Returns this polynomial as a human-readable string, using the given variable name instead of x.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2" title="Returns this polynomial as a human-readable string, using the given variable name instead of x.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a7bc46f4943f0e97275fbad97415e9f46" name="a7bc46f4943f0e97275fbad97415e9f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc46f4943f0e97275fbad97415e9f46">&#9670;&nbsp;</a></span>utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string using unicode characters, using the given variable name instead of <code>x</code>. </p>
<p >This is similar to the output from <a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2" title="Returns this polynomial as a human-readable string, using the given variable name instead of x.">str()</a>, except that it uses unicode characters to make the output more pleasant to read. In particular, it makes use of superscript digits for exponents and a wider minus sign.</p>
<p >The string is encoded in UTF-8.</p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="classregina_1_1Laurent.html#a7bc46f4943f0e97275fbad97415e9f46" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the symbol to use for the variable in this polynomial. This may be <code>null</code>, in which case the default variable <code>x</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a unicode-enabled human-readable string. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a222949d4b018e949da5d72f8884b87a5" name="a222949d4b018e949da5d72f8884b87a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222949d4b018e949da5d72f8884b87a5">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent.html">regina::Laurent</a>&lt; T &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>variable</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this polynomial to the given output stream, using the given variable name instead of <code>x</code>. </p>
<p >If <em>utf8</em> is passed as <code>true</code> then unicode superscript characters will be used for exponents and the minus sign; these will be encoded using UTF-8. This will make the output nicer, but will require more complex fonts to be available on the user's machine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1Laurent.html#aba407d6cdb53604413e4cd718099f3f2" title="Returns this polynomial as a human-readable string, using the given variable name instead of x.">str()</a> or <a class="el" href="classregina_1_1Laurent.html#a7bc46f4943f0e97275fbad97415e9f46" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if unicode characters may be used. </td></tr>
    <tr><td class="paramname">variable</td><td>the symbol to use for the variable in this polynomial. This may be <code>null</code>, in which case the default variable <code>x</code> will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
<li>maths/<a class="el" href="laurent_8h.html">laurent.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
