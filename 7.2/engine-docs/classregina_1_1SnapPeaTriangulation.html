<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::SnapPeaTriangulation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1SnapPeaTriangulation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SnapPeaTriangulation Class Reference<div class="ingroups"><a class="el" href="group__snappea.html">SnapPea Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Offers direct access to the SnapPea kernel from within Regina.  
 <a href="classregina_1_1SnapPeaTriangulation.html#details">More...</a></p>

<p><code>#include &lt;snappea/snappeatriangulation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SnapPeaTriangulation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SnapPeaTriangulation.png" usemap="#regina::SnapPeaTriangulation_map" alt=""/>
  <map id="regina::SnapPeaTriangulation_map" name="regina::SnapPeaTriangulation_map">
<area href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold." alt="regina::Triangulation&lt; 3 &gt;" shape="rect" coords="436,112,717,136"/>
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; SnapPeaTriangulation &gt;" shape="rect" coords="727,112,1008,136"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SnapPeaTriangulation &gt;" shape="rect" coords="1018,112,1299,136"/>
<area href="classregina_1_1detail_1_1TriangulationBase.html" alt="regina::detail::TriangulationBase&lt; 3 &gt;" shape="rect" coords="436,56,717,80"/>
<area href="classregina_1_1Snapshottable.html" alt="regina::Snapshottable&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="0,0,281,24"/>
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="291,0,572,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="582,0,863,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="873,0,1154,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9fb06be1a5084ff01ac6a96de0050770"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770">SolutionType</a> { <br />
&#160;&#160;<a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770a835f52eddacbc3b1f8316c97d2288430">not_attempted</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770a797f18a2bd313e031389ee991b3b095d">geometric_solution</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770a56e29f22d00dbe72de8afd5427a59d49">nongeometric_solution</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770adf6bd950be5e16cedc23bcc0df6e7f41">flat_solution</a>
, <br />
&#160;&#160;<a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770a817953dfa6d08754a863760d16519a00">degenerate_solution</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770a18c7358f04fa8024f22855f759a36f6b">other_solution</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770af4a6f61e1b36942029af652d1b9b1cbe">no_solution</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770ab48f2469d5cb22bd61f6471aaeade1fe">externally_computed</a>
<br />
 }</td></tr>
<tr class="memdesc:a9fb06be1a5084ff01ac6a96de0050770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the different types of solution that can be found when solving for a hyperbolic structure.  <a href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770">More...</a><br /></td></tr>
<tr class="separator:a9fb06be1a5084ff01ac6a96de0050770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af493515e72e2059b4c23986d0cde0d87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87">CoverEnumerationType</a> { <a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87afff8f198c433dc62952637db8b353ad0">cyclic_covers</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87a8f127a000f33b941e12eaf8a73dfeeac">all_covers</a>
 }</td></tr>
<tr class="memdesc:af493515e72e2059b4c23986d0cde0d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which types of covers should be enumerated when calling <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a>.  <a href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87">More...</a><br /></td></tr>
<tr class="separator:af493515e72e2059b4c23986d0cde0d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2e873e96003ef01494e95f44962dda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda">CoverType</a> { <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962ddaa6bf8aa4dab7dd6d45be7fc164a23c98f">unknown_cover</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962ddaae5abb9c1c82e9855790f6c6e59c5dfdb">irregular_cover</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962ddaa97d807390bce8c0d947779401058708d">regular_cover</a>
, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962ddaa89b9a3dc02fd1b66f09d4b5eeb69a4c3">cyclic_cover</a>
 }</td></tr>
<tr class="memdesc:abd2e873e96003ef01494e95f44962dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the different types of covers that can be produced by <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a>.  <a href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda">More...</a><br /></td></tr>
<tr class="separator:abd2e873e96003ef01494e95f44962dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75395b2e289bf58155f6b1f94b47530a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a75395b2e289bf58155f6b1f94b47530a">TuraevViroSet</a> = std::map&lt; std::pair&lt; unsigned long, bool &gt;, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &gt;</td></tr>
<tr class="memdesc:a75395b2e289bf58155f6b1f94b47530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from (<em>r</em>, <em>parity</em>) pairs to Turaev-Viro invariants, as described by <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a75395b2e289bf58155f6b1f94b47530a">More...</a><br /></td></tr>
<tr class="separator:a75395b2e289bf58155f6b1f94b47530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#ae9a076c6b4eb0edc40694aedaf5bd3c4">isReadOnlySnapshot</a> () const</td></tr>
<tr class="memdesc:ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this object is a read-only deep copy that was created by a snapshot.  <a href="classregina_1_1Snapshottable.html#ae9a076c6b4eb0edc40694aedaf5bd3c4">More...</a><br /></td></tr>
<tr class="separator:ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <a href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">More...</a><br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a5047642ef20743096e6795ba23d58c03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a5047642ef20743096e6795ba23d58c03">SnapPeaTriangulation</a> ()</td></tr>
<tr class="memdesc:a5047642ef20743096e6795ba23d58c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null triangulation, with no internal SnapPea data at all.  <a href="classregina_1_1SnapPeaTriangulation.html#a5047642ef20743096e6795ba23d58c03">More...</a><br /></td></tr>
<tr class="separator:a5047642ef20743096e6795ba23d58c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ced0a54008d83752b3009c8efd5b2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae7ced0a54008d83752b3009c8efd5b2b">SnapPeaTriangulation</a> (const std::string &amp;fileNameOrContents)</td></tr>
<tr class="memdesc:ae7ced0a54008d83752b3009c8efd5b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new SnapPea triangulation from the contents of SnapPea data file.  <a href="classregina_1_1SnapPeaTriangulation.html#ae7ced0a54008d83752b3009c8efd5b2b">More...</a><br /></td></tr>
<tr class="separator:ae7ced0a54008d83752b3009c8efd5b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3b5e06d4b977325a32d7d6f8e216a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9e3b5e06d4b977325a32d7d6f8e216a3">SnapPeaTriangulation</a> (const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;src)</td></tr>
<tr class="memdesc:a9e3b5e06d4b977325a32d7d6f8e216a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given SnapPea triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a9e3b5e06d4b977325a32d7d6f8e216a3">More...</a><br /></td></tr>
<tr class="separator:a9e3b5e06d4b977325a32d7d6f8e216a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f4edda1c14e3f6117cfab5d147738"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a996f4edda1c14e3f6117cfab5d147738">SnapPeaTriangulation</a> (<a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a996f4edda1c14e3f6117cfab5d147738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given SnapPea triangulation into this new triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a996f4edda1c14e3f6117cfab5d147738">More...</a><br /></td></tr>
<tr class="separator:a996f4edda1c14e3f6117cfab5d147738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4c2d636af7f2e3f341f451a6990479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7f4c2d636af7f2e3f341f451a6990479">SnapPeaTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, bool ignored=false)</td></tr>
<tr class="memdesc:a7f4c2d636af7f2e3f341f451a6990479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given Regina triangulation to a SnapPea triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a7f4c2d636af7f2e3f341f451a6990479">More...</a><br /></td></tr>
<tr class="separator:a7f4c2d636af7f2e3f341f451a6990479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adba76d384a5f98c18e811bed614737"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7adba76d384a5f98c18e811bed614737">SnapPeaTriangulation</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link)</td></tr>
<tr class="memdesc:a7adba76d384a5f98c18e811bed614737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ideal SnapPea triangulation representing the complement of the given link in the 3-sphere.  <a href="classregina_1_1SnapPeaTriangulation.html#a7adba76d384a5f98c18e811bed614737">More...</a><br /></td></tr>
<tr class="separator:a7adba76d384a5f98c18e811bed614737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b147dcd88e92267266f9c0f2860464"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a28b147dcd88e92267266f9c0f2860464">SnapPeaTriangulation</a> (regina::snappea::Triangulation *data)</td></tr>
<tr class="memdesc:a28b147dcd88e92267266f9c0f2860464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation that holds the given raw data from the SnapPea kernel.  <a href="classregina_1_1SnapPeaTriangulation.html#a28b147dcd88e92267266f9c0f2860464">More...</a><br /></td></tr>
<tr class="separator:a28b147dcd88e92267266f9c0f2860464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae36fd8774da3c29d017294021402b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#adae36fd8774da3c29d017294021402b6">~SnapPeaTriangulation</a> ()</td></tr>
<tr class="memdesc:adae36fd8774da3c29d017294021402b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#adae36fd8774da3c29d017294021402b6">More...</a><br /></td></tr>
<tr class="separator:adae36fd8774da3c29d017294021402b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tetrahedra</div></td></tr>
<tr class="memitem:a4a456cdb3de447101da9d6fe100708b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a4a456cdb3de447101da9d6fe100708b6">operator=</a> (const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;src)</td></tr>
<tr class="memdesc:a4a456cdb3de447101da9d6fe100708b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given SnapPea triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a4a456cdb3de447101da9d6fe100708b6">More...</a><br /></td></tr>
<tr class="separator:a4a456cdb3de447101da9d6fe100708b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefce7b87855dc42579028accd19e616d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aefce7b87855dc42579028accd19e616d">operator=</a> (<a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aefce7b87855dc42579028accd19e616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given triangulation into this triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#aefce7b87855dc42579028accd19e616d">More...</a><br /></td></tr>
<tr class="separator:aefce7b87855dc42579028accd19e616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7a6bc4f86db0ee34232c78c5cfc597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aba7a6bc4f86db0ee34232c78c5cfc597">swap</a> (<a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;other)</td></tr>
<tr class="memdesc:aba7a6bc4f86db0ee34232c78c5cfc597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given SnapPea triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#aba7a6bc4f86db0ee34232c78c5cfc597">More...</a><br /></td></tr>
<tr class="separator:aba7a6bc4f86db0ee34232c78c5cfc597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad019a40fe1a2a2abc87045bce9bb9f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ad019a40fe1a2a2abc87045bce9bb9f52">nullify</a> ()</td></tr>
<tr class="memdesc:ad019a40fe1a2a2abc87045bce9bb9f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a null SnapPea triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#ad019a40fe1a2a2abc87045bce9bb9f52">More...</a><br /></td></tr>
<tr class="separator:ad019a40fe1a2a2abc87045bce9bb9f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:ab6c7b296f9e7ba7599f0343bfeca3c4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab6c7b296f9e7ba7599f0343bfeca3c4a">isNull</a> () const</td></tr>
<tr class="memdesc:ab6c7b296f9e7ba7599f0343bfeca3c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation contains valid SnapPea data.  <a href="classregina_1_1SnapPeaTriangulation.html#ab6c7b296f9e7ba7599f0343bfeca3c4a">More...</a><br /></td></tr>
<tr class="separator:ab6c7b296f9e7ba7599f0343bfeca3c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5777e3cbe10ce40d1ce123b88dca60"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a5f5777e3cbe10ce40d1ce123b88dca60">name</a> () const</td></tr>
<tr class="memdesc:a5f5777e3cbe10ce40d1ce123b88dca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SnapPea's internal name for this triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a5f5777e3cbe10ce40d1ce123b88dca60">More...</a><br /></td></tr>
<tr class="separator:a5f5777e3cbe10ce40d1ce123b88dca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hyperbolic Structures</div></td></tr>
<tr class="memitem:ad406c96fb657b36cba5fddb1366a729f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770">SolutionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ad406c96fb657b36cba5fddb1366a729f">solutionType</a> () const</td></tr>
<tr class="memdesc:ad406c96fb657b36cba5fddb1366a729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of solution found when solving for a hyperbolic structure, with respect to the current Dehn filling (if any).  <a href="classregina_1_1SnapPeaTriangulation.html#ad406c96fb657b36cba5fddb1366a729f">More...</a><br /></td></tr>
<tr class="separator:ad406c96fb657b36cba5fddb1366a729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ff5bfcc94c9e3a1c17a6c464a62ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a757ff5bfcc94c9e3a1c17a6c464a62ca">volume</a> () const</td></tr>
<tr class="memdesc:a757ff5bfcc94c9e3a1c17a6c464a62ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the volume of the current solution to the hyperbolic gluing equations.  <a href="classregina_1_1SnapPeaTriangulation.html#a757ff5bfcc94c9e3a1c17a6c464a62ca">More...</a><br /></td></tr>
<tr class="separator:a757ff5bfcc94c9e3a1c17a6c464a62ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c576f86cb7675ab965e74dc8151abba"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7c576f86cb7675ab965e74dc8151abba">volumeWithPrecision</a> () const</td></tr>
<tr class="memdesc:a7c576f86cb7675ab965e74dc8151abba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the volume of the current solution to the hyperbolic gluing equations, and estimates the accuracy of the answer.  <a href="classregina_1_1SnapPeaTriangulation.html#a7c576f86cb7675ab965e74dc8151abba">More...</a><br /></td></tr>
<tr class="separator:a7c576f86cb7675ab965e74dc8151abba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65ce6f4e579a65045294a94e6d94e73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa65ce6f4e579a65045294a94e6d94e73">volumeZero</a> () const</td></tr>
<tr class="memdesc:aa65ce6f4e579a65045294a94e6d94e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current solution to the gluing equations has volume approximately zero.  <a href="classregina_1_1SnapPeaTriangulation.html#aa65ce6f4e579a65045294a94e6d94e73">More...</a><br /></td></tr>
<tr class="separator:aa65ce6f4e579a65045294a94e6d94e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a451bd5ec702a229ada193bda78575"><td class="memItemLeft" align="right" valign="top">const std::complex&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ac9a451bd5ec702a229ada193bda78575">shape</a> (size_t tet) const</td></tr>
<tr class="memdesc:ac9a451bd5ec702a229ada193bda78575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shape of the given tetrahedron, with respect to the Dehn filled hyperbolic structure.  <a href="classregina_1_1SnapPeaTriangulation.html#ac9a451bd5ec702a229ada193bda78575">More...</a><br /></td></tr>
<tr class="separator:ac9a451bd5ec702a229ada193bda78575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99782c2bdc6fc9868da9999a30fb76d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a99782c2bdc6fc9868da9999a30fb76d7">minImaginaryShape</a> () const</td></tr>
<tr class="memdesc:a99782c2bdc6fc9868da9999a30fb76d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum imaginary part found amongst all tetrahedron shapes, with respect to the Dehn filled hyperbolic structure.  <a href="classregina_1_1SnapPeaTriangulation.html#a99782c2bdc6fc9868da9999a30fb76d7">More...</a><br /></td></tr>
<tr class="separator:a99782c2bdc6fc9868da9999a30fb76d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe3a28d577944678d29bbd727d8268b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a5fe3a28d577944678d29bbd727d8268b">gluingEquations</a> () const</td></tr>
<tr class="memdesc:a5fe3a28d577944678d29bbd727d8268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix describing Thurston's gluing equations.  <a href="classregina_1_1SnapPeaTriangulation.html#a5fe3a28d577944678d29bbd727d8268b">More...</a><br /></td></tr>
<tr class="separator:a5fe3a28d577944678d29bbd727d8268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e781e24d1fa15a599ac0dda941d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a371e781e24d1fa15a599ac0dda941d9d">gluingEquationsRect</a> () const</td></tr>
<tr class="memdesc:a371e781e24d1fa15a599ac0dda941d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix describing Thurston's gluing equations in a streamlined form.  <a href="classregina_1_1SnapPeaTriangulation.html#a371e781e24d1fa15a599ac0dda941d9d">More...</a><br /></td></tr>
<tr class="separator:a371e781e24d1fa15a599ac0dda941d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e9438ad2adb5b9f8866aff1ab454d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae13e9438ad2adb5b9f8866aff1ab454d">operator==</a> (const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;other) const</td></tr>
<tr class="memdesc:ae13e9438ad2adb5b9f8866aff1ab454d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given SnapPea triangulation are, at some elementary level, the same.  <a href="classregina_1_1SnapPeaTriangulation.html#ae13e9438ad2adb5b9f8866aff1ab454d">More...</a><br /></td></tr>
<tr class="separator:ae13e9438ad2adb5b9f8866aff1ab454d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958953c6a57822d9bab7e626e548f86e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a958953c6a57822d9bab7e626e548f86e">operator!=</a> (const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;other) const</td></tr>
<tr class="memdesc:a958953c6a57822d9bab7e626e548f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given SnapPea triangulation are, at some elementary level, different.  <a href="classregina_1_1SnapPeaTriangulation.html#a958953c6a57822d9bab7e626e548f86e">More...</a><br /></td></tr>
<tr class="separator:a958953c6a57822d9bab7e626e548f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cusps</div></td></tr>
<tr class="memitem:a67facbc8a73fa32e37ee2bc79df76aa1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1">countCusps</a> () const</td></tr>
<tr class="memdesc:a67facbc8a73fa32e37ee2bc79df76aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of cusps (both filled and complete).  <a href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1">More...</a><br /></td></tr>
<tr class="separator:a67facbc8a73fa32e37ee2bc79df76aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b3badd67a8ccb5ec0111d5c995e19"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aec4b3badd67a8ccb5ec0111d5c995e19">countCompleteCusps</a> () const</td></tr>
<tr class="memdesc:aec4b3badd67a8ccb5ec0111d5c995e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of complete cusps (that is, unfilled cusps).  <a href="classregina_1_1SnapPeaTriangulation.html#aec4b3badd67a8ccb5ec0111d5c995e19">More...</a><br /></td></tr>
<tr class="separator:aec4b3badd67a8ccb5ec0111d5c995e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666f1827e93752400941de349992d1f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a3666f1827e93752400941de349992d1f">countFilledCusps</a> () const</td></tr>
<tr class="memdesc:a3666f1827e93752400941de349992d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of filled cusps.  <a href="classregina_1_1SnapPeaTriangulation.html#a3666f1827e93752400941de349992d1f">More...</a><br /></td></tr>
<tr class="separator:a3666f1827e93752400941de349992d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a9bbccbfb02315886e2f5371f2607"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Cusp.html">Cusp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607">cusp</a> (unsigned whichCusp=0) const</td></tr>
<tr class="memdesc:a951a9bbccbfb02315886e2f5371f2607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the given cusp of this manifold.  <a href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607">More...</a><br /></td></tr>
<tr class="separator:a951a9bbccbfb02315886e2f5371f2607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282f5add01134a87b87655dc6eaa2c2a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a282f5add01134a87b87655dc6eaa2c2a">cusps</a> () const</td></tr>
<tr class="memdesc:a282f5add01134a87b87655dc6eaa2c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to information about all of the cusps of this manifold.  <a href="classregina_1_1SnapPeaTriangulation.html#a282f5add01134a87b87655dc6eaa2c2a">More...</a><br /></td></tr>
<tr class="separator:a282f5add01134a87b87655dc6eaa2c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b013fc3e254abe020b7ed51622c88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae6b013fc3e254abe020b7ed51622c88e">fill</a> (int m, int l, unsigned whichCusp=0)</td></tr>
<tr class="memdesc:ae6b013fc3e254abe020b7ed51622c88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a Dehn filling to the given cusp.  <a href="classregina_1_1SnapPeaTriangulation.html#ae6b013fc3e254abe020b7ed51622c88e">More...</a><br /></td></tr>
<tr class="separator:ae6b013fc3e254abe020b7ed51622c88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f9c7a14c1bbe226f4215d19ab5becd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae0f9c7a14c1bbe226f4215d19ab5becd">unfill</a> (unsigned whichCusp=0)</td></tr>
<tr class="memdesc:ae0f9c7a14c1bbe226f4215d19ab5becd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any filling on the given cusp.  <a href="classregina_1_1SnapPeaTriangulation.html#ae0f9c7a14c1bbe226f4215d19ab5becd">More...</a><br /></td></tr>
<tr class="separator:ae0f9c7a14c1bbe226f4215d19ab5becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b5f8a885091ca71c2ba1b3b8bbe96a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a08b5f8a885091ca71c2ba1b3b8bbe96a">filledPartial</a> (unsigned whichCusp) const</td></tr>
<tr class="memdesc:a08b5f8a885091ca71c2ba1b3b8bbe96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retriangulates to permanently fill the given cusp.  <a href="classregina_1_1SnapPeaTriangulation.html#a08b5f8a885091ca71c2ba1b3b8bbe96a">More...</a><br /></td></tr>
<tr class="separator:a08b5f8a885091ca71c2ba1b3b8bbe96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9c91037aad030285b22621f0ff0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a92b9c91037aad030285b22621f0ff0be">filledPartial</a> () const</td></tr>
<tr class="memdesc:a92b9c91037aad030285b22621f0ff0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retriangulates to permanently fill some but not all cusps.  <a href="classregina_1_1SnapPeaTriangulation.html#a92b9c91037aad030285b22621f0ff0be">More...</a><br /></td></tr>
<tr class="separator:a92b9c91037aad030285b22621f0ff0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9969078c164e2a1cf0460ba74dc51b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab9969078c164e2a1cf0460ba74dc51b3">filledAll</a> () const</td></tr>
<tr class="memdesc:ab9969078c164e2a1cf0460ba74dc51b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retriangulates to permanently fill all cusps.  <a href="classregina_1_1SnapPeaTriangulation.html#ab9969078c164e2a1cf0460ba74dc51b3">More...</a><br /></td></tr>
<tr class="separator:ab9969078c164e2a1cf0460ba74dc51b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43e3884dce2f26e6920fb9b64d2c4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#af43e3884dce2f26e6920fb9b64d2c4d8">slopeEquations</a> () const</td></tr>
<tr class="memdesc:af43e3884dce2f26e6920fb9b64d2c4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix for computing boundary slopes of spun-normal surfaces at the cusps of the triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#af43e3884dce2f26e6920fb9b64d2c4d8">More...</a><br /></td></tr>
<tr class="separator:af43e3884dce2f26e6920fb9b64d2c4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Invariants</div></td></tr>
<tr class="memitem:a6347d1e9433a27bd969049d8ca8ef01d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d">homologyFilled</a> () const</td></tr>
<tr class="memdesc:a6347d1e9433a27bd969049d8ca8ef01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group of the manifold with respect to the current Dehn filling (if any).  <a href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d">More...</a><br /></td></tr>
<tr class="separator:a6347d1e9433a27bd969049d8ca8ef01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8486cf851a69f057505860cda7a92a65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65">fundamentalGroupFilled</a> (bool simplifyPresentation=true, bool fillingsMayAffectGenerators=true, bool minimiseNumberOfGenerators=true, bool tryHardToShortenRelators=true) const</td></tr>
<tr class="memdesc:a8486cf851a69f057505860cda7a92a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).  <a href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65">More...</a><br /></td></tr>
<tr class="separator:a8486cf851a69f057505860cda7a92a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09adf6ddf426a6a4ea334824f4ab5796"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a09adf6ddf426a6a4ea334824f4ab5796"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796">enumerateCovers</a> (int sheets, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87">CoverEnumerationType</a> type, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a09adf6ddf426a6a4ea334824f4ab5796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates connected <em>k</em>-sheeted covers of the underlying manifold.  <a href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796">More...</a><br /></td></tr>
<tr class="separator:a09adf6ddf426a6a4ea334824f4ab5796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulating SnapPea triangulations</div></td></tr>
<tr class="memitem:aa4d0a996d3b80ce72dc630b1898134e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8">protoCanonise</a> () const</td></tr>
<tr class="memdesc:aa4d0a996d3b80ce72dc630b1898134e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition contains non-tetrahedron cells.  <a href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8">More...</a><br /></td></tr>
<tr class="separator:aa4d0a996d3b80ce72dc630b1898134e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b504d7e838c1651f98a79001467119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a35b504d7e838c1651f98a79001467119">protoCanonize</a> () const</td></tr>
<tr class="memdesc:a35b504d7e838c1651f98a79001467119"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">protoCanonise()</a>, which constructs the canonical cell decomposition using an arbitrary retriangulation if necessary.  <a href="classregina_1_1SnapPeaTriangulation.html#a35b504d7e838c1651f98a79001467119">More...</a><br /></td></tr>
<tr class="separator:a35b504d7e838c1651f98a79001467119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cad97766bcdf5c61b156b8aa0d8fa38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38">canonise</a> () const</td></tr>
<tr class="memdesc:a2cad97766bcdf5c61b156b8aa0d8fa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the canonical retriangulation of the canonical cell decomposition.  <a href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38">More...</a><br /></td></tr>
<tr class="separator:a2cad97766bcdf5c61b156b8aa0d8fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b8e0ad9bdee474ec2dd45e27bc36d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a23b8e0ad9bdee474ec2dd45e27bc36d7">canonize</a> () const</td></tr>
<tr class="memdesc:a23b8e0ad9bdee474ec2dd45e27bc36d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a>, which constructs the canonical retriangulation of the canonical cell decomposition.  <a href="classregina_1_1SnapPeaTriangulation.html#a23b8e0ad9bdee474ec2dd45e27bc36d7">More...</a><br /></td></tr>
<tr class="separator:a23b8e0ad9bdee474ec2dd45e27bc36d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d154865770119b812e7044c327dab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4">randomise</a> ()</td></tr>
<tr class="memdesc:a41d154865770119b812e7044c327dab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology.  <a href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4">More...</a><br /></td></tr>
<tr class="separator:a41d154865770119b812e7044c327dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f4b530f457331a0fd1958b32a5d0b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#ac8f4b530f457331a0fd1958b32a5d0b3">randomize</a> ()</td></tr>
<tr class="memdesc:ac8f4b530f457331a0fd1958b32a5d0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4" title="Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology.">randomise()</a>, which asks SnapPea to randomly retriangulate this manifold.  <a href="classregina_1_1SnapPeaTriangulation.html#ac8f4b530f457331a0fd1958b32a5d0b3">More...</a><br /></td></tr>
<tr class="separator:ac8f4b530f457331a0fd1958b32a5d0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SnapPea Input and Output</div></td></tr>
<tr class="memitem:a72bf21c353d9a6908fb2ad1cceeef899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a72bf21c353d9a6908fb2ad1cceeef899">snapPea</a> () const</td></tr>
<tr class="memdesc:a72bf21c353d9a6908fb2ad1cceeef899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the full contents of a SnapPea data file that describes this triangulation.  <a href="classregina_1_1SnapPeaTriangulation.html#a72bf21c353d9a6908fb2ad1cceeef899">More...</a><br /></td></tr>
<tr class="separator:a72bf21c353d9a6908fb2ad1cceeef899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979d361c39388005df28ddba4050d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a0979d361c39388005df28ddba4050d52">snapPea</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a0979d361c39388005df28ddba4050d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the full contents of a SnapPea data file describing this triangulation to the given output stream.  <a href="classregina_1_1SnapPeaTriangulation.html#a0979d361c39388005df28ddba4050d52">More...</a><br /></td></tr>
<tr class="separator:a0979d361c39388005df28ddba4050d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aaa7b5e790451d0732dbd158804249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a91aaa7b5e790451d0732dbd158804249">saveSnapPea</a> (const char *filename) const</td></tr>
<tr class="memdesc:a91aaa7b5e790451d0732dbd158804249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this triangulation to the given file using SnapPea's native file format.  <a href="classregina_1_1SnapPeaTriangulation.html#a91aaa7b5e790451d0732dbd158804249">More...</a><br /></td></tr>
<tr class="separator:a91aaa7b5e790451d0732dbd158804249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ab44e8aa8e6a1e0723767b94d60ce59d7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7">inAnyPacket</a> ()</td></tr>
<tr class="memdesc:ab44e8aa8e6a1e0723767b94d60ce59d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7">More...</a><br /></td></tr>
<tr class="separator:ab44e8aa8e6a1e0723767b94d60ce59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb91289cea42534269630ab6081e96a7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acb91289cea42534269630ab6081e96a7">inAnyPacket</a> () const</td></tr>
<tr class="memdesc:acb91289cea42534269630ab6081e96a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#acb91289cea42534269630ab6081e96a7">More...</a><br /></td></tr>
<tr class="separator:acb91289cea42534269630ab6081e96a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d2e60921b2f4aef3d44c73808e0e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa5d2e60921b2f4aef3d44c73808e0e30">isSnapPea</a> ()</td></tr>
<tr class="memdesc:aa5d2e60921b2f4aef3d44c73808e0e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SnapPea triangulation that holds this data, if there is one.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa5d2e60921b2f4aef3d44c73808e0e30">More...</a><br /></td></tr>
<tr class="separator:aa5d2e60921b2f4aef3d44c73808e0e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1469710de4bfd75ff21d8fa52a6a8c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae1469710de4bfd75ff21d8fa52a6a8c1">isSnapPea</a> () const</td></tr>
<tr class="memdesc:ae1469710de4bfd75ff21d8fa52a6a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SnapPea triangulation that holds this data, if there is one.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae1469710de4bfd75ff21d8fa52a6a8c1">More...</a><br /></td></tr>
<tr class="separator:ae1469710de4bfd75ff21d8fa52a6a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tetrahedra</div></td></tr>
<tr class="memitem:a8ed61991de885c0e4b393690f91b0930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8ed61991de885c0e4b393690f91b0930">newTetrahedron</a> ()</td></tr>
<tr class="memdesc:a8ed61991de885c0e4b393690f91b0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a8ed61991de885c0e4b393690f91b0930">More...</a><br /></td></tr>
<tr class="separator:a8ed61991de885c0e4b393690f91b0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d942a89497e2bce4ee716db55dfd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad6d942a89497e2bce4ee716db55dfd92">newTetrahedron</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:ad6d942a89497e2bce4ee716db55dfd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad6d942a89497e2bce4ee716db55dfd92">More...</a><br /></td></tr>
<tr class="separator:ad6d942a89497e2bce4ee716db55dfd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac05e1fccff29a9d160199629473ea"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a2aac05e1fccff29a9d160199629473ea"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *, k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a2aac05e1fccff29a9d160199629473ea">newTetrahedra</a> ()</td></tr>
<tr class="memdesc:a2aac05e1fccff29a9d160199629473ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a2aac05e1fccff29a9d160199629473ea">More...</a><br /></td></tr>
<tr class="separator:a2aac05e1fccff29a9d160199629473ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ef43d396c8751d33af3d735baa87e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a17ef43d396c8751d33af3d735baa87e3">newTetrahedra</a> (size_t k)</td></tr>
<tr class="memdesc:a17ef43d396c8751d33af3d735baa87e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a17ef43d396c8751d33af3d735baa87e3">More...</a><br /></td></tr>
<tr class="separator:a17ef43d396c8751d33af3d735baa87e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d12119aa7e43ba418129a62edd57f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a7d12119aa7e43ba418129a62edd57f92">removeTetrahedron</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:a7d12119aa7e43ba418129a62edd57f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a7d12119aa7e43ba418129a62edd57f92">More...</a><br /></td></tr>
<tr class="separator:a7d12119aa7e43ba418129a62edd57f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085896e8328394d9cb399529e97d6b7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a085896e8328394d9cb399529e97d6b7a">removeTetrahedronAt</a> (size_t index)</td></tr>
<tr class="memdesc:a085896e8328394d9cb399529e97d6b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a085896e8328394d9cb399529e97d6b7a">More...</a><br /></td></tr>
<tr class="separator:a085896e8328394d9cb399529e97d6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5db4562cc8b5cc400c32cc84baf052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5d5db4562cc8b5cc400c32cc84baf052">removeAllTetrahedra</a> ()</td></tr>
<tr class="memdesc:a5d5db4562cc8b5cc400c32cc84baf052"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a5d5db4562cc8b5cc400c32cc84baf052">More...</a><br /></td></tr>
<tr class="separator:a5d5db4562cc8b5cc400c32cc84baf052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42e9ae581e5df1e9a55ffa64cba52bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab42e9ae581e5df1e9a55ffa64cba52bb">swap</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;other)</td></tr>
<tr class="memdesc:ab42e9ae581e5df1e9a55ffa64cba52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ab42e9ae581e5df1e9a55ffa64cba52bb">More...</a><br /></td></tr>
<tr class="separator:ab42e9ae581e5df1e9a55ffa64cba52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Queries</div></td></tr>
<tr class="memitem:a47ae349fb76332c8202c1eebd643b569"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a47ae349fb76332c8202c1eebd643b569">hasBoundaryTriangles</a> () const</td></tr>
<tr class="memdesc:a47ae349fb76332c8202c1eebd643b569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5ffca92f7a401c3beb7a603d997a088e" title="Determines if this triangulation has any boundary facets.">hasBoundaryFacets()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a47ae349fb76332c8202c1eebd643b569">More...</a><br /></td></tr>
<tr class="separator:a47ae349fb76332c8202c1eebd643b569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda46274460bd9de64f06e16435c5e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a2fda46274460bd9de64f06e16435c5e1">countBoundaryTriangles</a> () const</td></tr>
<tr class="memdesc:a2fda46274460bd9de64f06e16435c5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8c1a05fe022a95b928a068f9909b036c" title="Returns the total number of boundary facets in this triangulation.">countBoundaryFacets()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a2fda46274460bd9de64f06e16435c5e1">More...</a><br /></td></tr>
<tr class="separator:a2fda46274460bd9de64f06e16435c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46851fcdaca6a86afe44b9fd185d0c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a46851fcdaca6a86afe44b9fd185d0c1b">hasTwoSphereBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:a46851fcdaca6a86afe44b9fd185d0c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation contains any two-sphere boundary components.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a46851fcdaca6a86afe44b9fd185d0c1b">More...</a><br /></td></tr>
<tr class="separator:a46851fcdaca6a86afe44b9fd185d0c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcccbe5dab59415beab467a51fdab22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aafcccbe5dab59415beab467a51fdab22">hasNegativeIdealBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:aafcccbe5dab59415beab467a51fdab22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation contains any ideal boundary components with negative Euler characteristic.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aafcccbe5dab59415beab467a51fdab22">More...</a><br /></td></tr>
<tr class="separator:aafcccbe5dab59415beab467a51fdab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be01e573b97c0bfdbc34a2da2b97a6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5be01e573b97c0bfdbc34a2da2b97a6f">hasMinimalBoundary</a> () const</td></tr>
<tr class="memdesc:a5be01e573b97c0bfdbc34a2da2b97a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the boundary of this triangulation contains the smallest possible number of triangles.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a5be01e573b97c0bfdbc34a2da2b97a6f">More...</a><br /></td></tr>
<tr class="separator:a5be01e573b97c0bfdbc34a2da2b97a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d6f6483a5b84bf99f671c63df34b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af8d6f6483a5b84bf99f671c63df34b73">hasMinimalVertices</a> () const</td></tr>
<tr class="memdesc:af8d6f6483a5b84bf99f671c63df34b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation contains the smallest possible number of vertices for the 3-manifold that it represents.  <a href="classregina_1_1Triangulation_3_013_01_4.html#af8d6f6483a5b84bf99f671c63df34b73">More...</a><br /></td></tr>
<tr class="separator:af8d6f6483a5b84bf99f671c63df34b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:aea8890fe2a84e4c147c43c2ae3c2386f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aea8890fe2a84e4c147c43c2ae3c2386f">eulerCharManifold</a> () const</td></tr>
<tr class="memdesc:aea8890fe2a84e4c147c43c2ae3c2386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euler characteristic of the corresponding compact 3-manifold.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aea8890fe2a84e4c147c43c2ae3c2386f">More...</a><br /></td></tr>
<tr class="separator:aea8890fe2a84e4c147c43c2ae3c2386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef22e54275916f8b81b8fd74ab8a439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6ef22e54275916f8b81b8fd74ab8a439">isIdeal</a> () const</td></tr>
<tr class="memdesc:a6ef22e54275916f8b81b8fd74ab8a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is ideal.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a6ef22e54275916f8b81b8fd74ab8a439">More...</a><br /></td></tr>
<tr class="separator:a6ef22e54275916f8b81b8fd74ab8a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97688a6770fe85d320b05edd355abbc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a97688a6770fe85d320b05edd355abbc2">isStandard</a> () const</td></tr>
<tr class="memdesc:a97688a6770fe85d320b05edd355abbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is standard.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a97688a6770fe85d320b05edd355abbc2">More...</a><br /></td></tr>
<tr class="separator:a97688a6770fe85d320b05edd355abbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07002c044286b6ba00d747d3fa49d52a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a07002c044286b6ba00d747d3fa49d52a">isClosed</a> () const</td></tr>
<tr class="memdesc:a07002c044286b6ba00d747d3fa49d52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is closed.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a07002c044286b6ba00d747d3fa49d52a">More...</a><br /></td></tr>
<tr class="separator:a07002c044286b6ba00d747d3fa49d52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579be62f99849f22c5a23cceb3f2bf41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a579be62f99849f22c5a23cceb3f2bf41">isOrdered</a> () const</td></tr>
<tr class="memdesc:a579be62f99849f22c5a23cceb3f2bf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is ordered; that is, if tetrahedron vertices are labelled so that all gluing permutations are order-preserving on the tetrahedron faces.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a579be62f99849f22c5a23cceb3f2bf41">More...</a><br /></td></tr>
<tr class="separator:a579be62f99849f22c5a23cceb3f2bf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Properties</div></td></tr>
<tr class="memitem:a6527c268fe007510be5ffd8d99509f62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6527c268fe007510be5ffd8d99509f62">homologyRel</a> () const</td></tr>
<tr class="memdesc:a6527c268fe007510be5ffd8d99509f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relative first homology group with respect to the boundary for this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a6527c268fe007510be5ffd8d99509f62">More...</a><br /></td></tr>
<tr class="separator:a6527c268fe007510be5ffd8d99509f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3952258a66287d9efc752eb338f6626"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab3952258a66287d9efc752eb338f6626">homologyBdry</a> () const</td></tr>
<tr class="memdesc:ab3952258a66287d9efc752eb338f6626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group of the boundary for this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ab3952258a66287d9efc752eb338f6626">More...</a><br /></td></tr>
<tr class="separator:ab3952258a66287d9efc752eb338f6626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c0948923311085b2d5c0bb61a6ab95"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a86c0948923311085b2d5c0bb61a6ab95">homologyH2Z2</a> () const</td></tr>
<tr class="memdesc:a86c0948923311085b2d5c0bb61a6ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second homology group with coefficients in Z_2 for this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a86c0948923311085b2d5c0bb61a6ab95">More...</a><br /></td></tr>
<tr class="separator:a86c0948923311085b2d5c0bb61a6ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c7fc5f723ce2c68158d7319dda0cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4">turaevViro</a> (unsigned long r, bool parity=true, <a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ad3c7fc5f723ce2c68158d7319dda0cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4">More...</a><br /></td></tr>
<tr class="separator:ad3c7fc5f723ce2c68158d7319dda0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d6e40d1a39ee48966c7a95f00092da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da">turaevViroApprox</a> (unsigned long r, unsigned long whichRoot=1, <a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>) const</td></tr>
<tr class="memdesc:a45d6e40d1a39ee48966c7a95f00092da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floating-point approximation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da">More...</a><br /></td></tr>
<tr class="separator:a45d6e40d1a39ee48966c7a95f00092da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a33c581d838c8d558da03acc290c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a75395b2e289bf58155f6b1f94b47530a">TuraevViroSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad43a33c581d838c8d558da03acc290c7">allCalculatedTuraevViro</a> () const</td></tr>
<tr class="memdesc:ad43a33c581d838c8d558da03acc290c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifold.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad43a33c581d838c8d558da03acc290c7">More...</a><br /></td></tr>
<tr class="separator:ad43a33c581d838c8d558da03acc290c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e4179fae4ecc6764dc7a1bf318a3c0"><td class="memItemLeft" align="right" valign="top">std::array&lt; long, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af6e4179fae4ecc6764dc7a1bf318a3c0">longitudeCuts</a> () const</td></tr>
<tr class="memdesc:af6e4179fae4ecc6764dc7a1bf318a3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the algebraic longitude as a curve on the boundary of a triangulated knot complement.  <a href="classregina_1_1Triangulation_3_013_01_4.html#af6e4179fae4ecc6764dc7a1bf318a3c0">More...</a><br /></td></tr>
<tr class="separator:af6e4179fae4ecc6764dc7a1bf318a3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c785e342e4d35edb9f1cdaf40a5540d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6c785e342e4d35edb9f1cdaf40a5540d">longitude</a> ()</td></tr>
<tr class="memdesc:a6c785e342e4d35edb9f1cdaf40a5540d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edge, and returns this edge.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a6c785e342e4d35edb9f1cdaf40a5540d">More...</a><br /></td></tr>
<tr class="separator:a6c785e342e4d35edb9f1cdaf40a5540d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9903daeee0c9c58c3d7872e054076569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9903daeee0c9c58c3d7872e054076569">meridian</a> ()</td></tr>
<tr class="memdesc:a9903daeee0c9c58c3d7872e054076569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a triangulated knot complement so that the meridian follows a single boundary edge, and returns this edge.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a9903daeee0c9c58c3d7872e054076569">More...</a><br /></td></tr>
<tr class="separator:a9903daeee0c9c58c3d7872e054076569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317601abbfe21f86ff9f8b1c254f00b9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a317601abbfe21f86ff9f8b1c254f00b9">meridianLongitude</a> ()</td></tr>
<tr class="memdesc:a317601abbfe21f86ff9f8b1c254f00b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a single boundary edge, and returns these two edges.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a317601abbfe21f86ff9f8b1c254f00b9">More...</a><br /></td></tr>
<tr class="separator:a317601abbfe21f86ff9f8b1c254f00b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Normal Surfaces and Angle Structures</div></td></tr>
<tr class="memitem:a16653ca34f64f08b06977942f2ce00de"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a16653ca34f64f08b06977942f2ce00de"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a16653ca34f64f08b06977942f2ce00de">linkingSurface</a> (const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, subdim &gt; &amp;<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8">face</a>) const</td></tr>
<tr class="memdesc:a16653ca34f64f08b06977942f2ce00de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the link of the given face as a normal surface.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a16653ca34f64f08b06977942f2ce00de">More...</a><br /></td></tr>
<tr class="separator:a16653ca34f64f08b06977942f2ce00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f53c7239fd5e5675628d91bf70292f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa9f53c7239fd5e5675628d91bf70292f">isZeroEfficient</a> () const</td></tr>
<tr class="memdesc:aa9f53c7239fd5e5675628d91bf70292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is 0-efficient.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa9f53c7239fd5e5675628d91bf70292f">More...</a><br /></td></tr>
<tr class="separator:aa9f53c7239fd5e5675628d91bf70292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18754e52a8c76dcadb6f885bb7c551bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a18754e52a8c76dcadb6f885bb7c551bc">knowsZeroEfficient</a> () const</td></tr>
<tr class="memdesc:a18754e52a8c76dcadb6f885bb7c551bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known whether or not this triangulation is 0-efficient? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa9f53c7239fd5e5675628d91bf70292f" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a18754e52a8c76dcadb6f885bb7c551bc">More...</a><br /></td></tr>
<tr class="separator:a18754e52a8c76dcadb6f885bb7c551bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d92d88a4a00fee457751e054e0ae4f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5d92d88a4a00fee457751e054e0ae4f7">hasSplittingSurface</a> () const</td></tr>
<tr class="memdesc:a5d92d88a4a00fee457751e054e0ae4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation has a normal splitting surface.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a5d92d88a4a00fee457751e054e0ae4f7">More...</a><br /></td></tr>
<tr class="separator:a5d92d88a4a00fee457751e054e0ae4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ffedc66a8452087e82dccf568afa7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4e5ffedc66a8452087e82dccf568afa7">nonTrivialSphereOrDisc</a> () const</td></tr>
<tr class="memdesc:a4e5ffedc66a8452087e82dccf568afa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a non-vertex-linking normal sphere or disc within this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a4e5ffedc66a8452087e82dccf568afa7">More...</a><br /></td></tr>
<tr class="separator:a4e5ffedc66a8452087e82dccf568afa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99edba3a5ebb17bcfad1bbe2f7ede12"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad99edba3a5ebb17bcfad1bbe2f7ede12">octagonalAlmostNormalSphere</a> () const</td></tr>
<tr class="memdesc:ad99edba3a5ebb17bcfad1bbe2f7ede12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an octagonal almost normal 2-sphere within this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad99edba3a5ebb17bcfad1bbe2f7ede12">More...</a><br /></td></tr>
<tr class="separator:ad99edba3a5ebb17bcfad1bbe2f7ede12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91466715d657a6d6fb8cad7d45b0aa22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22">strictAngleStructure</a> () const</td></tr>
<tr class="memdesc:a91466715d657a6d6fb8cad7d45b0aa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a strict angle structure on this triangulation, if one exists.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22">More...</a><br /></td></tr>
<tr class="separator:a91466715d657a6d6fb8cad7d45b0aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d01479e8abe3e6759f13b66babb9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c">hasStrictAngleStructure</a> () const</td></tr>
<tr class="memdesc:acf9d01479e8abe3e6759f13b66babb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation supports a strict angle structure.  <a href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c">More...</a><br /></td></tr>
<tr class="separator:acf9d01479e8abe3e6759f13b66babb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac439e27b0888b60b2d256e9ad8eaaa15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac439e27b0888b60b2d256e9ad8eaaa15">knowsStrictAngleStructure</a> () const</td></tr>
<tr class="memdesc:ac439e27b0888b60b2d256e9ad8eaaa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this triangulation supports a strict angle structure? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ac439e27b0888b60b2d256e9ad8eaaa15">More...</a><br /></td></tr>
<tr class="separator:ac439e27b0888b60b2d256e9ad8eaaa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff19565dafd9d6b64e4d0e99cdf54d36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36">generalAngleStructure</a> () const</td></tr>
<tr class="memdesc:aff19565dafd9d6b64e4d0e99cdf54d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generalised angle structure on this triangulation, if one exists.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36">More...</a><br /></td></tr>
<tr class="separator:aff19565dafd9d6b64e4d0e99cdf54d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7a09adb86c472b9764f2f553b03b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9c7a09adb86c472b9764f2f553b03b07">hasGeneralAngleStructure</a> () const</td></tr>
<tr class="memdesc:a9c7a09adb86c472b9764f2f553b03b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation supports a generalised angle structure.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a9c7a09adb86c472b9764f2f553b03b07">More...</a><br /></td></tr>
<tr class="separator:a9c7a09adb86c472b9764f2f553b03b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:a21f68d896757112ff99db229e05e0558"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a21f68d896757112ff99db229e05e0558">maximalForestInBoundary</a> () const</td></tr>
<tr class="memdesc:a21f68d896757112ff99db229e05e0558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a maximal forest in the 1-skeleton of the triangulation boundary.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a21f68d896757112ff99db229e05e0558">More...</a><br /></td></tr>
<tr class="separator:a21f68d896757112ff99db229e05e0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dadda881273e35b036a76868403c40e"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a2dadda881273e35b036a76868403c40e">maximalForestInSkeleton</a> (bool canJoinBoundaries=true) const</td></tr>
<tr class="memdesc:a2dadda881273e35b036a76868403c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a maximal forest in the triangulation's 1-skeleton.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a2dadda881273e35b036a76868403c40e">More...</a><br /></td></tr>
<tr class="separator:a2dadda881273e35b036a76868403c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63140ff3ab1dd53acd661a6c8cde47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:ad63140ff3ab1dd53acd661a6c8cde47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the triangulation using fast and greedy heuristics.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e">More...</a><br /></td></tr>
<tr class="separator:ad63140ff3ab1dd53acd661a6c8cde47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc067391ecf8f6269e624ee9d658761"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0bc067391ecf8f6269e624ee9d658761">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:a0bc067391ecf8f6269e624ee9d658761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of tetrahedra.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a0bc067391ecf8f6269e624ee9d658761">More...</a><br /></td></tr>
<tr class="separator:a0bc067391ecf8f6269e624ee9d658761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696fcaf4e922a333dd5ed9035b724e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5">simplifyExhaustive</a> (int height=1, unsigned threads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a8696fcaf4e922a333dd5ed9035b724e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5">More...</a><br /></td></tr>
<tr class="separator:a8696fcaf4e922a333dd5ed9035b724e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a4b8a276b82d111455455fd74ecfc4"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ab2a4b8a276b82d111455455fd74ecfc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab2a4b8a276b82d111455455fd74ecfc4">retriangulate</a> (int height, unsigned threads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ab2a4b8a276b82d111455455fd74ecfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all triangulations that can be reached from this via Pachner moves, without exceeding a given number of additional tetrahedra.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ab2a4b8a276b82d111455455fd74ecfc4">More...</a><br /></td></tr>
<tr class="separator:ab2a4b8a276b82d111455455fd74ecfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e659747844d582d50162a471fd81ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab">minimiseBoundary</a> ()</td></tr>
<tr class="memdesc:ae3e659747844d582d50162a471fd81ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab">More...</a><br /></td></tr>
<tr class="separator:ae3e659747844d582d50162a471fd81ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160ade86ae2ac23ac91a97d25aa79de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9160ade86ae2ac23ac91a97d25aa79de">minimizeBoundary</a> ()</td></tr>
<tr class="memdesc:a9160ade86ae2ac23ac91a97d25aa79de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a9160ade86ae2ac23ac91a97d25aa79de">More...</a><br /></td></tr>
<tr class="separator:a9160ade86ae2ac23ac91a97d25aa79de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af570c3698d9267f8a3bb373addedc071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071">minimiseVertices</a> ()</td></tr>
<tr class="memdesc:af570c3698d9267f8a3bb373addedc071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold that it represents, potentially adding tetrahedra to do this.  <a href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071">More...</a><br /></td></tr>
<tr class="separator:af570c3698d9267f8a3bb373addedc071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9befd3e78a51a9e5b3168a9e2f800b99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9befd3e78a51a9e5b3168a9e2f800b99">minimizeVertices</a> ()</td></tr>
<tr class="memdesc:a9befd3e78a51a9e5b3168a9e2f800b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a9befd3e78a51a9e5b3168a9e2f800b99">More...</a><br /></td></tr>
<tr class="separator:a9befd3e78a51a9e5b3168a9e2f800b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cf09bfb6bc4e6f82db1466b3765b97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af0cf09bfb6bc4e6f82db1466b3765b97">fourFourMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, int newAxis, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:af0cf09bfb6bc4e6f82db1466b3765b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 4-4 move about the given edge.  <a href="classregina_1_1Triangulation_3_013_01_4.html#af0cf09bfb6bc4e6f82db1466b3765b97">More...</a><br /></td></tr>
<tr class="separator:af0cf09bfb6bc4e6f82db1466b3765b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac177c5e1e70fb0d0a24324108ce64ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac177c5e1e70fb0d0a24324108ce64ead">twoZeroMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ac177c5e1e70fb0d0a24324108ce64ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ac177c5e1e70fb0d0a24324108ce64ead">More...</a><br /></td></tr>
<tr class="separator:ac177c5e1e70fb0d0a24324108ce64ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa1cd8d7fd0334ad909beafcd75974c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acaa1cd8d7fd0334ad909beafcd75974c">twoZeroMove</a> (<a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *v, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:acaa1cd8d7fd0334ad909beafcd75974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given vertex of degree 2.  <a href="classregina_1_1Triangulation_3_013_01_4.html#acaa1cd8d7fd0334ad909beafcd75974c">More...</a><br /></td></tr>
<tr class="separator:acaa1cd8d7fd0334ad909beafcd75974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f35dda23ea3274dbf35c3196508df26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4f35dda23ea3274dbf35c3196508df26">twoOneMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, int edgeEnd, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a4f35dda23ea3274dbf35c3196508df26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-1 move about the given edge.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a4f35dda23ea3274dbf35c3196508df26">More...</a><br /></td></tr>
<tr class="separator:a4f35dda23ea3274dbf35c3196508df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9113fca5e95226551dfde803b8ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3fa9113fca5e95226551dfde803b8ef2">zeroTwoMove</a> (<a class="el" href="group__generic.html#ga0d59f1efc647fdeca1fa5ca8aa2fc743">EdgeEmbedding</a>&lt; 3 &gt; e0, int t0, <a class="el" href="group__generic.html#ga0d59f1efc647fdeca1fa5ca8aa2fc743">EdgeEmbedding</a>&lt; 3 &gt; e1, int t1, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a3fa9113fca5e95226551dfde803b8ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles <code>e0.tetrahedron()-&gt;triangle(e0.vertices()[t0])</code> and <code>e1.tetrahedron()-&gt;triangle(e1.vertices()[t1])</code>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a3fa9113fca5e95226551dfde803b8ef2">More...</a><br /></td></tr>
<tr class="separator:a3fa9113fca5e95226551dfde803b8ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743fc6719e55852c85abb7899ac6d061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a743fc6719e55852c85abb7899ac6d061">zeroTwoMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, size_t t0, size_t t1, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a743fc6719e55852c85abb7899ac6d061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles incident to <em>e</em> that are numbered <em>t0</em> and <em>t1</em>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a743fc6719e55852c85abb7899ac6d061">More...</a><br /></td></tr>
<tr class="separator:a743fc6719e55852c85abb7899ac6d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2297104719d871336ec02112ae2e5579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a2297104719d871336ec02112ae2e5579">zeroTwoMove</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *t0, int e0, <a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *t1, int e1, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a2297104719d871336ec02112ae2e5579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles <em>t0</em> and <em>t1</em>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a2297104719d871336ec02112ae2e5579">More...</a><br /></td></tr>
<tr class="separator:a2297104719d871336ec02112ae2e5579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f76566647492c74f380c466edcbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4e1f76566647492c74f380c466edcbe5">openBook</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a4e1f76566647492c74f380c466edcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a book opening move about the given triangle.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a4e1f76566647492c74f380c466edcbe5">More...</a><br /></td></tr>
<tr class="separator:a4e1f76566647492c74f380c466edcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83effbc43af294638b92d39246ebb26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa83effbc43af294638b92d39246ebb26">closeBook</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aa83effbc43af294638b92d39246ebb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a book closing move about the given boundary edge.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa83effbc43af294638b92d39246ebb26">More...</a><br /></td></tr>
<tr class="separator:aa83effbc43af294638b92d39246ebb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b16dc8a8d13d3b01f1cee099988fd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a37b16dc8a8d13d3b01f1cee099988fd3">shellBoundary</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a37b16dc8a8d13d3b01f1cee099988fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a37b16dc8a8d13d3b01f1cee099988fd3">More...</a><br /></td></tr>
<tr class="separator:a37b16dc8a8d13d3b01f1cee099988fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15b75f55bf6eaead57e6864fd7db58d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d">collapseEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aa15b75f55bf6eaead57e6864fd7db58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d">More...</a><br /></td></tr>
<tr class="separator:aa15b75f55bf6eaead57e6864fd7db58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9a8527f05610a08f7f7a3d5042d152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#afd9a8527f05610a08f7f7a3d5042d152">reorderTetrahedraBFS</a> (bool reverse=false)</td></tr>
<tr class="memdesc:afd9a8527f05610a08f7f7a3d5042d152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the tetrahedra of this triangulation using a breadth-first search, so that small-numbered tetrahedra are adjacent to other small-numbered tetrahedra.  <a href="classregina_1_1Triangulation_3_013_01_4.html#afd9a8527f05610a08f7f7a3d5042d152">More...</a><br /></td></tr>
<tr class="separator:afd9a8527f05610a08f7f7a3d5042d152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c5856b28d23276d52d5c4c7705b5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8b1c5856b28d23276d52d5c4c7705b5d">order</a> (bool forceOriented=false)</td></tr>
<tr class="memdesc:a8b1c5856b28d23276d52d5c4c7705b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels tetrahedron vertices in this triangulation to give an ordered triangulation, if possible.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a8b1c5856b28d23276d52d5c4c7705b5d">More...</a><br /></td></tr>
<tr class="separator:a8b1c5856b28d23276d52d5c4c7705b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompositions</div></td></tr>
<tr class="memitem:a62be236f61c28a04a102667cfbd6eea3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a62be236f61c28a04a102667cfbd6eea3">summands</a> () const</td></tr>
<tr class="memdesc:a62be236f61c28a04a102667cfbd6eea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the connected sum decomposition of this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a62be236f61c28a04a102667cfbd6eea3">More...</a><br /></td></tr>
<tr class="separator:a62be236f61c28a04a102667cfbd6eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95050517897ca5dc5b5da5f022155e49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49">isSphere</a> () const</td></tr>
<tr class="memdesc:a95050517897ca5dc5b5da5f022155e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of a 3-sphere.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49">More...</a><br /></td></tr>
<tr class="separator:a95050517897ca5dc5b5da5f022155e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d53ef63ff44a1a45227a48d22afb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a298d53ef63ff44a1a45227a48d22afb5">knowsSphere</a> () const</td></tr>
<tr class="memdesc:a298d53ef63ff44a1a45227a48d22afb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a298d53ef63ff44a1a45227a48d22afb5">More...</a><br /></td></tr>
<tr class="separator:a298d53ef63ff44a1a45227a48d22afb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccc3c75b25276fa66c4fc1b337cc0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c">isBall</a> () const</td></tr>
<tr class="memdesc:a4bccc3c75b25276fa66c4fc1b337cc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of a 3-dimensional ball.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c">More...</a><br /></td></tr>
<tr class="separator:a4bccc3c75b25276fa66c4fc1b337cc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ece1722460a2265a4926a7d517af2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa1ece1722460a2265a4926a7d517af2e">knowsBall</a> () const</td></tr>
<tr class="memdesc:aa1ece1722460a2265a4926a7d517af2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimensional ball? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa1ece1722460a2265a4926a7d517af2e">More...</a><br /></td></tr>
<tr class="separator:aa1ece1722460a2265a4926a7d517af2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6887425d2144a4f3a485c59ec9b74c3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e">isSolidTorus</a> () const</td></tr>
<tr class="memdesc:a6887425d2144a4f3a485c59ec9b74c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of the solid torus; that is, the unknot complement.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e">More...</a><br /></td></tr>
<tr class="separator:a6887425d2144a4f3a485c59ec9b74c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281f3fc9351e4c757fec0053252d1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a281f3fc9351e4c757fec0053252d1dd4">knowsSolidTorus</a> () const</td></tr>
<tr class="memdesc:a281f3fc9351e4c757fec0053252d1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus (that is, the unknot complement)? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a281f3fc9351e4c757fec0053252d1dd4">More...</a><br /></td></tr>
<tr class="separator:a281f3fc9351e4c757fec0053252d1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca8e041483cec8b065c0a48d4448b00"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00">recogniseHandlebody</a> () const</td></tr>
<tr class="memdesc:a5ca8e041483cec8b065c0a48d4448b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of an orientable handlebody, and if so, which genus.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00">More...</a><br /></td></tr>
<tr class="separator:a5ca8e041483cec8b065c0a48d4448b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a7147a44915b76f3cebfc71eceab85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad2a7147a44915b76f3cebfc71eceab85">knowsHandlebody</a> () const</td></tr>
<tr class="memdesc:ad2a7147a44915b76f3cebfc71eceab85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of an orientable handlebody? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00" title="Determines whether this is a triangulation of an orientable handlebody, and if so,...">recogniseHandlebody()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad2a7147a44915b76f3cebfc71eceab85">More...</a><br /></td></tr>
<tr class="separator:ad2a7147a44915b76f3cebfc71eceab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0326a12e5c235b90e78ccd3f51e5863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863">isTxI</a> () const</td></tr>
<tr class="memdesc:ae0326a12e5c235b90e78ccd3f51e5863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the underlying 3-manifold is the product of a torus with an interval.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863">More...</a><br /></td></tr>
<tr class="separator:ae0326a12e5c235b90e78ccd3f51e5863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a53ffd0e9e8e5b2e9c8521c58871ec56b">knowsTxI</a> () const</td></tr>
<tr class="memdesc:a53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a the product of a torus with an interval? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a53ffd0e9e8e5b2e9c8521c58871ec56b">More...</a><br /></td></tr>
<tr class="separator:a53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7785d4bb75a5366cc4d9bae5bf5536ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a7785d4bb75a5366cc4d9bae5bf5536ae">isIrreducible</a> () const</td></tr>
<tr class="memdesc:a7785d4bb75a5366cc4d9bae5bf5536ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the underlying 3-manifold (which must be closed) is irreducible.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a7785d4bb75a5366cc4d9bae5bf5536ae">More...</a><br /></td></tr>
<tr class="separator:a7785d4bb75a5366cc4d9bae5bf5536ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96238fc751a6350e17ce5727a183ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa96238fc751a6350e17ce5727a183ba1">knowsIrreducible</a> () const</td></tr>
<tr class="memdesc:aa96238fc751a6350e17ce5727a183ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold is irreducible? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa96238fc751a6350e17ce5727a183ba1">More...</a><br /></td></tr>
<tr class="separator:aa96238fc751a6350e17ce5727a183ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6b6645fdc68b91645acda38cedb2a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8">hasCompressingDisc</a> () const</td></tr>
<tr class="memdesc:a3f6b6645fdc68b91645acda38cedb2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a compressing disc within the underlying 3-manifold.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8">More...</a><br /></td></tr>
<tr class="separator:a3f6b6645fdc68b91645acda38cedb2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a70b6cb41cbea1bab5fbe1692ecd8a2d7">knowsCompressingDisc</a> () const</td></tr>
<tr class="memdesc:a70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold contains a compressing disc? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a70b6cb41cbea1bab5fbe1692ecd8a2d7">More...</a><br /></td></tr>
<tr class="separator:a70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dd70d1448cb32ce52da8e8ae78f6d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a14dd70d1448cb32ce52da8e8ae78f6d8">isHaken</a> () const</td></tr>
<tr class="memdesc:a14dd70d1448cb32ce52da8e8ae78f6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a14dd70d1448cb32ce52da8e8ae78f6d8">More...</a><br /></td></tr>
<tr class="separator:a14dd70d1448cb32ce52da8e8ae78f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#adaeafdd4bd2b7a28d3bcfcb31521a5a3">knowsHaken</a> () const</td></tr>
<tr class="memdesc:adaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold is Haken? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> for further details.  <a href="classregina_1_1Triangulation_3_013_01_4.html#adaeafdd4bd2b7a28d3bcfcb31521a5a3">More...</a><br /></td></tr>
<tr class="separator:adaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d8cba1fae2b39de379ff6c8df4d61c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c">hasSimpleCompressingDisc</a> () const</td></tr>
<tr class="memdesc:a31d8cba1fae2b39de379ff6c8df4d61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a "simple" compressing disc inside this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c">More...</a><br /></td></tr>
<tr class="separator:a31d8cba1fae2b39de379ff6c8df4d61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345829b2c1486eb39f319ed90720c97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab345829b2c1486eb39f319ed90720c97">niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:ab345829b2c1486eb39f319ed90720c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nice tree decomposition of the face pairing graph of this triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ab345829b2c1486eb39f319ed90720c97">More...</a><br /></td></tr>
<tr class="separator:ab345829b2c1486eb39f319ed90720c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions, Extensions and Covers</div></td></tr>
<tr class="memitem:ac025b93b99f5b674fd448e6374c81142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142">idealToFinite</a> ()</td></tr>
<tr class="memdesc:ac025b93b99f5b674fd448e6374c81142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ideal triangulation into a finite triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142">More...</a><br /></td></tr>
<tr class="separator:ac025b93b99f5b674fd448e6374c81142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24fe1e3bae956fbf8954fb54adc19e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4">pinchEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e)</td></tr>
<tr class="memdesc:ad24fe1e3bae956fbf8954fb54adc19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pinches an internal edge to a point.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4">More...</a><br /></td></tr>
<tr class="separator:ad24fe1e3bae956fbf8954fb54adc19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171f874204819014b8a5ea77b1ca2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae171f874204819014b8a5ea77b1ca2aa">puncture</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet=nullptr)</td></tr>
<tr class="memdesc:ae171f874204819014b8a5ea77b1ca2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punctures this manifold by removing a 3-ball from the interior of the given tetrahedron.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae171f874204819014b8a5ea77b1ca2aa">More...</a><br /></td></tr>
<tr class="separator:ae171f874204819014b8a5ea77b1ca2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Building Triangulations</div></td></tr>
<tr class="memitem:aa511ce61e49b446c391b6f97338b9e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa511ce61e49b446c391b6f97338b9e1b">layerOn</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a25e675a24773baa6ddca79a6ae7e2899">edge</a>)</td></tr>
<tr class="memdesc:aa511ce61e49b446c391b6f97338b9e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a layering upon the given boundary edge of the triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa511ce61e49b446c391b6f97338b9e1b">More...</a><br /></td></tr>
<tr class="separator:aa511ce61e49b446c391b6f97338b9e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bd90a983d00116514d0dd5bbefe3a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0bd90a983d00116514d0dd5bbefe3a2">fillTorus</a> (unsigned long cuts0, unsigned long cuts1, unsigned long cuts2, <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; 3 &gt; *bc=nullptr)</td></tr>
<tr class="memdesc:ae0bd90a983d00116514d0dd5bbefe3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae0bd90a983d00116514d0dd5bbefe3a2">More...</a><br /></td></tr>
<tr class="separator:ae0bd90a983d00116514d0dd5bbefe3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6f440e7d977462241c1b4f16a169e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6b6f440e7d977462241c1b4f16a169e3">fillTorus</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e0, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e1, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e2, unsigned long cuts0, unsigned long cuts1, unsigned long cuts2)</td></tr>
<tr class="memdesc:a6b6f440e7d977462241c1b4f16a169e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a6b6f440e7d977462241c1b4f16a169e3">More...</a><br /></td></tr>
<tr class="separator:a6b6f440e7d977462241c1b4f16a169e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024090512e8debb67c5895ec9eb80efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a024090512e8debb67c5895ec9eb80efa">insertLayeredSolidTorus</a> (unsigned long cuts0, unsigned long cuts1)</td></tr>
<tr class="memdesc:a024090512e8debb67c5895ec9eb80efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new layered solid torus into the triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a024090512e8debb67c5895ec9eb80efa">More...</a><br /></td></tr>
<tr class="separator:a024090512e8debb67c5895ec9eb80efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0671a3ebe7d61fe1fc9ba26862bfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf0671a3ebe7d61fe1fc9ba26862bfce">connectedSumWith</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> &amp;other)</td></tr>
<tr class="memdesc:acf0671a3ebe7d61fe1fc9ba26862bfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the connected sum of this triangulation with the given triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#acf0671a3ebe7d61fe1fc9ba26862bfce">More...</a><br /></td></tr>
<tr class="separator:acf0671a3ebe7d61fe1fc9ba26862bfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Triangulations</div></td></tr>
<tr class="memitem:a8b1081ff442801c2d33038c11031ee2b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8b1081ff442801c2d33038c11031ee2b">dehydrate</a> () const</td></tr>
<tr class="memdesc:a8b1081ff442801c2d33038c11031ee2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dehydrates this triangulation into an alphabetical string.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a8b1081ff442801c2d33038c11031ee2b">More...</a><br /></td></tr>
<tr class="separator:a8b1081ff442801c2d33038c11031ee2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aeff844c71c39d0ae40b4d1c4aa3b0efc">recogniser</a> () const</td></tr>
<tr class="memdesc:aeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that expresses this triangulation in Matveev's 3-manifold recogniser format.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aeff844c71c39d0ae40b4d1c4aa3b0efc">More...</a><br /></td></tr>
<tr class="separator:aeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f721425309c5b113d24d0e06abfb08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a61f721425309c5b113d24d0e06abfb08">recogniser</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a61f721425309c5b113d24d0e06abfb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a61f721425309c5b113d24d0e06abfb08">More...</a><br /></td></tr>
<tr class="separator:a61f721425309c5b113d24d0e06abfb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403a36d9a4748032f5abb7e16c24621d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a403a36d9a4748032f5abb7e16c24621d">recognizer</a> () const</td></tr>
<tr class="memdesc:a403a36d9a4748032f5abb7e16c24621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aeff844c71c39d0ae40b4d1c4aa3b0efc" title="Returns a string that expresses this triangulation in Matveev&#39;s 3-manifold recogniser format.">recogniser()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a403a36d9a4748032f5abb7e16c24621d">More...</a><br /></td></tr>
<tr class="separator:a403a36d9a4748032f5abb7e16c24621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9565c761baf1d0fcf41f1e08baf1733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af9565c761baf1d0fcf41f1e08baf1733">recognizer</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af9565c761baf1d0fcf41f1e08baf1733"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for recognizer(std::ostream&amp;).  <a href="classregina_1_1Triangulation_3_013_01_4.html#af9565c761baf1d0fcf41f1e08baf1733">More...</a><br /></td></tr>
<tr class="separator:af9565c761baf1d0fcf41f1e08baf1733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c68d0faa4438c15960509298e100ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa0c68d0faa4438c15960509298e100ec">saveRecogniser</a> (const char *filename) const</td></tr>
<tr class="memdesc:aa0c68d0faa4438c15960509298e100ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this triangulation to the given file in Matveev's 3-manifold recogniser format.  <a href="classregina_1_1Triangulation_3_013_01_4.html#aa0c68d0faa4438c15960509298e100ec">More...</a><br /></td></tr>
<tr class="separator:aa0c68d0faa4438c15960509298e100ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae579243386ad33795b0759dd5fb35fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae579243386ad33795b0759dd5fb35fab">saveRecognizer</a> (const char *filename) const</td></tr>
<tr class="memdesc:ae579243386ad33795b0759dd5fb35fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa0c68d0faa4438c15960509298e100ec" title="Writes this triangulation to the given file in Matveev&#39;s 3-manifold recogniser format.">saveRecogniser()</a>.  <a href="classregina_1_1Triangulation_3_013_01_4.html#ae579243386ad33795b0759dd5fb35fab">More...</a><br /></td></tr>
<tr class="separator:ae579243386ad33795b0759dd5fb35fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simplices</div></td></tr>
<tr class="memitem:a3871caa1f02ccda957f22ebd9a646ff5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5">size</a> () const</td></tr>
<tr class="memdesc:a3871caa1f02ccda957f22ebd9a646ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of top-dimensional simplices in the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5">More...</a><br /></td></tr>
<tr class="separator:a3871caa1f02ccda957f22ebd9a646ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a7d5c459569dbf66147b62f695c2d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d">simplices</a> () const</td></tr>
<tr class="memdesc:a7d7a7d5c459569dbf66147b62f695c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all top-dimensional simplices in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d">More...</a><br /></td></tr>
<tr class="separator:a7d7a7d5c459569dbf66147b62f695c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e269a7332e80aeec3603881fd175d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a> (size_t index)</td></tr>
<tr class="memdesc:ae2e269a7332e80aeec3603881fd175d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">More...</a><br /></td></tr>
<tr class="separator:ae2e269a7332e80aeec3603881fd175d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdadce4ea703518064241597cf1514b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7cdadce4ea703518064241597cf1514b">simplex</a> (size_t index) const</td></tr>
<tr class="memdesc:a7cdadce4ea703518064241597cf1514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a7cdadce4ea703518064241597cf1514b">More...</a><br /></td></tr>
<tr class="separator:a7cdadce4ea703518064241597cf1514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437">newSimplex</a> ()</td></tr>
<tr class="memdesc:ad107a418e2691dc5ad7bb9e90dcba437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex and adds it to this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437">More...</a><br /></td></tr>
<tr class="separator:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829224a264241e43a8f2bbdf5bfcb253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a829224a264241e43a8f2bbdf5bfcb253">newSimplex</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a829224a264241e43a8f2bbdf5bfcb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex with the given description and adds it to this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a829224a264241e43a8f2bbdf5bfcb253">More...</a><br /></td></tr>
<tr class="separator:a829224a264241e43a8f2bbdf5bfcb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e0403df58ea41ee87cfeb3e111845e"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *, k &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e">newSimplices</a> ()</td></tr>
<tr class="memdesc:a80e0403df58ea41ee87cfeb3e111845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <em>k</em> new top-dimensional simplices, adds them to this triangulation, and returns them in a std::array.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e">More...</a><br /></td></tr>
<tr class="separator:a80e0403df58ea41ee87cfeb3e111845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911cdc0a8942418d4e257a81ce24a110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a911cdc0a8942418d4e257a81ce24a110">newSimplices</a> (size_t k)</td></tr>
<tr class="memdesc:a911cdc0a8942418d4e257a81ce24a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <em>k</em> new top-dimensional simplices and adds them to this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a911cdc0a8942418d4e257a81ce24a110">More...</a><br /></td></tr>
<tr class="separator:a911cdc0a8942418d4e257a81ce24a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba">removeSimplex</a> (<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given top-dimensional simplex from this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba">More...</a><br /></td></tr>
<tr class="separator:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec">removeSimplexAt</a> (size_t index)</td></tr>
<tr class="memdesc:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-dimensional simplex at the given index in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec">More...</a><br /></td></tr>
<tr class="separator:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91a640743f9ce2710d17eda77d520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a">removeAllSimplices</a> ()</td></tr>
<tr class="memdesc:a3e91a640743f9ce2710d17eda77d520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simplices from the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a">More...</a><br /></td></tr>
<tr class="separator:a3e91a640743f9ce2710d17eda77d520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae3fa3daf9672da64a0fa8a82a439d65b">moveContentsTo</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae3fa3daf9672da64a0fa8a82a439d65b">More...</a><br /></td></tr>
<tr class="separator:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Queries</div></td></tr>
<tr class="memitem:a20e5dba7654710e79eecaf849f248d38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a20e5dba7654710e79eecaf849f248d38">countComponents</a> () const</td></tr>
<tr class="memdesc:a20e5dba7654710e79eecaf849f248d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a20e5dba7654710e79eecaf849f248d38">More...</a><br /></td></tr>
<tr class="separator:a20e5dba7654710e79eecaf849f248d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658bf830fdf052e1beaa5423298c51b2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a658bf830fdf052e1beaa5423298c51b2">countBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:a658bf830fdf052e1beaa5423298c51b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary components in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a658bf830fdf052e1beaa5423298c51b2">More...</a><br /></td></tr>
<tr class="separator:a658bf830fdf052e1beaa5423298c51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d32300a09aa008d03099e4b84e873"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873">countFaces</a> () const</td></tr>
<tr class="memdesc:a929d32300a09aa008d03099e4b84e873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873">More...</a><br /></td></tr>
<tr class="separator:a929d32300a09aa008d03099e4b84e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51bc921de7b1971061a1a2353f9ad96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad51bc921de7b1971061a1a2353f9ad96">countFaces</a> (int subdim) const</td></tr>
<tr class="memdesc:ad51bc921de7b1971061a1a2353f9ad96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad51bc921de7b1971061a1a2353f9ad96">More...</a><br /></td></tr>
<tr class="separator:ad51bc921de7b1971061a1a2353f9ad96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4978fb0aeb2d208806404431e445a567"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4978fb0aeb2d208806404431e445a567">countVertices</a> () const</td></tr>
<tr class="memdesc:a4978fb0aeb2d208806404431e445a567"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;0&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a4978fb0aeb2d208806404431e445a567">More...</a><br /></td></tr>
<tr class="separator:a4978fb0aeb2d208806404431e445a567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf438f54b1ccec5a42916b00132ed2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f">countEdges</a> () const</td></tr>
<tr class="memdesc:addf438f54b1ccec5a42916b00132ed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;1&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f">More...</a><br /></td></tr>
<tr class="separator:addf438f54b1ccec5a42916b00132ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1fb3c66e81c2d533e1fac79439126"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0ff1fb3c66e81c2d533e1fac79439126">countTriangles</a> () const</td></tr>
<tr class="memdesc:a0ff1fb3c66e81c2d533e1fac79439126"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;2&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a0ff1fb3c66e81c2d533e1fac79439126">More...</a><br /></td></tr>
<tr class="separator:a0ff1fb3c66e81c2d533e1fac79439126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4329504df39fb7dbf796600329146d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2e4329504df39fb7dbf796600329146d">countTetrahedra</a> () const</td></tr>
<tr class="memdesc:a2e4329504df39fb7dbf796600329146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;3&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2e4329504df39fb7dbf796600329146d">More...</a><br /></td></tr>
<tr class="separator:a2e4329504df39fb7dbf796600329146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f6885850adfdf4c8c278dd241f5f90"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a10f6885850adfdf4c8c278dd241f5f90">countPentachora</a> () const</td></tr>
<tr class="memdesc:a10f6885850adfdf4c8c278dd241f5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;4&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a10f6885850adfdf4c8c278dd241f5f90">More...</a><br /></td></tr>
<tr class="separator:a10f6885850adfdf4c8c278dd241f5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c48ed1736e27aa09620cd924507ef4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad5c48ed1736e27aa09620cd924507ef4">fVector</a> () const</td></tr>
<tr class="memdesc:ad5c48ed1736e27aa09620cd924507ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the f-vector of this triangulation, which counts the number of faces of all dimensions.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad5c48ed1736e27aa09620cd924507ef4">More...</a><br /></td></tr>
<tr class="separator:ad5c48ed1736e27aa09620cd924507ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9f1a9b278dd911add0d10351e8089d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aca9f1a9b278dd911add0d10351e8089d">components</a> () const</td></tr>
<tr class="memdesc:aca9f1a9b278dd911add0d10351e8089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all components of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aca9f1a9b278dd911add0d10351e8089d">More...</a><br /></td></tr>
<tr class="separator:aca9f1a9b278dd911add0d10351e8089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76267c6a893785e1fe396e5b439806"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2b76267c6a893785e1fe396e5b439806">boundaryComponents</a> () const</td></tr>
<tr class="memdesc:a2b76267c6a893785e1fe396e5b439806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all boundary components of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2b76267c6a893785e1fe396e5b439806">More...</a><br /></td></tr>
<tr class="separator:a2b76267c6a893785e1fe396e5b439806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a59c70ef42fd731d7167df4973f389"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389">faces</a> () const</td></tr>
<tr class="memdesc:ac4a59c70ef42fd731d7167df4973f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for C++ programmers.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389">More...</a><br /></td></tr>
<tr class="separator:ac4a59c70ef42fd731d7167df4973f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0813f17eb6b6c91802b73403a5258d6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae0813f17eb6b6c91802b73403a5258d6">faces</a> (int subdim) const</td></tr>
<tr class="memdesc:ae0813f17eb6b6c91802b73403a5258d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for Python programmers.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae0813f17eb6b6c91802b73403a5258d6">More...</a><br /></td></tr>
<tr class="separator:ae0813f17eb6b6c91802b73403a5258d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ec5cdb434c3119eb68ce0deae76c8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad44ec5cdb434c3119eb68ce0deae76c8">vertices</a> () const</td></tr>
<tr class="memdesc:ad44ec5cdb434c3119eb68ce0deae76c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;0&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad44ec5cdb434c3119eb68ce0deae76c8">More...</a><br /></td></tr>
<tr class="separator:ad44ec5cdb434c3119eb68ce0deae76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935e2e6267aab03599c1eeacee2dc78"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae935e2e6267aab03599c1eeacee2dc78">edges</a> () const</td></tr>
<tr class="memdesc:ae935e2e6267aab03599c1eeacee2dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;1&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae935e2e6267aab03599c1eeacee2dc78">More...</a><br /></td></tr>
<tr class="separator:ae935e2e6267aab03599c1eeacee2dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#acce900ea2eb29bfac1b9c93ca78f9ea3">triangles</a> () const</td></tr>
<tr class="memdesc:acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 2.  <a href="classregina_1_1detail_1_1TriangulationBase.html#acce900ea2eb29bfac1b9c93ca78f9ea3">More...</a><br /></td></tr>
<tr class="separator:acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff42c3c6b43c59759b08be17d7e269"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a93ff42c3c6b43c59759b08be17d7e269">tetrahedra</a> () const</td></tr>
<tr class="memdesc:a93ff42c3c6b43c59759b08be17d7e269"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 3.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a93ff42c3c6b43c59759b08be17d7e269">More...</a><br /></td></tr>
<tr class="separator:a93ff42c3c6b43c59759b08be17d7e269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c5adb83f7790b90bb1a63ec960a4a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab87c5adb83f7790b90bb1a63ec960a4a">pentachora</a> () const</td></tr>
<tr class="memdesc:ab87c5adb83f7790b90bb1a63ec960a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 4.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ab87c5adb83f7790b90bb1a63ec960a4a">More...</a><br /></td></tr>
<tr class="separator:ab87c5adb83f7790b90bb1a63ec960a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd435c05fdb9ad2ce0229c08965e87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4dd435c05fdb9ad2ce0229c08965e87d">component</a> (size_t index) const</td></tr>
<tr class="memdesc:a4dd435c05fdb9ad2ce0229c08965e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested connected component of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a4dd435c05fdb9ad2ce0229c08965e87d">More...</a><br /></td></tr>
<tr class="separator:a4dd435c05fdb9ad2ce0229c08965e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6eee4278d413b28cc3519ea07d90d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aef6eee4278d413b28cc3519ea07d90d0">boundaryComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:aef6eee4278d413b28cc3519ea07d90d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested boundary component of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aef6eee4278d413b28cc3519ea07d90d0">More...</a><br /></td></tr>
<tr class="separator:aef6eee4278d413b28cc3519ea07d90d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ea1cdd46af32418fb76c49712ccb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8">face</a> (size_t index) const</td></tr>
<tr class="memdesc:a802ea1cdd46af32418fb76c49712ccb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for C++ programmers.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8">More...</a><br /></td></tr>
<tr class="separator:a802ea1cdd46af32418fb76c49712ccb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4df33248af1794170e1ca76cd59256"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4c4df33248af1794170e1ca76cd59256">face</a> (int subdim, size_t index) const</td></tr>
<tr class="memdesc:a4c4df33248af1794170e1ca76cd59256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for Python programmers.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a4c4df33248af1794170e1ca76cd59256">More...</a><br /></td></tr>
<tr class="separator:a4c4df33248af1794170e1ca76cd59256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b86e0d3a00fa5da038c6cce117b343f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9b86e0d3a00fa5da038c6cce117b343f">vertex</a> (size_t index) const</td></tr>
<tr class="memdesc:a9b86e0d3a00fa5da038c6cce117b343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;0&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a9b86e0d3a00fa5da038c6cce117b343f">More...</a><br /></td></tr>
<tr class="separator:a9b86e0d3a00fa5da038c6cce117b343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e675a24773baa6ddca79a6ae7e2899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a25e675a24773baa6ddca79a6ae7e2899">edge</a> (size_t index) const</td></tr>
<tr class="memdesc:a25e675a24773baa6ddca79a6ae7e2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;1&gt;()</a>.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a25e675a24773baa6ddca79a6ae7e2899">More...</a><br /></td></tr>
<tr class="separator:a25e675a24773baa6ddca79a6ae7e2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f98ff3524ca696f47c2d875d6ec22f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af5f98ff3524ca696f47c2d875d6ec22f">triangle</a> (size_t index)</td></tr>
<tr class="memdesc:af5f98ff3524ca696f47c2d875d6ec22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2.  <a href="classregina_1_1detail_1_1TriangulationBase.html#af5f98ff3524ca696f47c2d875d6ec22f">More...</a><br /></td></tr>
<tr class="separator:af5f98ff3524ca696f47c2d875d6ec22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7536b6eef07a72d344053560d06594"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5c7536b6eef07a72d344053560d06594">triangle</a> (size_t index) const</td></tr>
<tr class="memdesc:a5c7536b6eef07a72d344053560d06594"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a5c7536b6eef07a72d344053560d06594">More...</a><br /></td></tr>
<tr class="separator:a5c7536b6eef07a72d344053560d06594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dec07a713f18b9675926a33a7ee544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85dec07a713f18b9675926a33a7ee544">tetrahedron</a> (size_t index)</td></tr>
<tr class="memdesc:a85dec07a713f18b9675926a33a7ee544"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a85dec07a713f18b9675926a33a7ee544">More...</a><br /></td></tr>
<tr class="separator:a85dec07a713f18b9675926a33a7ee544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2272099afa80eff2b1aed22237df0147"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2272099afa80eff2b1aed22237df0147">tetrahedron</a> (size_t index) const</td></tr>
<tr class="memdesc:a2272099afa80eff2b1aed22237df0147"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2272099afa80eff2b1aed22237df0147">More...</a><br /></td></tr>
<tr class="separator:a2272099afa80eff2b1aed22237df0147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523d84b537174c0e660c16fddfe178ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a523d84b537174c0e660c16fddfe178ee">pentachoron</a> (size_t index)</td></tr>
<tr class="memdesc:a523d84b537174c0e660c16fddfe178ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a523d84b537174c0e660c16fddfe178ee">More...</a><br /></td></tr>
<tr class="separator:a523d84b537174c0e660c16fddfe178ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac8b4af8fb72bfe82006ab8997ce0bccd">pentachoron</a> (size_t index) const</td></tr>
<tr class="memdesc:ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ac8b4af8fb72bfe82006ab8997ce0bccd">More...</a><br /></td></tr>
<tr class="separator:ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2a9a1bdc2c2e643c8c424cd31f557207">translate</a> (const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *other) const</td></tr>
<tr class="memdesc:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a face of some other triangulation into the corresponding face of this triangulation, using simplex numbers for the translation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2a9a1bdc2c2e643c8c424cd31f557207">More...</a><br /></td></tr>
<tr class="separator:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839950f320f6f0ca655e7a880a66c2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a839950f320f6f0ca655e7a880a66c2ee">pairing</a> () const</td></tr>
<tr class="memdesc:a839950f320f6f0ca655e7a880a66c2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dual graph of this triangulation, expressed as a facet pairing.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a839950f320f6f0ca655e7a880a66c2ee">More...</a><br /></td></tr>
<tr class="separator:a839950f320f6f0ca655e7a880a66c2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:a6b111a8470576f19f950a2347ff9f3f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6b111a8470576f19f950a2347ff9f3f5">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6b111a8470576f19f950a2347ff9f3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is empty.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a6b111a8470576f19f950a2347ff9f3f5">More...</a><br /></td></tr>
<tr class="separator:a6b111a8470576f19f950a2347ff9f3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cf08805f1b496f644e75c1a0b34dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde">isValid</a> () const</td></tr>
<tr class="memdesc:ab6cf08805f1b496f644e75c1a0b34dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is valid.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde">More...</a><br /></td></tr>
<tr class="separator:ab6cf08805f1b496f644e75c1a0b34dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffca92f7a401c3beb7a603d997a088e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5ffca92f7a401c3beb7a603d997a088e">hasBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a5ffca92f7a401c3beb7a603d997a088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation has any boundary facets.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a5ffca92f7a401c3beb7a603d997a088e">More...</a><br /></td></tr>
<tr class="separator:a5ffca92f7a401c3beb7a603d997a088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a05fe022a95b928a068f9909b036c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8c1a05fe022a95b928a068f9909b036c">countBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a8c1a05fe022a95b928a068f9909b036c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of boundary facets in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a8c1a05fe022a95b928a068f9909b036c">More...</a><br /></td></tr>
<tr class="separator:a8c1a05fe022a95b928a068f9909b036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cea5a70cdc8bf81306e413b69a472c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a38cea5a70cdc8bf81306e413b69a472c">countBoundaryFaces</a> () const</td></tr>
<tr class="memdesc:a38cea5a70cdc8bf81306e413b69a472c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary <em>subdim</em>-faces in this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a38cea5a70cdc8bf81306e413b69a472c">More...</a><br /></td></tr>
<tr class="separator:a38cea5a70cdc8bf81306e413b69a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0734a644b899ff1ff8f58554547452"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7a0734a644b899ff1ff8f58554547452">countBoundaryFaces</a> (int subdim) const</td></tr>
<tr class="memdesc:a7a0734a644b899ff1ff8f58554547452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a7a0734a644b899ff1ff8f58554547452">More...</a><br /></td></tr>
<tr class="separator:a7a0734a644b899ff1ff8f58554547452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223875697502990070b0e7587f63ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6223875697502990070b0e7587f63ce7">isOrientable</a> () const</td></tr>
<tr class="memdesc:a6223875697502990070b0e7587f63ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is orientable.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a6223875697502990070b0e7587f63ce7">More...</a><br /></td></tr>
<tr class="separator:a6223875697502990070b0e7587f63ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576e6c66cfbb7fabd21cc782c38f300d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a576e6c66cfbb7fabd21cc782c38f300d">isConnected</a> () const</td></tr>
<tr class="memdesc:a576e6c66cfbb7fabd21cc782c38f300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is connected.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a576e6c66cfbb7fabd21cc782c38f300d">More...</a><br /></td></tr>
<tr class="separator:a576e6c66cfbb7fabd21cc782c38f300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712e58bba1242110e49b2fac979e98f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab712e58bba1242110e49b2fac979e98f">isOriented</a> () const</td></tr>
<tr class="memdesc:ab712e58bba1242110e49b2fac979e98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ab712e58bba1242110e49b2fac979e98f">More...</a><br /></td></tr>
<tr class="separator:ab712e58bba1242110e49b2fac979e98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8063bd8d3c1ff8d896ae0a24db2203d5">eulerCharTri</a> () const</td></tr>
<tr class="memdesc:a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euler characteristic of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a8063bd8d3c1ff8d896ae0a24db2203d5">More...</a><br /></td></tr>
<tr class="separator:a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Properties</div></td></tr>
<tr class="memitem:a419c0f6e468ad24cfc450775c6a19b81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81">group</a> () const</td></tr>
<tr class="memdesc:a419c0f6e468ad24cfc450775c6a19b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fundamental group of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81">More...</a><br /></td></tr>
<tr class="separator:a419c0f6e468ad24cfc450775c6a19b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408718df2c6cc65f21adabc50850ec63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63">fundamentalGroup</a> () const</td></tr>
<tr class="memdesc:a408718df2c6cc65f21adabc50850ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>, which returns the fundamental group of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63">More...</a><br /></td></tr>
<tr class="separator:a408718df2c6cc65f21adabc50850ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af21977c3e7391562de87c7357bb86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae6af21977c3e7391562de87c7357bb86">simplifiedFundamentalGroup</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> newGroup)</td></tr>
<tr class="memdesc:ae6af21977c3e7391562de87c7357bb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the triangulation that you have simplified the presentation of its fundamental group.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae6af21977c3e7391562de87c7357bb86">More...</a><br /></td></tr>
<tr class="separator:ae6af21977c3e7391562de87c7357bb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a72bfac6207c6ac044d98cd6ec2081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081">homology</a> () const</td></tr>
<tr class="memdesc:a34a72bfac6207c6ac044d98cd6ec2081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081">More...</a><br /></td></tr>
<tr class="separator:a34a72bfac6207c6ac044d98cd6ec2081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb67028a0ade026c03ffdc4665f2871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adbb67028a0ade026c03ffdc4665f2871">homology</a> (int k) const</td></tr>
<tr class="memdesc:adbb67028a0ade026c03ffdc4665f2871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated, where the parameter <em>k</em> does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#adbb67028a0ade026c03ffdc4665f2871">More...</a><br /></td></tr>
<tr class="separator:adbb67028a0ade026c03ffdc4665f2871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6dde5a1cad6b5a763af7ee662eba28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ada6dde5a1cad6b5a763af7ee662eba28">markedHomology</a> () const</td></tr>
<tr class="memdesc:ada6dde5a1cad6b5a763af7ee662eba28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ada6dde5a1cad6b5a763af7ee662eba28">More...</a><br /></td></tr>
<tr class="separator:ada6dde5a1cad6b5a763af7ee662eba28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9273c04a7cf7c89831bce0aa12da15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adb9273c04a7cf7c89831bce0aa12da15">markedHomology</a> (int k) const</td></tr>
<tr class="memdesc:adb9273c04a7cf7c89831bce0aa12da15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation, where the parameter <em>k</em> does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#adb9273c04a7cf7c89831bce0aa12da15">More...</a><br /></td></tr>
<tr class="separator:adb9273c04a7cf7c89831bce0aa12da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfa4594ab1ba473360ff7b91750f49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a">boundaryMap</a> () const</td></tr>
<tr class="memdesc:abdfa4594ab1ba473360ff7b91750f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a">More...</a><br /></td></tr>
<tr class="separator:abdfa4594ab1ba473360ff7b91750f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200793f011759542228bbe3c44f3df85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a200793f011759542228bbe3c44f3df85">boundaryMap</a> (int subdim) const</td></tr>
<tr class="memdesc:a200793f011759542228bbe3c44f3df85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a200793f011759542228bbe3c44f3df85">More...</a><br /></td></tr>
<tr class="separator:a200793f011759542228bbe3c44f3df85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9418f87d687dd5e488b972a5ff7992a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae9418f87d687dd5e488b972a5ff7992a">dualBoundaryMap</a> () const</td></tr>
<tr class="memdesc:ae9418f87d687dd5e488b972a5ff7992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae9418f87d687dd5e488b972a5ff7992a">More...</a><br /></td></tr>
<tr class="separator:ae9418f87d687dd5e488b972a5ff7992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346459be4eb9fbb487340a7d3441e1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a346459be4eb9fbb487340a7d3441e1ef">dualBoundaryMap</a> (int subdim) const</td></tr>
<tr class="memdesc:a346459be4eb9fbb487340a7d3441e1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a346459be4eb9fbb487340a7d3441e1ef">More...</a><br /></td></tr>
<tr class="separator:a346459be4eb9fbb487340a7d3441e1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61a040faab0610d2dbfc515c94abb04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae61a040faab0610d2dbfc515c94abb04">dualToPrimal</a> () const</td></tr>
<tr class="memdesc:ae61a040faab0610d2dbfc515c94abb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from dual chains to primal chains that preserves homology classes.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae61a040faab0610d2dbfc515c94abb04">More...</a><br /></td></tr>
<tr class="separator:ae61a040faab0610d2dbfc515c94abb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2f61c320f8f9da4ea89715f3c2873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaef2f61c320f8f9da4ea89715f3c2873">dualToPrimal</a> (int subdim) const</td></tr>
<tr class="memdesc:aaef2f61c320f8f9da4ea89715f3c2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from dual chains to primal chains that preserves homology classes, where the chain dimension does not need to be known until runtime.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aaef2f61c320f8f9da4ea89715f3c2873">More...</a><br /></td></tr>
<tr class="separator:aaef2f61c320f8f9da4ea89715f3c2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec">orient</a> ()</td></tr>
<tr class="memdesc:a2711fd7c7115ce19b6833f0d61c42bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec">More...</a><br /></td></tr>
<tr class="separator:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5583fe8731e5186eac30bb7dfeafa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3f5583fe8731e5186eac30bb7dfeafa6">reflect</a> ()</td></tr>
<tr class="memdesc:a3f5583fe8731e5186eac30bb7dfeafa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a3f5583fe8731e5186eac30bb7dfeafa6">More...</a><br /></td></tr>
<tr class="separator:a3f5583fe8731e5186eac30bb7dfeafa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dc5df8252f6e34ea45b19ca33c3964"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a39dc5df8252f6e34ea45b19ca33c3964">pachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a39dc5df8252f6e34ea45b19ca33c3964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a39dc5df8252f6e34ea45b19ca33c3964">More...</a><br /></td></tr>
<tr class="separator:a39dc5df8252f6e34ea45b19ca33c3964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions, Extensions and Covers</div></td></tr>
<tr class="memitem:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae061e36e8ecbfa2f1edc36ed9eb99a51">makeDoubleCover</a> ()</td></tr>
<tr class="memdesc:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this triangulation into its double cover.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ae061e36e8ecbfa2f1edc36ed9eb99a51">More...</a><br /></td></tr>
<tr class="separator:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7139822eb449840c13dbcc304f8491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491">subdivide</a> ()</td></tr>
<tr class="memdesc:a0e7139822eb449840c13dbcc304f8491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a barycentric subdivision of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491">More...</a><br /></td></tr>
<tr class="separator:a0e7139822eb449840c13dbcc304f8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13345c67f4c82d9976863c8c5372db5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a13345c67f4c82d9976863c8c5372db5b">barycentricSubdivision</a> ()</td></tr>
<tr class="memdesc:a13345c67f4c82d9976863c8c5372db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that performs a barycentric subdivision of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a13345c67f4c82d9976863c8c5372db5b">More...</a><br /></td></tr>
<tr class="separator:a13345c67f4c82d9976863c8c5372db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25a58b48e39f3c7f8621b84432d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adc25a58b48e39f3c7f8621b84432d294">finiteToIdeal</a> ()</td></tr>
<tr class="memdesc:adc25a58b48e39f3c7f8621b84432d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each real boundary component into a cusp (i.e., an ideal vertex).  <a href="classregina_1_1detail_1_1TriangulationBase.html#adc25a58b48e39f3c7f8621b84432d294">More...</a><br /></td></tr>
<tr class="separator:adc25a58b48e39f3c7f8621b84432d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompositions</div></td></tr>
<tr class="memitem:a8c9bc864e2b45447e3fcc92f99d3840e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8c9bc864e2b45447e3fcc92f99d3840e">triangulateComponents</a> () const</td></tr>
<tr class="memdesc:a8c9bc864e2b45447e3fcc92f99d3840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the individual connected components of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a8c9bc864e2b45447e3fcc92f99d3840e">More...</a><br /></td></tr>
<tr class="separator:a8c9bc864e2b45447e3fcc92f99d3840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphism Testing</div></td></tr>
<tr class="memitem:a597cf2c4f78312124b2ec637173eb29e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a597cf2c4f78312124b2ec637173eb29e">operator==</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a597cf2c4f78312124b2ec637173eb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially identical to the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a597cf2c4f78312124b2ec637173eb29e">More...</a><br /></td></tr>
<tr class="separator:a597cf2c4f78312124b2ec637173eb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d460f2fae401327eed5fd915ead79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a931d460f2fae401327eed5fd915ead79">operator!=</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a931d460f2fae401327eed5fd915ead79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is not combinatorially identical to the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a931d460f2fae401327eed5fd915ead79">More...</a><br /></td></tr>
<tr class="separator:a931d460f2fae401327eed5fd915ead79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568895b8abeb672289fcee779ebf01a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac568895b8abeb672289fcee779ebf01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially isomorphic to the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a">More...</a><br /></td></tr>
<tr class="separator:ac568895b8abeb672289fcee779ebf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e42b826a392816a796e0e15f85ded"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a868e42b826a392816a796e0e15f85ded">isContainedIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a868e42b826a392816a796e0e15f85ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="classregina_1_1detail_1_1TriangulationBase.html#a868e42b826a392816a796e0e15f85ded">More...</a><br /></td></tr>
<tr class="separator:a868e42b826a392816a796e0e15f85ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0481813042dab2c6140fc8d6fbbd189d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0481813042dab2c6140fc8d6fbbd189d">findAllIsomorphisms</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a0481813042dab2c6140fc8d6fbbd189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a0481813042dab2c6140fc8d6fbbd189d">More...</a><br /></td></tr>
<tr class="separator:a0481813042dab2c6140fc8d6fbbd189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea60c854787cc26a39618dcdf2196b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac3ea60c854787cc26a39618dcdf2196b">findAllSubcomplexesIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ac3ea60c854787cc26a39618dcdf2196b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="classregina_1_1detail_1_1TriangulationBase.html#ac3ea60c854787cc26a39618dcdf2196b">More...</a><br /></td></tr>
<tr class="separator:ac3ea60c854787cc26a39618dcdf2196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe58df75da67242635ddcea5398d1b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abe58df75da67242635ddcea5398d1b77">makeCanonical</a> ()</td></tr>
<tr class="memdesc:abe58df75da67242635ddcea5398d1b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form.  <a href="classregina_1_1detail_1_1TriangulationBase.html#abe58df75da67242635ddcea5398d1b77">More...</a><br /></td></tr>
<tr class="separator:abe58df75da67242635ddcea5398d1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Building Triangulations</div></td></tr>
<tr class="memitem:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2bf93dbca6715c1a455a2d47f66a6476">insertTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a2bf93dbca6715c1a455a2d47f66a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given triangulation into this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a2bf93dbca6715c1a455a2d47f66a6476">More...</a><br /></td></tr>
<tr class="separator:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Triangulations</div></td></tr>
<tr class="memitem:a3133ab83d943df1dd216dc2fbde58c6c"><td class="memItemLeft" align="right" valign="top">Encoding::Signature&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c">isoSig</a> () const</td></tr>
<tr class="memdesc:a3133ab83d943df1dd216dc2fbde58c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature of the given type for this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c">More...</a><br /></td></tr>
<tr class="separator:a3133ab83d943df1dd216dc2fbde58c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3939293964c4646c7f60cacd94c52"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Encoding::Signature, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a47a3939293964c4646c7f60cacd94c52">isoSigDetail</a> () const</td></tr>
<tr class="memdesc:a47a3939293964c4646c7f60cacd94c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature for this triangulation, along with the relabelling that will occur when the triangulation is reconstructed from it.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a47a3939293964c4646c7f60cacd94c52">More...</a><br /></td></tr>
<tr class="separator:a47a3939293964c4646c7f60cacd94c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393121abbf7a159a21ffca9deb9fb824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a393121abbf7a159a21ffca9deb9fb824">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a393121abbf7a159a21ffca9deb9fb824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this triangulation to the given output stream.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a393121abbf7a159a21ffca9deb9fb824">More...</a><br /></td></tr>
<tr class="separator:a393121abbf7a159a21ffca9deb9fb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ace7c9ec1168ef9e7cb34b3e4a5b9b873">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C++ code that can be used to reconstruct this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ace7c9ec1168ef9e7cb34b3e4a5b9b873">More...</a><br /></td></tr>
<tr class="separator:ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <a href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">More...</a><br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SnapPea kernel messages</div></td></tr>
<tr class="memitem:a57466689aa69193ce70a026c84a43969"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a57466689aa69193ce70a026c84a43969">kernelMessagesEnabled</a> ()</td></tr>
<tr class="memdesc:a57466689aa69193ce70a026c84a43969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the SnapPea kernel writes diagnostic messages to standard output.  <a href="classregina_1_1SnapPeaTriangulation.html#a57466689aa69193ce70a026c84a43969">More...</a><br /></td></tr>
<tr class="separator:a57466689aa69193ce70a026c84a43969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c42217fc152e7f22c7ea1717954a6db"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9c42217fc152e7f22c7ea1717954a6db">enableKernelMessages</a> (bool enabled=true)</td></tr>
<tr class="memdesc:a9c42217fc152e7f22c7ea1717954a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures whether or not the SnapPea kernel should write diagnostic messages to standard output.  <a href="classregina_1_1SnapPeaTriangulation.html#a9c42217fc152e7f22c7ea1717954a6db">More...</a><br /></td></tr>
<tr class="separator:a9c42217fc152e7f22c7ea1717954a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978beab0e6350c4a455ac4bc48e2a369"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a978beab0e6350c4a455ac4bc48e2a369">disableKernelMessages</a> ()</td></tr>
<tr class="memdesc:a978beab0e6350c4a455ac4bc48e2a369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the SnapPea kernel should not write diagnostic messages to standard output.  <a href="classregina_1_1SnapPeaTriangulation.html#a978beab0e6350c4a455ac4bc48e2a369">More...</a><br /></td></tr>
<tr class="separator:a978beab0e6350c4a455ac4bc48e2a369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Importing Triangulations</div></td></tr>
<tr class="memitem:a9e37617ce0bdb569f260dd44c7745844"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9e37617ce0bdb569f260dd44c7745844">rehydrate</a> (const std::string &amp;dehydration)</td></tr>
<tr class="memdesc:a9e37617ce0bdb569f260dd44c7745844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehydrates the given alphabetical string into a 3-dimensional triangulation.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a9e37617ce0bdb569f260dd44c7745844">More...</a><br /></td></tr>
<tr class="separator:a9e37617ce0bdb569f260dd44c7745844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfbd0b4f36b096210d77a56526d7024"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8bfbd0b4f36b096210d77a56526d7024">fromSnapPea</a> (const std::string &amp;snapPeaData)</td></tr>
<tr class="memdesc:a8bfbd0b4f36b096210d77a56526d7024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file.  <a href="classregina_1_1Triangulation_3_013_01_4.html#a8bfbd0b4f36b096210d77a56526d7024">More...</a><br /></td></tr>
<tr class="separator:a8bfbd0b4f36b096210d77a56526d7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa177dda3276927267a3ae0130765a6f1"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa177dda3276927267a3ae0130765a6f1">dimension</a></td></tr>
<tr class="memdesc:aa177dda3276927267a3ae0130765a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aa177dda3276927267a3ae0130765a6f1">More...</a><br /></td></tr>
<tr class="separator:aa177dda3276927267a3ae0130765a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a111c0d2dfaba45d86517ba04bb7aa019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#a111c0d2dfaba45d86517ba04bb7aa019">swap</a> (<a class="el" href="classregina_1_1Snapshottable.html">Snapshottable</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a111c0d2dfaba45d86517ba04bb7aa019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation.  <a href="classregina_1_1Snapshottable.html#a111c0d2dfaba45d86517ba04bb7aa019">More...</a><br /></td></tr>
<tr class="separator:a111c0d2dfaba45d86517ba04bb7aa019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e625e918d497e1a006bc13b64a1d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f">takeSnapshot</a> ()</td></tr>
<tr class="memdesc:ac7e625e918d497e1a006bc13b64a1d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called before modification and/or destruction of the type <em>T</em> contents.  <a href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f">More...</a><br /></td></tr>
<tr class="separator:ac7e625e918d497e1a006bc13b64a1d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1739e33bdbb5c52cb77de81ec93c1ec8">simplices_</a></td></tr>
<tr class="memdesc:a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-dimensional simplices that form the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a1739e33bdbb5c52cb77de81ec93c1ec8">More...</a><br /></td></tr>
<tr class="separator:a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e46682d3ce5b05f7e693f863018f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa6e46682d3ce5b05f7e693f863018f66">boundaryComponents_</a></td></tr>
<tr class="memdesc:aa6e46682d3ce5b05f7e693f863018f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The components that form the boundary of the triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aa6e46682d3ce5b05f7e693f863018f66">More...</a><br /></td></tr>
<tr class="separator:aa6e46682d3ce5b05f7e693f863018f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db8e55f59788fbb27cb5a15c44f127a"><td class="memItemLeft" align="right" valign="top">std::array&lt; size_t, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1db8e55f59788fbb27cb5a15c44f127a">nBoundaryFaces_</a></td></tr>
<tr class="memdesc:a1db8e55f59788fbb27cb5a15c44f127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary faces of each dimension.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a1db8e55f59788fbb27cb5a15c44f127a">More...</a><br /></td></tr>
<tr class="separator:a1db8e55f59788fbb27cb5a15c44f127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a106dc9d8ffc9e2bd1dd35ad35d52773c">valid_</a></td></tr>
<tr class="memdesc:a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this triangulation valid? See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a106dc9d8ffc9e2bd1dd35ad35d52773c">More...</a><br /></td></tr>
<tr class="separator:a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449383159ee760c127c30e39ac22467f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a449383159ee760c127c30e39ac22467f">topologyLock_</a></td></tr>
<tr class="memdesc:a449383159ee760c127c30e39ac22467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If non-zero, this will cause Triangulation&lt;dim&gt;::clearAllProperties() to preserve any computed properties that related to the manifold (as opposed to the specific triangulation).  <a href="classregina_1_1detail_1_1TriangulationBase.html#a449383159ee760c127c30e39ac22467f">More...</a><br /></td></tr>
<tr class="separator:a449383159ee760c127c30e39ac22467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Administration</h2></td></tr>
<tr class="memitem:a1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="a1d0602a6c116c8988a3ad360752661e9" name="a1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:a1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed9e9f725af5a1be122745c83852632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7ed9e9f725af5a1be122745c83852632">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a7ed9e9f725af5a1be122745c83852632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1SnapPeaTriangulation.html#a7ed9e9f725af5a1be122745c83852632">More...</a><br /></td></tr>
<tr class="separator:a7ed9e9f725af5a1be122745c83852632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0cea08290f51551c72f17f432cb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7a0cea08290f51551c72f17f432cb8b0">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a7a0cea08290f51551c72f17f432cb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1SnapPeaTriangulation.html#a7a0cea08290f51551c72f17f432cb8b0">More...</a><br /></td></tr>
<tr class="separator:a7a0cea08290f51551c72f17f432cb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Importing Triangulations</h2></td></tr>
<tr class="memitem:ad91567ffbe224dcd1f1da3cb273efe49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49">fromGluings</a> (size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5">size</a>, std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &gt; &gt; gluings)</td></tr>
<tr class="memdesc:ad91567ffbe224dcd1f1da3cb273efe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a triangulation from a hard-coded list of gluings.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49">More...</a><br /></td></tr>
<tr class="separator:ad91567ffbe224dcd1f1da3cb273efe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af25408f7eb0b1c5bc3a87b1e93e7d0d2">fromGluings</a> (size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5">size</a>, Iterator beginGluings, Iterator endGluings)</td></tr>
<tr class="memdesc:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a triangulation from a list of gluings.  <a href="classregina_1_1detail_1_1TriangulationBase.html#af25408f7eb0b1c5bc3a87b1e93e7d0d2">More...</a><br /></td></tr>
<tr class="separator:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91da7bdae05981c20c2e3ee234cc48d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d">fromIsoSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:af91da7bdae05981c20c2e3ee234cc48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a full triangulation from an isomorphism signature.  <a href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d">More...</a><br /></td></tr>
<tr class="separator:af91da7bdae05981c20c2e3ee234cc48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776984602dd80817c160e797aeca67c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a776984602dd80817c160e797aeca67c3">fromSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:a776984602dd80817c160e797aeca67c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, to recover a full triangulation from an isomorphism signature.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a776984602dd80817c160e797aeca67c3">More...</a><br /></td></tr>
<tr class="separator:a776984602dd80817c160e797aeca67c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0eedc0b1fc037af0d9c6c23c32d79f2b">isoSigComponentSize</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a0eedc0b1fc037af0d9c6c23c32d79f2b">More...</a><br /></td></tr>
<tr class="separator:a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e807b7e562aeafd28ca506bd78f7b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a93e807b7e562aeafd28ca506bd78f7b4">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a93e807b7e562aeafd28ca506bd78f7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a triangulation from its given tight encoding.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a93e807b7e562aeafd28ca506bd78f7b4">More...</a><br /></td></tr>
<tr class="separator:a93e807b7e562aeafd28ca506bd78f7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa87b9f9c40a48cee3a1ee9c71bd70fef">ensureSkeleton</a> () const</td></tr>
<tr class="memdesc:aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all "on demand" skeletal objects have been calculated.  <a href="classregina_1_1detail_1_1TriangulationBase.html#aa87b9f9c40a48cee3a1ee9c71bd70fef">More...</a><br /></td></tr>
<tr class="separator:aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eccc799a49667455b78f790f258098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a99eccc799a49667455b78f790f258098">calculatedSkeleton</a> () const</td></tr>
<tr class="memdesc:a99eccc799a49667455b78f790f258098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the skeletal objects and properties of this triangulation have been calculated.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a99eccc799a49667455b78f790f258098">More...</a><br /></td></tr>
<tr class="separator:a99eccc799a49667455b78f790f258098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571569a34bb4173bd5eb6b521ff503cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a571569a34bb4173bd5eb6b521ff503cb">clearBaseProperties</a> ()</td></tr>
<tr class="memdesc:a571569a34bb4173bd5eb6b521ff503cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all properties that are managed by this base class.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a571569a34bb4173bd5eb6b521ff503cb">More...</a><br /></td></tr>
<tr class="separator:a571569a34bb4173bd5eb6b521ff503cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16509c98bc3e4b38f673aff15337f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8b16509c98bc3e4b38f673aff15337f5">swapBaseData</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">TriangulationBase</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:a8b16509c98bc3e4b38f673aff15337f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all data that is managed by this base class, including simplices, skeletal data, cached properties and the snapshotting data, with the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#a8b16509c98bc3e4b38f673aff15337f5">More...</a><br /></td></tr>
<tr class="separator:a8b16509c98bc3e4b38f673aff15337f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad1d1a2ca27fd966c3c7403f0a1c6080d">writeXMLBaseProperties</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing properties of this triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase.html#ad1d1a2ca27fd966c3c7403f0a1c6080d">More...</a><br /></td></tr>
<tr class="separator:ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Offers direct access to the SnapPea kernel from within Regina. </p>
<p >An object of this class represents a 3-manifold triangulation, stored directly in the SnapPea kernel using SnapPea's internal format.</p>
<p >Regarding interaction with the SnapPea kernel:</p>
<ul>
<li>This class acts as the <b>sole C/C++ conduit</b> between the Regina calculation engine and Regina's inbuilt version of the SnapPea kernel. Regina should not interact with the SnapPea kernel at the C/C++ level other than through this class.</li>
<li>Regina can, however, interact with SnapPy at the Python level. Regina's version of the SnapPea kernel lives within a separate namespace (regina::snappea), and so there should be no conflicts between Regina's copy and SnapPy's copy of the SnapPea kernel (which may even be different versions). You can pass triangulations back and forth between Regina and SnapPy using strings that contain the contents of a SnapPea data file (see for instance <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a72bf21c353d9a6908fb2ad1cceeef899" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">SnapPeaTriangulation::snapPea()</a>).</li>
</ul>
<p >Regarding the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface:</p>
<ul>
<li>You can happily query this object using both SnapPea functions (such as <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a757ff5bfcc94c9e3a1c17a6c464a62ca" title="Computes the volume of the current solution to the hyperbolic gluing equations.">SnapPeaTriangulation::volume()</a>, and others specific to this class) and Regina's native triangulation functions (such as <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">Triangulation&lt;3&gt;::homology()</a>, and others inherited from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>). This is because an object of this class stores <em>two</em> representations of the triangulation (SnapPea's and Regina's), which are always kept in sync.</li>
<li>However, you may <b>only edit this object using the SnapPea functions specific to this class</b> (such as <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4" title="Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology.">SnapPeaTriangulation::randomise()</a>). This is essentially because the synchronisation is one-way only (from SnapPea to Regina, but not in the other direction).</li>
<li>Any attempt to edit this triangulation via the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface (for instance, by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">Triangulation&lt;3&gt;::pachner()</a>) will automatically cause this to become a <b>null triangulation</b>, with no tetrahedra and no SnapPea data at all.</li>
<li>In particular, if you wish to assign one SnapPea triangulation to another, or swap the contents of two SnapPea triangulations, then you <em>must</em> cast both objects to <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> before performing the operation. If either argument is presented as the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> then the inherited operation on <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> will be called instead, which will (as above) nullify one or both SnapPea triangulations respectively.</li>
</ul>
<p >Null triangulations appear more generally when Regina is unable to represent data in SnapPea's native format. You can test for a null triangulation by calling <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab6c7b296f9e7ba7599f0343bfeca3c4a" title="Determines whether this triangulation contains valid SnapPea data.">isNull()</a>. Null triangulations can occur for several reasons, such as (but not limited to):</p>
<ul>
<li>attempting to build a SnapPea triangulation from a Regina triangulation that is invalid, has boundary faces, or has higher genus vertex links (none of which SnapPea can handle);</li>
<li>attempting to read a broken SnapPea data file;</li>
<li>attempting to change a SnapPea triangulation using the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface (as discussed above);</li>
<li>attempting to import a SnapPea triangulation that uses unsupported (e.g., non-integer or non-coprime) filling coefficients, as discussed below).</li>
</ul>
<p >Regarding fillings: SnapPea can store and manipulate Dehn fillings on cusps, and the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class respects these where it can (but with restrictions on the possible filling coefficients; see below). However, Regina's own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class knows nothing about fillings at all. Therefore:</p>
<ul>
<li>Routines inherited through the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface will ignore fillings completely (so, for instance, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a> will return the first homology of the unfilled manifold, even if SnapPea has designated fillings on the cusps).</li>
<li>Routines that are defined here in the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class are generally aware of fillings (so, for instance, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">homologyFilled()</a> will return the first homology of the filled manifold). See the individual notes for each member function for details on how it handles fillings.</li>
<li>In particular, if you are testing two triangulations for equality: if either triangulation is presented as the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> then you will be calling the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> comparision operators, which <em>only</em> compare the tetrahedron labelling and gluings. If you wish to compare cusps and fillings as well, you must ensure that both triangulations are cast to <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> (in which case the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> comparison operators will be used).</li>
</ul>
<p >For now, <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> only supports the following types of filling coefficients: on orientable cusps the filling coefficients must be coprime integers, and non non-orientable cusps the filling coefficients must be the integers (±1, 0). Any attempt to import a triangulation from a SnapPea file with filling coefficients outside these requirements will result in a null triangulation (as discussed above).</p>
<p >There are many places in the SnapPea kernel where SnapPea throws a fatal error. These fatal errors are converted into exceptions (in particular, <a class="el" href="classregina_1_1SnapPeaFatalError.html" title="An exception that is thrown when the SnapPea kernel encounters a fatal error.">SnapPeaFatalError</a> and <a class="el" href="classregina_1_1SnapPeaMemoryFull.html" title="An exception that is thrown when the SnapPea kernel finds that all available memory has been exhauste...">SnapPeaMemoryFull</a>), which can be caught and handled politely. You should assume, unless you have good reason to believe otherwise (e.g., you have read and traced through the SnapPea source code), that any member function of this class that uses the SnapPea kernel could throw either of these exceptions.</p>
<p >Regina uses the variant of the SnapPea kernel that is shipped with SnapPy (standard precision), as well as some additional code written explicitly for SnapPy. The header regina-config.h includes a macro SNAPPY_VERSION that gives the exact version of SnapPy that is bundled into Regina, and you can query this at runtime by calling Regina's function <a class="el" href="group__engine.html#gac7ecbe807b064aa9a99877faaee478dd" title="Returns the version of SnapPy whose underlying SnapPea kernel is built into Regina.">regina::versionSnapPy()</a>.</p>
<p >Since Regina 7.0, <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> is no longer a "packet type" that can be inserted directly into the packet tree. Instead a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> in the packet tree, you must create a new PacketOf&lt;SnapPeaTriangulation&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, and so inherits the full <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> interface.</li>
<li>If you are adding new functions to this class that edit the triangulation, you must still remember to create a ChangeEventSpan. This will ensure that, if the triangulation is being managed by a PacketOf&lt;SnapPeaTriangulation&gt;, then the appropriate packet change events will be fired. All other events (aside from packetToBeChanged() and packetWasChanged() are managed directly by the PacketOf&lt;SnapPeaTriangulation&gt; wrapper class.</li>
</ul>
<p >Regarding the packet interface, there is currently a deficiency when listening for change events on a PacketOf&lt;SnapPeaTriangulation&gt;:</p>
<ul>
<li>As described above, if you edit the triangulation using the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface, this will nullify the SnapPea triangulation.</li>
<li>As expected, this will fire a pair of change events. However, the packetToBeChanged() event will be fired too late: specifically, it will be fired <em>after</em> the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> change is made but <em>before</em> the SnapPea triangulation is nullifed. In particular, it will already be too late to take a copy of the original SnapPea triangulation.</li>
<li>Since fixing this will require non-trivial re-engineering of the code, and since users should not be modifying SnapPea triangulations via the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface, this deficiency is being left to stay for the time being.</li>
</ul>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<p >The SnapPea kernel was originally written by Jeff Weeks. SnapPy, where this kernel is now maintained, is primarily developed by Marc Culler, Nathan Dunfield and Matthias Goerner, with contributions from many people. SnapPy and the corresponding SnapPea kernel are distributed under the terms of the GNU General Public License, version 2 or any later version, as published by the Free Software Foundation.</p>
<p >See <a href="http://snappy.computop.org/">http://snappy.computop.org/</a> for further information on SnapPea and its successor SnapPy.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaFatalError.html" title="An exception that is thrown when the SnapPea kernel encounters a fatal error.">SnapPeaFatalError</a></td><td>The SnapPea kernel detected a fatal error from which it could not recover. This could be thrown by any member function that uses the SnapPea kernel.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaMemoryFull.html" title="An exception that is thrown when the SnapPea kernel finds that all available memory has been exhauste...">SnapPeaMemoryFull</a></td><td>The SnapPea kernel ran out of memory. This could be thrown by any member function that uses the SnapPea kernel. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a75395b2e289bf58155f6b1f94b47530a" name="a75395b2e289bf58155f6b1f94b47530a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75395b2e289bf58155f6b1f94b47530a">&#9670;&nbsp;</a></span>TuraevViroSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::TuraevViroSet =  std::map&lt;std::pair&lt;unsigned long, bool&gt;, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from (<em>r</em>, <em>parity</em>) pairs to Turaev-Viro invariants, as described by <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af493515e72e2059b4c23986d0cde0d87" name="af493515e72e2059b4c23986d0cde0d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af493515e72e2059b4c23986d0cde0d87">&#9670;&nbsp;</a></span>CoverEnumerationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87">regina::SnapPeaTriangulation::CoverEnumerationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which types of covers should be enumerated when calling <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a>. </p>
<p >This enumeration is identical to SnapPea's PermutationSubgroup enum, though the values here are named differently. The enumeration is declared again here because Regina code should not in general interact directly with the SnapPea kernel. Values may be freely converted between the two enumeration types by simple assignment and/or typecasting.</p>
<dl class="section warning"><dt>Warning</dt><dd>This enumeration must always be kept in sync with SnapPea's PermutationSubgroup enumeration. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af493515e72e2059b4c23986d0cde0d87afff8f198c433dc62952637db8b353ad0" name="af493515e72e2059b4c23986d0cde0d87afff8f198c433dc62952637db8b353ad0"></a>cyclic_covers&#160;</td><td class="fielddoc"><p >Indicates that only cyclic covers should be enumerated. </p>
<p >This corresponds to the SnapPea constant <em>permutation_subgroup_Zn</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af493515e72e2059b4c23986d0cde0d87a8f127a000f33b941e12eaf8a73dfeeac" name="af493515e72e2059b4c23986d0cde0d87a8f127a000f33b941e12eaf8a73dfeeac"></a>all_covers&#160;</td><td class="fielddoc"><p >Indicates that all covers should be enumerated. </p>
<p >This corresponds to the SnapPea constant <em>permutation_subgroup_Sn</em>. </p>
</td></tr>
</table>

</div>
</div>
<a id="abd2e873e96003ef01494e95f44962dda" name="abd2e873e96003ef01494e95f44962dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2e873e96003ef01494e95f44962dda">&#9670;&nbsp;</a></span>CoverType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda">regina::SnapPeaTriangulation::CoverType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the different types of covers that can be produced by <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a>. </p>
<p >This enumeration is identical to SnapPea's own CoveringType enum; it is declared again here because Regina code should not in general interact directly with the SnapPea kernel. Values may be freely converted between the two enumeration types by simple assignment and/or typecasting.</p>
<dl class="section warning"><dt>Warning</dt><dd>This enumeration must always be kept in sync with SnapPea's own CoveringType enumeration. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd2e873e96003ef01494e95f44962ddaa6bf8aa4dab7dd6d45be7fc164a23c98f" name="abd2e873e96003ef01494e95f44962ddaa6bf8aa4dab7dd6d45be7fc164a23c98f"></a>unknown_cover&#160;</td><td class="fielddoc"><p >Indicates that SnapPea has not yet computed the covering type. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2e873e96003ef01494e95f44962ddaae5abb9c1c82e9855790f6c6e59c5dfdb" name="abd2e873e96003ef01494e95f44962ddaae5abb9c1c82e9855790f6c6e59c5dfdb"></a>irregular_cover&#160;</td><td class="fielddoc"><p >Indicates a covering where there exist two lifts of a point in the base manifold with no covering transformation that takes one to the other. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2e873e96003ef01494e95f44962ddaa97d807390bce8c0d947779401058708d" name="abd2e873e96003ef01494e95f44962ddaa97d807390bce8c0d947779401058708d"></a>regular_cover&#160;</td><td class="fielddoc"><p >Indicates a covering that is not cyclic, and where for any two lifts of a point in the base manfiold, there is a covering transformation taking one to the other. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2e873e96003ef01494e95f44962ddaa89b9a3dc02fd1b66f09d4b5eeb69a4c3" name="abd2e873e96003ef01494e95f44962ddaa89b9a3dc02fd1b66f09d4b5eeb69a4c3"></a>cyclic_cover&#160;</td><td class="fielddoc"><p >Indicates a cyclic covering. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9fb06be1a5084ff01ac6a96de0050770" name="a9fb06be1a5084ff01ac6a96de0050770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb06be1a5084ff01ac6a96de0050770">&#9670;&nbsp;</a></span>SolutionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770">regina::SnapPeaTriangulation::SolutionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the different types of solution that can be found when solving for a hyperbolic structure. </p>
<p >This enumeration is identical to SnapPea's own SolutionType enum; it is declared again here because Regina code should not in general interact directly with the SnapPea kernel. Values may be freely converted between the two enumeration types by simple assignment and/or typecasting.</p>
<dl class="section warning"><dt>Warning</dt><dd>This enumeration must always be kept in sync with SnapPea's own SolutionType enumeration. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770a835f52eddacbc3b1f8316c97d2288430" name="a9fb06be1a5084ff01ac6a96de0050770a835f52eddacbc3b1f8316c97d2288430"></a>not_attempted&#160;</td><td class="fielddoc"><p >A solution has not been attempted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770a797f18a2bd313e031389ee991b3b095d" name="a9fb06be1a5084ff01ac6a96de0050770a797f18a2bd313e031389ee991b3b095d"></a>geometric_solution&#160;</td><td class="fielddoc"><p >All tetrahedra are positively oriented. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770a56e29f22d00dbe72de8afd5427a59d49" name="a9fb06be1a5084ff01ac6a96de0050770a56e29f22d00dbe72de8afd5427a59d49"></a>nongeometric_solution&#160;</td><td class="fielddoc"><p >The overall volume is positive, but some tetrahedra are flat or negatively oriented. </p>
<p >No tetrahedra have shape 0, 1 or infinity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770adf6bd950be5e16cedc23bcc0df6e7f41" name="a9fb06be1a5084ff01ac6a96de0050770adf6bd950be5e16cedc23bcc0df6e7f41"></a>flat_solution&#160;</td><td class="fielddoc"><p >All tetrahedra are flat, but none have shape 0, 1 or infinity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770a817953dfa6d08754a863760d16519a00" name="a9fb06be1a5084ff01ac6a96de0050770a817953dfa6d08754a863760d16519a00"></a>degenerate_solution&#160;</td><td class="fielddoc"><p >At least one tetrahedron has shape 0, 1 or infinity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770a18c7358f04fa8024f22855f759a36f6b" name="a9fb06be1a5084ff01ac6a96de0050770a18c7358f04fa8024f22855f759a36f6b"></a>other_solution&#160;</td><td class="fielddoc"><p >The volume is zero or negative, but the solution is neither flat nor degenerate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770af4a6f61e1b36942029af652d1b9b1cbe" name="a9fb06be1a5084ff01ac6a96de0050770af4a6f61e1b36942029af652d1b9b1cbe"></a>no_solution&#160;</td><td class="fielddoc"><p >The gluing equations could not be solved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fb06be1a5084ff01ac6a96de0050770ab48f2469d5cb22bd61f6471aaeade1fe" name="a9fb06be1a5084ff01ac6a96de0050770ab48f2469d5cb22bd61f6471aaeade1fe"></a>externally_computed&#160;</td><td class="fielddoc"><p >Tetrahedron shapes were inserted into the triangulation. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5047642ef20743096e6795ba23d58c03" name="a5047642ef20743096e6795ba23d58c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5047642ef20743096e6795ba23d58c03">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a null triangulation, with no internal SnapPea data at all. </p>

</div>
</div>
<a id="ae7ced0a54008d83752b3009c8efd5b2b" name="ae7ced0a54008d83752b3009c8efd5b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ced0a54008d83752b3009c8efd5b2b">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileNameOrContents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new SnapPea triangulation from the contents of SnapPea data file. </p>
<p >The argument may be the <em>name</em> of a SnapPea file, or it may also be the <em>contents</em> of a SnapPea file (so the file itself need not actually exist on the filesystem).</p>
<p >This routine uses the SnapPea kernel to read the data file, and so all SnapPea-specific information will be preserved (including information that Regina itself does not store, such as peripheral curves).</p>
<p >If this operation fails (e.g., if the given string does not represent a valid SnapPea data file), then this routine will thrown an exception; see below for details.</p>
<p >If this routine returns (as opposed to throwing an exception), then it is guaranteed that this is not a null SnapPea triangulation. In this successful scenario, this constructor will ask SnapPea to try to find a hyperbolic structure before it returns.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor can be used in a Python session to pass data from SnapPy through to Regina's copy of the SnapPea kernel (which is strictly separate from SnapPy's), without losing any of SnapPy's internal information.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If (for some reason) you pass a filename that begins with "% Triangulation", then Regina will interpret this as the contents of a SnapPea file (not a filename).</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>If the given argument is a filename, then this routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the filename, and simply passes it through unchanged to low-level C/C++ file I/O routines. This routine assumes that the file <em>contents</em>, however, are in UTF-8 (the standard encoding used throughout Regina).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>The SnapPea kernel could not read the given file, or could not parse the file contents (which could have been passed explicitly or could have been read from file).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileNameOrContents</td><td>either the name of a SnapPea data file, or the contents of a SnapPea data file (which need not actually exist on the filesystem). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e3b5e06d4b977325a32d7d6f8e216a3" name="a9e3b5e06d4b977325a32d7d6f8e216a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3b5e06d4b977325a32d7d6f8e216a3">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given SnapPea triangulation. </p>
<p >If <em>src</em> is a null triangulation then this will be a null triangulation also. See <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab6c7b296f9e7ba7599f0343bfeca3c4a" title="Determines whether this triangulation contains valid SnapPea data.">isNull()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the SnapPea triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a996f4edda1c14e3f6117cfab5d147738" name="a996f4edda1c14e3f6117cfab5d147738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996f4edda1c14e3f6117cfab5d147738">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given SnapPea triangulation into this new triangulation. </p>
<p >This is much faster than the copy constructor, but is still linear time. This is because every tetrahedron must be adjusted to point back to this new triangulation instead of <em>src</em>.</p>
<p >All tetrahedra, cusps and skeletal objects (faces, components and boundary components) that belong to <em>src</em> will be moved into this triangulation, and so any pointers or references to Tetrahedron&lt;3&gt;, <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a>, Face&lt;3, subdim&gt;, <a class="el" href="classregina_1_1Component_3_013_01_4.html" title="Represents a connected component of a 3-manifold triangulation.">Component&lt;3&gt;</a> or BoundaryComponent&lt;3&gt; objects will remain valid. Likewise, all cached properties will be moved into this triangulation.</p>
<p >The triangulation that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this triangulation is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4c2d636af7f2e3f341f451a6990479" name="a7f4c2d636af7f2e3f341f451a6990479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4c2d636af7f2e3f341f451a6990479">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignored</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given Regina triangulation to a SnapPea triangulation. </p>
<p >This copy will be independent (i.e., this triangulation will not be affected if <em>tri</em> is later changed or destroyed).</p>
<p >Since Regina works with more general kinds of trianguations than SnapPea, not all Regina triangulations can be represented in SnapPea format. If the conversion is unsuccessful, this will be marked as a null triangulation. You should always test <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab6c7b296f9e7ba7599f0343bfeca3c4a" title="Determines whether this triangulation contains valid SnapPea data.">isNull()</a> to determine whether the conversion was successful.</p>
<p >Regarding the conversion:</p>
<ul>
<li>If <em>tri</em> is of the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, then this effectively acts as a copy constructor: all SnapPea-specific information will be cloned directly through the SnapPea kernel. If <em>tri</em> is a null SnapPea triangulation then this copy will be a null triangulation also.</li>
<li>If <em>tri</em> is of the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, then Regina will attempt to convert this triangulation to SnapPea format. If the conversion is successful, this constructor will immediately ask SnapPea to try to find a hyperbolic structure.</li>
</ul>
<p >Regarding peripheral curves: native Regina triangulations do not store or use peripheral curves themselves, and so this constructor makes a default choice during the conversion process. Specifically:</p>
<ul>
<li>If solution_type() is geometric_solution or nongeometric_solution, then on each torus cusp the meridian and longitude are chosen to be the (shortest, second shortest) basis, and their orientations follow the convention used by the <em>SnapPy</em> kernel. Be warned, however, that this choice might not be unique for some cusp shapes, and the resolution of such ambiguities might be machine-dependent.</li>
<li>If solution_type() is something else (e.g., degenerate or flat), or if SnapPea throws a fatal error when attempting to install the (shortest, second shortest) basis as described above, then Regina will accept whatever basis SnapPea installs by default. Be warned that this default basis may change (and indeed has changed in the past) across different versions of the SnapPea kernel.</li>
</ul>
<p >Regarding internal vertices (i.e., vertices whose links are spheres): SnapPea is designed to work only with triangulations where every vertex is ideal. As a result:</p>
<ul>
<li>You may pass a closed triangulation to this constructor, but SnapPea will automatically convert this into a filling of a cusped manifold, using an ideal triangulation.</li>
<li>You may also pass a triangulation that uses both ideal and internal vertices. In this case, SnapPea will retriangulate the manifold so that it uses ideal vertices only.</li>
</ul>
<p >Even if SnapPea does not retriangulate the manifold (for the reasons described above), it is possible that the tetrahedron and vertex numbers might be changed in the new SnapPea triangulation. In particular, if the given Regina triangulation is orientable but not oriented, then you should <em>expect</em> these numbers to change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the Regina triangulation to clone. </td></tr>
    <tr><td class="paramname">ignored</td><td>a legacy parameter that is now ignored. (This argument was once required if you wanted to pass a closed triangluation to SnapPea.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7adba76d384a5f98c18e811bed614737" name="a7adba76d384a5f98c18e811bed614737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adba76d384a5f98c18e811bed614737">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new ideal SnapPea triangulation representing the complement of the given link in the 3-sphere. </p>
<p >This is <em>not</em> the same triangulation that would be produced by calling <code><a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>(link.complement())</code>. By calling <code>link.complement()</code>, you through Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class and therefore lose the peripheral curves. Although the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> constructor will install new peripheral curves, there is no guarantee that these are the same curves as before; in particular, there is no guarantee that these new curves will correspond in any way to the original link diagram.</p>
<p >In contrast, by calling <code>SnapPeaTriangulation(link)</code> directly, the link complement will be triangulated by the SnapPea kernel and not by Regina. As a result, the peripheral curves installed by SnapPea will be precisely the curves from the link diagram.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given link is empty, or it has so many crossings and/or components that SnapPea cannot handle it. (The latter problem will only occur if the number of crossings and/or components does not fit into a native C++ <code>int</code>.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link whose complement we should build. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28b147dcd88e92267266f9c0f2860464" name="a28b147dcd88e92267266f9c0f2860464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b147dcd88e92267266f9c0f2860464">&#9670;&nbsp;</a></span>SnapPeaTriangulation() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramtype">regina::snappea::Triangulation *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new triangulation that holds the given raw data from the SnapPea kernel. </p>
<p >Typical users will not be able to call this constructor, since the SnapPea kernel headers are not part of Regina's public API and are not shipped with Regina's development headers.</p>
<p >This new triangulation will take ownership of <em>data</em>, and will use it directly as its native SnapPea representation. Nevertheless, this constructor is not constant time, since it also needs to construct a native Regina representation of the same triangulation.</p>
<p >The given SnapPea kernel data may be <code>null</code>, in which case this will become a null SnapPea triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Regina's Python interface does not allow you to talk directly with the built-in copy of the SnapPea C kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the raw SnapPea kernel data to use in this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adae36fd8774da3c29d017294021402b6" name="adae36fd8774da3c29d017294021402b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae36fd8774da3c29d017294021402b6">&#9670;&nbsp;</a></span>~SnapPeaTriangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaTriangulation::~SnapPeaTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p >All internal SnapPea data will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad43a33c581d838c8d558da03acc290c7" name="ad43a33c581d838c8d558da03acc290c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43a33c581d838c8d558da03acc290c7">&#9670;&nbsp;</a></span>allCalculatedTuraevViro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;<a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a75395b2e289bf58155f6b1f94b47530a">::TuraevViroSet</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::allCalculatedTuraevViro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifold. </p>
<p >This cache is updated every time <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> is called, and is emptied whenever the triangulation is modified.</p>
<p >Turaev-Viro invariants are identified by an (<em>r</em>, <em>parity</em>) pair as described in the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> documentation. The cache is just a set that maps (<em>r</em>, <em>parity</em>) pairs to the corresponding invariant values.</p>
<p >For even values of <em>r</em>, the parity is ignored when calling <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> (since the even and odd versions of the invariant contain essentially the same information). Therefore, in this cache, all even values of <em>r</em> will have the corresponding parities set to <code>false</code>.</p>
<dl class="section note"><dt>Note</dt><dd>All invariants in this cache are now computed using exact arithmetic, as elements of a cyclotomic field. This is a change from Regina 4.96 and earlier, which computed floating-point approximations instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns a Python dictionary. It also returns by value, not by reference (i.e., if more Turaev-Viro invariants are computed later on, the dictionary that was originally returned will not change as a result).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the cache of all Turaev-Viro invariants that have already been calculated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro</a> </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="a13345c67f4c82d9976863c8c5372db5b" name="a13345c67f4c82d9976863c8c5372db5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13345c67f4c82d9976863c8c5372db5b">&#9670;&nbsp;</a></span>barycentricSubdivision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::barycentricSubdivision</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that performs a barycentric subdivision of the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">subdivide()</a>, both to shorten the name but also to make it clearer that this triangulation will be modified directly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions. </dd></dl>

</div>
</div>
<a id="aef6eee4278d413b28cc3519ea07d90d0" name="aef6eee4278d413b28cc3519ea07d90d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6eee4278d413b28cc3519ea07d90d0">&#9670;&nbsp;</a></span>boundaryComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested boundary component of this triangulation. </p>
<p >Note that each time the triangulation changes, all boundary components will be deleted and replaced with new ones. Therefore this object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired boundary component; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a658bf830fdf052e1beaa5423298c51b2" title="Returns the number of boundary components in this triangulation.">countBoundaryComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested boundary component. </dd></dl>

</div>
</div>
<a id="a2b76267c6a893785e1fe396e5b439806" name="a2b76267c6a893785e1fe396e5b439806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b76267c6a893785e1fe396e5b439806">&#9670;&nbsp;</a></span>boundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all boundary components of this triangulation. </p>
<p >Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (BoundaryComponent&lt;dim&gt;* b : tri.boundaryComponents()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual boundary components <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2b76267c6a893785e1fe396e5b439806" title="Returns an object that allows iteration through and random access to all boundary components of this ...">boundaryComponents()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all boundary components. </dd></dl>

</div>
</div>
<a id="abdfa4594ab1ba473360ff7b91750f49a" name="abdfa4594ab1ba473360ff7b91750f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfa4594ab1ba473360ff7b91750f49a">&#9670;&nbsp;</a></span>boundaryMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>boundaryMap&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>boundaryMap(subdim)</code>.</p>
<p >See the non-templated boundaryMap(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>boundaryMap(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 1 and <em>dim</em> inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a200793f011759542228bbe3c44f3df85" name="a200793f011759542228bbe3c44f3df85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200793f011759542228bbe3c44f3df85">&#9670;&nbsp;</a></span>boundaryMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap&lt;subdim&gt;()</a> instead, which is slightly faster.</p>
<p >This is the boundary map that you would use if you were building the homology groups manually from a chain complex.</p>
<p >Unlike <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a>, this code does <em>not</em> use the dual skeleton: instead it uses the primal (i.e., ordinary) skeleton.</p>
<ul>
<li>The main advantage of this is that you can easily match rows and columns of the returned matrix to faces of this triangulation.</li>
<li>The main disadvantage is that ideal vertices are <em>not</em> treated as though they were truncated; instead they are just treated as 0-faces that appear as part of the chain complex.</li>
</ul>
<p >The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th (<em>subdim</em>-1)-face of this triangulation.</p>
<p >For the boundary map, we fix orientations as follows. In simplicial homology, for any <em>k</em>, the orientation of a <em>k</em>-simplex is determined by assigning labels 0,...,<em>k</em> to its vertices. For this routine, since every <em>k</em>-face <em>f</em> is already a <em>k</em>-simplex, these labels will just be the inherent vertex labels 0,...,<em>k</em> of the corresponding Face&lt;k&gt; object. If you need to convert these labels into vertex numbers of a top-dimensional simplex containing <em>f</em>, you can use either <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;k&gt;()</a>, or the equivalent routine <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html#a8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;k&gt;::vertices()</a>.</p>
<p >If you wish to convert these boundary maps to homology groups yourself, either the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class (if you do not need to track which face is which) or the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class (if you do need to track individual faces) can help you do this.</p>
<p >Note that, unlike many of the templated face-related routines, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., less than 1 or greater than <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 1 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a99eccc799a49667455b78f790f258098" name="a99eccc799a49667455b78f790f258098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eccc799a49667455b78f790f258098">&#9670;&nbsp;</a></span>calculatedSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculatedSkeleton</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the skeletal objects and properties of this triangulation have been calculated. </p>
<p >These are only calculated "on demand", when a skeletal property is first queried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the skeleton has been calculated. </dd></dl>

</div>
</div>
<a id="a2cad97766bcdf5c61b156b8aa0d8fa38" name="a2cad97766bcdf5c61b156b8aa0d8fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cad97766bcdf5c61b156b8aa0d8fa38">&#9670;&nbsp;</a></span>canonise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::SnapPeaTriangulation::canonise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the canonical retriangulation of the canonical cell decomposition. </p>
<p >Any fillings on the cusps of this SnapPea triangulation will be ignored. In the resulting canonical triangulation (which is one of Regina's native <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> objects, not a SnapPea triangulation), these fillings will be completely forgotten.</p>
<p >The canonical cell decomposition is the one described in "Convex hulls and isometries of cusped hyperbolic 3-manifolds", Jeffrey R. Weeks, Topology Appl. 52 (1993), 127-149.</p>
<p >If the canonical cell decomposition is already a triangulation then we leave it untouched. Otherwise, the canonical retriangulation introduces internal (finite) vertices, and is defined as follows:</p>
<ul>
<li>within each 3-cell of the original complex we introduce a new internal vertex, and cone the 3-cell boundary to this new vertex;</li>
<li>through each 2-cell of the original complex we insert the dual edge (joining the two new finite vertices on either side), and we replace the two cones on either side of the 2-cell with a ring of tetrahedra surrounding this dual edge.</li>
</ul>
<p >See canonize_part_2.c in the SnapPea source code for details.</p>
<p >This routine discards the hyperbolic structure along with all SnapPea-specific information (such as peripheral curves and fillings), and simply returns one of Regina's native triangulations. If you need to preserve SnapPea-specific information then you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">protoCanonise()</a> instead.</p>
<p >SnapPea is not always able to compute the canonical cell decomposition: if it fails then then this routine will throw an exception (see below for details).</p>
<dl class="section user"><dt>SnapPy</dt><dd>The function <code><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a></code> means different things for SnapPy versus the SnapPea kernel. Here Regina follows the naming convention used in the SnapPea kernel. Specifically: Regina's routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">SnapPeaTriangulation::protoCanonise()</a> corresponds to SnapPy's <code>Manifold.canonize()</code> and the SnapPea kernel's <code>proto_canonize(manifold)</code>. Regina's routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">SnapPeaTriangulation::canonise()</a> corresponds to the SnapPea kernel's <code>canonize(manifold)</code>, and is not available through SnapPy at all.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The SnapPea kernel does not always compute the canonical cell decomposition correctly. Sometimes it gives the wrong answer, although in such a case it still guarantees that the manifold it <em>does</em> return is homeomorphic to the original. Sometimes it gives no answer at all, in which case this routine will throw an exception (see below).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The SnapPea kernel was unable to compute the canonical cell decomposition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the canonical triangulation of the canonical cell decomposition. </dd></dl>

</div>
</div>
<a id="a23b8e0ad9bdee474ec2dd45e27bc36d7" name="a23b8e0ad9bdee474ec2dd45e27bc36d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b8e0ad9bdee474ec2dd45e27bc36d7">&#9670;&nbsp;</a></span>canonize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::SnapPeaTriangulation::canonize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a>, which constructs the canonical retriangulation of the canonical cell decomposition. </p>
<p >See <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a> for further details.</p>
<p >This alias is provided as "glue" between the British spelling used throughout Regina and the American spelling used throughout the SnapPea kernel.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The SnapPea kernel was unable to compute the canonical cell decomposition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the canonical triangulation of the canonical cell decomposition. </dd></dl>

</div>
</div>
<a id="a571569a34bb4173bd5eb6b521ff503cb" name="a571569a34bb4173bd5eb6b521ff503cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571569a34bb4173bd5eb6b521ff503cb">&#9670;&nbsp;</a></span>clearBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::clearBaseProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all properties that are managed by this base class. </p>
<p >This includes deleting all skeletal objects and emptying the corresponding internal lists, as well as clearing other cached properties and deallocating the corresponding memory where required.</p>
<p >Note that TriangulationBase almost never calls this routine itself (the one exception is the copy assignment operator). Typically <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a571569a34bb4173bd5eb6b521ff503cb" title="Clears all properties that are managed by this base class.">clearBaseProperties()</a> is only ever called by Triangulation&lt;dim&gt;::clearAllProperties(), which in turn is called by "atomic" routines that change the triangluation (before firing packet change events), as well as the Triangulation&lt;dim&gt; destructor. </p>

</div>
</div>
<a id="aa83effbc43af294638b92d39246ebb26" name="aa83effbc43af294638b92d39246ebb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83effbc43af294638b92d39246ebb26">&#9670;&nbsp;</a></span>closeBook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::closeBook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a book closing move about the given boundary edge. </p>
<p >This involves taking a boundary edge of the triangulation and folding together the two boundary triangles on either side. This move is the inverse of the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4e1f76566647492c74f380c466edcbe5" title="Checks the eligibility of and/or performs a book opening move about the given triangle.">openBook()</a> move, and is used to simplify the boundary of the triangulation. This move can be done if:</p>
<ul>
<li>the edge <em>e</em> is a boundary edge;</li>
<li>the two vertices opposite <em>e</em> in the boundary triangles that contain <em>e</em> are valid and distinct;</li>
<li>the boundary component containing <em>e</em> contains more than two triangles.</li>
</ul>
<p >There are in fact several other distinctness conditions on the nearby edges and triangles, but they follow automatically from the conditions above.</p>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this operation will (trivially) preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="aa15b75f55bf6eaead57e6864fd7db58d" name="aa15b75f55bf6eaead57e6864fd7db58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15b75f55bf6eaead57e6864fd7db58d">&#9670;&nbsp;</a></span>collapseEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::collapseEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices. </p>
<p >This operation (when it is allowed) does not change the topology of the manifold, decreases the number of vertices by one, and also decreases the number of tetrahedra.</p>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If you are trying to reduce the number of vertices without changing the topology, and if <em>e</em> is an edge connecting an internal vertex with some different vertex, then either <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> or <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> may be more appropriate for your situation (though you may find it easier just to call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> instead).</p>
<ul>
<li>The advantage of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> is that it decreases the number of tetrahedra, whereas <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> increases this number (but only by two).</li>
<li>The disadvantages of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> are that it cannot always be performed, and its validity tests are expensive; <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> on the other hand can always be used for edges <em>e</em> of the type described above.</li>
</ul>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<p >The eligibility requirements for this move are somewhat involved, and are discussed in detail in the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> source code for those who are interested.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to collapse. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the given edge may be collapsed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a4dd435c05fdb9ad2ce0229c08965e87d" name="a4dd435c05fdb9ad2ce0229c08965e87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd435c05fdb9ad2ce0229c08965e87d">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested connected component of this triangulation. </p>
<p >Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore this component object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired component; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a20e5dba7654710e79eecaf849f248d38" title="Returns the number of connected components in this triangulation.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested component. </dd></dl>

</div>
</div>
<a id="aca9f1a9b278dd911add0d10351e8089d" name="aca9f1a9b278dd911add0d10351e8089d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9f1a9b278dd911add0d10351e8089d">&#9670;&nbsp;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all components of this triangulation. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Component&lt;dim&gt;* c : tri.components()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual component objects <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aca9f1a9b278dd911add0d10351e8089d" title="Returns an object that allows iteration through and random access to all components of this triangula...">components()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all components. </dd></dl>

</div>
</div>
<a id="acf0671a3ebe7d61fe1fc9ba26862bfce" name="acf0671a3ebe7d61fe1fc9ba26862bfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0671a3ebe7d61fe1fc9ba26862bfce">&#9670;&nbsp;</a></span>connectedSumWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::connectedSumWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms the connected sum of this triangulation with the given triangulation. </p>
<p >This triangulation will be altered directly.</p>
<p >If this and the given triangulation are both oriented, then the result will be oriented also, and the connected sum will respect these orientations.</p>
<p >If one or both triangulations contains multiple connected components, this routine will connect the components containing tetrahedron 0 of each triangulation, and will copy any additional components across with no modification.</p>
<p >If either triangulation is empty, then the result will simply be a clone of the other triangulation.</p>
<p >This and/or the given triangulation may be bounded or ideal, or even invalid; in all cases the connected sum will be formed correctly. Note, however, that the result might possibly contain internal vertices (even if the original triangulations do not).</p>
<p >It is allowed to pass this triangulation as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to sum with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a658bf830fdf052e1beaa5423298c51b2" name="a658bf830fdf052e1beaa5423298c51b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658bf830fdf052e1beaa5423298c51b2">&#9670;&nbsp;</a></span>countBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary components in this triangulation. </p>
<p >Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary components. </dd></dl>

</div>
</div>
<a id="a38cea5a70cdc8bf81306e413b69a472c" name="a38cea5a70cdc8bf81306e413b69a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cea5a70cdc8bf81306e413b69a472c">&#9670;&nbsp;</a></span>countBoundaryFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary <em>subdim</em>-faces in this triangulation. </p>
<p >This is the fastest way to count faces if you know <em>subdim</em> at compile time.</p>
<p >Specifically, this counts the number of <em>subdim</em>-faces for which isBoundary() returns <code>true</code>. This may lead to some unexpected results in non-standard scenarios; see the documentation for the non-templated countBoundaryFaces(int) for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>countBoundaryFaces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a7a0734a644b899ff1ff8f58554547452" name="a7a0734a644b899ff1ff8f58554547452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0734a644b899ff1ff8f58554547452">&#9670;&nbsp;</a></span>countBoundaryFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime. </p>
<p >This routine takes linear time in the dimension <em>dim</em>. For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a38cea5a70cdc8bf81306e413b69a472c" title="Returns the number of boundary subdim-faces in this triangulation.">countBoundaryFaces&lt;subdim&gt;()</a> instead, which is fast constant time.</p>
<p >Specifically, this counts the number of <em>subdim</em>-faces for which isBoundary() returns <code>true</code>. This may lead to some unexpected results in non-standard scenarios; for example:</p>
<ul>
<li>In <a class="el" href="stddim.html">non-standard dimensions</a>, ideal vertices are not recognised and so will not be counted as boundary;</li>
<li>In an invalid triangulation, the number of boundary faces reported here may be smaller than the number of faces obtained when you triangulate the boundary using <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#aa2d51205dc9900043de370654f2c097c" title="Returns the full (dim-1)-dimensional triangulation of this boundary component.">BoundaryComponent::build()</a>. This is because "pinched" faces (where separate parts of the boundary are identified together) will only be counted once here, but will "spring apart" into multiple faces when the boundary is triangulated.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative or greater than <em>dim</em>-1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a8c1a05fe022a95b928a068f9909b036c" name="a8c1a05fe022a95b928a068f9909b036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1a05fe022a95b928a068f9909b036c">&#9670;&nbsp;</a></span>countBoundaryFacets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of boundary facets in this triangulation. </p>
<p >This routine counts facets of top-dimensional simplices that are not glued to some adjacent top-dimensional simplex.</p>
<p >This is equivalent to calling countBoundaryFaces&lt;dim-1&gt;().</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a id="a2fda46274460bd9de64f06e16435c5e1" name="a2fda46274460bd9de64f06e16435c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fda46274460bd9de64f06e16435c5e1">&#9670;&nbsp;</a></span>countBoundaryTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::countBoundaryTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8c1a05fe022a95b928a068f9909b036c" title="Returns the total number of boundary facets in this triangulation.">countBoundaryFacets()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8c1a05fe022a95b928a068f9909b036c" title="Returns the total number of boundary facets in this triangulation.">countBoundaryFacets()</a> for further information. </p>

</div>
</div>
<a id="aec4b3badd67a8ccb5ec0111d5c995e19" name="aec4b3badd67a8ccb5ec0111d5c995e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4b3badd67a8ccb5ec0111d5c995e19">&#9670;&nbsp;</a></span>countCompleteCusps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SnapPeaTriangulation::countCompleteCusps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of complete cusps (that is, unfilled cusps). </p>
<p >It is always true that <code><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aec4b3badd67a8ccb5ec0111d5c995e19" title="Returns the total number of complete cusps (that is, unfilled cusps).">countCompleteCusps()</a> + <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a3666f1827e93752400941de349992d1f" title="Returns the total number of filled cusps.">countFilledCusps()</a> == <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a></code>.</p>
<dl class="section user"><dt>SnapPy</dt><dd>This has no corresponding routine in SnapPy, though the information is easily acessible via <code>Manifold.cusp_info("is_complete")</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of complete cusps. </dd></dl>

</div>
</div>
<a id="a20e5dba7654710e79eecaf849f248d38" name="a20e5dba7654710e79eecaf849f248d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e5dba7654710e79eecaf849f248d38">&#9670;&nbsp;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of connected components in this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a id="a67facbc8a73fa32e37ee2bc79df76aa1" name="a67facbc8a73fa32e37ee2bc79df76aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67facbc8a73fa32e37ee2bc79df76aa1">&#9670;&nbsp;</a></span>countCusps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SnapPeaTriangulation::countCusps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of cusps (both filled and complete). </p>
<p >This returns the same value as the inherited function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a658bf830fdf052e1beaa5423298c51b2" title="Returns the number of boundary components in this triangulation.">Triangulation&lt;3&gt;::countBoundaryComponents()</a>.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.num_cusps()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of cusps. </dd></dl>

</div>
</div>
<a id="addf438f54b1ccec5a42916b00132ed2f" name="addf438f54b1ccec5a42916b00132ed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf438f54b1ccec5a42916b00132ed2f">&#9670;&nbsp;</a></span>countEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countEdges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;1&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a929d32300a09aa008d03099e4b84e873" name="a929d32300a09aa008d03099e4b84e873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929d32300a09aa008d03099e4b84e873">&#9670;&nbsp;</a></span>countFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this triangulation. </p>
<p >This is the fastest way to count faces if you know <em>subdim</em> at compile time.</p>
<p >For convenience, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>. This is <em>not</em> the case for the routines <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a>, which give access to individual faces (the reason relates to the fact that top-dimensional simplices are built manually, whereas lower-dimensional faces are deduced properties).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>countFaces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em> inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ad51bc921de7b1971061a1a2353f9ad96" name="ad51bc921de7b1971061a1a2353f9ad96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51bc921de7b1971061a1a2353f9ad96">&#9670;&nbsp;</a></span>countFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime. </p>
<p >This routine takes linear time in the dimension <em>dim</em>. For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a> instead, which is fast constant time.</p>
<p >For convenience, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>. This is <em>not</em> the case for the routines <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a>, which give access to individual faces (the reason relates to the fact that top-dimensional simplices are built manually, whereas lower-dimensional faces are deduced properties).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative or greater than <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a3666f1827e93752400941de349992d1f" name="a3666f1827e93752400941de349992d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3666f1827e93752400941de349992d1f">&#9670;&nbsp;</a></span>countFilledCusps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SnapPeaTriangulation::countFilledCusps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of filled cusps. </p>
<p >It is always true that <code><a class="el" href="classregina_1_1SnapPeaTriangulation.html#aec4b3badd67a8ccb5ec0111d5c995e19" title="Returns the total number of complete cusps (that is, unfilled cusps).">countCompleteCusps()</a> + <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a3666f1827e93752400941de349992d1f" title="Returns the total number of filled cusps.">countFilledCusps()</a> == <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a></code>.</p>
<dl class="section user"><dt>SnapPy</dt><dd>This has no corresponding routine in SnapPy, though the information is easily acessible via <code>Manifold.cusp_info("is_complete")</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of filled cusps. </dd></dl>

</div>
</div>
<a id="a10f6885850adfdf4c8c278dd241f5f90" name="a10f6885850adfdf4c8c278dd241f5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f6885850adfdf4c8c278dd241f5f90">&#9670;&nbsp;</a></span>countPentachora()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countPentachora</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;4&gt;()</a>. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a2e4329504df39fb7dbf796600329146d" name="a2e4329504df39fb7dbf796600329146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4329504df39fb7dbf796600329146d">&#9670;&nbsp;</a></span>countTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countTetrahedra</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;3&gt;()</a>. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a0ff1fb3c66e81c2d533e1fac79439126" name="a0ff1fb3c66e81c2d533e1fac79439126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1fb3c66e81c2d533e1fac79439126">&#9670;&nbsp;</a></span>countTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countTriangles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;2&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a4978fb0aeb2d208806404431e445a567" name="a4978fb0aeb2d208806404431e445a567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4978fb0aeb2d208806404431e445a567">&#9670;&nbsp;</a></span>countVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;0&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a951a9bbccbfb02315886e2f5371f2607" name="a951a9bbccbfb02315886e2f5371f2607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a9bbccbfb02315886e2f5371f2607">&#9670;&nbsp;</a></span>cusp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Cusp.html">Cusp</a> &amp; regina::SnapPeaTriangulation::cusp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichCusp</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the given cusp of this manifold. </p>
<p >This information includes the filling coefficients (if any), along with other combinatorial information.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.cusp_info()[c]</code>, though the set of information returned about each cusp is different.</dd></dl>
<p>These <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> objects should be considered temporary only; you should not hold onto references or pointers to them. If you need to hold on to information about a cusp, you can simply copy the <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> object by value (an operation that is both cheap and safe).</p>
<p >In older versions of Regina, this routine would explicitly check for a null triangulation. Nowadays this is the responsibility of the user or programmer.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be warned that cusp <em>i</em> might not correspond to vertex <em>i</em> of the triangulation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichCusp</td><td>the index of a cusp according to SnapPea; this must be between 0 and <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>information about the given cusp. </dd></dl>

</div>
</div>
<a id="a282f5add01134a87b87655dc6eaa2c2a" name="a282f5add01134a87b87655dc6eaa2c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282f5add01134a87b87655dc6eaa2c2a">&#9670;&nbsp;</a></span>cusps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::SnapPeaTriangulation::cusps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to information about all of the cusps of this manifold. </p>
<p >This information includes the filling coefficients (if any), along with other combinatorial information.</p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. The elements of the list will be read-only objects of type <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a>. For example, your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Cusp&amp; c : tri-&gt;cusps()) { ... }</div>
</div><!-- fragment --><p >These <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> objects should be considered temporary only; you should not hold onto references or pointers to them. If you need to hold on to information about a cusp, you can simply copy the <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> object by value (an operation that is both cheap and safe).</p>
<dl class="section warning"><dt>Warning</dt><dd>Be warned that cusp <em>i</em> might not correspond to vertex <em>i</em> of the triangulation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all cusps of this manifold. </dd></dl>

</div>
</div>
<a id="a8b1081ff442801c2d33038c11031ee2b" name="a8b1081ff442801c2d33038c11031ee2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1081ff442801c2d33038c11031ee2b">&#9670;&nbsp;</a></span>dehydrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::dehydrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dehydrates this triangulation into an alphabetical string. </p>
<p >A <em>dehydration string</em> is a compact text representation of a triangulation, introduced by Callahan, Hildebrand and Weeks for their cusped hyperbolic census (see below). The dehydration string of an <em>n</em>-tetrahedron triangulation consists of approximately (but not precisely) 5<em>n</em>/2 lower-case letters.</p>
<p >Dehydration strings come with some restrictions:</p><ul>
<li>They rely on the triangulation being "canonical" in some combinatorial sense. This is not enforced here; instead a combinatorial isomorphism is applied to make the triangulation canonical, and this isomorphic triangulation is dehydrated instead. Note that the original triangulation is not changed.</li>
<li>They require the triangulation to be connected.</li>
<li>They require the triangulation to have no boundary triangles (though ideal triangulations are fine).</li>
<li>They can only support triangulations with at most 25 tetrahedra.</li>
</ul>
<p >The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9e37617ce0bdb569f260dd44c7745844" title="Rehydrates the given alphabetical string into a 3-dimensional triangulation.">rehydrate()</a> can be used to recover a triangulation from a dehydration string. Note that the triangulation recovered might not be identical to the original, but it is guaranteed to be an isomorphic copy.</p>
<p >For a full description of the dehydrated triangulation format, see <em>A <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> of Cusped Hyperbolic 3-Manifolds</em>, Callahan, Hildebrand and Weeks, Mathematics of Computation 68/225, 1999.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this triangulation is disconnected, it has boundary triangles, or it contains more than 25 tetrahedra.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dehydrated representation of this triangulation (or an isomorphic variant of this triangulation). </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a978beab0e6350c4a455ac4bc48e2a369" name="a978beab0e6350c4a455ac4bc48e2a369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978beab0e6350c4a455ac4bc48e2a369">&#9670;&nbsp;</a></span>disableKernelMessages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::SnapPeaTriangulation::disableKernelMessages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that the SnapPea kernel should not write diagnostic messages to standard output. </p>
<p >Calling this routine is equivalent to calling enableKernelMessages(false).</p>
<p >Note that diagnostic messages are already disabled by default.</p>
<p >This routine (which interacts with static data) is thread-safe. </p>

</div>
</div>
<a id="ae9418f87d687dd5e488b972a5ff7992a" name="ae9418f87d687dd5e488b972a5ff7992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9418f87d687dd5e488b972a5ff7992a">&#9670;&nbsp;</a></span>dualBoundaryMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualBoundaryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>dualBoundaryMap&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>dualBoundaryMap(subdim)</code>.</p>
<p >See the non-templated dualBoundaryMap(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>dualBoundaryMap(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dual face dimension; this must be between 1 and <em>dim</em> inclusive if <em>dim</em> is one of Regina's standard dimensions, or between 1 and (<em>dim</em> - 1) inclusive otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a346459be4eb9fbb487340a7d3441e1ef" name="a346459be4eb9fbb487340a7d3441e1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346459be4eb9fbb487340a7d3441e1ef">&#9670;&nbsp;</a></span>dualBoundaryMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualBoundaryMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae9418f87d687dd5e488b972a5ff7992a" title="Returns the boundary map from dual subdim-faces to dual (subdim-1)-faces of the triangulation.">dualBoundaryMap&lt;subdim&gt;()</a> instead, which is slightly faster.</p>
<p >This function is analogous to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a>, but is designed to work with dual faces instead of ordinary (primal) faces. In particular, this is used in the implementation of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a>, which works with the dual skeleton in order to effectively truncate ideal vertices.</p>
<p >The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th dual <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th dual (<em>subdim</em>-1)-face of this triangulation. Here we index dual faces in the same order as the (primal) faces of the triangulation that they are dual to, except that we omit primal <em>boundary</em> faces (i.e., primal faces for which <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a2fc849ef77244993696cbfe08083f336" title="Determines if this face lies entirely on the boundary of the triangulation.">Face::isBoundary()</a> returns <code>true</code>). Therefore, for triangulations with boundary, the dual face indices and the corresponding primal face indices might not be equal.</p>
<p >For this dual boundary map, for positive dual face dimensions <em>k</em>, we fix the orientations of the dual <em>k</em>-faces as follows:</p>
<ul>
<li>In simplicial homology, the orientation of a <em>k</em>-simplex is determined by assigning labels 0,...,<em>k</em> to its vertices.</li>
<li>Consider a dual <em>k</em>-face <em>d</em>, and let this be dual to the primal (<em>dim</em>-<em>k</em>)-face <em>f</em>. In general, <em>d</em> will <em>not</em> be a simplex. Let <em>B</em> denote the barycentre of <em>f</em> (which also appears as the "centre" point of <em>d</em>).</li>
<li>Let <em>emb</em> be an arbitrary <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a>&lt;dim-k&gt; for <em>f</em> (i.e., chosen from <code>f.embeddings()</code>), and let <em>s</em> be the corresponding top-dimensional simplex containing <em>f</em> (i.e., <code>emb.simplex()</code>). For the special case of dual edges (<em>k</em> = 1), this choice matters; here we choose <em>emb</em> to be the first embedding (that is, <code>f.front()</code>). For larger <em>k</em> this choice does not matter; see below for the reasons why.</li>
<li>Now consider how <em>d</em> intersects the top-dimensional simplex <em>s</em>. This intersection is a <em>k</em>-polytope with <em>B</em> as one of its vertices. We can extend this polytope away from <em>B</em>, pushing it all the way through the simplex <em>s</em>, until it becomes a <em>k</em>-simplex <em>g</em> whose vertices are <em>B</em> along with the <em>k</em> "unused" vertices of <em>s</em> that do <em>not</em> appear in <em>f</em>.</li>
<li>We can now define the orientation of the dual <em>k</em>-face <em>d</em> to be the orientation of this <em>k</em>-simplex <em>g</em> that contains it. All that remains now is to orient <em>g</em> by choosing a labelling 0,...,<em>k</em> for its vertices.</li>
<li>To orient <em>g</em>, we assign the label 0 to <em>B</em>, and we assign the labels 1,...,<em>k</em> to the "unused" vertices <code>v[dim-k+1]</code>,...,<code>v[dim]</code> of <em>s</em> respectively, where <em>v</em> is the permutation <code>emb.vertices()</code>.</li>
<li>Finally, we note that for <em>k</em> &gt; 1, the orientation for <em>d</em> does not depend on the particular choice of <em>s</em> and <em>emb:</em> by the preconditions and the fact that this routine only considers duals of non-boundary faces, the link of <em>f</em> must be a sphere, and therefore the images of those "other" vertices are fixed in a way that preserves orientation as you walk around the link. See the documentation for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">Simplex&lt;dim&gt;::faceMapping()</a> for details.</li>
<li>For the special case of dual edges (<em>k</em> = 1), the conditions above can be described more simply: the two endpoints of the dual edge <em>d</em> correspond to the two top-dimensional simplices on either side of the (<em>dim</em>-1)-face <em>f</em>, and we orient <em>d</em> by labelling these endpoints (0, 1) in the order (<code>f.back()</code>, <code>f.front()</code>).</li>
</ul>
<p >If you wish to convert these boundary maps to homology groups yourself, either the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class (if you do not need to track which dual face is which) or the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class (if you do need to track individual dual faces) can help you do this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (as documented for the <em>subdim</em> argument below).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the dual face dimension; this must be between 1 and <em>dim</em> inclusive if <em>dim</em> is one of Regina's standard dimensions, or between 1 and (<em>dim</em> - 1) inclusive otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="ae61a040faab0610d2dbfc515c94abb04" name="ae61a040faab0610d2dbfc515c94abb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61a040faab0610d2dbfc515c94abb04">&#9670;&nbsp;</a></span>dualToPrimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualToPrimal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map from dual chains to primal chains that preserves homology classes. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>dualToPrimal&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>dualToPrimal(subdim)</code>.</p>
<p >See the non-templated dualToPrimal(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This trianguation is valid, non-empty, and non-ideal. Note that Regina can only detect ideal triangulations in <a class="el" href="stddim.html">standard dimensions</a>; for higher dimensions it is the user's reponsibility to confirm this some other way.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>dualToPrimal(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the chain dimension; this must be between 0 and (<em>dim</em> - 1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from dual <em>subdim</em>-chains to primal <em>subdim</em>-chains. </dd></dl>

</div>
</div>
<a id="aaef2f61c320f8f9da4ea89715f3c2873" name="aaef2f61c320f8f9da4ea89715f3c2873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef2f61c320f8f9da4ea89715f3c2873">&#9670;&nbsp;</a></span>dualToPrimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualToPrimal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map from dual chains to primal chains that preserves homology classes, where the chain dimension does not need to be known until runtime. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae61a040faab0610d2dbfc515c94abb04" title="Returns a map from dual chains to primal chains that preserves homology classes.">dualToPrimal&lt;subdim&gt;()</a> instead, which is slightly faster.</p>
<p >The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th dual <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th primal <em>subdim</em>-face of this triangulation.</p>
<p >We index and orient these dual and primal faces in the same manner as <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae9418f87d687dd5e488b972a5ff7992a" title="Returns the boundary map from dual subdim-faces to dual (subdim-1)-faces of the triangulation.">dualBoundaryMap()</a> and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a> respectively. In particular, dual faces are indexed in the same order as the primal (<em>dim</em>-<em>subdim</em>)-faces of the triangulation that they are dual to, except that we omit primal boundary faces. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae9418f87d687dd5e488b972a5ff7992a" title="Returns the boundary map from dual subdim-faces to dual (subdim-1)-faces of the triangulation.">dualBoundaryMap()</a> and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a> for further details.</p>
<p >The key feature of this map is that, if a column vector <em>v</em> represents a cycle <em>c</em> in the dual chain complex (i.e., it is a chain with zero boundary), and if this map is represented by the matrix <em>M</em>, then the vector <code>M×v</code> represents a cycle in the primal chain complex that belongs to the same <em>subdim</em>th homology class as <em>c</em>.</p>
<p >Regarding implementation: the map is constructed by (i) subdividing each dual face into smaller <em>subdim</em>-simplices whose vertices are barycentres of primal faces of different dimensions, (ii) moving each barycentre to vertex 0 of the corresponding face, and then (iii) discarding any resulting simplices with repeated vertices (which become "flattened" to a dimension less than <em>subdim</em>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This trianguation is valid, non-empty, and non-ideal. Note that Regina can only detect ideal triangulations in <a class="el" href="stddim.html">standard dimensions</a>; for higher dimensions it is the user's reponsibility to confirm this some other way.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The chain dimension <em>subdim</em> is outside the supported range (as documented for the <em>subdim</em> argument below).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the chain dimension; this must be between 0 and (<em>dim</em> - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from dual <em>subdim</em>-chains to primal <em>subdim</em>-chains. </dd></dl>

</div>
</div>
<a id="ace7c9ec1168ef9e7cb34b3e4a5b9b873" name="ace7c9ec1168ef9e7cb34b3e4a5b9b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7c9ec1168ef9e7cb34b3e4a5b9b873">&#9670;&nbsp;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dumpConstruction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns C++ code that can be used to reconstruct this triangulation. </p>
<p >This code will call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">Triangulation&lt;dim&gt;::fromGluings()</a>, passing a hard-coded C++ initialiser list.</p>
<p >The main purpose of this routine is to generate this hard-coded initialiser list, which can be tedious and error-prone to write by hand.</p>
<p >Note that the number of lines of code produced grows linearly with the number of simplices. If this triangulation is very large, the returned string will be very large as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="a25e675a24773baa6ddca79a6ae7e2899" name="a25e675a24773baa6ddca79a6ae7e2899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e675a24773baa6ddca79a6ae7e2899">&#9670;&nbsp;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;1&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ae935e2e6267aab03599c1eeacee2dc78" name="ae935e2e6267aab03599c1eeacee2dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935e2e6267aab03599c1eeacee2dc78">&#9670;&nbsp;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;1&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a9c42217fc152e7f22c7ea1717954a6db" name="a9c42217fc152e7f22c7ea1717954a6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c42217fc152e7f22c7ea1717954a6db">&#9670;&nbsp;</a></span>enableKernelMessages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::SnapPeaTriangulation::enableKernelMessages </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures whether or not the SnapPea kernel should write diagnostic messages to standard output. </p>
<p >By default such diagnostic messages are disabled.</p>
<p >This routine (which interacts with static data) is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> if diagnostic messages should be enabled, or <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa87b9f9c40a48cee3a1ee9c71bd70fef" name="aa87b9f9c40a48cee3a1ee9c71bd70fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87b9f9c40a48cee3a1ee9c71bd70fef">&#9670;&nbsp;</a></span>ensureSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::ensureSkeleton</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all "on demand" skeletal objects have been calculated. </p>

</div>
</div>
<a id="a09adf6ddf426a6a4ea334824f4ab5796" name="a09adf6ddf426a6a4ea334824f4ab5796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09adf6ddf426a6a4ea334824f4ab5796">&#9670;&nbsp;</a></span>enumerateCovers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SnapPeaTriangulation::enumerateCovers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sheets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#af493515e72e2059b4c23986d0cde0d87">CoverEnumerationType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates connected <em>k</em>-sheeted covers of the underlying manifold. </p>
<p >The number of sheets <em>k</em> is passed as the first argument to this function.</p>
<p >Regina does this (with the help of SnapPea) by:</p>
<ul>
<li>enumerating all transitive representations of the fundamental group into either the symmetric group <em>S(k)</em> or the cyclic group <em>Z_k</em> (according to the parameter <em>type</em>), using the SnapPea function <code>find_representations()</code>; and then</li>
<li>building the cover that corresponds to each representation, using the SnapPea function <code>construct_cover()</code>.</li>
</ul>
<p >If you are only interested in the corresponding index <em>k</em> subgroups of the fundamental group and not the triangulated covers themselves, then you may wish to consider the native Regina function <a class="el" href="classregina_1_1GroupPresentation.html#ab76ec8d931ca133a2c145ffbc0ef7955" title="Enumerates all transitive representations of this group into the symmetric group S(k).">GroupPresentation::enumerateCovers()</a> instead. That function is highly optimised, and should be considerably faster as <em>k</em> grows.</p>
<p >Each covering space is produced once up to equivalence; here equivalent covers correspond to conjugate representations of the fundamental group.</p>
<p >To enumerate <em>all</em> <em>k</em>-sheeted covers up to equivalence, set <em>type</em> to <em>all_covers</em>. Be warned, however, that this becomes enormously slow as the number of sheets <em>k</em> grows. An alternative is to enumerate only cyclic covers by setting <em>type</em> to <em>cyclic_covers</em>; this significantly limits the set of covers produced but is also much faster for larger <em>k</em>.</p>
<p >For each cover that is produced, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a SnapPea triangulation; this will be the newly produced cover. This argument will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>The second argument to <em>action</em> must be of type <em><a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda" title="Indicates the different types of covers that can be produced by enumerateCovers().">SnapPeaTriangulation::CoverType</a></em>. This will indicate the type of cover that has been constructed; see the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda" title="Indicates the different types of covers that can be produced by enumerateCovers().">SnapPeaTriangulation::CoverType</a> documentation for details. In the same call to <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a> you may observe different types of covers being produced (i.e., this value is computed individually for each cover). You should, however, never see the value <em>unknown_cover</em>.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
<li><em>action</em> must not make changes to this original triangulation (i.e., the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> upon which <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a09adf6ddf426a6a4ea334824f4ab5796" title="Enumerates connected k-sheeted covers of the underlying manifold.">enumerateCovers()</a> is being called).</li>
</ul>
<p >Be aware that this routine does the bulk of its work before any covers are produced. Specifically, because of the design of the SnapPea kernel, this routine first enumerates all requested representations of the fundamental group (which is the slow part), and only then does it construct the cover and call <em>action</em> for each representation, one at a time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null triangulation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you are enumerating all covers, then the argument <em>sheets</em> should be <em>very</em> small.</dd>
<dd>
The covers that are produced will typically use far more tetrahedra than necessary. If size is important then you should take a copy using Regina's native type <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> and call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> on that. Note that you cannot call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> directly on a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, since (like all modifying functions inherited from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>) this will nullify the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the class notes for further explanation.</dd>
<dd>
The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>enumerateCovers(sheets, type, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, it returns the number of covers found, but it does <em>not</em> take an addition argument list (<em>args</em>). The second form is <code>enumerateCovers(sheets, type)</code>, which returns a Python list containing all of the triangulated covers, each given as a pair (<a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#abd2e873e96003ef01494e95f44962dda" title="Indicates the different types of covers that can be produced by enumerateCovers().">SnapPeaTriangulation::CoverType</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sheets</td><td>the number of sheets in the covers to produce (i.e., the number <em>k</em> in the description above); this must be a positive integer. </td></tr>
    <tr><td class="paramname">type</td><td>indicates whether to enumerate all covers (up to equivalence) or only cyclic covers. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each cover that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial triangulation and type arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of covers found. </dd></dl>

</div>
</div>
<a id="aea8890fe2a84e4c147c43c2ae3c2386f" name="aea8890fe2a84e4c147c43c2ae3c2386f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8890fe2a84e4c147c43c2ae3c2386f">&#9670;&nbsp;</a></span>eulerCharManifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::eulerCharManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euler characteristic of the corresponding compact 3-manifold. </p>
<p >Instead of simply calculating <code>V-E+F-T</code>, this routine also:</p>
<ul>
<li>treats ideal vertices as surface boundary components (i.e., effectively truncates them);</li>
<li>truncates invalid boundary vertices (i.e., boundary vertices whose links are not discs);</li>
<li>truncates the projective plane cusps at the midpoints of invalid edges (edges identified with themselves in reverse).</li>
</ul>
<p >For ideal triangulations, this routine therefore computes the proper Euler characteristic of the manifold (unlike <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8063bd8d3c1ff8d896ae0a24db2203d5" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a>, which does not).</p>
<p >For triangulations whose vertex links are all spheres or discs, this routine and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8063bd8d3c1ff8d896ae0a24db2203d5" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a> give identical results.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the corresponding compact manifold. </dd></dl>

</div>
</div>
<a id="a8063bd8d3c1ff8d896ae0a24db2203d5" name="a8063bd8d3c1ff8d896ae0a24db2203d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8063bd8d3c1ff8d896ae0a24db2203d5">&#9670;&nbsp;</a></span>eulerCharTri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::eulerCharTri</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euler characteristic of this triangulation. </p>
<p >This will be evaluated strictly as the alternating sum of the number of <em>i</em>-faces (that is, <code><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4978fb0aeb2d208806404431e445a567" title="A dimension-specific alias for countFaces&lt;0&gt;().">countVertices()</a> - <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f" title="A dimension-specific alias for countFaces&lt;1&gt;().">countEdges()</a> + <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0ff1fb3c66e81c2d533e1fac79439126" title="A dimension-specific alias for countFaces&lt;2&gt;().">countTriangles()</a> - ...</code>).</p>
<p >Note that this routine handles ideal triangulations in a non-standard way. Since it computes the Euler characteristic of the triangulation (and not the underlying manifold), this routine will treat each ideal boundary component as a single vertex, and <em>not</em> as an entire (<em>dim</em>-1)-dimensional boundary component.</p>
<p >In Regina's <a class="el" href="stddim.html">standard dimensions</a>, for a routine that handles ideal boundary components properly (by treating them as (<em>dim</em>-1)-dimensional boundary components when computing Euler characteristic), you can use the routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aea8890fe2a84e4c147c43c2ae3c2386f" title="Returns the Euler characteristic of the corresponding compact 3-manifold.">eulerCharManifold()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of this triangulation. </dd></dl>

</div>
</div>
<a id="a4c4df33248af1794170e1ca76cd59256" name="a4c4df33248af1794170e1ca76cd59256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4df33248af1794170e1ca76cd59256">&#9670;&nbsp;</a></span>face() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for Python programmers. </p>
<p >For C++ users, this routine is not very useful: since precise types must be know at compile time, this routine returns a std::variant <em>v</em> that could store a pointer to any class Face&lt;dim, ...&gt;. This means you cannot access the face directly: you will still need some kind of compile-time knowledge of <em>subdim</em> before you can extract and use an appropriate Face&lt;dim, subdim&gt; object from <em>v</em>. However, once you know <em>subdim</em> at compile time, you are better off using the (simpler and faster) routine <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;subdim&gt;()</a> instead.</p>
<p >For Python users, this routine is much more useful: the return type can be chosen at runtime, and so this routine simply returns a Face&lt;dim, subdim&gt; object of the appropriate face dimension that you can use immediately.</p>
<p >The specific return type for C++ programmers will be std::variant&lt;Face&lt;dim, 0&gt;*, ..., <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a>&lt;dim, dim-1&gt;*&gt;.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative, or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="a802ea1cdd46af32418fb76c49712ccb8" name="a802ea1cdd46af32418fb76c49712ccb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802ea1cdd46af32418fb76c49712ccb8">&#9670;&nbsp;</a></span>face() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for C++ programmers. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>face(subdim, index)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ac4a59c70ef42fd731d7167df4973f389" name="ac4a59c70ef42fd731d7167df4973f389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a59c70ef42fd731d7167df4973f389">&#9670;&nbsp;</a></span>faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for C++ programmers. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Face&lt;dim, subdim&gt;* f : tri.faces&lt;subdim&gt;()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual faces <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> again each time you need it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>faces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ae0813f17eb6b6c91802b73403a5258d6" name="ae0813f17eb6b6c91802b73403a5258d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0813f17eb6b6c91802b73403a5258d6">&#9670;&nbsp;</a></span>faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for Python programmers. </p>
<p >C++ users should not use this routine. The return type must be fixed at compile time, and so it is a std::variant that can hold any of the lightweight return types from the templated <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;subdim&gt;()</a> function. This means that the return value will still need compile-time knowledge of <em>subdim</em> to extract and use the appropriate face objects. However, once you know <em>subdim</em> at compile time, you are much better off using the (simpler and faster) routine <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;subdim&gt;()</a> instead.</p>
<p >For Python users, this routine is much more useful: the return type can be chosen at runtime, and so this routine returns a Python list of Face&lt;dim, subdim&gt; objects (holding all the <em>subdim</em>-faces of the triangulation), which you can use immediately.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative, or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ae6b013fc3e254abe020b7ed51622c88e" name="ae6b013fc3e254abe020b7ed51622c88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b013fc3e254abe020b7ed51622c88e">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::fill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichCusp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a Dehn filling to the given cusp. </p>
<p >This routine will automatically ask SnapPea to update the hyperbolic structure according to the new filling coefficients.</p>
<p >The triangulation itself will not change; this routine will simply ask SnapPea to store the given filling coefficients alongside the cusp, to be used in operations such as computing hyperbolic structures. If you wish to retriangulate to permanently fill the cusp, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab9969078c164e2a1cf0460ba74dc51b3" title="Retriangulates to permanently fill all cusps.">filledAll()</a> or <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a08b5f8a885091ca71c2ba1b3b8bbe96a" title="Retriangulates to permanently fill the given cusp.">filledPartial()</a> instead.</p>
<p >For orientable cusps only coprime filling coefficients are allowed, and for non-orientable cusps only (±1, 0) fillings are allowed. Although SnapPea can handle more general fillings, Regina will enforce these conditions; if they are not satisfied then it will do nothing and simply return <code>false</code>.</p>
<p >As a special case however, you may pass (0, 0) as the filling coefficients, in which case this routine will behave identically to <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae0f9c7a14c1bbe226f4215d19ab5becd" title="Removes any filling on the given cusp.">unfill()</a>.</p>
<p >It is possible that, if the given integers are extremely large, SnapPea cannot convert the filling coefficients to its own internal floating-point representation. If this happens then this routine will again do nothing and simply return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be warned that cusp <em>i</em> might not correspond to vertex <em>i</em> of the triangulation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the first (meridional) filling coefficient. </td></tr>
    <tr><td class="paramname">l</td><td>the second (longitudinal) filling coefficient. </td></tr>
    <tr><td class="paramname">whichCusp</td><td>the index of the cusp to fill according to SnapPea; this must be between 0 and <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the filling coefficients were accepted (according to the conditions outlined above). </dd></dl>

</div>
</div>
<a id="ab9969078c164e2a1cf0460ba74dc51b3" name="ab9969078c164e2a1cf0460ba74dc51b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9969078c164e2a1cf0460ba74dc51b3">&#9670;&nbsp;</a></span>filledAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::SnapPeaTriangulation::filledAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retriangulates to permanently fill all cusps. </p>
<p >This uses the current Dehn filling coefficients on the cusps, as set by <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae6b013fc3e254abe020b7ed51622c88e" title="Assigns a Dehn filling to the given cusp.">fill()</a>. The result will be a closed triangulation, of type <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (not <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>).</p>
<p >This routine requires every cusp to be non-complete. If one or more cusps is complete (i.e., has no filling coefficients assigned), then this routine will throw an exception.</p>
<p >This replaces the old filledTriangulation() routines from Regina 6.0.1 and earlier, which decided at runtime whether to return a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> or a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. Since this routine explicitly fills all cusps, it is able to guarantee an explicit return type of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> at compile time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>All cusps of this manifold are non-complete (i.e., have filling coefficients assigned). This will be checked, and an exception will be thrown if this requirement is not met.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>Some cusp of this manifold is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the filled triangulation. </dd></dl>

</div>
</div>
<a id="a92b9c91037aad030285b22621f0ff0be" name="a92b9c91037aad030285b22621f0ff0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9c91037aad030285b22621f0ff0be">&#9670;&nbsp;</a></span>filledPartial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> regina::SnapPeaTriangulation::filledPartial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retriangulates to permanently fill some but not all cusps. </p>
<p >This uses the current Dehn filling coefficients on the cusps, as set by <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae6b013fc3e254abe020b7ed51622c88e" title="Assigns a Dehn filling to the given cusp.">fill()</a>. The result will be another instance of <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, with at least one cusp remaining.</p>
<p >This routine requires at least one cusp to be complete (i.e., to have no filling coefficients assigned), since most of the SnapPea kernel requires its triangulations to have at least one cusp.</p>
<ul>
<li>If all cusps are complete, then the result will simply be a clone of this triangulation.</li>
<li>If some but not all cusps are complete, then the result will be a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> with fewer cusps. The remaining cusps might be reindexed, and all <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> structures will be destroyed and rebuilt. Auxiliary information on the remaining cusps (such as peripheral curves) will be preserved, and SnapPea will automatically attempt to compute a hyperbolic structure on the new triangulation.</li>
<li>If no cusps are complete (i.e., all cusps have filling coefficients), then this routine will throw an exception. For such scenarios you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab9969078c164e2a1cf0460ba74dc51b3" title="Retriangulates to permanently fill all cusps.">filledAll()</a> instead.</li>
</ul>
<p >This replaces the old filledTriangulation() routines from Regina 6.0.1 and earlier, which decided at runtime whether to return a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> or a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. Since this routine explicitly does not fill all cusps, it is able to guarantee an explicit return type of <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> at compile time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At least one cusp of this manifold is complete (i.e., has no filling coefficients assigned). This will be checked, and an exception will be thrown if this requirement is not met.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>All cusps of this manifold are non-complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the filled triangulation. </dd></dl>

</div>
</div>
<a id="a08b5f8a885091ca71c2ba1b3b8bbe96a" name="a08b5f8a885091ca71c2ba1b3b8bbe96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b5f8a885091ca71c2ba1b3b8bbe96a">&#9670;&nbsp;</a></span>filledPartial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> regina::SnapPeaTriangulation::filledPartial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichCusp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retriangulates to permanently fill the given cusp. </p>
<p >This uses the current Dehn filling coefficients on the cusp, as set by <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ae6b013fc3e254abe020b7ed51622c88e" title="Assigns a Dehn filling to the given cusp.">fill()</a>. The result will be another instance of <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, with at least one cusp remaining.</p>
<p >This routine requires the manifold to have at least two cusps (i.e., the cusp being filled, plus at least one other). This is because most of the SnapPea kernel routines require its triangulations to have at least one cusp.</p>
<p >The error conditions are as follows:</p>
<ul>
<li>If the given cusp has no filling coefficients assigned (i.e., it is complete), then it cannot be filled: instead this routine will throw an exception.</li>
<li>If the manifold has only one cusp, then this routine will likewise throw an exception. For such scenarios you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ab9969078c164e2a1cf0460ba74dc51b3" title="Retriangulates to permanently fill all cusps.">filledAll()</a> instead, which will return a closed Regina triangulation.</li>
<li>Otherwise, if there is at least one other cusp, the result will be a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> with one fewer cusp. The remaining cusps might be reindexed, and all <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> structures will be destroyed and rebuilt. Auxiliary information on the remaining cusps (such as peripheral curves) will be preserved, and SnapPea will automatically attempt to compute a hyperbolic structure on the new triangulation.</li>
</ul>
<p >This replaces the old filledTriangulation() routines from Regina 6.0.1 and earlier, which decided at runtime whether to return a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> or a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. Since this routine explicitly does not fill all cusps, it is able to guarantee an explicit return type of <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> at compile time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given cusp is non-complete (i.e., has filling coefficients assigned), and the manifold has at least one other cusp. These preconditions will be checked, and an exception will be thrown if they are not met.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be warned that cusp <em>i</em> might not correspond to vertex <em>i</em> of the triangulation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>The given cusp is complete, and/or it is the only cusp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichCusp</td><td>the index of the cusp to permanently fill according to SnapPea; this must be between 0 and <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the filled triangulation. </dd></dl>

</div>
</div>
<a id="a6b6f440e7d977462241c1b4f16a169e3" name="a6b6f440e7d977462241c1b4f16a169e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6f440e7d977462241c1b4f16a169e3">&#9670;&nbsp;</a></span>fillTorus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fillTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a two-triangle torus boundary component by attaching a solid torus along a given curve. </p>
<p >The three edges of the boundary component should be passed as the arguments <em>e0</em>, <em>e1</em> and <em>e2</em>. The boundary component will then be filled with a solid torus whose meridional curve cuts these three edges <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> times respectively.</p>
<p >For the filling to be performed successfully, the three given edges must belong to the same boundary component, and this boundary component must be a two-triangle torus. Moreover, the integers <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> must be coprime, and two of them must add to give the third. If any of these conditions are not met, then this routine will do nothing and return <code>false</code>.</p>
<p >The triangulation will be simplified before returning.</p>
<p >There are two versions of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a>; the other takes a boundary component, and sets <em>e0</em>, <em>e1</em> and <em>e2</em> to its three edges according to Regina's own edge numbering. This version of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a> should be used when you know how the filling curve cuts each boundary edge but you do not know how these edges are indexed in the corresponding boundary component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e0</td><td>one of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">e1</td><td>the second of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">e2</td><td>the second of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">cuts0</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e0</em>. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e1</em>. </td></tr>
    <tr><td class="paramname">cuts2</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the boundary component was filled successfully, or <code>false</code> if one of the required conditions as described above is not satisfied. </dd></dl>

</div>
</div>
<a id="ae0bd90a983d00116514d0dd5bbefe3a2" name="ae0bd90a983d00116514d0dd5bbefe3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bd90a983d00116514d0dd5bbefe3a2">&#9670;&nbsp;</a></span>fillTorus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fillTorus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a two-triangle torus boundary component by attaching a solid torus along a given curve. </p>
<p >The boundary component to be filled should be passed as the argument <em>bc</em>; if the triangulation has exactly one boundary component then you may omit <em>bc</em> (i.e., pass <code>null</code>), and the (unique) boundary component will be inferred.</p>
<p >If the boundary component cannot be inferred, and/or if the selected boundary component is not a two-triangle torus, then this routine will do nothing and return <code>false</code>.</p>
<p >Otherwise the given boundary component will be filled with a solid torus whose meridional curve cuts the edges <code>bc-&gt;edge(0)</code>, <code>bc-&gt;edge(1)</code> and <code>bc-&gt;edge(2)</code> a total of <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> times respectively.</p>
<p >For the filling to be performed successfully, the integers <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> must be coprime, and two of them must add to give the third. Otherwise, as above, this routine will do nothing and return <code>false</code>.</p>
<p >The triangulation will be simplified before returning.</p>
<p >There are two versions of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a>; the other takes three explicit edges instead of a boundary component. You should use the other version if you know how the filling curve cuts each boundary edge but you do not know how these edges are indexed in the boundary component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cuts0</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(0)</code>. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(1)</code>. </td></tr>
    <tr><td class="paramname">cuts2</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(2)</code>. </td></tr>
    <tr><td class="paramname">bc</td><td>the boundary component to fill. If the triangulation has precisely one boundary component then this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the boundary component was filled successfully, or <code>false</code> if one of the required conditions as described above is not satisfied. </dd></dl>

</div>
</div>
<a id="a0481813042dab2c6140fc8d6fbbd189d" name="a0481813042dab2c6140fc8d6fbbd189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0481813042dab2c6140fc8d6fbbd189d">&#9670;&nbsp;</a></span>findAllIsomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllIsomorphisms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p >This routine behaves identically to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a>, except that instead of returning just one isomorphism, all such isomorphisms will be found and processed. See the <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> notes for details on this.</p>
<p >For each isomorphism that is found, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be of type <code>(const <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a>&lt;dim&gt;&amp;)</code>; this will be a reference to the isomorphism that was found. If <em>action</em> wishes to keep the isomorphism, it should take a deep copy (not a reference), since the isomorphism may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that the search for isomorphisms should continue, and a return value of <code>true</code> indicates that the search should terminate immediately.</li>
<li>This triangulation <em>must</em> remain constant while the search runs (i.e., <em>action</em> must not modify the triangulation).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>findAllIsomorphisms(other, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, the return value indicates whether <em>action</em> ever terminated the search, but it does <em>not</em> take an additonal argument list (<em>args</em>). The second form is <code>findAllIsomorphisms(other)</code>, which returns a Python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each isomorphism that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial isomorphism argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="ac3ea60c854787cc26a39618dcdf2196b" name="ac3ea60c854787cc26a39618dcdf2196b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ea60c854787cc26a39618dcdf2196b">&#9670;&nbsp;</a></span>findAllSubcomplexesIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllSubcomplexesIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p >This routine behaves identically to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a868e42b826a392816a796e0e15f85ded" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a>, except that instead of returning just one isomorphism (which may be boundary incomplete and need not be onto), all such isomorphisms will be found and processed. See the <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a868e42b826a392816a796e0e15f85ded" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a> notes for details on this.</p>
<p >For each isomorphism that is found, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be of type <code>(const <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a>&lt;dim&gt;&amp;)</code>; this will be a reference to the isomorphism that was found. If <em>action</em> wishes to keep the isomorphism, it should take a deep copy (not a reference), since the isomorphism may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that the search for isomorphisms should continue, and a return value of <code>true</code> indicates that the search should terminate immediately.</li>
<li>This triangulation <em>must</em> remain constant while the search runs (i.e., <em>action</em> must not modify the triangulation).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>findAllSubcomplexesIn(other, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, the return value indicates whether <em>action</em> ever terminated the search, but it does <em>not</em> take an additonal argument list (<em>args</em>). The second form is <code>findAllSubcomplexesIn(other)</code>, which returns a Python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for isomorphic copies of this triangulation. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each isomorphism that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial isomorphism argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="adc25a58b48e39f3c7f8621b84432d294" name="adc25a58b48e39f3c7f8621b84432d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25a58b48e39f3c7f8621b84432d294">&#9670;&nbsp;</a></span>finiteToIdeal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::finiteToIdeal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts each real boundary component into a cusp (i.e., an ideal vertex). </p>
<p >Only boundary components formed from real (<em>dim</em>-1)-faces will be affected; ideal boundary components are already cusps and so will not be changed.</p>
<p >One side-effect of this operation is that all spherical boundary components will be filled in with balls.</p>
<p >This operation is performed by attaching a new <em>dim</em>-simplex to each boundary (<em>dim</em>-1)-face, and then gluing these new simplices together in a way that mirrors the adjacencies of the underlying boundary facets. Each boundary component will thereby be pushed up through the new simplices and converted into a cusp formed using vertices of these new simplices.</p>
<p >In Regina's <a class="el" href="stddim.html">standard dimensions</a>, where triangulations also support an <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> operation, this routine is a loose converse of that operation.</p>
<p >In dimension 2, every boundary component is spherical and so this routine simply fills all the punctures in the underlying surface. (In dimension 2, triangulations cannot have cusps).</p>
<dl class="section warning"><dt>Warning</dt><dd>If a real boundary component contains vertices whose links are not discs, this operation may have unexpected results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a id="af0cf09bfb6bc4e6f82db1466b3765b97" name="af0cf09bfb6bc4e6f82db1466b3765b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cf09bfb6bc4e6f82db1466b3765b97">&#9670;&nbsp;</a></span>fourFourMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fourFourMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 4-4 move about the given edge. </p>
<p >This involves replacing the four tetrahedra joined at that edge with four tetrahedra joined along a different edge. Consider the octahedron made up of the four original tetrahedra; this has three internal axes. The initial four tetrahedra meet along the given edge which forms one of these axes; the new tetrahedra will meet along a different axis. This move can be done iff (i) the edge is valid and non-boundary, and (ii) the four tetrahedra are distinct.</p>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this 4-4 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">newAxis</td><td>Specifies which axis of the octahedron the new tetrahedra should meet along; this should be 0 or 1. Consider the four original tetrahedra in the order described by Edge&lt;3&gt;::embedding(0,...,3); call these tetrahedra 0, 1, 2 and<ol type="1">
<li>If <em>newAxis</em> is 0, the new axis will separate tetrahedra 0 and 1 from 2 and 3. If <em>newAxis</em> is 1, the new axis will separate tetrahedra 1 and 2 from 3 and 0. </li>
</ol>
</td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="af25408f7eb0b1c5bc3a87b1e93e7d0d2" name="af25408f7eb0b1c5bc3a87b1e93e7d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25408f7eb0b1c5bc3a87b1e93e7d0d2">&#9670;&nbsp;</a></span>fromGluings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromGluings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>beginGluings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>endGluings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a triangulation from a list of gluings. </p>
<p >This routine is an analogue to the variant of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">fromGluings()</a> that takes a C++ initialiser list; however, here the input data may be constructed at runtime (which makes it accessible to Python, amongst other things).</p>
<p >The iterator range (<em>beginGluings</em>, <em>endGluings</em>) should encode the list of gluings for the triangulation. Each iterator in this range must dereference to a tuple of the form (<em>simp</em>, <em>facet</em>, <em>adj</em>, <em>gluing</em>); here <em>simp</em>, <em>facet</em> and <em>adj</em> are all integers, and <em>gluing</em> is of type <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;. Each such tuple indicates that facet <em>facet</em> of top-dimensional simplex number <em>simp</em> should be glued to top-dimensional simplex number <em>adj</em> using the permutation <em>gluing</em>. In other words, such a tuple encodes the same information as calling <code>simplex(simp).join(facet, simplex(adj), gluing)</code> upon the triangulation being constructed.</p>
<p >Every gluing should be encoded from <em>one direction only</em>. This means, for example, that to build a closed 3-manifold triangulation with <em>n</em> tetrahedra, you would pass a list of 2<em>n</em> such tuples. If you attempt to make the same gluing twice (e.g., once from each direction), then this routine will throw an exception.</p>
<p >Any facet of a simplex that does not feature in the given list of gluings (either as a source or a destination) will be left as a boundary facet.</p>
<p >Note that, as usual, the top-dimensional simplices are numbered 0,...,(<em>size</em>-1), and the facets of each simplex are numbered 0,...,<em>dim</em>.</p>
<p >As an example, Python users can construct the figure eight knot complement as follows:</p>
<div class="fragment"><div class="line">tri = Triangulation3.fromGluings(2, [</div>
<div class="line">    ( 0, 0, 1, Perm4(1,3,0,2) ), ( 0, 1, 1, Perm4(2,0,3,1) ),</div>
<div class="line">    ( 0, 2, 1, Perm4(0,3,2,1) ), ( 0, 3, 1, Perm4(2,1,0,3) )])</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The assumption is that the iterators dereference to a std::tuple&lt;size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;&gt;. However, this is not strictly necessary - the dereferenced type may be any type that supports std::get (and for which std::get&lt;0..3&gt;() yields suitable integer/permutation types).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given list of gluings does not correctly describe a triangulation with <em>size</em> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The gluings should be passed as a single Python list of tuples (not an iterator pair).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of top-dimensional simplices in the triangulation to construct. </td></tr>
    <tr><td class="paramname">beginGluings</td><td>the beginning of the list of gluings, as described above. </td></tr>
    <tr><td class="paramname">endGluings</td><td>a past-the-end iterator indicating the end of the list of gluings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="ad91567ffbe224dcd1f1da3cb273efe49" name="ad91567ffbe224dcd1f1da3cb273efe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91567ffbe224dcd1f1da3cb273efe49">&#9670;&nbsp;</a></span>fromGluings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromGluings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>gluings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a triangulation from a hard-coded list of gluings. </p>
<p >This routine takes a C++ initialiser list, which makes it useful for creating hard-coded examples directly in C++ code without needing to write a tedious sequence of calls to <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">Simplex&lt;dim&gt;::join()</a>.</p>
<p >Each element of the initialiser list should be a tuple of the form (<em>simp</em>, <em>facet</em>, <em>adj</em>, <em>gluing</em>), which indicates that facet <em>facet</em> of top-dimensional simplex number <em>simp</em> should be glued to top-dimensional simplex number <em>adj</em> using the permutation <em>gluing</em>. In other words, such a tuple encodes the same information as calling <code>simplex(simp).join(facet, simplex(adj), gluing)</code> upon the triangulation being constructed.</p>
<p >Every gluing should be encoded from <em>one direction only</em>. This means, for example, that to build a closed 3-manifold triangulation with <em>n</em> tetrahedra, you would pass a list of 2<em>n</em> such tuples. If you attempt to make the same gluing twice (e.g., once from each direction), then this routine will throw an exception.</p>
<p >Any facet of a simplex that does not feature in the given list of gluings (either as a source or a destination) will be left as a boundary facet.</p>
<p >Note that, as usual, the top-dimensional simplices are numbered 0,...,(<em>size</em>-1), and the facets of each simplex are numbered 0,...,<em>dim</em>.</p>
<p >As an example, you can construct the figure eight knot complement using the following code:</p>
<div class="fragment"><div class="line">Triangulation&lt;3&gt; tri = <a class="code hl_function" href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49">Triangulation&lt;3&gt;::fromGluings</a>(2, {</div>
<div class="line">    { 0, 0, 1, {1,3,0,2} }, { 0, 1, 1, {2,0,3,1} },</div>
<div class="line">    { 0, 2, 1, {0,3,2,1} }, { 0, 3, 1, {2,1,0,3} }});</div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_ad91567ffbe224dcd1f1da3cb273efe49"><div class="ttname"><a href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49">regina::detail::TriangulationBase::fromGluings</a></div><div class="ttdeci">static Triangulation&lt; dim &gt; fromGluings(size_t size, std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, Perm&lt; dim+1 &gt; &gt; &gt; gluings)</div><div class="ttdoc">Creates a triangulation from a hard-coded list of gluings.</div><div class="ttdef"><b>Definition:</b> triangulation.h:4155</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you have an existing triangulation that you would like to hard-code in this way, you can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ace7c9ec1168ef9e7cb34b3e4a5b9b873" title="Returns C++ code that can be used to reconstruct this triangulation.">dumpConstruction()</a> to generate the corresponding C++ source code.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given list of gluings does not correctly describe a triangulation with <em>size</em> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the variant of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">fromGluings()</a> that takes this same data using a Python list (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of top-dimensional simplices in the triangulation to construct. </td></tr>
    <tr><td class="paramname">gluings</td><td>describes the gluings between these top-dimensional simplices, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="af91da7bdae05981c20c2e3ee234cc48d" name="af91da7bdae05981c20c2e3ee234cc48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91da7bdae05981c20c2e3ee234cc48d">&#9670;&nbsp;</a></span>fromIsoSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromIsoSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a full triangulation from an isomorphism signature. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p >Currently this routine only supports isomorphism signatures that were created with the default encoding (i.e., there was no <em>Encoding</em> template parameter passed to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>).</p>
<p >Calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> followed by <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> is not guaranteed to produce an <em>identical</em> triangulation to the original, but it is guaranteed to produce a combinatorially <em>isomorphic</em> triangulation. In other words, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> may reconstruct the triangulation with its simplices and/or vertices relabelled. The optional argument to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> allows you to determine the precise relabelling that will be used, if you need to know it.</p>
<p >For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid <em>dim</em>-dimensional isomorphism signature created using the default encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signatures are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="a776984602dd80817c160e797aeca67c3" name="a776984602dd80817c160e797aeca67c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776984602dd80817c160e797aeca67c3">&#9670;&nbsp;</a></span>fromSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, to recover a full triangulation from an isomorphism signature. </p>
<p >This alias <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a776984602dd80817c160e797aeca67c3" title="Alias for fromIsoSig(), to recover a full triangulation from an isomorphism signature.">fromSig()</a> is provided to assist with generic code that can work with both triangulations and links.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid <em>dim</em>-dimensional isomorphism signature created using the default encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signatures are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="a8bfbd0b4f36b096210d77a56526d7024" name="a8bfbd0b4f36b096210d77a56526d7024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfbd0b4f36b096210d77a56526d7024">&#9670;&nbsp;</a></span>fromSnapPea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fromSnapPea </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>snapPeaData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file. </p>
<p >All other SnapPea-specific information (such as peripheral curves, and the manifold name) will be ignored, since Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class does not track such information itself.</p>
<p >If you wish to preserve all SnapPea-specific information from the data file, you should work with the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class instead (which uses the SnapPea kernel directly, and can therefore store anything that SnapPea can).</p>
<p >If you wish to read a triangulation from a SnapPea <em>file</em>, you should likewise call the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> constructor, giving the filename as argument. This will read all SnapPea-specific information (as described above), and also avoids constructing an enormous intermediate string.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is "lossy", in that drops SnapPea-specific information (as described above). Unless you specifically need an <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (not an <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>) or you need to avoid calling routines from the SnapPea kernel, it is highly recommended that you create a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> from the given file contents instead. See the string-based <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> constructor for how to do this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given SnapPea data was not in the correct format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snapPeaData</td><td>a string containing the full contents of a SnapPea data file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a native Regina triangulation extracted from the given SnapPea data. </dd></dl>

</div>
</div>
<a id="a408718df2c6cc65f21adabc50850ec63" name="a408718df2c6cc65f21adabc50850ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408718df2c6cc65f21adabc50850ec63">&#9670;&nbsp;</a></span>fundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fundamentalGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>, which returns the fundamental group of this triangulation. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for further details, including how ideal vertices and invalid faces are managed.</p>
<dl class="section note"><dt>Note</dt><dd>In Regina 7.2, the routine <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> was renamed to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for brevity and for consistency with <a class="el" href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the group of this link; that is, the fundamental group of the link exterior.">Link::group()</a>. This more expressive name <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> will be kept as a long-term alias, and you are welcome to continue using it if you prefer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute the fundamental group with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::fundamentalGroupFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a id="a8486cf851a69f057505860cda7a92a65" name="a8486cf851a69f057505860cda7a92a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8486cf851a69f057505860cda7a92a65">&#9670;&nbsp;</a></span>fundamentalGroupFilled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::SnapPeaTriangulation::fundamentalGroupFilled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplifyPresentation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillingsMayAffectGenerators</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minimiseNumberOfGenerators</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tryHardToShortenRelators</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fundamental group of the manifold with respect to the current Dehn filling (if any). </p>
<p >Any complete cusps (without fillings) will be treated as though they had been truncated.</p>
<p >This is different from the inherited <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> routine (and its alias <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a>) from the parent <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class:</p>
<ul>
<li>This routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">fundamentalGroupFilled()</a> respects Dehn fillings, and directly uses SnapPea's code to compute fundamental groups.</li>
<li>The inherited <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> routine uses only Regina's code, and works purely within Regina's parent <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class. Since <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> knows nothing about SnapPea or fillings, this means that any fillings on the cusps (which are specific to SnapPea triangulations) will be ignored.</li>
</ul>
<p >Note that each time the triangulation changes, the fundamental group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">fundamentalGroupFilled()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplifyPresentation</td><td><code>true</code> if SnapPea should attempt to simplify the group presentation, or <code>false</code> if it should be left unsimplified. Even if <em>simplifyPresentation</em> is <code>false</code>, this routine will always eliminate adjacent (x, x^-1) pairs. </td></tr>
    <tr><td class="paramname">fillingsMayAffectGenerators</td><td><code>true</code> if SnapPea's choice of generators is allowed to depend on the Dehn fillings, or <code>false</code> if the choice of generators should be consistent across different fillings. </td></tr>
    <tr><td class="paramname">minimiseNumberOfGenerators</td><td><code>true</code> if SnapPea's group simplification code should try to reduce the number of generators at the expense of increasing the total length of the relations, or <code>false</code> if it should do the opposite. </td></tr>
    <tr><td class="paramname">tryHardToShortenRelators</td><td><code>true</code> if SnapPea's group simplification code should try to reduce the length of the relations by inserting one relation into another. In general this is a good thing, but it can be very costly for large presentations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group of the filled manifold. </dd></dl>

</div>
</div>
<a id="ad5c48ed1736e27aa09620cd924507ef4" name="ad5c48ed1736e27aa09620cd924507ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c48ed1736e27aa09620cd924507ef4">&#9670;&nbsp;</a></span>fVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the f-vector of this triangulation, which counts the number of faces of all dimensions. </p>
<p >The vector that is returned will have length <em>dim</em>+1. If this vector is <em>f</em>, then <em>f</em>[<em>k</em>] will be the number of <em>k</em>-faces for each 0 ≤ <em>k</em> ≤ <em>dim</em>.</p>
<p >This routine is significantly more heavyweight than <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>. Its advantage is that, unlike the templatised <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>, it allows you to count faces whose dimensions are not known until runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>the f-vector of this triangulation. </dd></dl>

</div>
</div>
<a id="aff19565dafd9d6b64e4d0e99cdf54d36" name="aff19565dafd9d6b64e4d0e99cdf54d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff19565dafd9d6b64e4d0e99cdf54d36">&#9670;&nbsp;</a></span>generalAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::generalAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a generalised angle structure on this triangulation, if one exists. </p>
<p >A <em>generalised</em> angle structure must satisfy the same matching equations as all angle structures do, but there is no constraint on the signs of the angles; in particular, negative angles are allowed. If a generalised angle structure does exist, then this routine is guaranteed to return one.</p>
<p >This routine is designed for scenarios where you already know that a generalised angle structure exists. This means:</p>
<ul>
<li>If no generalised angle structure exists, this routine will throw an exception, which will incur a significant overhead.</li>
<li>It should be rare that you do not know in advance whether a generalised angle structure exists (see the simple conditions in the note below). However, if you don't yet know, you should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9c7a09adb86c472b9764f2f553b03b07" title="Determines whether this triangulation supports a generalised angle structure.">hasGeneralAngleStructure()</a> first. If the answer is no, this will avoid the overhead of throwing and catching exceptions. If the answer is yes, this will have the side-effect of caching the angle structure, which means your subsequent call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36" title="Returns a generalised angle structure on this triangulation, if one exists.">generalAngleStructure()</a> will be essentially instantaneous.</li>
</ul>
<p >The underlying algorithm simply solves a system of linear equations, and so should be fast even for large triangulations.</p>
<p >The result of this routine is cached internally: as long as the triangulation does not change, multiple calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36" title="Returns a generalised angle structure on this triangulation, if one exists.">generalAngleStructure()</a> will return identical angle structures, and every call after the first be essentially instantaneous.</p>
<p >If the triangulation does change, however, then the cached angle structure will be deleted, and any reference that was returned before will become invalid.</p>
<dl class="section note"><dt>Note</dt><dd>For a valid triangulation with no boundary faces, a generalised angle structure exists if and only if every vertex link is a torus or Klein bottle. The "only if" direction is a simple Euler characteristic calculation; for the "if" direction see "Angle structures and normal surfaces", Feng Luo and Stephan Tillmann, Trans. Amer. Math. Soc. 360:6 (2008), pp. 2849-2866).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NoSolution.html" title="An exception thrown when Regina has certified that a mathematical problem has no solution.">NoSolution</a></td><td>No generalised angle structure exists on this triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a generalised angle structure on this triangulation, if one exists. </dd></dl>

</div>
</div>
<a id="a5fe3a28d577944678d29bbd727d8268b" name="a5fe3a28d577944678d29bbd727d8268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe3a28d577944678d29bbd727d8268b">&#9670;&nbsp;</a></span>gluingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> regina::SnapPeaTriangulation::gluingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix describing Thurston's gluing equations. </p>
<p >This will be with respect to the current Dehn filling (if any).</p>
<p >Each row of this matrix will describe a single equation. The first <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f" title="A dimension-specific alias for countFaces&lt;1&gt;().">countEdges()</a> rows will list the edge equations, and the following 2 * <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aec4b3badd67a8ccb5ec0111d5c995e19" title="Returns the total number of complete cusps (that is, unfilled cusps).">countCompleteCusps()</a> + <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a3666f1827e93752400941de349992d1f" title="Returns the total number of filled cusps.">countFilledCusps()</a> rows will list the cusp equations.</p>
<p >The edge equations will be ordered arbitrarily. The cusp equations will be presented in pairs ordered by cusp index (as stored by SnapPea); within each pair the meridian equation will appear before the longitude equation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</p>
<p >The matrix will contain <code>3 * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a></code> columns. The first three columns represent shape parameters <code>z</code>, <code>1/(1-z)</code> and <code>(z-1)/z</code> for the first tetrahedron; the next three columns represent shape parameters <code>z</code>, <code>1/(1-z)</code> and <code>(z-1)/z</code> for the second tetrahedron, and so on. By Regina's edge numbering conventions, <code>z</code> corresponds to edges 0 and 5 of the tetrahedron, <code>1/(1-z)</code> corresponds to edges 1 and 4 of the tetrahedron, and <code>(z-1)/z</code> corresponds to edges 2 and 3 of the tetrahedron.</p>
<p >More specifically, a row of the form <code>a b c d e f ...</code> describes an equation with left hand side <code>a log(z0) + b log(1/(1-z0)) + c log((z0-1)/z) + d log(z1) + ...</code>, and with right hand side <code>2πi</code> for an edge equation or 0 for a cusp equation.</p>
<p >See also <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a371e781e24d1fa15a599ac0dda941d9d" title="Returns a matrix describing Thurston&#39;s gluing equations in a streamlined form.">gluingEquationsRect()</a>, which returns the gluing equations in a more streamlined form.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.gluing_equations()</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix with (<em>number_of_rows</em> + <em>number_of_cusps</em>) rows and (3 * <em>number_of_tetrahedra</em>) columns as described above. </dd></dl>

</div>
</div>
<a id="a371e781e24d1fa15a599ac0dda941d9d" name="a371e781e24d1fa15a599ac0dda941d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e781e24d1fa15a599ac0dda941d9d">&#9670;&nbsp;</a></span>gluingEquationsRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> regina::SnapPeaTriangulation::gluingEquationsRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix describing Thurston's gluing equations in a streamlined form. </p>
<p >This will be with respect to the current Dehn filling (if any).</p>
<p >Each row of this matrix will describe a single equation. The rows begin with the edge equations (in arbitrary order) followed by the cusp equations (ordered by cusp index); for precise details see the documentation for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a5fe3a28d577944678d29bbd727d8268b" title="Returns a matrix describing Thurston&#39;s gluing equations.">gluingEquations()</a>, which uses the same ordering.</p>
<p >The matrix will contain <code>2 * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a> + 1</code> columns. Let <em>k</em> = <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1, and suppose the shape parameters for tetrahedra 0, 1, ..., k are <em>z0</em>, <em>z1</em>, ..., <em>zk</em> (here each shape parameter corresponds to edges 0 and 5 of the corresponding tetrahedron). Then a row of the form <code>a0 a1 ... ak b0 b1 ... bk c</code> describes the equation <code>z0^a0 z1^a1 ... zk^ak (1-z0)^b0 (1-z1)^b1 ... (1-zk)^bk = c</code>, where <em>c</em> will always be 1 or -1.</p>
<p >See also <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a5fe3a28d577944678d29bbd727d8268b" title="Returns a matrix describing Thurston&#39;s gluing equations.">gluingEquations()</a>, which returns the gluing equations in a more transparent term-by-term form.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.gluing_equations(form="rect")</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix with (<em>number_of_rows</em> + <em>number_of_cusps</em>) rows and (2 * <em>number_of_tetrahedra</em> + 1) columns as described above. </dd></dl>

</div>
</div>
<a id="a419c0f6e468ad24cfc450775c6a19b81" name="a419c0f6e468ad24cfc450775c6a19b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c0f6e468ad24cfc450775c6a19b81">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fundamental group of this triangulation. </p>
<p >The fundamental group is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the fundamental group will be calculated as if each such vertex had been truncated.</li>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the fundamental group will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the fundamental group will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> might change.</li>
</ul>
<p >Bear in mind that each time the triangulation changes, the fundamental group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<p >Before Regina 7.2, this routine was called <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a>. It has since been renamed to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for brevity and for consistency with <a class="el" href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the group of this link; that is, the fundamental group of the link exterior.">Link::group()</a>. The more expressive name <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> will be kept, and you are welcome to use that instead if you prefer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute the fundamental group with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::fundamentalGroupFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a id="a5ffca92f7a401c3beb7a603d997a088e" name="a5ffca92f7a401c3beb7a603d997a088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffca92f7a401c3beb7a603d997a088e">&#9670;&nbsp;</a></span>hasBoundaryFacets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation has any boundary facets. </p>
<p >This routine returns <code>true</code> if and only if the triangulation contains some top-dimension simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there are boundary facets. </dd></dl>

</div>
</div>
<a id="a47ae349fb76332c8202c1eebd643b569" name="a47ae349fb76332c8202c1eebd643b569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae349fb76332c8202c1eebd643b569">&#9670;&nbsp;</a></span>hasBoundaryTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasBoundaryTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5ffca92f7a401c3beb7a603d997a088e" title="Determines if this triangulation has any boundary facets.">hasBoundaryFacets()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5ffca92f7a401c3beb7a603d997a088e" title="Determines if this triangulation has any boundary facets.">hasBoundaryFacets()</a> for further information. </p>

</div>
</div>
<a id="a3f6b6645fdc68b91645acda38cedb2a8" name="a3f6b6645fdc68b91645acda38cedb2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6b6645fdc68b91645acda38cedb2a8">&#9670;&nbsp;</a></span>hasCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a compressing disc within the underlying 3-manifold. </p>
<p >Let <em>M</em> be the underlying 3-manifold and let <em>B</em> be its boundary. By a <em>compressing disc</em>, we mean a disc <em>D</em> properly embedded in <em>M</em>, where the boundary of <em>D</em> lies in <em>B</em> but does not bound a disc in <em>B</em>.</p>
<p >This routine will first call the heuristic routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">hasSimpleCompressingDisc()</a> in the hope of obtaining a fast answer. If this fails, it will do one of two things:</p>
<ul>
<li>If the triangulation is orientable and 1-vertex, it will use the linear programming and crushing machinery outlined in "Computing closed essential surfaces in knot complements", Burton, Coward and Tillmann, SCG '13, p405-414, 2013. This is often extremely fast, even for triangulations with many tetrahedra.</li>
<li>If the triangulation is non-orientable or has multiple vertices then it will run a full enumeration of vertex normal surfaces, as described in "Algorithms for the
  complete decomposition of a closed 3-manifold", Jaco and Tollefson, Illinois J. Math. 39 (1995), 358-406. As the number of tetrahedra grows, this can become extremely slow.</li>
</ul>
<p >This routine will work on a copy of this triangulation, not the original. In particular, the copy will be simplified, which means that there is no harm in calling this routine on an unsimplified triangulation.</p>
<p >If this triangulation has no boundary components, this routine will simply return <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal. </dd>
<dd>
The underlying 3-manifold is irreducible.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine can be infeasibly slow for large triangulations (particularly those that are non-orientable or have multiple vertices), since it may need to perform a full enumeration of vertex normal surfaces, and since it might perform "large" operations on these surfaces such as cutting along them. See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">hasSimpleCompressingDisc()</a> for a "heuristic shortcut" that is faster but might not give a definitive answer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying 3-manifold contains a compressing disc, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="a9c7a09adb86c472b9764f2f553b03b07" name="a9c7a09adb86c472b9764f2f553b03b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7a09adb86c472b9764f2f553b03b07">&#9670;&nbsp;</a></span>hasGeneralAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasGeneralAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation supports a generalised angle structure. </p>
<p >A <em>generalised</em> angle structure must satisfy the same matching equations as all angle structures do, but there is no constraint on the signs of the angles; in particular, negative angles are allowed.</p>
<p >This routine returns <code>false</code> if and only if <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36" title="Returns a generalised angle structure on this triangulation, if one exists.">generalAngleStructure()</a> throws an exception. However, if you do not <em>know</em> whether a generalised angle structure exists, then this routine is faster:</p>
<ul>
<li>If there is <em>no</em> generalised angle structure, this routine will avoid the overhead of throwing and catching exceptions.</li>
<li>If there <em>is</em> a generalised angle structure, this routine will find and cache this angle structure, which means that any subsequent call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36" title="Returns a generalised angle structure on this triangulation, if one exists.">generalAngleStructure()</a> to retrieve its details will be essentially instantaneous.</li>
</ul>
<p >The underlying algorithm simply solves a system of linear equations, and so should be fast even for large triangulations.</p>
<dl class="section note"><dt>Note</dt><dd>For a valid triangulation with no boundary faces, a generalised angle structure exists if and only if every vertex link is a torus or Klein bottle. The "only if" direction is a simple Euler characteristic calculation; for the "if" direction see "Angle structures and normal surfaces", Feng Luo and Stephan Tillmann, Trans. Amer. Math. Soc. 360:6 (2008), pp. 2849-2866).</dd>
<dd>
Even if the condition above is true and it is clear that a generalised angle structure should exist, this routine will still do the extra work to compute an explicit solution (in order to fulfil the promise made in the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aff19565dafd9d6b64e4d0e99cdf54d36" title="Returns a generalised angle structure on this triangulation, if one exists.">generalAngleStructure()</a> documentation).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a generalised angle structure exists on this triangulation. </dd></dl>

</div>
</div>
<a id="a5be01e573b97c0bfdbc34a2da2b97a6f" name="a5be01e573b97c0bfdbc34a2da2b97a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be01e573b97c0bfdbc34a2da2b97a6f">&#9670;&nbsp;</a></span>hasMinimalBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasMinimalBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the boundary of this triangulation contains the smallest possible number of triangles. </p>
<p >This is true if and only if, amongst all real boundary components, every sphere or projective plane boundary component has precisely two triangles, and every other boundary component has precisely one vertex.</p>
<p >For the purposes of this routine, ideal boundary components are ignored.</p>
<p >If this routine returns <code>false</code>, you can call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a> to make the number of boundary triangles minimal.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the boundary contains the smallest possible number of triangles. </dd></dl>

</div>
</div>
<a id="af8d6f6483a5b84bf99f671c63df34b73" name="af8d6f6483a5b84bf99f671c63df34b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d6f6483a5b84bf99f671c63df34b73">&#9670;&nbsp;</a></span>hasMinimalVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasMinimalVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation contains the smallest possible number of vertices for the 3-manifold that it represents. </p>
<p >This is true if and only if:</p>
<ul>
<li>amongst all real boundary components, every sphere or projective plane boundary component has precisely two triangles, and every other boundary component has precisely one vertex;</li>
<li>amongst all connected components, every closed component has precisely one vertex, and every component with real or ideal boundary has no internal vertices at all.</li>
</ul>
<p >If this routine returns <code>false</code>, you can call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> to make the number of vertices minimal.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation contains the smallest possible number of vertices. </dd></dl>

</div>
</div>
<a id="aafcccbe5dab59415beab467a51fdab22" name="aafcccbe5dab59415beab467a51fdab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcccbe5dab59415beab467a51fdab22">&#9670;&nbsp;</a></span>hasNegativeIdealBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasNegativeIdealBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation contains any ideal boundary components with negative Euler characteristic. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is at least one such boundary component. </dd></dl>

</div>
</div>
<a id="a31d8cba1fae2b39de379ff6c8df4d61c" name="a31d8cba1fae2b39de379ff6c8df4d61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d8cba1fae2b39de379ff6c8df4d61c">&#9670;&nbsp;</a></span>hasSimpleCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasSimpleCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a "simple" compressing disc inside this triangulation. </p>
<p >Let <em>M</em> be the underlying 3-manifold and let <em>B</em> be its boundary. By a <em>compressing disc</em>, we mean a disc <em>D</em> properly embedded in <em>M</em>, where the boundary of <em>D</em> lies in <em>B</em> but does not bound a disc in <em>B</em>.</p>
<p >By a <em>simple</em> compressing disc, we mean a compressing disc that has a very simple combinatorial structure (here "simple" is subject to change; see the warning below). Examples include the compressing disc inside a 1-tetrahedron solid torus, or a compressing disc formed from a single internal triangle surrounded by three boundary edges.</p>
<p >The purpose of this routine is to avoid working with normal surfaces within a large triangulation where possible. This routine is relatively fast, and if it returns <code>true</code> then this 3-manifold definitely contains a compressing disc. If this routine returns <code>false</code> then there might or might not be a compressing disc; the user will need to perform a full normal surface enumeration using <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> to be sure.</p>
<p >This routine will work on a copy of this triangulation, not the original. In particular, the copy will be simplified, which means that there is no harm in calling this routine on an unsimplified triangulation.</p>
<p >If this triangulation has no boundary components, this routine will simply return <code>false</code>.</p>
<p >For further information on this test, see "The Weber-Seifert
dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<dl class="section warning"><dt>Warning</dt><dd>The definition of "simple" is subject to change in future releases of Regina. That is, this routine may be expanded over time to identify more types of compressing discs (thus making it more useful as a "heuristic shortcut").</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a simple compressing disc was found, or <code>false</code> if not. Note that even with a return value of <code>false</code>, there might still be a compressing disc (just not one with a simple combinatorial structure). </dd></dl>

</div>
</div>
<a id="a5d92d88a4a00fee457751e054e0ae4f7" name="a5d92d88a4a00fee457751e054e0ae4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d92d88a4a00fee457751e054e0ae4f7">&#9670;&nbsp;</a></span>hasSplittingSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasSplittingSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation has a normal splitting surface. </p>
<p >See <a class="el" href="classregina_1_1NormalSurface.html#a330f08b68053b89d2545c0027bbc3405" title="Determines whether or not this surface is a splitting surface.">NormalSurface::isSplitting()</a> for details regarding normal splitting surfaces.</p>
<p >In the special case where this is the empty triangulation, this routine returns <code>false</code>.</p>
<p >As of Regina 6.0, this routine is now fast (small polynomial time), and works even for triangulations with more than one connected component. Thanks to Robert Haraway.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation has a normal splitting surface. </dd></dl>

</div>
</div>
<a id="acf9d01479e8abe3e6759f13b66babb9c" name="acf9d01479e8abe3e6759f13b66babb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d01479e8abe3e6759f13b66babb9c">&#9670;&nbsp;</a></span>hasStrictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasStrictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation supports a strict angle structure. </p>
<p >Recall that a <em>strict</em> angle structure is one in which every angle is strictly between 0 and π.</p>
<p >This routine returns <code>false</code> if and only if <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22" title="Returns a strict angle structure on this triangulation, if one exists.">strictAngleStructure()</a> throws an exception. However, if you do not <em>know</em> whether a strict angle structure exists, then this routine is faster:</p>
<ul>
<li>If there is <em>no</em> strict angle structure, this routine will avoid the overhead of throwing and catching exceptions.</li>
<li>If there <em>is</em> a strict angle structure, this routine will find and cache this angle structure, which means that any subsequent call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22" title="Returns a strict angle structure on this triangulation, if one exists.">strictAngleStructure()</a> to retrieve its details will be essentially instantaneous.</li>
</ul>
<p >The underlying algorithm runs a single linear program (it does <em>not</em> enumerate all vertex angle structures). This means that it is likely to be fast even for large triangulations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a strict angle structure exists on this triangulation. </dd></dl>

</div>
</div>
<a id="a46851fcdaca6a86afe44b9fd185d0c1b" name="a46851fcdaca6a86afe44b9fd185d0c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46851fcdaca6a86afe44b9fd185d0c1b">&#9670;&nbsp;</a></span>hasTwoSphereBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasTwoSphereBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation contains any two-sphere boundary components. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is at least one two-sphere boundary component. </dd></dl>

</div>
</div>
<a id="a34a72bfac6207c6ac044d98cd6ec2081" name="a34a72bfac6207c6ac044d98cd6ec2081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a72bfac6207c6ac044d98cd6ec2081">&#9670;&nbsp;</a></span>homology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>homology&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>homology(subdim)</code>.</p>
<p >See the non-templated homology(int) for full details on exactly what this function computes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Unless you are computing first homology (<em>k</em> = 1), this triangulation must be valid, and every face that is not a vertex must have a ball or sphere link. The link condition already forms part of the validity test if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, but in higher dimensions it is the user's own responsibility to ensure this. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid, and the homology dimension <em>k</em> is not 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>homology(k)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to return; this must be between 1 and (<em>dim</em> - 1) inclusive if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, or between 1 and (<em>dim</em> - 2) inclusive if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group. </dd></dl>

</div>
</div>
<a id="adbb67028a0ade026c03ffdc4665f2871" name="adbb67028a0ade026c03ffdc4665f2871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb67028a0ade026c03ffdc4665f2871">&#9670;&nbsp;</a></span>homology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homology </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated, where the parameter <em>k</em> does not need to be known until runtime. </p>
<p >For C++ programmers who know <em>k</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology&lt;k&gt;()</a> instead, which is slightly faster.</p>
<p >A problem with computing homology is that, if <em>dim</em> is not one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, then Regina cannot actually <em>detect</em> ideal vertices (since in general this requires solving undecidable problems). Currently we resolve this by insisting that, in higher dimensions, the homology dimension <em>k</em> is at most (<em>dim</em>-2); the underlying algorithm will then effectively truncate <em>all</em> vertices (since truncating "ordinary" vertices whose links are spheres or balls does not affect the <em>k</em>th homology in such cases).</p>
<p >In general, this routine insists on working with a valid triangulation (see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for what this means). However, for historical reasons, if you are computing first homology (<em>k</em> = 1) then your triangulation is allowed to be invalid, though the results might or might not be useful to you. The homology will be computed using the dual skeleton: what this means is that any invalid faces of dimension 0,1,...,(<em>dim</em>-3) will be treated as though their centroids had been truncated, but any invalid (<em>dim</em>-2)-faces will be treated <em>without</em> such truncation. A side-effect is that, after performing a barycentric on an invalid triangulation, the group returned by <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology&lt;1&gt;()</a> might change.</p>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute homology with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::homologyFilled()</a> instead.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Unless you are computing first homology (<em>k</em> = 1), this triangulation must be valid, and every face that is not a vertex must have a ball or sphere link. The link condition already forms part of the validity test if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, but in higher dimensions it is the user's own responsibility to ensure this. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid, and the homology dimension <em>k</em> is not 1.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The homology dimension <em>k</em> is outside the supported range. This range depends upon the triangulation dimension <em>dim</em>; for details see the documentation below for the argument <em>k</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Like the C++ template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology&lt;k&gt;()</a>, you can omit the homology dimension <em>k</em>; this will default to 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to return; this must be between 1 and (<em>dim</em> - 1) inclusive if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, or between 1 and (<em>dim</em> - 2) inclusive if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group. </dd></dl>

</div>
</div>
<a id="ab3952258a66287d9efc752eb338f6626" name="ab3952258a66287d9efc752eb338f6626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3952258a66287d9efc752eb338f6626">&#9670;&nbsp;</a></span>homologyBdry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyBdry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first homology group of the boundary for this triangulation. </p>
<p >Note that ideal vertices are considered part of the boundary.</p>
<p >Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab3952258a66287d9efc752eb338f6626" title="Returns the first homology group of the boundary for this triangulation.">homologyBdry()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<p >This routine is fairly fast, since it deduces the homology of each boundary component through knowing what kind of surface it is.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of the boundary. </dd></dl>

</div>
</div>
<a id="a6347d1e9433a27bd969049d8ca8ef01d" name="a6347d1e9433a27bd969049d8ca8ef01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6347d1e9433a27bd969049d8ca8ef01d">&#9670;&nbsp;</a></span>homologyFilled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::SnapPeaTriangulation::homologyFilled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first homology group of the manifold with respect to the current Dehn filling (if any). </p>
<p >Any complete cusps (without fillings) will be treated as though they had been truncated.</p>
<p >This is different from the inherited <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a> routine from the parent <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class:</p>
<ul>
<li>This routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">homologyFilled()</a> respects Dehn fillings, and uses a combination of both SnapPea's and Regina's code to compute homology groups. There may be situations in which the SnapPea kernel cannot perform its part of the computation (see below), in which case this routine will throw a <a class="el" href="classregina_1_1SnapPeaUnsolvedCase.html" title="An exception thrown when the SnapPea kernel is not able to perform some computation.">SnapPeaUnsolvedCase</a> exception.</li>
<li>The inherited <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a> routine uses only Regina's code, and works purely within Regina's parent <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class. Since <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> knows nothing about SnapPea or fillings, this means that any fillings on the cusps (which are specific to SnapPea triangulations) will be ignored. The <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a> routine will always return a solution.</li>
</ul>
<p >This routine uses exact arithmetic, and so you are guaranteed that - if it returns a result at all - that this result does not suffer from integer overflows. Essentially, the process is this:</p>
<ul>
<li>SnapPea constructs a filled relation matrix using machine integer arithmetic, but detects overflow (in which case this routine will throw an exception);</li>
<li>Regina then uses exact integer arithmetic to solve for the abelian group invariants (i.e., Smith normal form).</li>
</ul>
<p >Note that each time the triangulation changes, the homology group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">homologyFilled()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaUnsolvedCase.html" title="An exception thrown when the SnapPea kernel is not able to perform some computation.">SnapPeaUnsolvedCase</a></td><td>SnapPea detected an overflow when attempting to create the filled relation matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of the filled manifold. </dd></dl>

</div>
</div>
<a id="a86c0948923311085b2d5c0bb61a6ab95" name="a86c0948923311085b2d5c0bb61a6ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c0948923311085b2d5c0bb61a6ab95">&#9670;&nbsp;</a></span>homologyH2Z2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyH2Z2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the second homology group with coefficients in Z_2 for this triangulation. </p>
<p >If this triangulation contains any ideal vertices, the homology group will be calculated as if each such vertex had been truncated. The algorithm used calculates the relative first homology group with respect to the boundary and uses homology and cohomology theorems to deduce the second homology group.</p>
<p >This group will simply be the direct sum of several copies of Z_2, so the number of Z_2 terms is returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of Z_2 terms in the second homology group with coefficients in Z_2. </dd></dl>

</div>
</div>
<a id="a6527c268fe007510be5ffd8d99509f62" name="a6527c268fe007510be5ffd8d99509f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6527c268fe007510be5ffd8d99509f62">&#9670;&nbsp;</a></span>homologyRel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyRel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the relative first homology group with respect to the boundary for this triangulation. </p>
<p >Note that ideal vertices are considered part of the boundary.</p>
<p >Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6527c268fe007510be5ffd8d99509f62" title="Returns the relative first homology group with respect to the boundary for this triangulation.">homologyRel()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the relative first homology group with respect to the boundary. </dd></dl>

</div>
</div>
<a id="ac025b93b99f5b674fd448e6374c81142" name="ac025b93b99f5b674fd448e6374c81142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac025b93b99f5b674fd448e6374c81142">&#9670;&nbsp;</a></span>idealToFinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::idealToFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an ideal triangulation into a finite triangulation. </p>
<p >All ideal or invalid vertices are truncated and thus converted into real boundary components made from unglued faces of tetrahedra.</p>
<p >Note that this operation is a loose converse of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adc25a58b48e39f3c7f8621b84432d294" title="Converts each real boundary component into a cusp (i.e., an ideal vertex).">finiteToIdeal()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this routine subdivides all tetrahedra as if <em>all</em> vertices (not just some) were ideal. This may lead to more tetrahedra than are necessary.</dd>
<dd>
Currently, the presence of an invalid edge will force the triangulation to be subdivided regardless of the value of parameter <em>forceDivision</em>. The final triangulation will still have the projective plane cusp caused by the invalid edge.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Have this routine only use as many tetrahedra as are necessary, leaving finite vertices alone.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was changed. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>David Letscher </dd></dl>

</div>
</div>
<a id="ab44e8aa8e6a1e0723767b94d60ce59d7" name="ab44e8aa8e6a1e0723767b94d60ce59d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44e8aa8e6a1e0723767b94d60ce59d7">&#9670;&nbsp;</a></span>inAnyPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::inAnyPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation. </p>
<p >This routine is similar to PacketOf&lt;Triangulation&lt;3&gt;&gt;::packet(). In particular, if this triangulation is held directly by a 3-dimensional triangulation packet <em>p</em>, then this routine will return <em>p</em>.</p>
<p >The difference is when this triangulation is held "indirectly" by a SnapPea triangulation packet <em>q</em> (i.e., this is the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> data belonging to the SnapPea triangulation). In such a scenario, <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code> (since there is no "direct" 3-dimensional triangulation packet), but <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">inAnyPacket()</a> will return <em>q</em> (since the triangulation is still "indirectly" held by a different type of packet).</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data (directly or indirectly), or <code>null</code> if this data is not held by either a 3-dimensional triangulation packet or a SnapPea triangulation packet. </dd></dl>

</div>
</div>
<a id="acb91289cea42534269630ab6081e96a7" name="acb91289cea42534269630ab6081e96a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb91289cea42534269630ab6081e96a7">&#9670;&nbsp;</a></span>inAnyPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::inAnyPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation. </p>
<p >This routine is similar to PacketOf&lt;Triangulation&lt;3&gt;&gt;::packet(). In particular, if this triangulation is held directly by a 3-dimensional triangulation packet <em>p</em>, then this routine will return <em>p</em>.</p>
<p >The difference is when this triangulation is held "indirectly" by a SnapPea triangulation packet <em>q</em> (i.e., this is the inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> data belonging to the SnapPea triangulation). In such a scenario, <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code> (since there is no "direct" 3-dimensional triangulation packet), but <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">inAnyPacket()</a> will return <em>q</em> (since the triangulation is still "indirectly" held by a different type of packet).</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data (directly or indirectly), or <code>null</code> if this data is not held by either a 3-dimensional triangulation packet or a SnapPea triangulation packet. </dd></dl>

</div>
</div>
<a id="a024090512e8debb67c5895ec9eb80efa" name="a024090512e8debb67c5895ec9eb80efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024090512e8debb67c5895ec9eb80efa">&#9670;&nbsp;</a></span>insertLayeredSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertLayeredSolidTorus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new layered solid torus into the triangulation. </p>
<p >The meridinal disc of the layered solid torus will intersect the three edges of the boundary torus in <em>cuts0</em>, <em>cuts1</em> and (<em>cuts0</em> + <em>cuts1</em>) points respectively.</p>
<p >The boundary torus will always consist of faces 012 and 013 of the tetrahedron containing this boundary torus (this tetrahedron will be returned). In face 012, edges 12, 02 and 01 will meet the meridinal disc <em>cuts0</em>, <em>cuts1</em> and (<em>cuts0</em> + <em>cuts1</em>) times respectively. The only exceptions are if these three intersection numbers are (1,1,2) or (0,1,1), in which case edges 12, 02 and 01 will meet the meridinal disc (1, 2 and 1) or (1, 1 and 0) times respectively.</p>
<p >The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>0 ≤ <em>cuts0</em> ≤ <em>cuts1</em>; </dd>
<dd>
gcd(<em>cuts0</em>, <em>cuts1</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cuts0</td><td>the smallest of the three desired intersection numbers. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the second smallest of the three desired intersection numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tetrahedron containing the boundary torus.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1LayeredSolidTorus.html" title="Represents a layered solid torus in a triangulation.">LayeredSolidTorus</a> </dd></dl>

</div>
</div>
<a id="a2bf93dbca6715c1a455a2d47f66a6476" name="a2bf93dbca6715c1a455a2d47f66a6476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf93dbca6715c1a455a2d47f66a6476">&#9670;&nbsp;</a></span>insertTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a copy of the given triangulation into this triangulation. </p>
<p >The top-dimensional simplices of <em>source</em> will be copied into this triangulation in the same order in which they appear in <em>source</em>. That is, if the original size of this triangulation was <em>S</em>, then the simplex at index <em>i</em> in <em>source</em> will be copied into this triangulation as a new simplex at index <em>S</em>+<em>i</em>.</p>
<p >The copies will use the same vertex numbering and descriptions as the original simplices from <em>source</em>, and any gluings between the simplices of <em>source</em> will likewise be copied across as gluings between their copies in this triangulation.</p>
<p >This routine behaves correctly when <em>source</em> is this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63140ff3ab1dd53acd661a6c8cde47e" name="ad63140ff3ab1dd53acd661a6c8cde47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63140ff3ab1dd53acd661a6c8cde47e">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to simplify the triangulation using fast and greedy heuristics. </p>
<p >This routine will attempt to reduce the number of tetrahedra, the number of vertices and the number of boundary triangles (with the number of tetrahedra as its priority).</p>
<p >Currently this routine uses <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0bc067391ecf8f6269e624ee9d658761" title="Uses all known simplification moves to reduce the triangulation monotonically to some local minimum n...">simplifyToLocalMinimum()</a> and <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> in combination with random 4-4 moves, book opening moves and book closing moves.</p>
<p >Although <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> works very well most of the time, it can occasionally get stuck; in such cases you may wish to try the more powerful but (much) slower <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> instead.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same triangulation may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd><em>Optimise:</em> Include random 2-3 moves to get out of wells.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was successfully simplified. Otherwise this triangulation will not be changed. </dd></dl>

</div>
</div>
<a id="a4bccc3c75b25276fa66c4fc1b337cc0c" name="a4bccc3c75b25276fa66c4fc1b337cc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bccc3c75b25276fa66c4fc1b337cc0c">&#9670;&nbsp;</a></span>isBall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of a 3-dimensional ball. </p>
<p >This routine is based on <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a>, which in turn combines Rubinstein's 3-sphere recognition algorithm with Jaco and Rubinstein's 0-efficiency prime decomposition algorithm.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa1ece1722460a2265a4926a7d517af2e" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimension...">knowsBall()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a triangulation of a 3-dimensional ball. </dd></dl>

</div>
</div>
<a id="a07002c044286b6ba00d747d3fa49d52a" name="a07002c044286b6ba00d747d3fa49d52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07002c044286b6ba00d747d3fa49d52a">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is closed. </p>
<p >This is the case if and only if it has no boundary. Note that ideal triangulations are not closed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is closed. </dd></dl>

</div>
</div>
<a id="a576e6c66cfbb7fabd21cc782c38f300d" name="a576e6c66cfbb7fabd21cc782c38f300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576e6c66cfbb7fabd21cc782c38f300d">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isConnected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is connected. </p>
<p >This routine returns <code>false</code> only if there is more than one connected component. In particular, it returns <code>true</code> for the empty triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is connected. </dd></dl>

</div>
</div>
<a id="a868e42b826a392816a796e0e15f85ded" name="a868e42b826a392816a796e0e15f85ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868e42b826a392816a796e0e15f85ded">&#9670;&nbsp;</a></span>isContainedIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p >Specifically, this routine determines if there is a boundary incomplete combinatorial isomorphism from this triangulation to <em>other</em>. Boundary incomplete isomorphisms are described in detail in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p >In particular, note that facets of top-dimensional simplices that lie on the boundary of this triangulation need not correspond to boundary facets of <em>other</em>, and that <em>other</em> may contain more top-dimensional simplices than this triangulation.</p>
<p >If a boundary incomplete isomorphism is found, the details of this isomorphism are returned. Thus, to test whether an isomorphism exists, you can just call <code>if (isContainedIn(other))</code>.</p>
<p >If more than one such isomorphism exists, only one will be returned. For a routine that returns all such isomorphisms, see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac3ea60c854787cc26a39618dcdf2196b" title="Finds all ways in which an isomorphic copy of this triangulation is contained within the given triang...">findAllSubcomplexesIn()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for an isomorphic copy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if such a copy is found, or no value otherwise. </dd></dl>

</div>
</div>
<a id="a6b111a8470576f19f950a2347ff9f3f5" name="a6b111a8470576f19f950a2347ff9f3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b111a8470576f19f950a2347ff9f3f5">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isEmpty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation is empty. </p>
<p >An empty triangulation is one with no simplices at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is empty. </dd></dl>

</div>
</div>
<a id="a14dd70d1448cb32ce52da8e8ae78f6d8" name="a14dd70d1448cb32ce52da8e8ae78f6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dd70d1448cb32ce52da8e8ae78f6d8">&#9670;&nbsp;</a></span>isHaken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isHaken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken. </p>
<p >In other words, this routine determines whether the underlying 3-manifold contains an embedded closed two-sided incompressible surface.</p>
<p >Currently Hakenness testing is available only for irreducible manifolds. This routine will first test whether the manifold is irreducible and, if it is not, will return <code>false</code> immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine could be very slow for larger triangulations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the underlying 3-manifold is irreducible and Haken. </dd></dl>

</div>
</div>
<a id="a6ef22e54275916f8b81b8fd74ab8a439" name="a6ef22e54275916f8b81b8fd74ab8a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef22e54275916f8b81b8fd74ab8a439">&#9670;&nbsp;</a></span>isIdeal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is ideal. </p>
<p >This is the case if and only if one of the vertex links is closed and not a 2-sphere. Note that the triangulation is not required to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is ideal. </dd></dl>

</div>
</div>
<a id="a7785d4bb75a5366cc4d9bae5bf5536ae" name="a7785d4bb75a5366cc4d9bae5bf5536ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7785d4bb75a5366cc4d9bae5bf5536ae">&#9670;&nbsp;</a></span>isIrreducible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isIrreducible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the underlying 3-manifold (which must be closed) is irreducible. </p>
<p >In other words, this routine determines whether every embedded sphere in the underlying 3-manifold bounds a ball.</p>
<p >If the underlying 3-manifold is orientable, this routine will use fast crushing and branch-and-bound methods. If the underlying 3-manifold is non-orientable, it will use a (much slower) full enumeration of vertex normal surfaces.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and might be slow for larger triangulations.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the underlying 3-manifold is irreducible. </dd></dl>

</div>
</div>
<a id="ac568895b8abeb672289fcee779ebf01a" name="ac568895b8abeb672289fcee779ebf01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac568895b8abeb672289fcee779ebf01a">&#9670;&nbsp;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p >Two triangulations are <em>isomorphic</em> if and only it is possible to relabel their top-dimensional simplices and the (<em>dim</em>+1) vertices of each simplex in a way that makes the two triangulations combinatorially identical, as returned by isIdenticalTo().</p>
<p >Equivalently, two triangulations are isomorphic if and only if there is a one-to-one and onto boundary complete combinatorial isomorphism from this triangulation to <em>other</em>, as described in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p >In particular, note that this triangulation and <em>other</em> must contain the same number of top-dimensional simplices for such an isomorphism to exist.</p>
<p >If the triangulations are isomorphic, then this routine returns one such boundary complete isomorphism (i.e., one such relabelling). Otherwise it returns no value. Thus, to test whether an isomorphism exists, you can just call <code>if (isIsomorphicTo(other))</code>.</p>
<p >There may be many such isomorphisms between the two triangulations. If you need to find <em>all</em> such isomorphisms, you may call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0481813042dab2c6140fc8d6fbbd189d" title="Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.">findAllIsomorphisms()</a> instead.</p>
<p >If you need to ensure that top-dimensional simplices are labelled the same in both triangulations (i.e., that the triangulations are related by the <em>identity</em> isomorphism), you should call the stricter test isIdenticalTo() instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if the two triangulations are combinatorially isomorphic, or no value otherwise. </dd></dl>

</div>
</div>
<a id="ab6c7b296f9e7ba7599f0343bfeca3c4a" name="ab6c7b296f9e7ba7599f0343bfeca3c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c7b296f9e7ba7599f0343bfeca3c4a">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation contains valid SnapPea data. </p>
<p >A null SnapPea triangulation can occur (for instance) when converting unusual types of Regina triangulation into SnapPea format, or when reading broken SnapPea data files. See the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a null triangulation, or <code>false</code> if this triangulation contains valid SnapPea data. </dd></dl>

</div>
</div>
<a id="a579be62f99849f22c5a23cceb3f2bf41" name="a579be62f99849f22c5a23cceb3f2bf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579be62f99849f22c5a23cceb3f2bf41">&#9670;&nbsp;</a></span>isOrdered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is ordered; that is, if tetrahedron vertices are labelled so that all gluing permutations are order-preserving on the tetrahedron faces. </p>
<p >Equivalently, this tests whether the edges of the triangulation can all be oriented such that they induce a consistent ordering on the vertices of each tetrahedron.</p>
<p >Triangulations are not ordered by default, and indeed some cannot be ordered at all. The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8b1c5856b28d23276d52d5c4c7705b5d" title="Relabels tetrahedron vertices in this triangulation to give an ordered triangulation,...">order()</a> will attempt to relabel tetrahedron vertices to give an ordered triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all gluing permutations are order preserving on the tetrahedron faces.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="a6223875697502990070b0e7587f63ce7" name="a6223875697502990070b0e7587f63ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223875697502990070b0e7587f63ce7">&#9670;&nbsp;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOrientable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is orientable. </dd></dl>

</div>
</div>
<a id="ab712e58bba1242110e49b2fac979e98f" name="ab712e58bba1242110e49b2fac979e98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab712e58bba1242110e49b2fac979e98f">&#9670;&nbsp;</a></span>isOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOriented</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets. </p>
<p >Specifically, this routine returns <code>true</code> if and only if every gluing permutation has negative sign.</p>
<p >Note that <em>orientable</em> triangulations are not always <em>oriented</em> by default. You can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> if you need the top-dimensional simplices to be oriented consistently as described above.</p>
<p >A non-orientable triangulation can never be oriented.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all top-dimensional simplices are oriented consistently.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="a3133ab83d943df1dd216dc2fbde58c6c" name="a3133ab83d943df1dd216dc2fbde58c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3133ab83d943df1dd216dc2fbde58c6c">&#9670;&nbsp;</a></span>isoSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Encoding::Signature <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature of the given type for this triangulation. </p>
<p >Support for different <em>types</em> of signature is new to Regina 7.0 (see below for details); all isomorphism signatures created in Regina 6.0.1 or earlier are of the default type <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a>.</p>
<p >An <em>isomorphism signature</em> is a compact representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. That is, for any fixed signature type <em>T</em>, two triangulations of dimension <em>dim</em> are combinatorially isomorphic if and only if their isomorphism signatures of type <em>T</em> are the same.</p>
<p >The length of an isomorphism signature is proportional to <code>n log n</code>, where <em>n</em> is the number of top-dimenisonal simplices. The time required to construct it is worst-case <code>O((dim!) n² log² n)</code>. Whilst this is fine for large triangulations, it becomes very slow for large <em>dimensions</em>; the main reason for introducing different signature types is that some alternative types can be much faster to compute in practice.</p>
<p >Whilst the format of an isomorphism signature bears some similarity to dehydration strings for 3-manifolds, they are more general: isomorphism signatures can be used with any triangulations, including closed, bounded and/or disconnected triangulations, as well as triangulations with many simplices. Note also that 3-manifold dehydration strings are not unique up to isomorphism (they depend on the particular labelling of tetrahedra).</p>
<p >The routine <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> can be used to recover a triangulation from an isomorphism signature (only if the default encoding has been used, but it does not matter which signature type was used). The triangulation recovered might not be identical to the original, but it <em>will</em> be combinatorially isomorphic. If you need the precise relabelling, you can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a47a3939293964c4646c7f60cacd94c52" title="Constructs the isomorphism signature for this triangulation, along with the relabelling that will occ...">isoSigDetail()</a> instead.</p>
<p >Regina supports several different variants of isomorphism signatures, which are tailored to different computational needs; these are currently determined by the template parameters <em>Type</em> and <em>Encoding:</em> </p>
<ul>
<li>The <em>Type</em> parameter identifies which signature type is to be constructed. Essentially, different signature types use different rules to determine which labelling of a triangulation is "canonical". The default type <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a> is slow (it never does better than the worst-case time described above); its main advantage is that it is consistent with the original implementation of isomorphism signatures in Regina 4.90.</li>
<li>The <em>Encoding</em> parameter controls how Regina encodes a canonical labelling into a final signature. The default encoding <a class="el" href="classregina_1_1IsoSigPrintable.html" title="The default encoding to use for isomorphism signatures.">IsoSigPrintable</a> returns a std::string consisting entirely of printable characters in the 7-bit ASCII range. Importantly, this default encoding is currently the only encoding from which Regina can <em>reconstruct</em> a triangulation from its isomorphism signature.</li>
</ul>
<p >You may instead pass your own type and/or encoding parameters as template arguments. Currently this facility is for internal use only, and the requirements for type and encoding parameters may change in future versions of Regina. At present:</p>
<ul>
<li>The <em>Type</em> parameter should be a class that is constructible from a componenent reference, and that offers the member functions <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a>, perm() and next(); see the implementation of <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a> for details.</li>
<li>The <em>Encoding</em> parameter should be a class that offers a <em><a class="el" href="classregina_1_1Signature.html" title="Represents a signature of a splitting surface in a closed 3-manifold triangulation.">Signature</a></em> type alias, and static functions emptySig() and encode(). See the implementation of <a class="el" href="classregina_1_1IsoSigPrintable.html" title="The default encoding to use for isomorphism signatures.">IsoSigPrintable</a> for details.</li>
</ul>
<p >For a full and precise description of the classic isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section user"><dt>Python</dt><dd>Although this is a templated function, all of the variants supplied with Regina are available to Python users. For the default type and encoding, you can simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>. For other signature types, you should call the function as isoSig_<em>Type</em>, where the suffix <em>Type</em> is an abbreviated version of the <em>Type</em> template parameter; one such example is <code>isoSig_EdgeDegrees</code> (for the case where <em>Type</em> is the class IsoSigEdgeDegrees). Currently Regina only offers one encoding (the default), and so there are no suffixes for encodings.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a id="a0eedc0b1fc037af0d9c6c23c32d79f2b" name="a0eedc0b1fc037af0d9c6c23c32d79f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eedc0b1fc037af0d9c6c23c32d79f2b">&#9670;&nbsp;</a></span>isoSigComponentSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSigComponentSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p >Currently this routine only supports isomorphism signatures that were created with the default encoding (i.e., there was no <em>Encoding</em> template parameter passed to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>).</p>
<p >If the signature describes a connected triangulation, this routine will simply return the size of that triangulation (e.g., the number of tetrahedra in the case <em>dim</em> = 3). You can also pass an isomorphism signature that describes a disconnected triangulation; however, this routine will only return the number of top-dimensional simplices in the first connected component. If you need the total size of a disconnected triangulation, you will need to reconstruct the full triangulation by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead.</p>
<p >This routine is very fast, since it only examines the first few characters of the isomorphism signature (in which the size of the first component is encoded). However, a side-effect of this is that it is possible to pass an <em>invalid</em> isomorphism signature and still receive a positive result. If you need to test whether a signature is valid or not, you must call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead, which will examine the entire signature in full.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of a <em>dim</em>-dimensional triangulation. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices in the first connected component, or 0 if this could not be determined because the given string was not a valid isomorphism signature created using the default encoding. </dd></dl>

</div>
</div>
<a id="a47a3939293964c4646c7f60cacd94c52" name="a47a3939293964c4646c7f60cacd94c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a3939293964c4646c7f60cacd94c52">&#9670;&nbsp;</a></span>isoSigDetail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Encoding::Signature, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSigDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature for this triangulation, along with the relabelling that will occur when the triangulation is reconstructed from it. </p>
<p >Essentially, an isomorphism signature is a compact representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for much more detail on isomorphism signatures as well as the support for different signature types and encodings.</p>
<p >As described in the <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> notes, you can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> to recover a triangulation from an isomorphism signature (assuming the default encoding was used). Whilst the triangulation that is recovered will be combinatorially isomorphic to the original, it might not be identical. This routine returns not only the isomorphism signature, but also an isomorphism that describes the precise relationship between this triangulation and the reconstruction from <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>.</p>
<p >Specifically, if this routine returns the pair (<em>sig</em>, <em>relabelling</em>), this means that the triangulation reconstructed from <code>fromIsoSig(sig)</code> will be identical to <code>relabelling(this)</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Although this is a templated function, all of the variants supplied with Regina are available to Python users. For the default type and encoding, you can simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a47a3939293964c4646c7f60cacd94c52" title="Constructs the isomorphism signature for this triangulation, along with the relabelling that will occ...">isoSigDetail()</a>. For other signature types, you should call the function as isoSigDetail_<em>Type</em>, where the suffix <em>Type</em> is an abbreviated version of the <em>Type</em> template parameter; one such example is <code>isoSigDetail_EdgeDegrees</code> (for the case where <em>Type</em> is the class IsoSigEdgeDegrees). Currently Regina only offers one encoding (the default), and so there are no suffixes for encodings.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation must be non-empty and connected. The facility to return a relabelling for disconnected triangulations may be added to Regina in a later release.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is either empty or disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing (i) the isomorphism signature of this triangulation, and (ii) the isomorphism between this triangulation and the triangulation that would be reconstructed from <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>. </dd></dl>

</div>
</div>
<a id="ae9a076c6b4eb0edc40694aedaf5bd3c4" name="ae9a076c6b4eb0edc40694aedaf5bd3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a076c6b4eb0edc40694aedaf5bd3c4">&#9670;&nbsp;</a></span>isReadOnlySnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::isReadOnlySnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this object is a read-only deep copy that was created by a snapshot. </p>
<p >Recall that, if an image <em>I</em> of type <em>T</em> has a snapshot pointing to it, and if that image <em>I</em> is about to be modified or destroyed, then the snapshot will make an internal deep copy of <em>I</em> and refer to that instead.</p>
<p >The purpose of this routine is to identify whether the current object is such a deep copy. This may be important information, since a snapshot's deep copy is read-only: it must not be modified or destroyed by the outside world. (Of course the only way to access this deep copy is via const reference from the <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> dereference operators, but there are settings in which this constness is "forgotten", such as Regina's Python bindings.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object is a deep copy that was taken by a <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> object of some original type <em>T</em> image. </dd></dl>

</div>
</div>
<a id="aa5d2e60921b2f4aef3d44c73808e0e30" name="aa5d2e60921b2f4aef3d44c73808e0e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d2e60921b2f4aef3d44c73808e0e30">&#9670;&nbsp;</a></span>isSnapPea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isSnapPea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SnapPea triangulation that holds this data, if there is one. </p>
<p >This routine essentially replaces a dynamic_cast, since the class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is not polymorphic.</p>
<p >If this object in fact belongs to a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> <em>t</em> (through its inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface), then this routine will return <em>t</em>. Otherwise it will return <code>null</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the SnapPea triangulation that holds this data, or <code>null</code> if this data is not part of a SnapPea triangulation. </dd></dl>

</div>
</div>
<a id="ae1469710de4bfd75ff21d8fa52a6a8c1" name="ae1469710de4bfd75ff21d8fa52a6a8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1469710de4bfd75ff21d8fa52a6a8c1">&#9670;&nbsp;</a></span>isSnapPea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isSnapPea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SnapPea triangulation that holds this data, if there is one. </p>
<p >This routine essentially replaces a dynamic_cast, since the class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is not polymorphic.</p>
<p >If this object in fact belongs to a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> <em>t</em> (through its inherited <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> interface), then this routine will return <em>t</em>. Otherwise it will return <code>null</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the SnapPea triangulation that holds this data, or <code>null</code> if this data is not part of a SnapPea triangulation. </dd></dl>

</div>
</div>
<a id="a6887425d2144a4f3a485c59ec9b74c3e" name="a6887425d2144a4f3a485c59ec9b74c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6887425d2144a4f3a485c59ec9b74c3e">&#9670;&nbsp;</a></span>isSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of the solid torus; that is, the unknot complement. </p>
<p >This routine can be used on a triangulation with real boundary triangles, or on an ideal triangulation (in which case all ideal vertices will be assumed to be truncated).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so might be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a281f3fc9351e4c757fec0053252d1dd4" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus...">knowsSolidTorus()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is either a real (compact) or ideal (non-compact) triangulation of the solid torus. </dd></dl>

</div>
</div>
<a id="a95050517897ca5dc5b5da5f022155e49" name="a95050517897ca5dc5b5da5f022155e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95050517897ca5dc5b5da5f022155e49">&#9670;&nbsp;</a></span>isSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of a 3-sphere. </p>
<p >This routine relies upon a combination of Rubinstein's 3-sphere recognition algorithm and Jaco and Rubinstein's 0-efficiency prime decomposition algorithm.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a298d53ef63ff44a1a45227a48d22afb5" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere?...">knowsSphere()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a 3-sphere triangulation. </dd></dl>

</div>
</div>
<a id="a97688a6770fe85d320b05edd355abbc2" name="a97688a6770fe85d320b05edd355abbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97688a6770fe85d320b05edd355abbc2">&#9670;&nbsp;</a></span>isStandard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is standard. </p>
<p >This is the case if and only if every vertex is standard. See Vertex&lt;3&gt;::isStandard() for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is standard. </dd></dl>

</div>
</div>
<a id="ae0326a12e5c235b90e78ccd3f51e5863" name="ae0326a12e5c235b90e78ccd3f51e5863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0326a12e5c235b90e78ccd3f51e5863">&#9670;&nbsp;</a></span>isTxI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isTxI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the underlying 3-manifold is the product of a torus with an interval. </p>
<p >This routine can be used on a triangulation with real boundary triangles, or ideal boundary components, or a mix of both. If there are any ideal vertices, they will be treated as though they were truncated.</p>
<p >The underlying algorithm is due to Robert C. Haraway, III; see <a href="https://journals.carleton.ca/jocg/index.php/jocg/article/view/433">https://journals.carleton.ca/jocg/index.php/jocg/article/view/433</a> for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This algorithm ultimately relies on <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a>, which might run slowly for large triangulations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a triangulation (either real, ideal or a combination) of the product of the torus with an interval. </dd></dl>

</div>
</div>
<a id="ab6cf08805f1b496f644e75c1a0b34dde" name="ab6cf08805f1b496f644e75c1a0b34dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cf08805f1b496f644e75c1a0b34dde">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is valid. </p>
<p >There are several conditions that might make a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if some face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if some <em>subdim</em>-face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of this triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> ≥ 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p >Condition (1) is tested for all dimensions <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p >If a triangulation is invalid then you can call <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face&lt;dim, subdim&gt;::isValid()</a> to discover exactly which face(s) are responsible, and you can call <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a5249e464a3fbf13b0426260a62f91488" title="Determines if this face is identified with itself under a non-identity permutation.">Face&lt;dim, subdim&gt;::hasBadIdentification()</a> and/or <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ad5e55cae9e13a88139dc9794617f938b" title="Determines if this face does not have an appropriate link.">Face&lt;dim, subdim&gt;::hasBadLink()</a> to discover exactly which conditions fail.</p>
<p >Note that all invalid vertices are considered to be on the boundary; see isBoundary() for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is valid. </dd></dl>

</div>
</div>
<a id="aa9f53c7239fd5e5675628d91bf70292f" name="aa9f53c7239fd5e5675628d91bf70292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f53c7239fd5e5675628d91bf70292f">&#9670;&nbsp;</a></span>isZeroEfficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isZeroEfficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is 0-efficient. </p>
<p >A triangulation is 0-efficient if its only normal spheres and discs are vertex linking, and if it has no 2-sphere boundary components.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is 0-efficient. </dd></dl>

</div>
</div>
<a id="a57466689aa69193ce70a026c84a43969" name="a57466689aa69193ce70a026c84a43969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57466689aa69193ce70a026c84a43969">&#9670;&nbsp;</a></span>kernelMessagesEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SnapPeaTriangulation::kernelMessagesEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the SnapPea kernel writes diagnostic messages to standard output. </p>
<p >By default such diagnostic messages are disabled. To enable them, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9c42217fc152e7f22c7ea1717954a6db" title="Configures whether or not the SnapPea kernel should write diagnostic messages to standard output.">enableKernelMessages()</a>.</p>
<p >This routine (which interacts with static data) is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if diagonstic messages are enabled. </dd></dl>

</div>
</div>
<a id="aa1ece1722460a2265a4926a7d517af2e" name="aa1ece1722460a2265a4926a7d517af2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ece1722460a2265a4926a7d517af2e">&#9670;&nbsp;</a></span>knowsBall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimensional ball? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a ball; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="a70b6cb41cbea1bab5fbe1692ecd8a2d7" name="a70b6cb41cbea1bab5fbe1692ecd8a2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b6cb41cbea1bab5fbe1692ecd8a2d7">&#9670;&nbsp;</a></span>knowsCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold contains a compressing disc? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold has a compressing disc; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal. </dd>
<dd>
The underlying 3-manifold is irreducible.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="adaeafdd4bd2b7a28d3bcfcb31521a5a3" name="adaeafdd4bd2b7a28d3bcfcb31521a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeafdd4bd2b7a28d3bcfcb31521a5a3">&#9670;&nbsp;</a></span>knowsHaken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsHaken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold is Haken? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold is Haken; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ad2a7147a44915b76f3cebfc71eceab85" name="ad2a7147a44915b76f3cebfc71eceab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a7147a44915b76f3cebfc71eceab85">&#9670;&nbsp;</a></span>knowsHandlebody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsHandlebody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of an orientable handlebody? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00" title="Determines whether this is a triangulation of an orientable handlebody, and if so,...">recogniseHandlebody()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00" title="Determines whether this is a triangulation of an orientable handlebody, and if so,...">recogniseHandlebody()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00" title="Determines whether this is a triangulation of an orientable handlebody, and if so,...">recogniseHandlebody()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a5ca8e041483cec8b065c0a48d4448b00" title="Determines whether this is a triangulation of an orientable handlebody, and if so,...">recogniseHandlebody()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms an orientable handlebody; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He </dd></dl>

</div>
</div>
<a id="aa96238fc751a6350e17ce5727a183ba1" name="aa96238fc751a6350e17ce5727a183ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96238fc751a6350e17ce5727a183ba1">&#9670;&nbsp;</a></span>knowsIrreducible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsIrreducible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold is irreducible? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold is irreducible; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="a281f3fc9351e4c757fec0053252d1dd4" name="a281f3fc9351e4c757fec0053252d1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281f3fc9351e4c757fec0053252d1dd4">&#9670;&nbsp;</a></span>knowsSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus (that is, the unknot complement)? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a solid torus; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="a298d53ef63ff44a1a45227a48d22afb5" name="a298d53ef63ff44a1a45227a48d22afb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298d53ef63ff44a1a45227a48d22afb5">&#9670;&nbsp;</a></span>knowsSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a 3-sphere; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ac439e27b0888b60b2d256e9ad8eaaa15" name="ac439e27b0888b60b2d256e9ad8eaaa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac439e27b0888b60b2d256e9ad8eaaa15">&#9670;&nbsp;</a></span>knowsStrictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsStrictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this triangulation supports a strict angle structure? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22" title="Returns a strict angle structure on this triangulation, if one exists.">strictAngleStructure()</a> and <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> will be very fast (simply returning the precalculated solution).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the triangulation supports a strict angle structure; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="a53ffd0e9e8e5b2e9c8521c58871ec56b" name="a53ffd0e9e8e5b2e9c8521c58871ec56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ffd0e9e8e5b2e9c8521c58871ec56b">&#9670;&nbsp;</a></span>knowsTxI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsTxI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a the product of a torus with an interval? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> for further details. </p>
<p >If this property is indeed already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> will be very fast (simply returning the precalculated value).</p>
<p >If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> and this routine will return <code>true</code>.</p>
<p >Otherwise a call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms the product of the torus with an interval; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="a18754e52a8c76dcadb6f885bb7c551bc" name="a18754e52a8c76dcadb6f885bb7c551bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18754e52a8c76dcadb6f885bb7c551bc">&#9670;&nbsp;</a></span>knowsZeroEfficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsZeroEfficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known whether or not this triangulation is 0-efficient? See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa9f53c7239fd5e5675628d91bf70292f" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> for further details. </p>
<p >If this property is already known, future calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa9f53c7239fd5e5675628d91bf70292f" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation is 0-efficient; it merely tells you whether the answer has already been computed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="aa511ce61e49b446c391b6f97338b9e1b" name="aa511ce61e49b446c391b6f97338b9e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa511ce61e49b446c391b6f97338b9e1b">&#9670;&nbsp;</a></span>layerOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::layerOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a layering upon the given boundary edge of the triangulation. </p>
<p >See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for further details on what a layering entails.</p>
<p >The new tetrahedron will be returned, and the new boundary edge that it creates will be edge 5 (i.e., the edge joining vertices 2 and 3) of this tetrahedron.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge is a boundary edge of this triangulation, and the two boundary triangles on either side of it are distinct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the boundary edge upon which to layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new tetrahedron provided by the layering. </dd></dl>

</div>
</div>
<a id="a16653ca34f64f08b06977942f2ce00de" name="a16653ca34f64f08b06977942f2ce00de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16653ca34f64f08b06977942f2ce00de">&#9670;&nbsp;</a></span>linkingSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, bool &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::linkingSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the link of the given face as a normal surface. </p>
<p >Constructing the link of a face begins with building the frontier of a regular neighbourhood of the face. If this is already a normal surface, then then link is called <em>thin</em>. Otherwise the usual normalisation steps are performed until the surface becomes normal; note that these normalisation steps could change the topology of the surface, and in some pathological cases could even reduce it to the empty surface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to link; this must be between 0 and 2 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given face is a face of this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>s</em>, <em>thin</em>), where <em>s</em> is the face linking normal surface, and <em>thin</em> is <code>true</code> if and only if this link is thin (i.e., no additional normalisation steps were required). </dd></dl>

</div>
</div>
<a id="a6c785e342e4d35edb9f1cdaf40a5540d" name="a6c785e342e4d35edb9f1cdaf40a5540d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c785e342e4d35edb9f1cdaf40a5540d">&#9670;&nbsp;</a></span>longitude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::longitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edge, and returns this edge. </p>
<p >Assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine:</p>
<ul>
<li>identifies the algebraic longitude of the knot complement; that is, identifies the non-trivial simple closed curve on the boundary whose homology in the 3-manifold is trivial;</li>
<li>layers additional tetrahedra on the boundary if necessary so that this curve is represented by a single boundary edge;</li>
<li>returns that (possibly new) boundary edge.</li>
</ul>
<p >Whilst this routine returns less information than <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a317601abbfe21f86ff9f8b1c254f00b9" title="Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a si...">meridianLongitude()</a>, it (1) runs much faster since it is based on fast algebraic calculations, and (2) guarantees to terminate. In contrast, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a317601abbfe21f86ff9f8b1c254f00b9" title="Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a si...">meridianLongitude()</a> must repeatedly try to test for 3-spheres, and (as a result of only using fast 3-sphere recognition heuristics) does not guarantee to terminate.</p>
<p >At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<p >If the algebraic longitude is already represented by a single boundary edge, then it is guaranteed that this routine will <em>not</em> modify the triangulation, and will simply return this boundary edge.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may modify the triangluation, as explained above, which will have the side-effect of invalidating any existing Vertex, Edge or Triangle references.</dd>
<dd>
If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not a valid one-vertex orientable triangulation with homology <em>Z</em>, and with a two-triangle torus as its one and only boundary component. Note that this does not capture all of the preconditions for this routine, but it does capture those that are easy to test.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>An integer overflow occurred during the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary edge representing the algebraic longitude of the knot (after this triangulation has been modified if necessary). </dd></dl>

</div>
</div>
<a id="af6e4179fae4ecc6764dc7a1bf318a3c0" name="af6e4179fae4ecc6764dc7a1bf318a3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e4179fae4ecc6764dc7a1bf318a3c0">&#9670;&nbsp;</a></span>longitudeCuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; long, 3 &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::longitudeCuts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies the algebraic longitude as a curve on the boundary of a triangulated knot complement. </p>
<p >Specifically, assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine identifies the non-trivial simple closed curve on the boundary whose homology in the 3-manifold is trivial.</p>
<p >The curve will be returned as a triple of integers, indicating how many times the longitude intersects each of the three boundary edges. It is always true that the largest of these three integers will be the sum of the other two.</p>
<p >At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not a valid one-vertex orientable triangulation with homology <em>Z</em>, and with a two-triangle torus as its one and only boundary component. Note that this does not capture all of the preconditions for this routine, but it does capture those that are easy to test.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>An integer overflow occurred during the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a triple of non-negative integers indicating how many times the longitude intersects each of the three boundary edges. Specifically, if the returned tuple is <em>t</em> and the unique boundary component is <em>bc</em>, then for each <em>k</em> = 0,1,2, the element <code>t[k]</code> indicates the (absolute) number of times that the longitude intersects the edge <code>bc-&gt;edge(k)</code>. </dd></dl>

</div>
</div>
<a id="abe58df75da67242635ddcea5398d1b77" name="abe58df75da67242635ddcea5398d1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe58df75da67242635ddcea5398d1b77">&#9670;&nbsp;</a></span>makeCanonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form. </p>
<p >This is essentially the lexicographically smallest labelling when the facet gluings are written out in order.</p>
<p >Two triangulations are isomorphic if and only if their canonical forms are identical.</p>
<p >The lexicographic ordering assumes that the facet gluings are written in order of simplex index and then facet number. Each gluing is written as the destination simplex index followed by the gluing permutation (which in turn is written as the images of 0,1,...,<em>dim</em> in order).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This routine currently works only when the triangulation is connected. It may be extended to work with disconnected triangulations in later versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the triangulation was in canonical form to begin with. </dd></dl>

</div>
</div>
<a id="ae061e36e8ecbfa2f1edc36ed9eb99a51" name="ae061e36e8ecbfa2f1edc36ed9eb99a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae061e36e8ecbfa2f1edc36ed9eb99a51">&#9670;&nbsp;</a></span>makeDoubleCover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeDoubleCover</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this triangulation into its double cover. </p>
<p >Each orientable component will be duplicated, and each non-orientable component will be converted into its orientable double cover. </p>

</div>
</div>
<a id="ada6dde5a1cad6b5a763af7ee662eba28" name="ada6dde5a1cad6b5a763af7ee662eba28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6dde5a1cad6b5a763af7ee662eba28">&#9670;&nbsp;</a></span>markedHomology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::markedHomology</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation. </p>
<p >For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>markedHomology&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>markedHomology(subdim)</code>.</p>
<p >See the non-templated markedHomology(int) for full details on what this function computes, some important caveats to be aware of, and how the group that it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is empty or invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>markedHomology(k)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to compute; this must be between 1 and (<em>dim</em>-1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group of the union of all simplices in this triangulation, as described above. </dd></dl>

</div>
</div>
<a id="adb9273c04a7cf7c89831bce0aa12da15" name="adb9273c04a7cf7c89831bce0aa12da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9273c04a7cf7c89831bce0aa12da15">&#9670;&nbsp;</a></span>markedHomology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::markedHomology </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation, where the parameter <em>k</em> does not need to be known until runtime. </p>
<p >For C++ programmers who know <em>k</em> at compile time, you are better off using the template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ada6dde5a1cad6b5a763af7ee662eba28" title="Returns the kth homology group of this triangulation, without truncating ideal vertices,...">markedHomology&lt;k&gt;()</a> instead, which is slightly faster.</p>
<p >This is a specialised homology routine; you should only use it if you need to understand how individual <em>k</em>-faces (or chains of <em>k</em>-faces) appear within the homology group.</p>
<ul>
<li>The major disadvantage of this routine is that it does not truncate ideal vertices. Instead it computes the homology of the union of all top-dimensional simplices, working directly with the boundary maps between (<em>k</em>+1)-faces, <em>k</em>-faces and (<em>k</em>-1)-faces of the triangulation. If your triangulation is ideal, then this routine will almost certainly <em>not</em> give the correct homology group for the underlying manifold. If, however, all of your vertex links are spheres or balls (i.e., the triangulation is closed or all of its boundary components are built from unglued (<em>dim</em>-1)-faces), then the homology of the manifold will be computed correctly.</li>
<li>The major advantage is that, instead of returning a simpler <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a>, this routine returns a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a>. This allows you to track chains of individual <em>k</em>-faces of the triangulation as they appear within the homology group. Specifically, the chain complex cordinates with this <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> represent precisely the <em>k</em>-faces of the triangulation in the same order as they appear in the list <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;k&gt;()</a>, using the inherent orientation provided by Face&lt;dim, k&gt;.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is empty or invalid.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The homology dimension <em>k</em> is outside the supported range (i.e., less than 1 or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Like the C++ template function <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ada6dde5a1cad6b5a763af7ee662eba28" title="Returns the kth homology group of this triangulation, without truncating ideal vertices,...">markedHomology&lt;k&gt;()</a>, you can omit the homology dimension <em>k</em>; this will default to 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to compute; this must be between 1 and (<em>dim</em>-1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group of the union of all simplices in this triangulation, as described above. </dd></dl>

</div>
</div>
<a id="a21f68d896757112ff99db229e05e0558" name="a21f68d896757112ff99db229e05e0558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f68d896757112ff99db229e05e0558">&#9670;&nbsp;</a></span>maximalForestInBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::maximalForestInBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a maximal forest in the 1-skeleton of the triangulation boundary. </p>
<p >Note that the edge pointers returned will become invalid once the triangulation has changed.</p>
<dl class="section return"><dt>Returns</dt><dd>a set containing the edges of the maximal forest. </dd></dl>

</div>
</div>
<a id="a2dadda881273e35b036a76868403c40e" name="a2dadda881273e35b036a76868403c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dadda881273e35b036a76868403c40e">&#9670;&nbsp;</a></span>maximalForestInSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::maximalForestInSkeleton </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canJoinBoundaries</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a maximal forest in the triangulation's 1-skeleton. </p>
<p >It can be specified whether or not different boundary components may be joined by the maximal forest.</p>
<p >An edge leading to an ideal vertex is still a candidate for inclusion in the maximal forest. For the purposes of this algorithm, any ideal vertex will be treated as any other vertex (and will still be considered part of its own boundary component).</p>
<p >Note that the edge pointers returned will become invalid once the triangulation has changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canJoinBoundaries</td><td><code>true</code> if and only if different boundary components are allowed to be joined by the maximal forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set containing the edges of the maximal forest. </dd></dl>

</div>
</div>
<a id="a9903daeee0c9c58c3d7872e054076569" name="a9903daeee0c9c58c3d7872e054076569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9903daeee0c9c58c3d7872e054076569">&#9670;&nbsp;</a></span>meridian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::meridian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies a triangulated knot complement so that the meridian follows a single boundary edge, and returns this edge. </p>
<p >Assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine:</p>
<ul>
<li>identifies the meridian of the knot complement;</li>
<li>layers additional tetrahedra on the boundary if necessary so that this curve is represented by a single boundary edge;</li>
<li>returns that (possibly new) boundary edge.</li>
</ul>
<p >This routine uses fast heuristics to locate the meridian; as a result, <b>it does not guarantee to terminate</b> (but if you find a case where it does not, please let the Regina developers know!). If it does return then it guarantees that the result is correct.</p>
<p >This routine uses a similar algorithm to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a317601abbfe21f86ff9f8b1c254f00b9" title="Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a si...">meridianLongitude()</a>, with the same problem that it could be slow and might not terminate. However, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9903daeee0c9c58c3d7872e054076569" title="Modifies a triangulated knot complement so that the meridian follows a single boundary edge,...">meridian()</a> has the advantage that it might produce a smaller triangulation, since there is no need to arrange for the longitude to be a boundary edge also.</p>
<p >At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<p >If the meridian is already represented by a single boundary edge, then it is guaranteed that, if this routine does terminate, it will <em>not</em> modify the triangulation, and will simply return this boundary edge.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may modify the triangluation, as explained above, which will have the side-effect of invalidating any existing Vertex, Edge or Triangle references.</dd>
<dd>
If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not a valid one-vertex orientable triangulation with homology <em>Z</em>, and with a two-triangle torus as its one and only boundary component. Note that this does not capture all of the preconditions for this routine, but it does capture those that are easy to test.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>An integer overflow occurred during the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary edge representing the meridian (after this triangulation has been modified if necessary). </dd></dl>

</div>
</div>
<a id="a317601abbfe21f86ff9f8b1c254f00b9" name="a317601abbfe21f86ff9f8b1c254f00b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317601abbfe21f86ff9f8b1c254f00b9">&#9670;&nbsp;</a></span>meridianLongitude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::meridianLongitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a single boundary edge, and returns these two edges. </p>
<p >Assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine:</p>
<ul>
<li>identifies the meridian of the knot complement, and also the algebraic longitude (i.e., the non-trivial simple closed curve on the boundary whose homology in the 3-manifold is trivial);</li>
<li>layers additional tetrahedra on the boundary if necessary so that each of these curves is represented by a single boundary edge;</li>
<li>returns these two (possibly new) boundary edges.</li>
</ul>
<p >This routine uses fast heuristics to locate the meridian; as a result, <b>it does not guarantee to terminate</b> (but if you find a case where it does not, please let the Regina developers know!). If it does return then it guarantees that the result is correct.</p>
<p >Whilst this routine returns more information than <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6c785e342e4d35edb9f1cdaf40a5540d" title="Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edg...">longitude()</a>, note that <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a6c785e342e4d35edb9f1cdaf40a5540d" title="Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edg...">longitude()</a> (1) runs much faster since it is based on fast algebraic calculations, and (2) guarantees to terminate.</p>
<p >At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<p >If the meridian and algebraic longitude are already both represented by single boundary edges, then it is guaranteed that, if this routine does terminate, it will <em>not</em> modify the triangulation, and will simply return these two boundary edges.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may modify the triangluation, as explained above, which will have the side-effect of invalidating any existing Vertex, Edge or Triangle references.</dd>
<dd>
If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not a valid one-vertex orientable triangulation with homology <em>Z</em>, and with a two-triangle torus as its one and only boundary component. Note that this does not capture all of the preconditions for this routine, but it does capture those that are easy to test.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>An integer overflow occurred during the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>m</em>, <em>l</em>), where <em>m</em> is the boundary edge representing the meridian and <em>l</em> is the boundary edge representing the algebraic longitude of the knot complement (after this triangulation has been modified if necessary). </dd></dl>

</div>
</div>
<a id="a99782c2bdc6fc9868da9999a30fb76d7" name="a99782c2bdc6fc9868da9999a30fb76d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99782c2bdc6fc9868da9999a30fb76d7">&#9670;&nbsp;</a></span>minImaginaryShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double regina::SnapPeaTriangulation::minImaginaryShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum imaginary part found amongst all tetrahedron shapes, with respect to the Dehn filled hyperbolic structure. </p>
<p >Tetrahedron shapes are given in rectangular form using a fixed coordinate system, as described in the documentation for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ac9a451bd5ec702a229ada193bda78575" title="Returns the shape of the given tetrahedron, with respect to the Dehn filled hyperbolic structure.">shape()</a>.</p>
<p >If this is a null triangulation, or if <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ad406c96fb657b36cba5fddb1366a729f" title="Returns the type of solution found when solving for a hyperbolic structure, with respect to the curre...">solutionType()</a> is no_solution or not_attempted (i.e., we did not or could not solve for a hyperbolic structure), then this routine will simply return zero.</p>
<dl class="section user"><dt>SnapPy</dt><dd>This has no corresponding routine in SnapPy, though the information is easily acessible via <code>Manifold.tetrahedra_shapes(part="rect")</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum imaginary part amongst all tetrahedron shapes. </dd></dl>

</div>
</div>
<a id="ae3e659747844d582d50162a471fd81ab" name="ae3e659747844d582d50162a471fd81ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e659747844d582d50162a471fd81ab">&#9670;&nbsp;</a></span>minimiseBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimiseBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this. </p>
<p >This routine is for use with algorithms that require minimal boundaries (e.g., torus boundaries must contain exactly two triangles). As noted above, it may in fact increase the total number of tetrahedra in the triangulation (though the implementation does make efforts not to do this).</p>
<p >Once this routine is finished, every boundary component will have exactly one vertex, except for sphere and projective plane boundaries which will have exactly two triangles (but three and two vertices respectively).</p>
<p >The changes that this routine performs can always be expressed using only close book moves and/or layerings. In particular, this routine never creates new vertices, and it never creates a non-vertex-linking normal disc or sphere if there was not one before.</p>
<p >Although this routine only modifies real boundary components, it is fine if the triangulation also contains ideal boundary components (and these simply will be left alone). If the triangulation contains internal vertices, these will likewise be left untouched. If you wish to remove internal vertices also, then you should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> instead.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if every boundary component was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="af570c3698d9267f8a3bb373addedc071" name="af570c3698d9267f8a3bb373addedc071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af570c3698d9267f8a3bb373addedc071">&#9670;&nbsp;</a></span>minimiseVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimiseVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold that it represents, potentially adding tetrahedra to do this. </p>
<p >This routine is for use with algorithms that require a minimal number of vertices (e.g., one-vertex triangulations of closed manifolds, or <em>k</em>-vertex triangulations of the complements of <em>k</em>-component links). As noted above, this routine may in fact increase the total number of tetrahedra in the triangulation (though the implementation does make efforts not to do this).</p>
<p >Once this routine is finished:</p>
<ul>
<li>every real boundary component will have exactly one vertex, except for sphere and projective plane boundaries which will have three and two vertices respectively (i.e., the minimum possible);</li>
<li>for each component of the triangulation that contains one or more boundary components (either real and/or ideal), there will be no internal vertices at all;</li>
<li>for each component of the triangulation that has no boundary components (i.e., that represents a closed 3-manifold), there will be precisely one vertex.</li>
</ul>
<p >The changes that this routine performs can always be expressed using only close book moves, layerings, collapse edge moves, and/or pinch edge moves. In particular, this routine never creates new vertices.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is not valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the number of vertices was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="a9160ade86ae2ac23ac91a97d25aa79de" name="a9160ade86ae2ac23ac91a97d25aa79de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9160ade86ae2ac23ac91a97d25aa79de">&#9670;&nbsp;</a></span>minimizeBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimizeBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a>. </p>
<p >This ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this.</p>
<p >See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a> for further details.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Regina uses British English throughout its API. This synonym was a special case where Regina used to offer both British and American alternatives, but this will be removed in a future release. See the page on <a class="el" href="spelling.html">spelling throughout Regina</a> for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if every boundary component was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="a9befd3e78a51a9e5b3168a9e2f800b99" name="a9befd3e78a51a9e5b3168a9e2f800b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9befd3e78a51a9e5b3168a9e2f800b99">&#9670;&nbsp;</a></span>minimizeVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimizeVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a>. </p>
<p >This ensures that the triangulation contains the smallest possible number of vertices, potentially adding tetrahedra to do this.</p>
<p >See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> for further details.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Regina uses British English throughout its API. This synonym was a special case where Regina used to offer both British and American alternatives, but this will be removed in a future release. See the page on <a class="el" href="spelling.html">spelling throughout Regina</a> for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the number of vertices was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="ae3fa3daf9672da64a0fa8a82a439d65b" name="ae3fa3daf9672da64a0fa8a82a439d65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fa3daf9672da64a0fa8a82a439d65b">&#9670;&nbsp;</a></span>moveContentsTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents. </p>
<p >All top-dimensional simplices that currently belong to <em>dest</em> will remain there (and will keep the same indices in <em>dest</em>). All top-dimensional simplices that belong to this triangulation will be moved into <em>dest</em> also (but in general their indices will change).</p>
<p >This triangulation will become empty as a result.</p>
<p >Any pointers or references to Simplex&lt;dim&gt; objects will remain valid.</p>
<p >If your intention is to <em>replace</em> the simplices in <em>dest</em> (i.e., you do not need to preserve the original contents), then consider using the move assignment operator instead (which is more streamlined and also moves across any cached properties from the source triangulation).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the triangulation into which simplices should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f5777e3cbe10ce40d1ce123b88dca60" name="a5f5777e3cbe10ce40d1ce123b88dca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5777e3cbe10ce40d1ce123b88dca60">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SnapPeaTriangulation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns SnapPea's internal name for this triangulation. </p>
<p >This is the manifold name stored in the SnapPea kernel, which is typically different from the packet label assigned by Regina.</p>
<p >If this is a null triangulation then the empty string will be returned.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code><a class="el" href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667" title="Returns the common name of this 3-manifold as a human-readable string.">Manifold.name()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SnapPea's name for this triangulation. </dd></dl>

</div>
</div>
<a id="ad107a418e2691dc5ad7bb9e90dcba437" name="ad107a418e2691dc5ad7bb9e90dcba437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107a418e2691dc5ad7bb9e90dcba437">&#9670;&nbsp;</a></span>newSimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex and adds it to this triangulation. </p>
<p >The new simplex will have an empty description. All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p >The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="a829224a264241e43a8f2bbdf5bfcb253" name="a829224a264241e43a8f2bbdf5bfcb253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829224a264241e43a8f2bbdf5bfcb253">&#9670;&nbsp;</a></span>newSimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex with the given description and adds it to this triangulation. </p>
<p >All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p >Descriptions are optional, may have any format, and may be empty. How descriptions are used is entirely up to the user.</p>
<p >The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give to the new simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="a80e0403df58ea41ee87cfeb3e111845e" name="a80e0403df58ea41ee87cfeb3e111845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e0403df58ea41ee87cfeb3e111845e">&#9670;&nbsp;</a></span>newSimplices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *, k &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <em>k</em> new top-dimensional simplices, adds them to this triangulation, and returns them in a std::array. </p>
<p >The main purpose of this routine is to support structured binding; for example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [r, s, t] = ans.newSimplices&lt;3&gt;();</div>
<div class="line">r-&gt;join(0, s, {1, 2, 3, 0});</div>
<div class="line">...</div>
</div><!-- fragment --><p >All new simplices will have empty descriptions, and all facets of each new simplex will be boundary facets.</p>
<p >The new simplices will become the last <em>k</em> simplices in this triangulation. Specifically, if the return value is the array <em>ret</em>, then each simplex <code>ret[i]</code> will have index <code><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-k+i</code> in the overall triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the two variants of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> are essentially merged: the argument <em>k</em> is passed as an ordinary runtime argument, and the new top-dimensional simplices will be returned in a Python tuple of size <em>k</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the number of new top-dimensional simplices to add; this must be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing all of the new simplices, in the order in which they were added. </dd></dl>

</div>
</div>
<a id="a911cdc0a8942418d4e257a81ce24a110" name="a911cdc0a8942418d4e257a81ce24a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911cdc0a8942418d4e257a81ce24a110">&#9670;&nbsp;</a></span>newSimplices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplices </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <em>k</em> new top-dimensional simplices and adds them to this triangulation. </p>
<p >This is similar to the templated routine <code>newSimplices&lt;k&gt;()</code>, but with two key differences:</p>
<ul>
<li>This routine has the disadvantage that it does not return the new top-dimensional simplices, which means you cannot use it with structured binding.</li>
<li>This routine has the advantage that <em>k</em> does not need to be known until runtime, which means this routine is accessible to Python users.</li>
</ul>
<p >All new simplices will have empty descriptions, and all facets of each new simplex will be boundary facets.</p>
<p >The new simplices will become the last <em>k</em> simplices in this triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the two variants of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> are essentially merged: the argument <em>k</em> is passed as an ordinary runtime argument, and the new top-dimensional simplices will be returned in a Python tuple of size <em>k</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of new top-dimensional simplices to add; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aac05e1fccff29a9d160199629473ea" name="a2aac05e1fccff29a9d160199629473ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac05e1fccff29a9d160199629473ea">&#9670;&nbsp;</a></span>newTetrahedra() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *, k &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedra</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> for further information. </p>

</div>
</div>
<a id="a17ef43d396c8751d33af3d735baa87e3" name="a17ef43d396c8751d33af3d735baa87e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ef43d396c8751d33af3d735baa87e3">&#9670;&nbsp;</a></span>newTetrahedra() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> for further information. </p>

</div>
</div>
<a id="a8ed61991de885c0e4b393690f91b0930" name="a8ed61991de885c0e4b393690f91b0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed61991de885c0e4b393690f91b0930">&#9670;&nbsp;</a></span>newTetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a id="ad6d942a89497e2bce4ee716db55dfd92" name="ad6d942a89497e2bce4ee716db55dfd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d942a89497e2bce4ee716db55dfd92">&#9670;&nbsp;</a></span>newTetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedron </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a id="ab345829b2c1486eb39f319ed90720c97" name="ab345829b2c1486eb39f319ed90720c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab345829b2c1486eb39f319ed90720c97">&#9670;&nbsp;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nice tree decomposition of the face pairing graph of this triangulation. </p>
<p >This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of the face pairing graph.</p>
<p >See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="classregina_1_1TreeDecomposition.html#a2d545347437905541151b6c112bad03f" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p >This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p >The tree decomposition will be cached, so that if this routine is called a second time (and the underlying triangulation has not been changed) then the same tree decomposition will be returned immediately.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of the face pairing graph of this triangulation. </dd></dl>

</div>
</div>
<a id="a4e5ffedc66a8452087e82dccf568afa7" name="a4e5ffedc66a8452087e82dccf568afa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5ffedc66a8452087e82dccf568afa7">&#9670;&nbsp;</a></span>nonTrivialSphereOrDisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::nonTrivialSphereOrDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a non-vertex-linking normal sphere or disc within this triangulation. </p>
<p >If such a surface exists within this triangulation, this routine is guaranteed to find one.</p>
<dl class="section return"><dt>Returns</dt><dd>a non-vertex-linking normal sphere or disc, or no value if none exists. </dd></dl>

</div>
</div>
<a id="ad019a40fe1a2a2abc87045bce9bb9f52" name="ad019a40fe1a2a2abc87045bce9bb9f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad019a40fe1a2a2abc87045bce9bb9f52">&#9670;&nbsp;</a></span>nullify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::nullify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a null SnapPea triangulation. </p>

</div>
</div>
<a id="ad99edba3a5ebb17bcfad1bbe2f7ede12" name="ad99edba3a5ebb17bcfad1bbe2f7ede12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99edba3a5ebb17bcfad1bbe2f7ede12">&#9670;&nbsp;</a></span>octagonalAlmostNormalSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::octagonalAlmostNormalSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an octagonal almost normal 2-sphere within this triangulation. </p>
<p >If such a surface exists, this routine is guaranteed to find one.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable, connected, and 0-efficient. These preconditions are almost certainly more restrictive than they need to be, but we stay safe for now.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an octagonal almost normal 2-sphere, or no value if none exists. </dd></dl>

</div>
</div>
<a id="a4e1f76566647492c74f380c466edcbe5" name="a4e1f76566647492c74f380c466edcbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1f76566647492c74f380c466edcbe5">&#9670;&nbsp;</a></span>openBook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::openBook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a book opening move about the given triangle. </p>
<p >This involves taking a triangle meeting the boundary along two edges, and ungluing it to create two new boundary triangles (thus exposing the tetrahedra it initially joined). This move is the inverse of the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa83effbc43af294638b92d39246ebb26" title="Checks the eligibility of and/or performs a book closing move about the given boundary edge.">closeBook()</a> move, and is used to open the way for new <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a37b16dc8a8d13d3b01f1cee099988fd3" title="Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron.">shellBoundary()</a> moves.</p>
<p >This move can be done if:</p>
<ul>
<li>the triangle meets the boundary in precisely two edges (and thus also joins two tetrahedra);</li>
<li>the vertex between these two edges is a standard boundary vertex (its link is a disc);</li>
<li>the remaining edge of the triangle (which is internal to the triangulation) is valid.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this operation will (trivially) preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given triangle is a triangle of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a958953c6a57822d9bab7e626e548f86e" name="a958953c6a57822d9bab7e626e548f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958953c6a57822d9bab7e626e548f86e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given SnapPea triangulation are, at some elementary level, different. </p>
<p >This routine checks only those things that can be checked exactly, without going through the SnapPea kernel and without requiring floating-point comparisons.</p>
<p >In particular, it <em>does</em> check whether:</p>
<ul>
<li>the tetrahedron numbers, vertex labels and gluings are the same in both triangulations (i.e., the tests performed by Regina's native <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> comparison operators);</li>
<li>the same numbered cusps correspond to the same numbered vertices of the triangulation;</li>
<li>each pair of corresponding cusps are either both not filled, or both filled using the same coefficients.</li>
</ul>
<p >It does <em>not</em> check wehether corresponding tetrahedron shapes are the same, or if the volumes are "sufficiently close", or even whether the SnapPea kernel has produced the same solution type for both triangulations.</p>
<p >Two null SnapPea triangulations will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the SnapPea triangulation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only this and the given triangulation are different, according to the criteria described above. </dd></dl>

</div>
</div>
<a id="a931d460f2fae401327eed5fd915ead79" name="a931d460f2fae401327eed5fd915ead79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d460f2fae401327eed5fd915ead79">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is not combinatorially identical to the given triangulation. </p>
<p >Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p >For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> instead.</p>
<p >This test does <em>not</em> examine the textual simplex descriptions, as seen in <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a00178392c44456529f5250de6bc448ef" title="Returns the description associated with this simplex.">Simplex&lt;dim&gt;::description()</a>; these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p >(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are not combinatorially identical. </dd></dl>

</div>
</div>
<a id="a4a456cdb3de447101da9d6fe100708b6" name="a4a456cdb3de447101da9d6fe100708b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a456cdb3de447101da9d6fe100708b6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp; regina::SnapPeaTriangulation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given SnapPea triangulation. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to copy the contents of one SnapPea triangulation into another, you <em>must</em> cast both to <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> before calling the assignment operator. If either argument is presented as the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, then the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> assignment operator will be called instead; the result will be that (just like when you call any of the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> edit routines) this SnapPea triangulation will be reset to a null triangulation. See the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class notes for further discussion.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this triangulation. </dd></dl>

</div>
</div>
<a id="aefce7b87855dc42579028accd19e616d" name="aefce7b87855dc42579028accd19e616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefce7b87855dc42579028accd19e616d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp; regina::SnapPeaTriangulation::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given triangulation into this triangulation. </p>
<p >This is much faster than copy assignment, but is still linear time. This is because every tetrahedron must be adjusted to point back to this triangulation instead of <em>src</em>.</p>
<p >All tetrahedra, cusps and skeletal objects (faces, components and boundary components) that belong to <em>src</em> will be moved into this triangulation, and so any pointers or references to Tetrahedron&lt;3&gt;, <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a>, Face&lt;3, subdim&gt;, <a class="el" href="classregina_1_1Component_3_013_01_4.html" title="Represents a connected component of a 3-manifold triangulation.">Component&lt;3&gt;</a> or BoundaryComponent&lt;3&gt; objects will remain valid. Likewise, all cached properties will be moved into this triangulation.</p>
<p >The triangulation that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to move the contents of one SnapPea triangulation into another, you <em>must</em> cast both to <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> before calling the assignment operator. If either argument is presented as the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, then the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> assignment operator will be called instead; the result will be that (just like when you call any of the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> edit routines) this SnapPea triangulation will be reset to a null triangulation. See the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class notes for further discussion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this triangulation which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this triangulation. </dd></dl>

</div>
</div>
<a id="ae13e9438ad2adb5b9f8866aff1ab454d" name="ae13e9438ad2adb5b9f8866aff1ab454d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e9438ad2adb5b9f8866aff1ab454d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given SnapPea triangulation are, at some elementary level, the same. </p>
<p >This routine checks only those things that can be checked exactly, without going through the SnapPea kernel and without requiring floating-point comparisons.</p>
<p >In particular, it <em>does</em> check whether:</p>
<ul>
<li>the tetrahedron numbers, vertex labels and gluings are the same in both triangulations (i.e., the tests performed by Regina's native <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> comparison operators);</li>
<li>the same numbered cusps correspond to the same numbered vertices of the triangulation;</li>
<li>each pair of corresponding cusps are either both not filled, or both filled using the same coefficients.</li>
</ul>
<p >It does <em>not</em> check wehether corresponding tetrahedron shapes are the same, or if the volumes are "sufficiently close", or even whether the SnapPea kernel has produced the same solution type for both triangulations.</p>
<p >Two null SnapPea triangulations will be considered equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the SnapPea triangulation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only this and the given triangulation are the same, according to the criteria described above. </dd></dl>

</div>
</div>
<a id="a597cf2c4f78312124b2ec637173eb29e" name="a597cf2c4f78312124b2ec637173eb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597cf2c4f78312124b2ec637173eb29e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially identical to the given triangulation. </p>
<p >Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p >For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> instead.</p>
<p >This test does <em>not</em> examine the textual simplex descriptions, as seen in <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a00178392c44456529f5250de6bc448ef" title="Returns the description associated with this simplex.">Simplex&lt;dim&gt;::description()</a>; these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p >(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<p >In Regina 6.0.1 and earlier, this comparison was called isIdenticalTo().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are combinatorially identical. </dd></dl>

</div>
</div>
<a id="a8b1c5856b28d23276d52d5c4c7705b5d" name="a8b1c5856b28d23276d52d5c4c7705b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c5856b28d23276d52d5c4c7705b5d">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::order </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOriented</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabels tetrahedron vertices in this triangulation to give an ordered triangulation, if possible. </p>
<p >To be an ordered triangulation, all face gluings (when restricted to the tetrahedron face) must be order preserving. In other words, it must be possible to orient all edges of the triangulation in such a fashion that they are consistent with the ordering of the vertices in each tetrahedron.</p>
<p >If it is possible to order this triangulation, the vertices of each tetrahedron will be relabelled accordingly and this routine will return <code>true</code>. Otherwise, this routine will return <code>false</code> and the triangulation will not be changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may be slow, since it backtracks through all possible edge orientations until a consistent one has been found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceOriented</td><td><code>true</code> if the triangulation must be both ordered and <em>oriented</em>, in which case this routine will return <code>false</code> if the triangulation cannot be oriented and ordered at the same time. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation has been successfully ordered as described above, or <code>false</code> if not.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="a2711fd7c7115ce19b6833f0d61c42bec" name="a2711fd7c7115ce19b6833f0d61c42bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2711fd7c7115ce19b6833f0d61c42bec">&#9670;&nbsp;</a></span>orient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::orient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible. </p>
<p >This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of each top-dimensional simplices that has negative orientation. The result will be a triangulation where the top-dimensional simplices have their vertices labelled in a way that preserves orientation across adjacent facets. In particular, every gluing permutation will have negative sign.</p>
<p >If this triangulation includes both orientable and non-orientable components, the orientable components will be oriented as described above and the non-orientable components will be left untouched. </p>

</div>
</div>
<a id="a39dc5df8252f6e34ea45b19ca33c3964" name="a39dc5df8252f6e34ea45b19ca33c3964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dc5df8252f6e34ea45b19ca33c3964">&#9670;&nbsp;</a></span>pachner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face. </p>
<p >This involves replacing the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices meeting that <em>k</em>-face with (<em>k</em> + 1) new top-dimensional simplices joined along a new internal (<em>dim</em> - <em>k</em>)-face. This can be done iff (i) the given <em>k</em>-face is valid and non-boundary; (ii) the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices that contain it are distinct; and (iii) these simplices are joined in such a way that the link of the given <em>k</em>-face is the standard triangulation of the (<em>dim</em> - 1 - <em>k</em>)-sphere as the boundary of a (<em>dim</em> - <em>k</em>)-simplex.</p>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal. In In the special case <em>k</em> = <em>dim</em>, the move is always legal and so the <em>check</em> argument will simply be ignored.</p>
<p >Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>v</em>) can no longer be used.</p>
<p >If this triangulation is currently oriented, then this Pachner move will label the new top-dimensional simplices in a way that preserves the orientation.</p>
<p >See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be formed from vertices 0,1,...,(<em>dim</em> - <em>k</em>) of <code><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For the case <em>k</em> = <em>dim</em> in Regina's <a class="el" href="stddim.html">standard dimensions</a>, the labelling of the belt face has changed as of Regina 5.96 (the first prerelease for Regina 6.0). In versions 5.1 and earlier, the belt face was <code><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()-&gt;vertex(dim)</code>, and as of version 5.96 it is now <code><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()-&gt;vertex(0)</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive. You can still perform a Pachner move about a 0-face <em>dim</em>-face, but these moves use specialised implementations (as opposed to this generic template implementation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">inAnyPacket()</a> is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">inAnyPacket()</a> is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a839950f320f6f0ca655e7a880a66c2ee" name="a839950f320f6f0ca655e7a880a66c2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839950f320f6f0ca655e7a880a66c2ee">&#9670;&nbsp;</a></span>pairing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pairing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dual graph of this triangulation, expressed as a facet pairing. </p>
<p >Calling <code>tri.pairing()</code> is equivalent to calling <code><a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a>&lt;dim&gt;(tri)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not empty.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the dual graph of this triangulation. </dd></dl>

</div>
</div>
<a id="ab87c5adb83f7790b90bb1a63ec960a4a" name="ab87c5adb83f7790b90bb1a63ec960a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87c5adb83f7790b90bb1a63ec960a4a">&#9670;&nbsp;</a></span>pentachora()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachora</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 4. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a523d84b537174c0e660c16fddfe178ee" name="a523d84b537174c0e660c16fddfe178ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523d84b537174c0e660c16fddfe178ee">&#9670;&nbsp;</a></span>pentachoron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 4 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachoron </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ac8b4af8fb72bfe82006ab8997ce0bccd" name="ac8b4af8fb72bfe82006ab8997ce0bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4af8fb72bfe82006ab8997ce0bccd">&#9670;&nbsp;</a></span>pentachoron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachoron </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 4. It returns a const pentachoron pointer in dimension <em>dim</em> = 4, and a non-const pentachoron pointer in all higher dimensions.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ad24fe1e3bae956fbf8954fb54adc19e4" name="ad24fe1e3bae956fbf8954fb54adc19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24fe1e3bae956fbf8954fb54adc19e4">&#9670;&nbsp;</a></span>pinchEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::pinchEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pinches an internal edge to a point. </p>
<p >Topologically, this collapses the edge to a point with no further side-effects, and it increases the number of tetrahedra by two.</p>
<p >This operation can be performed on <em>any</em> internal edge, without further constraints. Two particularly useful settings are:</p>
<ul>
<li>If the edge joins an internal vertex with some different vertex (which may be internal, boundary, ideal or invalid), then this move does not change the topology of the manifold at all, and it reduces the total number of vertices by one. In this sense, it acts as an alternative to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a>, and unlike <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> it can <em>always</em> be performed.</li>
<li>If the edge runs from an internal vertex back to itself, then this move effectively drills out the edge, leaving an ideal torus or Klein bottle boundary component.</li>
</ul>
<p >We do not allow <em>e</em> to lie entirely on the triangulation boundary, because the implementation actually collapses an internal curve <em>parallel</em> to <em>e</em>, not the edge <em>e</em> itself (and so if <em>e</em> is a boundary edge then the topological effect would not be as intended). We do allow <em>e</em> to be an internal edge with both endpoints on the boundary, but note that in this case the resulting topological operation would render the triangulation invalid.</p>
<p >If you are trying to reduce the number of vertices without changing the topology, and if <em>e</em> is an edge connecting an internal vertex with some different vertex, then either <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> or <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> may be more appropriate for your situation (though you may find it easier just to call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af570c3698d9267f8a3bb373addedc071" title="Ensures that this triangulation contains the smallest possible number of vertices for the 3-manifold ...">minimiseVertices()</a> instead).</p>
<ul>
<li>The advantage of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> is that it decreases the number of tetrahedra, whereas <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> increases this number (but only by two).</li>
<li>The disadvantages of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> are that it cannot always be performed, and its validity tests are expensive; <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> on the other hand can always be used for edges <em>e</em> of the type described above.</li>
</ul>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge is an internal edge of this triangulation (that is, <em>e</em> does not lie entirely within the boundary).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to collapse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d0a996d3b80ce72dc630b1898134e8" name="aa4d0a996d3b80ce72dc630b1898134e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d0a996d3b80ce72dc630b1898134e8">&#9670;&nbsp;</a></span>protoCanonise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> regina::SnapPeaTriangulation::protoCanonise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition contains non-tetrahedron cells. </p>
<p >Any fillings on the cusps of this SnapPea triangulation will be ignored for the purposes of canonisation, though they will be copied over to the new SnapPea triangulation that is returned.</p>
<p >The canonical cell decomposition is the one described in "Convex hulls and isometries of cusped hyperbolic 3-manifolds", Jeffrey R. Weeks, Topology Appl. 52 (1993), 127-149.</p>
<p >If the canonical cell decomposition is already a triangulation then we leave it untouched, and otherwise we triangulate it arbitrarily. Either way, we preserve the hyperbolic structure.</p>
<p >If you need a canonical triangulation (as opposed to an arbitrary retriangulation), then you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a> instead.</p>
<p >SnapPea is not always able to triangulate the canonical cell decomposition: if it fails then then this routine will throw an exception (see below for details).</p>
<dl class="section user"><dt>SnapPy</dt><dd>The function <code><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">canonise()</a></code> means different things for SnapPy versus the SnapPea kernel. Here Regina follows the naming convention used in the SnapPea kernel. Specifically: Regina's routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">SnapPeaTriangulation::protoCanonise()</a> corresponds to SnapPy's <code>Manifold.canonize()</code> and the SnapPea kernel's <code>proto_canonize(manifold)</code>. Regina's routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a2cad97766bcdf5c61b156b8aa0d8fa38" title="Constructs the canonical retriangulation of the canonical cell decomposition.">SnapPeaTriangulation::canonise()</a> corresponds to the SnapPea kernel's <code>canonize(manifold)</code>, and is not available through SnapPy at all.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The SnapPea kernel does not always compute the canonical cell decomposition correctly. Sometimes it gives the wrong answer, although in such a case it still guarantees that the manifold it <em>does</em> return is homeomorphic to the original. Sometimes it gives no answer at all, in which case this routine will throw an exception (see below).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The SnapPea kernel was unable to triangulate the canonical cell decomposition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of the canonical cell decomposition. </dd></dl>

</div>
</div>
<a id="a35b504d7e838c1651f98a79001467119" name="a35b504d7e838c1651f98a79001467119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b504d7e838c1651f98a79001467119">&#9670;&nbsp;</a></span>protoCanonize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> regina::SnapPeaTriangulation::protoCanonize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">protoCanonise()</a>, which constructs the canonical cell decomposition using an arbitrary retriangulation if necessary. </p>
<p >See <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aa4d0a996d3b80ce72dc630b1898134e8" title="Constructs the canonical cell decomposition, using an arbitrary retriangulation if this decomposition...">protoCanonise()</a> for further details.</p>
<p >This alias is provided as "glue" between the British spelling used throughout Regina and the American spelling used throughout the SnapPea kernel.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The SnapPea kernel was unable to triangulate the canonical cell decomposition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of the canonical cell decomposition. </dd></dl>

</div>
</div>
<a id="ae171f874204819014b8a5ea77b1ca2aa" name="ae171f874204819014b8a5ea77b1ca2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae171f874204819014b8a5ea77b1ca2aa">&#9670;&nbsp;</a></span>puncture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::puncture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Punctures this manifold by removing a 3-ball from the interior of the given tetrahedron. </p>
<p >If no tetrahedron is specified (i.e., the tetrahedron pointer is <code>null</code>), then the puncture will be taken from the interior of tetrahedron 0.</p>
<p >The puncture will not meet the boundary of the tetrahedron, so nothing will go wrong if the tetrahedron has boundary facets and/or ideal vertices. A side-effect of this, however, is that the resulting triangulation will contain additional vertices, and will almost certainly be far from minimal. It is highly recommended that you run <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> if you do not need to preserve the combinatorial structure of the new triangulation.</p>
<p >The puncturing is done by subdividing the original tetrahedron. The new tetrahedra will have orientations consistent with the original tetrahedra, so if the triangulation was originally oriented then it will also be oriented after this routine has been called. See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab712e58bba1242110e49b2fac979e98f" title="Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplic...">isOriented()</a> for further details on oriented triangulations.</p>
<p >The new sphere boundary will be formed from two triangles; specifically, face 0 of the last and second-last tetrahedra of the triangulation. These two triangles will be joined so that vertex 1 of each tetrahedron coincides, and vertices 2,3 of one map to vertices 3,2 of the other.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is non-empty, and if <code>tet</code> is non-null then it is in fact a tetrahedron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron inside which the puncture will be taken. This may be <code>null</code> (the default), in which case the first tetrahedron will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41d154865770119b812e7044c327dab4" name="a41d154865770119b812e7044c327dab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d154865770119b812e7044c327dab4">&#9670;&nbsp;</a></span>randomise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::randomise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology. </p>
<p >This can help when SnapPea is having difficulty finding a hyperbolic structure.</p>
<p >This routine uses SnapPea's own internal retriangulation code.</p>
<p >After randomising, this routine will immediately ask SnapPea to try to find a hyperbolic structure.</p>
<p >If this is a null SnapPea triangulation, this routine does nothing.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.randomize()</code>. </dd></dl>

</div>
</div>
<a id="ac8f4b530f457331a0fd1958b32a5d0b3" name="ac8f4b530f457331a0fd1958b32a5d0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f4b530f457331a0fd1958b32a5d0b3">&#9670;&nbsp;</a></span>randomize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::randomize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4" title="Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology.">randomise()</a>, which asks SnapPea to randomly retriangulate this manifold. </p>
<p >See <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a41d154865770119b812e7044c327dab4" title="Asks SnapPea to randomly retriangulate this manifold, using local moves that preserve the topology.">randomise()</a> for further details.</p>
<p >This alias is provided as "glue" between the British spelling used throughout Regina and the American spelling used throughout the SnapPea kernel. </p>

</div>
</div>
<a id="a5ca8e041483cec8b065c0a48d4448b00" name="a5ca8e041483cec8b065c0a48d4448b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca8e041483cec8b065c0a48d4448b00">&#9670;&nbsp;</a></span>recogniseHandlebody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recogniseHandlebody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of an orientable handlebody, and if so, which genus. </p>
<p >Specifically, this routine returns the genus if this is indeed a handlebody, and returns -1 otherwise. This routine can be used on a triangulation with real boundary triangles, or on an ideal triangulation (in which case all ideal vertices will be assumed to be truncated).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so might be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad2a7147a44915b76f3cebfc71eceab85" title="Is it already known (or trivial to determine) whether or not this is a triangulation of an orientable...">knowsHandlebody()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the genus if this is a triangulation of an orientable handlebody, or -1 otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He </dd></dl>

</div>
</div>
<a id="aeff844c71c39d0ae40b4d1c4aa3b0efc" name="aeff844c71c39d0ae40b4d1c4aa3b0efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff844c71c39d0ae40b4d1c4aa3b0efc">&#9670;&nbsp;</a></span>recogniser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recogniser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string that expresses this triangulation in Matveev's 3-manifold recogniser format. </p>
<p >Recogniser exports are currently not available for triangulations that are invalid or contain boundary triangles. If either of these conditions is true then this routine will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This triangulation is either invalid or has boundary triangles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the 3-manifold recogniser data. </dd></dl>

</div>
</div>
<a id="a61f721425309c5b113d24d0e06abfb08" name="a61f721425309c5b113d24d0e06abfb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f721425309c5b113d24d0e06abfb08">&#9670;&nbsp;</a></span>recogniser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recogniser </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream. </p>
<p >Recogniser exports are currently not available for triangulations that are invalid or contain boundary triangles. If either of these conditions is true then this routine will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This triangulation is either invalid or has boundary triangles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aeff844c71c39d0ae40b4d1c4aa3b0efc" title="Returns a string that expresses this triangulation in Matveev&#39;s 3-manifold recogniser format.">recogniser()</a> with no arguments, which returns this data as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the recogniser data file will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a403a36d9a4748032f5abb7e16c24621d" name="a403a36d9a4748032f5abb7e16c24621d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403a36d9a4748032f5abb7e16c24621d">&#9670;&nbsp;</a></span>recognizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recognizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aeff844c71c39d0ae40b4d1c4aa3b0efc" title="Returns a string that expresses this triangulation in Matveev&#39;s 3-manifold recogniser format.">recogniser()</a>. </p>
<p >This returns a string that expresses this triangulation in Matveev's 3-manifold recogniser format.</p>
<p >Recogniser exports are currently not available for triangulations that are invalid or contain boundary triangles. If either of these conditions is true then this routine will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This triangulation is either invalid or has boundary triangles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the 3-manifold recogniser data. </dd></dl>

</div>
</div>
<a id="af9565c761baf1d0fcf41f1e08baf1733" name="af9565c761baf1d0fcf41f1e08baf1733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9565c761baf1d0fcf41f1e08baf1733">&#9670;&nbsp;</a></span>recognizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recognizer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for recognizer(std::ostream&amp;). </p>
<p >This writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream.</p>
<p >Recogniser exports are currently not available for triangulations that are invalid or contain boundary triangles. If either of these conditions is true then this routine will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This triangulation is either invalid or has boundary triangles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a403a36d9a4748032f5abb7e16c24621d" title="A synonym for recogniser().">recognizer()</a> with no arguments, which returns this data as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the recogniser data file will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f5583fe8731e5186eac30bb7dfeafa6" name="a3f5583fe8731e5186eac30bb7dfeafa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5583fe8731e5186eac30bb7dfeafa6">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::reflect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation. </p>
<p >In particular, if this triangulation is oriented, then it will be converted into an isomorphic triangulation with the opposite orientation.</p>
<p >This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of every top-dimensional simplex. </p>

</div>
</div>
<a id="a9e37617ce0bdb569f260dd44c7745844" name="a9e37617ce0bdb569f260dd44c7745844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e37617ce0bdb569f260dd44c7745844">&#9670;&nbsp;</a></span>rehydrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::rehydrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dehydration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehydrates the given alphabetical string into a 3-dimensional triangulation. </p>
<p >For a full description of the dehydrated triangulation format, see <em>A <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> of Cusped Hyperbolic 3-Manifolds</em>, Callahan, Hildebrand and Weeks, Mathematics of Computation 68/225, 1999.</p>
<p >The converse routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> can be used to extract a dehydration string from an existing triangulation. Dehydration followed by rehydration might not produce a triangulation identical to the original, but it is guaranteed to produce an isomorphic copy. See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> for the reasons behind this.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string could not be rehydrated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dehydration</td><td>a dehydrated representation of the triangulation to construct. Case is irrelevant; all letters will be treated as if they were lower case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rehydrated triangulation. </dd></dl>

</div>
</div>
<a id="a3e91a640743f9ce2710d17eda77d520a" name="a3e91a640743f9ce2710d17eda77d520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91a640743f9ce2710d17eda77d520a">&#9670;&nbsp;</a></span>removeAllSimplices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeAllSimplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simplices from the triangulation. </p>
<p >As a result, this triangulation will become empty.</p>
<p >All of the simplices that belong to this triangulation will be destroyed immediately. </p>

</div>
</div>
<a id="a5d5db4562cc8b5cc400c32cc84baf052" name="a5d5db4562cc8b5cc400c32cc84baf052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5db4562cc8b5cc400c32cc84baf052">&#9670;&nbsp;</a></span>removeAllTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeAllTetrahedra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a> for further information. </p>

</div>
</div>
<a id="a7b349c4e1fb4b27a9b20ed53b277a7ba" name="a7b349c4e1fb4b27a9b20ed53b277a7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b349c4e1fb4b27a9b20ed53b277a7ba">&#9670;&nbsp;</a></span>removeSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given top-dimensional simplex from this triangulation. </p>
<p >The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is a top-dimensional simplex in this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f36b004ba6af3d6ce11bdb655650ec" name="ac9f36b004ba6af3d6ce11bdb655650ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f36b004ba6af3d6ce11bdb655650ec">&#9670;&nbsp;</a></span>removeSimplexAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplexAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-dimensional simplex at the given index in this triangulation. </p>
<p >This is equivalent to calling <code>removeSimplex(simplex(index))</code>.</p>
<p >The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which top-dimensionalsimplex to remove; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d12119aa7e43ba418129a62edd57f92" name="a7d12119aa7e43ba418129a62edd57f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d12119aa7e43ba418129a62edd57f92">&#9670;&nbsp;</a></span>removeTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeTetrahedron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> for further information. </p>

</div>
</div>
<a id="a085896e8328394d9cb399529e97d6b7a" name="a085896e8328394d9cb399529e97d6b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085896e8328394d9cb399529e97d6b7a">&#9670;&nbsp;</a></span>removeTetrahedronAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeTetrahedronAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>. </p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a> for further information. </p>

</div>
</div>
<a id="afd9a8527f05610a08f7f7a3d5042d152" name="afd9a8527f05610a08f7f7a3d5042d152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9a8527f05610a08f7f7a3d5042d152">&#9670;&nbsp;</a></span>reorderTetrahedraBFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::reorderTetrahedraBFS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the tetrahedra of this triangulation using a breadth-first search, so that small-numbered tetrahedra are adjacent to other small-numbered tetrahedra. </p>
<p >Specifically, the reordering will operate as follows. Tetrahedron 0 will remain tetrahedron 0. Its immediate neighbours will be numbered 1, 2, 3 and 4 (though if these neighbours are not distinct then of course fewer labels will be required). Their immediate neighbours will in turn be numbered 5, 6, and so on, ultimately following a breadth-first search throughout the entire triangulation.</p>
<p >If the optional argument <em>reverse</em> is <code>true</code>, then tetrahedron numbers will be assigned in reverse order. That is, tetrahedron 0 will become tetrahedron <em>n-1</em>, its neighbours will become tetrahedra <em>n-2</em> down to <em>n-5</em>, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td><code>true</code> if the new tetrahedron numbers should be assigned in reverse order, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2a4b8a276b82d111455455fd74ecfc4" name="ab2a4b8a276b82d111455455fd74ecfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a4b8a276b82d111455455fd74ecfc4">&#9670;&nbsp;</a></span>retriangulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::retriangulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all triangulations that can be reached from this via Pachner moves, without exceeding a given number of additional tetrahedra. </p>
<p >Specifically, this routine will iterate through all triangulations that can be reached from this triangulation via 2-3 and 3-2 Pachner moves, without ever exceeding <em>height</em> additional tetrahedra beyond the original number.</p>
<p >For every such triangulation (including this starting triangulation), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take the following initial argument(s). Either (a) the first argument must be a triangulation (the precise type is discussed below), representing the triangluation that has been found; or else (b) the first two arguments must be of types const std::string&amp; followed by a triangulation, representing both the triangulation and <em>an</em> isomorphism signature. The second form is offered in order to avoid unnecessary recomputation within the <em>action</em> function; however, note that the signature might not be of the <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a> type (i.e., it might not match the output from the default version of <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>). If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li>The triangulation argument will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more triangulations will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this triangulation (i.e., the original triangulation upon which <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab2a4b8a276b82d111455455fd74ecfc4" title="Explores all triangulations that can be reached from this via Pachner moves, without exceeding a give...">retriangulate()</a> was called). This will not affect the search: all triangulations that this routine visits will be obtained via Pachner moves from the original form of this triangulation, before any subsequent changes (if any) were made.</li>
<li><em>action</em> will only be called once for each triangulation (including this starting triangulation). In other words, no triangulation will be revisited a second time in a single call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab2a4b8a276b82d111455455fd74ecfc4" title="Explores all triangulations that can be reached from this via Pachner moves, without exceeding a give...">retriangulate()</a>.</li>
</ul>
<p >This routine can be very slow and very memory-intensive, since the number of triangulations it visits may be superexponential in the number of tetrahedra, and it records every triangulation that it visits (so as to avoid revisiting the same triangulation again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p >If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional tetrahedra. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some triangulation that is passed to it.</p>
<p >Since Regina 7.0, this routine will not return until the exploration of triangulations is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the enumeration to start in the background), simply call this routine in a new detached thread.</p>
<p >To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time); as a corollary, the action should avoid expensive operations where possible (otherwise it will become a serialisation bottleneck in the multithreading).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is connected.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation has more than one connected component. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the arguments <em>tracker</em> and <em>args</em> are removed, so you call it as retriangulate(height, threads, action). Moreover, <em>action</em> must take exactly two arguments (const std::string&amp;, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>&amp;&amp;) representing a signature and the triangulation, as described in option (b) above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> tetrahedra to allow beyond the number of tetrahedra originally present in the triangulation, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each triangulation that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial triangulation argument(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="aa0c68d0faa4438c15960509298e100ec" name="aa0c68d0faa4438c15960509298e100ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c68d0faa4438c15960509298e100ec">&#9670;&nbsp;</a></span>saveRecogniser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::saveRecogniser </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes this triangulation to the given file in Matveev's 3-manifold recogniser format. </p>
<p >Recogniser exports are currently not available for triangulations that are invalid or contain boundary triangles. If either of these conditions is true then the file will not be written, and this routine will return <code>false</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the Recogniser file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="ae579243386ad33795b0759dd5fb35fab" name="ae579243386ad33795b0759dd5fb35fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae579243386ad33795b0759dd5fb35fab">&#9670;&nbsp;</a></span>saveRecognizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::saveRecognizer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aa0c68d0faa4438c15960509298e100ec" title="Writes this triangulation to the given file in Matveev&#39;s 3-manifold recogniser format.">saveRecogniser()</a>. </p>
<p >This writes this triangulation to the given file in Matveev's 3-manifold recogniser format.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the Recogniser file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="a91aaa7b5e790451d0732dbd158804249" name="a91aaa7b5e790451d0732dbd158804249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aaa7b5e790451d0732dbd158804249">&#9670;&nbsp;</a></span>saveSnapPea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::saveSnapPea </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this triangulation to the given file using SnapPea's native file format. </p>
<p >Unlike <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#aeb639b623dc4ad63c38597e5ba99f16c" title="Writes this triangulation to the given file using SnapPea&#39;s native file format.">Triangulation&lt;3&gt;::saveSnapPea()</a>, this routine uses the SnapPea kernel to produce the file contents. This means it will include not just the tetrahedron gluings, but also other SnapPea-specific information that Regina does not use (e.g., peripheral curves).</p>
<p >If this is a null triangulation, then the file will not be written and this routine will return <code>false</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the SnapPea file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="ac9a451bd5ec702a229ada193bda78575" name="ac9a451bd5ec702a229ada193bda78575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a451bd5ec702a229ada193bda78575">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::complex&lt; double &gt; &amp; regina::SnapPeaTriangulation::shape </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the shape of the given tetrahedron, with respect to the Dehn filled hyperbolic structure. </p>
<p >Tetrahedron shapes are given in rectangular form, and using a fixed coordinate system (fixed alignment, in SnapPea's terminology).</p>
<p >If this is a null triangulation, or if <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ad406c96fb657b36cba5fddb1366a729f" title="Returns the type of solution found when solving for a hyperbolic structure, with respect to the curre...">solutionType()</a> is no_solution or not_attempted (i.e., we did not or could not solve for a hyperbolic structure), then this routine will simply return zero.</p>
<p >This routine is fast constant time (unlike in SnapPea, where the corresponding routine <em>get_tet_shape</em> takes linear time). Therefore you can happily call this routine repeatedly without a significant performance penalty.</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.tetrahedra_shapes(part="rect")[tet]</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the index of a tetrahedron; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shape of the given tetrahedron, in rectangular form. </dd></dl>

</div>
</div>
<a id="a37b16dc8a8d13d3b01f1cee099988fd3" name="a37b16dc8a8d13d3b01f1cee099988fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b16dc8a8d13d3b01f1cee099988fd3">&#9670;&nbsp;</a></span>shellBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::shellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron. </p>
<p >This involves simply popping off a tetrahedron that touches the boundary. This can be done if:</p>
<ul>
<li>all edges of the tetrahedron are valid;</li>
<li>precisely one, two or three faces of the tetrahedron lie in the boundary;</li>
<li>if one face lies in the boundary, then the opposite vertex does not lie in the boundary, and no two of the remaining three edges are identified;</li>
<li>if two faces lie in the boundary, then the remaining edge does not lie in the boundary, and the remaining two faces of the tetrahedron are not identified.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this operation will (trivially) preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given tetrahedron is a tetrahedron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron upon which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae2e269a7332e80aeec3603881fd175d3" name="ae2e269a7332e80aeec3603881fd175d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e269a7332e80aeec3603881fd175d3">&#9670;&nbsp;</a></span>simplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p >Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="a7cdadce4ea703518064241597cf1514b" name="a7cdadce4ea703518064241597cf1514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdadce4ea703518064241597cf1514b">&#9670;&nbsp;</a></span>simplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p >Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="a7d7a7d5c459569dbf66147b62f695c2d" name="a7d7a7d5c459569dbf66147b62f695c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a7d5c459569dbf66147b62f695c2d">&#9670;&nbsp;</a></span>simplices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all top-dimensional simplices in this triangulation. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Simplex&lt;dim&gt;* s : tri.simplices()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the triangulation exists: even as simplices are added and/or removed, it will always reflect the simplices that are currently in the triangulation. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="ae6af21977c3e7391562de87c7357bb86" name="ae6af21977c3e7391562de87c7357bb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6af21977c3e7391562de87c7357bb86">&#9670;&nbsp;</a></span>simplifiedFundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplifiedFundamentalGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td>
          <td class="paramname"><em>newGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the triangulation that you have simplified the presentation of its fundamental group. </p>
<p >The old group presentation will be replaced by the (hopefully simpler) group that is passed.</p>
<p >This routine is useful for situations in which some external body (such as GAP) has simplified the group presentation better than Regina can.</p>
<p >Regina does <em>not</em> verify that the new group presentation is equivalent to the old, since this is - well, hard.</p>
<p >If the fundamental group has not yet been calculated for this triangulation, then this routine will store the new group as the fundamental group, under the assumption that you have worked out the group through some other clever means without ever having needed to call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> at all.</p>
<p >Note that this routine will not fire a packet change event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newGroup</td><td>a new (and hopefully simpler) presentation of the fundamental group of this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8696fcaf4e922a333dd5ed9035b724e5" name="a8696fcaf4e922a333dd5ed9035b724e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8696fcaf4e922a333dd5ed9035b724e5">&#9670;&nbsp;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph. </p>
<p >This routine is more powerful but much slower than <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p >Specifically, this routine will iterate through all triangulations that can be reached from this triangulation via 2-3 and 3-2 Pachner moves, without ever exceeding <em>height</em> additional tetrahedra beyond the original number.</p>
<p >If at any stage it finds a triangulation with <em>fewer</em> tetrahedra than the original, then this routine will call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> to shrink the triangulation further if possible and will then return <code>true</code>. If it cannot find a triangulation with fewer tetrahedra then it will leave this triangulation unchanged and return <code>false</code>.</p>
<p >This routine can be very slow and very memory-intensive: the number of triangulations it visits may be superexponential in the number of tetrahedra, and it records every triangulation that it visits (so as to avoid revisiting the same triangulation again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p >If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional tetrahedra. This means that the routine will not terminate until a simpler triangulation is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p >If you want a <em>fast</em> simplification routine, you should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> instead. The benefit of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> is that, for very stubborn triangulations where <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> finds itself stuck at a local minimum, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p >Since Regina 7.0, this routine will not return until either the triangulation is simplified or the exhaustive search is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the exhaustive search to start in the background), simply call this routine in a new detached thread.</p>
<p >To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either the triangulation was simplified or the search was exhausted).</p>
<p >If this routine is unable to simplify the triangulation, then the triangulation will not be changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is connected.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation has more than one connected component. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> tetrahedra to allow beyond the number of tetrahedra originally present in the triangulation, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>nullptr</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was successfully simplified to fewer tetrahedra. </dd></dl>

</div>
</div>
<a id="a0bc067391ecf8f6269e624ee9d658761" name="a0bc067391ecf8f6269e624ee9d658761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc067391ecf8f6269e624ee9d658761">&#9670;&nbsp;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of tetrahedra. </p>
<p >End users will probably not want to call this routine. You should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> if you want a fast (and usually effective) means of simplifying a triangulation, or you should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a8696fcaf4e922a333dd5ed9035b724e5" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p >The moves used by this routine include 3-2, 2-0 (edge and vertex), 2-1 and boundary shelling moves.</p>
<p >Moves that do not reduce the number of tetrahedra (such as 4-4 moves or book opening moves) are not used in this routine. Such moves do however feature in <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the triangulation was changed to reduce the number of tetrahedra; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="a3871caa1f02ccda957f22ebd9a646ff5" name="a3871caa1f02ccda957f22ebd9a646ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871caa1f02ccda957f22ebd9a646ff5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of top-dimensional simplices in the triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="af43e3884dce2f26e6920fb9b64d2c4d8" name="af43e3884dce2f26e6920fb9b64d2c4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43e3884dce2f26e6920fb9b64d2c4d8">&#9670;&nbsp;</a></span>slopeEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> regina::SnapPeaTriangulation::slopeEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix for computing boundary slopes of spun-normal surfaces at the cusps of the triangulation. </p>
<p >This matrix includes a pair of rows for each cusp in the triangulation: one row for determining the algebraic intersection number with the meridian, followed by one row for determining the algebraic intersection number with the longitude.</p>
<p >If the triangulation has more than one cusp, these pairs are ordered by cusp index (as stored by SnapPea). You can examine <code>cusp(cusp_number).<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9b86e0d3a00fa5da038c6cce117b343f" title="A dimension-specific alias for face&lt;0&gt;().">vertex()</a></code> to map these to Regina's vertex indices if needed.</p>
<p >For the purposes of this routine, any fillings on the cusps of this SnapPea triangulation will be ignored.</p>
<p >This matrix is constructed so that, if <em>M</em> and <em>L</em> are the rows for the meridian and longitude at some cusp, then for any spun-normal surface with quadrilateral coordinates <em>q</em>, the boundary curves have algebraic intersection number <em>M.q</em> with the meridian and <em>L.q</em> with the longitude. Equivalently, the boundary curves pass <em>L.q</em> times around the meridian and <em>-M.q</em> times around the longitude. To compute these slopes directly from a normal surface, see <a class="el" href="classregina_1_1NormalSurface.html#adc6df0a57dfc810cbde7845cd8ae9a31" title="Computes the information about the boundary slopes of this surface at each cusp of the triangulation.">NormalSurface::boundaryIntersections()</a>.</p>
<p >The orientations of the boundary curves of a spun-normal surface are chosen so that <em>if</em> meridian and longitude are a positive basis as vieved from the cusp, then as one travels along an oriented boundary curve, the spun-normal surface spirals into the cusp to one's right and down into the manifold to one's left.</p>
<dl class="section user"><dt>SnapPy</dt><dd>This has no corresponding routine in SnapPy.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>All vertex links in this triangulation must be tori.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this triangulation was constructed from a Regina triangulation (of class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>), then Regina will have no information about what meridian and longitude the user wishes to use (since Regina does not keep track of peripheral curves on cusps). Therefore Regina will give boundary slopes relative to the (shortest, second-shortest) basis, as described in the constructor <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a7f4c2d636af7f2e3f341f451a6990479" title="Converts the given Regina triangulation to a SnapPea triangulation.">SnapPeaTriangulation(const Triangulation&lt;3&gt;&amp;, bool)</a>. This might not be what the user expects.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>William Pettersson and Stephan Tillmann</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix with (2 * <em>number_of_cusps</em>) rows and (3 * <em>number_of_tetrahedra</em>) columns as described above. </dd></dl>

</div>
</div>
<a id="a72bf21c353d9a6908fb2ad1cceeef899" name="a72bf21c353d9a6908fb2ad1cceeef899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bf21c353d9a6908fb2ad1cceeef899">&#9670;&nbsp;</a></span>snapPea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SnapPeaTriangulation::snapPea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the full contents of a SnapPea data file that describes this triangulation. </p>
<p >In particular, this string can be used in a Python session to pass the triangulation directly to SnapPy (without writing to the filesystem).</p>
<p >Unlike <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0806bc4423a639426fb63d4277e895da" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">Triangulation&lt;3&gt;::snapPea()</a>, this routine uses the SnapPea kernel to produce the file contents. This means it will include not just the tetrahedron gluings, but also other SnapPea-specific information that Regina does not use (e.g., peripheral curves).</p>
<p >If you wish to export a triangulation to a SnapPea <em>file</em>, you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a91aaa7b5e790451d0732dbd158804249" title="Writes this triangulation to the given file using SnapPea&#39;s native file format.">saveSnapPea()</a> instead (which has better performance, and does not require you to construct an enormous intermediate string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the contents of the corresponding SnapPea data file. </dd></dl>

</div>
</div>
<a id="a0979d361c39388005df28ddba4050d52" name="a0979d361c39388005df28ddba4050d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0979d361c39388005df28ddba4050d52">&#9670;&nbsp;</a></span>snapPea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::snapPea </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the full contents of a SnapPea data file describing this triangulation to the given output stream. </p>
<p >Unlike <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0806bc4423a639426fb63d4277e895da" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">Triangulation&lt;3&gt;::snapPea()</a>, this routine uses the SnapPea kernel to produce the file contents. This means it will include not just the tetrahedron gluings, but also other SnapPea-specific information that Regina does not use (e.g., peripheral curves).</p>
<p >If you wish to extract the SnapPea data file as a string, you should call the zero-argument routine <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a72bf21c353d9a6908fb2ad1cceeef899" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">snapPea()</a> instead. If you wish to write to a real SnapPea data file on the filesystem, you should call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a91aaa7b5e790451d0732dbd158804249" title="Writes this triangulation to the given file using SnapPea&#39;s native file format.">saveSnapPea()</a> (which is also available in Python).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant of <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a72bf21c353d9a6908fb2ad1cceeef899" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">snapPea()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the SnapPea data file will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad406c96fb657b36cba5fddb1366a729f" name="ad406c96fb657b36cba5fddb1366a729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad406c96fb657b36cba5fddb1366a729f">&#9670;&nbsp;</a></span>solutionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaTriangulation.html#a9fb06be1a5084ff01ac6a96de0050770">SolutionType</a> regina::SnapPeaTriangulation::solutionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of solution found when solving for a hyperbolic structure, with respect to the current Dehn filling (if any). </p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.solution_type()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the solution type. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a91466715d657a6d6fb8cad7d45b0aa22" name="a91466715d657a6d6fb8cad7d45b0aa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91466715d657a6d6fb8cad7d45b0aa22">&#9670;&nbsp;</a></span>strictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::strictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a strict angle structure on this triangulation, if one exists. </p>
<p >Recall that a <em>strict</em> angle structure is one in which every angle is strictly between 0 and π. If a strict angle structure does exist, then this routine is guaranteed to return one.</p>
<p >This routine is designed for scenarios where you already know that a strict angle structure exists. This means:</p>
<ul>
<li>If no strict angle structure exists, this routine will throw an exception, which will incur a significant overhead.</li>
<li>If you do <em>not</em> know in advance whether a strict angle structure exists, you should call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#acf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> first. If the answer is no, this will avoid the overhead of throwing and catching exceptions. If the answer is yes, this will have the side-effect of caching the strict angle structure, which means your subsequent call to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22" title="Returns a strict angle structure on this triangulation, if one exists.">strictAngleStructure()</a> will be essentially instantaneous.</li>
</ul>
<p >The underlying algorithm runs a single linear program (it does <em>not</em> enumerate all vertex angle structures). This means that it is likely to be fast even for large triangulations.</p>
<p >The result of this routine is cached internally: as long as the triangulation does not change, multiple calls to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91466715d657a6d6fb8cad7d45b0aa22" title="Returns a strict angle structure on this triangulation, if one exists.">strictAngleStructure()</a> will return identical angle structures, and every call after the first be essentially instantaneous.</p>
<p >If the triangulation does change, however, then the cached angle structure will be deleted, and any reference that was returned before will become invalid.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NoSolution.html" title="An exception thrown when Regina has certified that a mathematical problem has no solution.">NoSolution</a></td><td>No strict angle structure exists on this triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a strict angle structure on this triangulation, if one exists. </dd></dl>

</div>
</div>
<a id="a0e7139822eb449840c13dbcc304f8491" name="a0e7139822eb449840c13dbcc304f8491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7139822eb449840c13dbcc304f8491">&#9670;&nbsp;</a></span>subdivide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::subdivide</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a barycentric subdivision of the triangulation. </p>
<p >This is done in-place, i.e., the triangulation will be modified directly.</p>
<p >Each top-dimensional simplex <em>s</em> is divided into (<em>dim</em> + 1) factorial sub-simplices by placing an extra vertex at the centroid of every face of every dimension. Each of these sub-simplices <em>t</em> is described by a permutation <em>p</em> of (0, ..., <em>dim</em>). The vertices of such a sub-simplex <em>t</em> are:</p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em>;</li>
<li>...</li>
<li>the centroid of face (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2], <em>p</em>[<em>dim</em>]) of <em>s</em>, which is the entire simplex <em>s</em> itself.</li>
</ul>
<p >The sub-simplices have their vertices numbered in a way that mirrors the original simplex <em>s:</em> </p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em> will be labelled <em>p</em>[0] in <em>t</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em> will be labelled <em>p</em>[1] in <em>t</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em> will be labelled <em>p</em>[2] in <em>t</em>;</li>
<li>...</li>
<li>the centroid of <em>s</em> itself will be labelled <em>p</em>[<em>dim</em>] in <em>t</em>.</li>
</ul>
<p >In particular, if this triangulation is currently oriented, then this barycentric subdivision will preserve the orientation.</p>
<p >If simplex <em>s</em> has index <em>i</em> in the original triangulation, then its sub-simplex corresponding to permutation <em>p</em> will have index <code>((dim + 1)! * i + p.orderedSnIndex())</code> in the resulting triangulation. In other words: sub-simplices are ordered first according to the original simplex that contains them, and then according to the lexicographical ordering of the corresponding permutations <em>p</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions. This precondition is a safety net, since in higher dimensions the triangulation would explode too quickly in size (and for the highest dimensions, possibly beyond the limits of <code>size_t</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimensions 3 and 4, both the labelling and ordering of sub-simplices in the subdivided triangulation has changed as of Regina 5.1. (Earlier versions of Regina made no guarantee about the labelling and ordering; these guarantees are also new to Regina 5.1).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the subdivision. However, only do this for <em>valid</em> triangulations (since we can have scenarios where invalid triangulations becoming valid and ideal after subdivision, which may change properties such as Triangulation&lt;4&gt;::knownSimpleLinks). </dd></dl>

</div>
</div>
<a id="a62be236f61c28a04a102667cfbd6eea3" name="a62be236f61c28a04a102667cfbd6eea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62be236f61c28a04a102667cfbd6eea3">&#9670;&nbsp;</a></span>summands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::summands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the connected sum decomposition of this triangulation. </p>
<p >The prime summands will be returned as a vector of triangulations; this triangulation will not be modified.</p>
<p >As far as possible, the summands will be represented using 0-efficient triangulations (i.e., triangulations that contain no non-vertex-linking normal spheres). Specifically, for every summand, either:</p>
<ul>
<li>the triangulation of the summand that is produced will be 0-efficient; or</li>
<li>the summand is one of RP3, the product S2xS1, or the twisted product S2x~S1. In each of these cases there is no possible 0-efficient triangulation of the summand, and so the triangulation that is produced will just be minimal (i.e., two tetrahedra).</li>
</ul>
<p >For non-orientable triangulations, this routine is only guaranteed to succeed if the original manifold contains no embedded two-sided projective planes. If the manifold <em>does</em> contain embedded two-sided projective planes, then this routine might still succeed but it might fail; however, such a failure will always be detected, and in such a case this routine will throw an exception (as detailed below).</p>
<p >Note that this routine is currently only available for closed triangulations; see the list of preconditions for full details. If this triangulation is a 3-sphere then this routine will return an empty list.</p>
<p >This function is new to Regina 7.0, and it has some important changes of behaviour from the old connectedSumDecomposition() from Regina 6.0.1 and earlier:</p>
<ul>
<li>This function does not insert the resulting components into the packet tree.</li>
<li>If this routine fails because of an embedded two-sided projective plane, then it throws an exception instead of returning -1.</li>
<li>This function does not assign labels to the new summands.</li>
</ul>
<p >The underlying algorithm appears in "A new approach to crushing
3-manifold triangulations", Discrete and Computational Geometry 52:1 (2014), pp. 116-139. This algorithm is based on the Jaco-Rubinstein 0-efficiency algorithm, and works in both orientable and non-orientable settings.</p>
<dl class="section warning"><dt>Warning</dt><dd>Users are strongly advised to check for exceptions if embedded two-sided projective planes are a possibility, since in such a case this routine might fail (as explained above). Note however that this routine might still succeed, and so success is not a proof that no embedded two-sided projective planes exist.</dd>
<dd>
The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations. For 3-sphere testing, see the routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a95050517897ca5dc5b5da5f022155e49" title="Determines whether this is a triangulation of a 3-sphere.">isSphere()</a> which uses faster methods where possible.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and connected.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The original manifold is non-orientable and contains one or more embedded two-sided projective planes, and this routine was not able to recover from this situation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of triangulations of prime summands. </dd></dl>

</div>
</div>
<a id="aba7a6bc4f86db0ee34232c78c5cfc597" name="aba7a6bc4f86db0ee34232c78c5cfc597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7a6bc4f86db0ee34232c78c5cfc597">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given SnapPea triangulation. </p>
<p >All information contained in this triangulation, including both Regina's and SnapPea's internal data as well as all cached properties, will be moved to <em>other</em>. Likewise, all information contained in <em>other</em> will be moved to this triangulation.</p>
<p >In particular, any pointers or references to Tetrahedron&lt;3&gt;, Face&lt;3, subdim&gt; and/or <a class="el" href="classregina_1_1Cusp.html" title="Used to return information about a single cusp of a SnapPea triangulation.">Cusp</a> objects will remain valid.</p>
<p >This routine will behave correctly if <em>other</em> is in fact this triangulation.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to swap the contents of two SnapPea triangulations, you <em>must</em> cast both to <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> before calling <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aba7a6bc4f86db0ee34232c78c5cfc597" title="Swaps the contents of this and the given SnapPea triangulation.">swap()</a>. If either argument is presented as the parent class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, then the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aba7a6bc4f86db0ee34232c78c5cfc597" title="Swaps the contents of this and the given SnapPea triangulation.">swap()</a> will be called instead; the result will be that (just like when you call any of the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> edit routines) both SnapPea triangulations will be reset to null triangulations. See the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class notes for further discussion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both triangulations which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the SnapPea triangulation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a111c0d2dfaba45d86517ba04bb7aa019" name="a111c0d2dfaba45d86517ba04bb7aa019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111c0d2dfaba45d86517ba04bb7aa019">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Snapshottable.html">Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap operation. </p>
<p >This should <em>only</em> be called when the entire type <em>T</em> contents of this object and <em>other</em> are being swapped. If one object has a current snapshot, then the other object will move in as the new image for that <em>same</em> snapshot. This avoids a deep copies of this object and/or <em>other</em>, even though both objects are changing.</p>
<p >In particular, if the swap function for <em>T</em> calls this base class function (as it should), then there is no need to call <a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f" title="Must be called before modification and/or destruction of the type T contents.">takeSnapshot()</a> from either this object or <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the snapshot image being swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab42e9ae581e5df1e9a55ffa64cba52bb" name="ab42e9ae581e5df1e9a55ffa64cba52bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42e9ae581e5df1e9a55ffa64cba52bb">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given triangulation. </p>
<p >All tetrahedra that belong to this triangulation will be moved to <em>other</em>, and all tetrahedra that belong to <em>other</em> will be moved to this triangulation. Likewise, all skeletal objects (such as lower-dimensional faces, components, and boundary components) and all cached properties (such as homology and fundamental group) will be swapped.</p>
<p >In particular, any pointers or references to Tetrahedron&lt;3&gt; and/or Face&lt;3, subdim&gt; objects will remain valid.</p>
<p >This routine will behave correctly if <em>other</em> is in fact this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both triangulations which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b16509c98bc3e4b38f673aff15337f5" name="a8b16509c98bc3e4b38f673aff15337f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b16509c98bc3e4b38f673aff15337f5">&#9670;&nbsp;</a></span>swapBaseData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::swapBaseData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all data that is managed by this base class, including simplices, skeletal data, cached properties and the snapshotting data, with the given triangulation. </p>
<p >Note that TriangulationBase never calls this routine itself. Typically <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a8b16509c98bc3e4b38f673aff15337f5" title="Swaps all data that is managed by this base class, including simplices, skeletal data,...">swapBaseData()</a> is only ever called by <a class="el" href="classregina_1_1Triangulation.html#a2bd6dce66f275321427010a5b11b0894" title="Swaps the contents of this and the given triangulation.">Triangulation&lt;dim&gt;::swap()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose data should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7e625e918d497e1a006bc13b64a1d4f" name="ac7e625e918d497e1a006bc13b64a1d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e625e918d497e1a006bc13b64a1d4f">&#9670;&nbsp;</a></span>takeSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::takeSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called before modification and/or destruction of the type <em>T</em> contents. </p>
<p >See the <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> class notes for a full explanation of how this requirement works.</p>
<p >There are a few exceptions where <a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f" title="Must be called before modification and/or destruction of the type T contents.">takeSnapshot()</a> does not need to be called: these are where type <em>T</em> move, copy and/or swap operations call the base class operations (as they should). See the <a class="el" href="classregina_1_1Snapshottable.html" title="A base class for images of type T that can be snapshotted at a particular moment in time.">Snapshottable</a> move, copy and swap functions for details.</p>
<p >If this object has a current snapshot, then this function will trigger a deep copy with the snapshot.</p>
<p >After this function returns, this object is guaranteed to be completely unenrolled from the snapshotting machinery. </p>

</div>
</div>
<a id="a93ff42c3c6b43c59759b08be17d7e269" name="a93ff42c3c6b43c59759b08be17d7e269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff42c3c6b43c59759b08be17d7e269">&#9670;&nbsp;</a></span>tetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedra</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 3. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a85dec07a713f18b9675926a33a7ee544" name="a85dec07a713f18b9675926a33a7ee544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dec07a713f18b9675926a33a7ee544">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 3 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a2272099afa80eff2b1aed22237df0147" name="a2272099afa80eff2b1aed22237df0147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2272099afa80eff2b1aed22237df0147">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3. </p>
<p >This alias is available for dimensions <em>dim</em> ≥ 3. It returns a const tetrahedron pointer in dimension <em>dim</em> = 3, and a non-const tetrahedron pointer in all higher dimensions.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a93e807b7e562aeafd28ca506bd78f7b4" name="a93e807b7e562aeafd28ca506bd78f7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e807b7e562aeafd28ca506bd78f7b4">&#9670;&nbsp;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a triangulation from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a <em>dim</em>-dimensional triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c" title="Reconstructs an object of type T from its given tight encoding.">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a <em>dim</em>-dimensional triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the triangulation represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&nbsp;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a393121abbf7a159a21ffca9deb9fb824" name="a393121abbf7a159a21ffca9deb9fb824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393121abbf7a159a21ffca9deb9fb824">&#9670;&nbsp;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this triangulation to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d" title="Returns the tight encoding of this object.">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&nbsp;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function <a class="el" href="group__utilities.html#ga588cb4d07d97f9a53e86859e4e233aab" title="Writes the tight encoding of the given boolean to the given output stream.">T::tightEncode()</a>. See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a2a9a1bdc2c2e643c8c424cd31f557207" name="a2a9a1bdc2c2e643c8c424cd31f557207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9a1bdc2c2e643c8c424cd31f557207">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a face of some other triangulation into the corresponding face of this triangulation, using simplex numbers for the translation. </p>
<p >Typically this routine would be used when the given face comes from a triangulation that is combinatorially identical to this, and you wish to obtain the corresponding face of this triangulation.</p>
<p >Specifically: if <em>other</em> refers to face <em>i</em> of top-dimensional simplex number <em>k</em> of some other triangulation, then this routine will return face <em>i</em> of top-dimensional simplex number <em>k</em> of this triangulation. Note that this routine does <em>not</em> use the face indices within each triangulation (which is outside the user's control), but rather the simplex numbering (which the user has full control over).</p>
<p >This routine behaves correctly even if <em>other</em> is a null pointer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation contains at least as many top-dimensional simplices as the triangulation containing <em>other</em> (though, as noted above, in typical scenarios both triangulations would actually be combinatorially identical).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the face to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face of this triangulation. </dd></dl>

</div>
</div>
<a id="af5f98ff3524ca696f47c2d875d6ec22f" name="af5f98ff3524ca696f47c2d875d6ec22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f98ff3524ca696f47c2d875d6ec22f">&#9670;&nbsp;</a></span>triangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 2 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a5c7536b6eef07a72d344053560d06594" name="a5c7536b6eef07a72d344053560d06594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7536b6eef07a72d344053560d06594">&#9670;&nbsp;</a></span>triangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2. </p>
<p >This alias is available for all dimensions <em>dim</em>. It returns a const triangle pointer in dimension <em>dim</em> = 2, and a non-const triangle pointer in all higher dimensions.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="acce900ea2eb29bfac1b9c93ca78f9ea3" name="acce900ea2eb29bfac1b9c93ca78f9ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce900ea2eb29bfac1b9c93ca78f9ea3">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;2&gt;()</a>, or an alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 2. </p>
<p >This alias is available for all dimensions.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a8c9bc864e2b45447e3fcc92f99d3840e" name="a8c9bc864e2b45447e3fcc92f99d3840e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9bc864e2b45447e3fcc92f99d3840e">&#9670;&nbsp;</a></span>triangulateComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangulateComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the individual connected components of this triangulation. </p>
<p >This triangulation will not be modified.</p>
<p >This function is new to Regina 7.0, and it has two important changes of behaviour from the old splitIntoComponents() from Regina 6.0.1 and earlier:</p>
<ul>
<li>This function does not insert the resulting components into the packet tree.</li>
<li>This function does not assign labels to the new components.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a list of individual component triangulations. </dd></dl>

</div>
</div>
<a id="ad3c7fc5f723ce2c68158d7319dda0cc4" name="ad3c7fc5f723ce2c68158d7319dda0cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c7fc5f723ce2c68158d7319dda0cc4">&#9670;&nbsp;</a></span>turaevViro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::turaevViro </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parity</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic. </p>
<p >The initial data for the Turaev-Viro invariant is as described in the paper of Turaev and Viro, "State sum invariants of 3-manifolds
and quantum 6j-symbols", Topology, vol. 31, no. 4, 1992, pp 865-902. In particular, Section 7 of this paper describes the initial data as determined by an integer r ≥ 3, and a root of unity q₀ of degree 2r for which q₀² is a primitive root of unity of degree r. There are several cases to consider:</p>
<ul>
<li><em>r</em> may be even. In this case <em>q₀</em> must be a primitive (<em>2r</em>)th root of unity, and the invariant is computed as an element of the cyclotomic field of order <em>2r</em>. There is no need to specify <em>which</em> root of unity is used, since switching between different roots of unity corresponds to an automorphism of the underlying cyclotomic field (i.e., it does not yield any new information). Therefore, if <em>r</em> is even, the additional argument <em>parity</em> is ignored.</li>
<li><em>r</em> may be odd, and <em>q₀</em> may be a primitive (2<em>r</em>)th root of unity. This case corresponds to passing the argument <em>parity</em> as <code>true</code>. Here the invariant is again computed as an element of the cyclotomic field of order <em>2r</em>. As before, there is no need to give further information as to which root of unity is used, since switching between roots of unity does not yield new information.</li>
<li><em>r</em> may be odd, and <em>q₀</em> may be a primitive (<em>r</em>)th root of unity. This case corresponds to passing the argument <em>parity</em> as <code>false</code>. In this case the invariant is computed as an element of the cyclotomic field of order <em>r</em>. Again, there is no need to give further information as to which root of unity is used.</li>
</ul>
<p >This routine works entirely within the relevant cyclotomic field, which yields exact results but adds a significant overhead to the running time. If you want a fast floating-point approximation, you can call <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> instead.</p>
<p >Unlike this routine, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> requires a precise specification of which root of unity is used (since it returns a numerical real value). The numerical value obtained by calling <code>turaevViroApprox(r, whichRoot)</code> should be the same as <code>turaevViro(r, parity).evaluate(whichRoot)</code>, where <em>parity</em> is <code>true</code> or <code>false</code> according to whether <em>whichRoot</em> is odd or even respectively. Of course in practice the numerical values might be very different, since <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> performs significantly more floating point operations, and so is subject to a much larger potential numerical error.</p>
<p >If the requested Turaev-Viro invariant has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger triangulations and/or larger values of <em>r</em>.</p>
<p >Since Regina 7.0, this routine will not return until the Turaev-Viro computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and non-empty.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the integer <em>r</em> as described above; this must be at least 3. </td></tr>
    <tr><td class="paramname">parity</td><td>determines for odd <em>r</em> whether <em>q₀</em> is a primitive <em>2r</em>th or <em>r</em>th root of unity, as described above. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the invariant. If you are not sure, the default value (ALG_DEFAULT) is a safe choice. This should be treated as a hint only: if the algorithm you choose is not supported for the given parameters (<em>r</em> and <em>parity</em>), then Regina will use another algorithm instead. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through will progress will be reported, or <code>nullptr</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested Turaev-Viro invariant, or an uninitialised field element if the calculation was cancelled via the given progress tracker.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad43a33c581d838c8d558da03acc290c7" title="Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifo...">allCalculatedTuraevViro</a> </dd></dl>

</div>
</div>
<a id="a45d6e40d1a39ee48966c7a95f00092da" name="a45d6e40d1a39ee48966c7a95f00092da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d6e40d1a39ee48966c7a95f00092da">&#9670;&nbsp;</a></span>turaevViroApprox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::turaevViroApprox </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>whichRoot</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floating-point approximation. </p>
<p >The initial data for the Turaev-Viro invariant is as described in the paper of Turaev and Viro, "State sum invariants of 3-manifolds
and quantum 6j-symbols", Topology, vol. 31, no. 4, 1992, pp 865-902. In particular, Section 7 describes the initial data as determined by an integer <em>r</em> ≥ 3 and a root of unity <em>q₀</em> of degree <em>2r</em> for which <em>q₀²</em> is a primitive root of unity of degree <em>r</em>.</p>
<p >The argument <em>whichRoot</em> specifies which root of unity is used for <em>q₀</em>. Specifically, <em>q₀</em> will be the root of unity <code>e^(2πi * whichRoot / 2r)</code>. There are additional preconditions on <em>whichRoot</em> to ensure that <em>q₀²</em> is a <em>primitive</em> root of unity of degree <em>r</em>; see below for details.</p>
<p >This same invariant can be computed by calling <code>turaevViro(r, parity).evaluate(whichRoot)</code>, where <em>parity</em> is <code>true</code> or <code>false</code> according to whether <em>whichRoot</em> is odd or even respectively. Calling <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> is significantly faster (since it avoids the overhead of working in cyclotomic fields), but may also lead to a much larger numerical error (since this routine might perform an exponential number of floating point operations, whereas the alternative only uses floating point for the final call to <a class="el" href="classregina_1_1Cyclotomic.html#a035724c74325a6121321d2c17fd57663" title="Returns the value of this cyclotomic field element as a complex number.">Cyclotomic::evaluate()</a>).</p>
<p >These invariants, although computed in the complex field, should all be reals. Thus the return type is an ordinary double.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and non-empty. </dd>
<dd>
The argument <em>whichRoot</em> is strictly between 0 and <em>2r</em>, and has no common factors with <em>r</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the integer <em>r</em> as described above; this must be at least 3. </td></tr>
    <tr><td class="paramname">whichRoot</td><td>specifies which root of unity is used for <em>q₀</em>, as described above. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the invariant. If you are not sure, the default value (ALG_DEFAULT) is a safe choice. This should be treated as a hint only: if the algorithm you choose is not supported for the given parameters (<em>r</em> and <em>whichRoot</em>), then Regina will use another algorithm instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested Turaev-Viro invariant.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad43a33c581d838c8d558da03acc290c7" title="Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifo...">allCalculatedTuraevViro</a> </dd></dl>

</div>
</div>
<a id="a4f35dda23ea3274dbf35c3196508df26" name="a4f35dda23ea3274dbf35c3196508df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f35dda23ea3274dbf35c3196508df26">&#9670;&nbsp;</a></span>twoOneMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoOneMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-1 move about the given edge. </p>
<p >This involves taking an edge meeting only one tetrahedron just once and merging that tetrahedron with one of the tetrahedra joining it.</p>
<p >This can be done assuming the following conditions:</p>
<ul>
<li>The edge must be valid and non-boundary.</li>
<li>The two remaining faces of the tetrahedron are not joined, and the tetrahedron face opposite the given endpoint of the edge is not boundary.</li>
<li>Consider the second tetrahedron to be merged (the one joined along the face opposite the given endpoint of the edge). Moreover, consider the two edges of this second tetrahedron that run from the (identical) vertices of the original tetrahedron not touching <em>e</em> to the vertex of the second tetrahedron not touching the original tetrahedron. These edges must be distinct and may not both be in the boundary.</li>
</ul>
<p >There are additional "distinct and not both boundary" conditions on faces of the second tetrahedron, but those follow automatically from the final condition above.</p>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this 2-1 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end of the edge <em>opposite</em> that at which the second tetrahedron (to be merged) is joined. The end is 0 or 1, corresponding to the labelling (0,1) of the vertices of the edge as described in <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html#a8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">EdgeEmbedding&lt;3&gt;::vertices()</a>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ac177c5e1e70fb0d0a24324108ce64ead" name="ac177c5e1e70fb0d0a24324108ce64ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac177c5e1e70fb0d0a24324108ce64ead">&#9670;&nbsp;</a></span>twoZeroMove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2. </p>
<p >This involves taking the two tetrahedra joined at that edge and squashing them flat. This can be done if:</p>
<ul>
<li>the edge is valid and non-boundary;</li>
<li>the two tetrahedra are distinct;</li>
<li>the edges opposite <em>e</em> in each tetrahedron are distinct and not both boundary;</li>
<li>if triangles <em>f1</em> and <em>f2</em> from one tetrahedron are to be flattened onto triangles <em>g1</em> and <em>g2</em> of the other respectively, then (a) <em>f1</em> and <em>g1</em> are distinct, (b) <em>f2</em> and <em>g2</em> are distinct, (c) we do not have both <em>f1</em> = <em>g2</em> and <em>g1</em> = <em>f2</em>, (d) we do not have both <em>f1</em> = <em>f2</em> and <em>g1</em> = <em>g2</em>, and (e) we do not have two of the triangles boundary and the other two identified.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="acaa1cd8d7fd0334ad909beafcd75974c" name="acaa1cd8d7fd0334ad909beafcd75974c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa1cd8d7fd0334ad909beafcd75974c">&#9670;&nbsp;</a></span>twoZeroMove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given vertex of degree 2. </p>
<p >This involves taking the two tetrahedra joined at that vertex and squashing them flat. This can be done if:</p>
<ul>
<li>the vertex is non-boundary and has a 2-sphere vertex link;</li>
<li>the two tetrahedra are distinct;</li>
<li>the triangles opposite <em>v</em> in each tetrahedron are distinct and not both boundary;</li>
<li>the two tetrahedra meet each other on all three faces touching the vertex (as opposed to meeting each other on one face and being glued to themselves along the other two).</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>v</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given vertex is a vertex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vertex about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae0f9c7a14c1bbe226f4215d19ab5becd" name="ae0f9c7a14c1bbe226f4215d19ab5becd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f9c7a14c1bbe226f4215d19ab5becd">&#9670;&nbsp;</a></span>unfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::unfill </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichCusp</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any filling on the given cusp. </p>
<p >After removing the filling, this routine will automatically ask SnapPea to update the hyperbolic structure.</p>
<p >If the given cusp is already complete, then this routine safely does nothing.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be warned that cusp <em>i</em> might not correspond to vertex <em>i</em> of the triangulation. The <a class="el" href="classregina_1_1Cusp.html#a4684e9ef9cccb082e106f50f91c856ac" title="Returns the corresponding vertex of the Regina triangulation (i.e., of the Triangulation&lt;3&gt; structure...">Cusp::vertex()</a> method (which is accessed through the <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a951a9bbccbfb02315886e2f5371f2607" title="Returns information about the given cusp of this manifold.">cusp()</a> routine) can help translate between SnapPea's cusp numbers and Regina's vertex numbers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichCusp</td><td>the index of the cusp to unfill according to SnapPea; this must be between 0 and <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a67facbc8a73fa32e37ee2bc79df76aa1" title="Returns the total number of cusps (both filled and complete).">countCusps()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a9b86e0d3a00fa5da038c6cce117b343f" name="a9b86e0d3a00fa5da038c6cce117b343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b86e0d3a00fa5da038c6cce117b343f">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;0&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ad44ec5cdb434c3119eb68ce0deae76c8" name="ad44ec5cdb434c3119eb68ce0deae76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ec5cdb434c3119eb68ce0deae76c8">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;0&gt;()</a>. </p>
<p >This alias is available for all dimensions <em>dim</em>.</p>
<p >See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a757ff5bfcc94c9e3a1c17a6c464a62ca" name="a757ff5bfcc94c9e3a1c17a6c464a62ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757ff5bfcc94c9e3a1c17a6c464a62ca">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double regina::SnapPeaTriangulation::volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the volume of the current solution to the hyperbolic gluing equations. </p>
<p >This will be with respect to the current Dehn filling (if any).</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.volume()</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated volume of the underlying 3-manifold. </dd></dl>

</div>
</div>
<a id="a7c576f86cb7675ab965e74dc8151abba" name="a7c576f86cb7675ab965e74dc8151abba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c576f86cb7675ab965e74dc8151abba">&#9670;&nbsp;</a></span>volumeWithPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, int &gt; regina::SnapPeaTriangulation::volumeWithPrecision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the volume of the current solution to the hyperbolic gluing equations, and estimates the accuracy of the answer. </p>
<p >This will be with respect to the current Dehn filling (if any).</p>
<dl class="section user"><dt>SnapPy</dt><dd>In SnapPy, this routine corresponds to calling <code>Manifold.volume(accuracy=True)</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first element is the estimated volume of the underlying 3-manifold, and whose second element is an estimate of the number of decimal places of accuracy in this volume. </dd></dl>

</div>
</div>
<a id="aa65ce6f4e579a65045294a94e6d94e73" name="aa65ce6f4e579a65045294a94e6d94e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65ce6f4e579a65045294a94e6d94e73">&#9670;&nbsp;</a></span>volumeZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaTriangulation::volumeZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the current solution to the gluing equations has volume approximately zero. </p>
<p >This test is <em>not</em> rigorous.</p>
<p >This requires (i) the volume itself to be very close to zero in an absolute sense, (ii) the volume to be zero within SnapPea's own estimated precision, and (iii) SnapPea's estimated precision to be sufficiently good in an absolute sense.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the volume of the current solution is approximately zero according to the constraints outlined above. </dd></dl>

</div>
</div>
<a id="a7a0cea08290f51551c72f17f432cb8b0" name="a7a0cea08290f51551c72f17f432cb8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0cea08290f51551c72f17f432cb8b0">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed9e9f725af5a1be122745c83852632" name="a7ed9e9f725af5a1be122745c83852632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed9e9f725af5a1be122745c83852632">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnapPeaTriangulation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1d1a2ca27fd966c3c7403f0a1c6080d" name="ad1d1a2ca27fd966c3c7403f0a1c6080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d1a2ca27fd966c3c7403f0a1c6080d">&#9670;&nbsp;</a></span>writeXMLBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeXMLBaseProperties </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing properties of this triangulation. </p>
<p >This routine covers those properties that are managed by this base class TriangulationBase and that have already been computed for this triangulation.</p>
<p >This routine is typically called from within Triangulation&lt;dim&gt;::writeXMLPacketData(). The XML elements that it writes are child elements of the <code>tri</code> element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a743fc6719e55852c85abb7899ac6d061" name="a743fc6719e55852c85abb7899ac6d061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743fc6719e55852c85abb7899ac6d061">&#9670;&nbsp;</a></span>zeroTwoMove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::zeroTwoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles incident to <em>e</em> that are numbered <em>t0</em> and <em>t1</em>. </p>
<p >This involves fattening up these two triangles into a new pair of tetrahedra around a new degree-two edge <em>d</em>; this is the inverse of performing a 2-0 move about the edge <em>d</em>. This can be done if and only if the following conditions are satisfied:</p>
<ul>
<li>The edge <em>e</em> is valid.</li>
<li>The numbers <em>t0</em> and <em>t1</em> are both less than or equal to <code>e-&gt;degree()</code>, and strictly less than <code>e-&gt;degree()</code> if <em>e</em> is non-boundary. This ensures that <em>t0</em> and <em>t1</em> correspond to sensible triangle numbers (as described below).</li>
</ul>
<p >The triangles incident to <em>e</em> are numbered as follows:</p>
<ul>
<li>For each <em>i</em> from 0 up to <code>e-&gt;degree()</code>, we assign the number <em>i</em> to the triangle <code>emb.tetrahedron()-&gt;triangle(emb.vertices()[3])</code>, where <em>emb</em> denotes <code>e-&gt;embedding(i)</code>.</li>
<li>If <em>e</em> is a boundary edge, then we additionally assign the number <code>e-&gt;degree()</code> to the boundary triangle <code>emb.tetrahedron()-&gt;triangle(emb.vertices()[2])</code>, where this time <em>emb</em> denotes <code>e-&gt;back()</code>.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this 0-2 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p >The implementation of this routine simply translates the given arguments to call the variant of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3fa9113fca5e95226551dfde803b8ef2" title="Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles e...">zeroTwoMove()</a> that takes a pair of edge embeddings (and other associated arguments).</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must by known in advance that the move is legal. </dd>
<dd>
The given edge <em>e</em> is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the common edge of the two triangles about which to perform the move. </td></tr>
    <tr><td class="paramname">t0</td><td>the number assigned to one of two triangles about which to perform the move. </td></tr>
    <tr><td class="paramname">t1</td><td>the number assigned to the other triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is false, the function simply returns <code>true</code>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He </dd></dl>

</div>
</div>
<a id="a3fa9113fca5e95226551dfde803b8ef2" name="a3fa9113fca5e95226551dfde803b8ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa9113fca5e95226551dfde803b8ef2">&#9670;&nbsp;</a></span>zeroTwoMove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::zeroTwoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d59f1efc647fdeca1fa5ca8aa2fc743">EdgeEmbedding</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d59f1efc647fdeca1fa5ca8aa2fc743">EdgeEmbedding</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles <code>e0.tetrahedron()-&gt;triangle(e0.vertices()[t0])</code> and <code>e1.tetrahedron()-&gt;triangle(e1.vertices()[t1])</code>. </p>
<p >This involves fattening up these two triangles into a new pair of tetrahedra around a new degree-two edge <em>d</em>; this is the inverse of performing a 2-0 move about the edge <em>d</em>. This can be done if and only if the following conditions are satisfied:</p>
<ul>
<li><em>e0</em> and <em>e1</em> are both embeddings of the same edge <em>e</em>.</li>
<li><em>t0</em> and <em>t1</em> are both either 2 or 3; this ensures that the triangles about which we perform the move are triangles that are incident with <em>e</em>.</li>
<li>The edge <em>e</em> is valid.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this 0-2 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the arguments <em>e0</em> and <em>e1</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must by known in advance that the move is legal. </dd>
<dd>
The edge <em>e</em> is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e0</td><td>an embedding of the common edge <em>e</em> of the two triangles about which to perform the move. </td></tr>
    <tr><td class="paramname">t0</td><td>one of the two triangles about which to perform the move (associated to the edge embedding <em>e0</em>). </td></tr>
    <tr><td class="paramname">e1</td><td>another embedding of the edge <em>e</em>. </td></tr>
    <tr><td class="paramname">t1</td><td>the other triangle about which to perform move (associated to the edge embedding <em>e1</em>). </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is false, the function simply returns <code>true</code>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He </dd></dl>

</div>
</div>
<a id="a2297104719d871336ec02112ae2e5579" name="a2297104719d871336ec02112ae2e5579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2297104719d871336ec02112ae2e5579">&#9670;&nbsp;</a></span>zeroTwoMove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::zeroTwoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles <em>t0</em> and <em>t1</em>. </p>
<p >This involves fattening up these two triangles into a new pair of tetrahedra around a new degree-two edge <em>d</em>; this is the inverse of performing a 2-0 move about the edge <em>d</em>. This can be done if and only if the following conditions are satisfied:</p>
<ul>
<li>The edges <code>t0-&gt;edge(e0)</code> and <code>t1-&gt;edge(e1)</code> are the same edge <em>e</em> of this triangulation.</li>
<li>The edge <em>e</em> is valid.</li>
</ul>
<p >If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p >If this triangulation is currently oriented, then this 0-2 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p >The implementation of this routine simply translates the given arguments to call the variant of <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3fa9113fca5e95226551dfde803b8ef2" title="Checks the eligibility of and/or performs a 0-2 move about the (not necessarily distinct) triangles e...">zeroTwoMove()</a> that takes a pair of edge embeddings (and other associated arguments).</p>
<p >Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the arguments <em>t0</em> and <em>t1</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must by known in advance that the move is legal. </dd>
<dd>
The given triangles <em>t0</em> and <em>t1</em> are triangles of this triangulation. </dd>
<dd>
The numbers <em>e0</em> and <em>e1</em> are both 0, 1 or 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>one of the two triangles about which to perform the move. </td></tr>
    <tr><td class="paramname">e0</td><td>the edge at which <em>t0</em> meets the other triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">t1</td><td>the other triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">e1</td><td>the edge at which <em>t1</em> meets <em>t0</em>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is false, the function simply returns <code>true</code>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa6e46682d3ce5b05f7e693f863018f66" name="aa6e46682d3ce5b05f7e693f863018f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e46682d3ce5b05f7e693f863018f66">&#9670;&nbsp;</a></span>boundaryComponents_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The components that form the boundary of the triangulation. </p>

</div>
</div>
<a id="a22c33546e75a026c5c5a603e61a13159" name="a22c33546e75a026c5c5a603e61a13159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c33546e75a026c5c5a603e61a13159">&#9670;&nbsp;</a></span>compressingDisc_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::compressingDisc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this 3-manifold contain a compressing disc? </p>

</div>
</div>
<a id="aa177dda3276927267a3ae0130765a6f1" name="aa177dda3276927267a3ae0130765a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa177dda3276927267a3ae0130765a6f1">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of the triangulation. </p>

</div>
</div>
<a id="adbbe0d88c4d72f7daf4a1ce93c09667c" name="adbbe0d88c4d72f7daf4a1ce93c09667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbe0d88c4d72f7daf4a1ce93c09667c">&#9670;&nbsp;</a></span>H1Bdry_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::H1Bdry_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First homology group of the boundary. </p>

</div>
</div>
<a id="a0aa1bc4ff0010371555dc6406d52867b" name="a0aa1bc4ff0010371555dc6406d52867b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa1bc4ff0010371555dc6406d52867b">&#9670;&nbsp;</a></span>H1Rel_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::H1Rel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative first homology group of the triangulation with respect to the boundary. </p>

</div>
</div>
<a id="acf04e50feec57afa9c5eaa636d139632" name="acf04e50feec57afa9c5eaa636d139632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf04e50feec57afa9c5eaa636d139632">&#9670;&nbsp;</a></span>H2_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::H2_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Second homology group of the triangulation. </p>

</div>
</div>
<a id="ae8fbdc1fd4237ceb14ee79caba90db54" name="ae8fbdc1fd4237ceb14ee79caba90db54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fbdc1fd4237ceb14ee79caba90db54">&#9670;&nbsp;</a></span>haken_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::haken_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this 3-manifold Haken? This property must only be stored for triangulations that are known to represent closed, connected, orientable, irreducible 3-manifolds. </p>

</div>
</div>
<a id="a14bf8a47d24cd828ad207449223b374b" name="a14bf8a47d24cd828ad207449223b374b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf8a47d24cd828ad207449223b374b">&#9670;&nbsp;</a></span>handlebody_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;ssize_t&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::handlebody_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a triangulation of an orientable handlebody? If so, this stores the genus; if not, this stores -1. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SnapPeaTriangulation.html">SnapPeaTriangulation</a>  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="a5318a1b5093ac0912d11e1e155d139c5" name="a5318a1b5093ac0912d11e1e155d139c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5318a1b5093ac0912d11e1e155d139c5">&#9670;&nbsp;</a></span>irreducible_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::irreducible_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this 3-manifold irreducible? </p>

</div>
</div>
<a id="a1db8e55f59788fbb27cb5a15c44f127a" name="a1db8e55f59788fbb27cb5a15c44f127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db8e55f59788fbb27cb5a15c44f127a">&#9670;&nbsp;</a></span>nBoundaryFaces_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;size_t, dim&gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::nBoundaryFaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary faces of each dimension. </p>

</div>
</div>
<a id="a7b21624912ec6a3a8d769712f23960d4" name="a7b21624912ec6a3a8d769712f23960d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b21624912ec6a3a8d769712f23960d4">&#9670;&nbsp;</a></span>negativeIdealBoundaryComponents_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::negativeIdealBoundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the triangulation contain any boundary components that are ideal and have negative Euler characteristic? </p>

</div>
</div>
<a id="a8b910ba6ae44fe308159cb5518d852f6" name="a8b910ba6ae44fe308159cb5518d852f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b910ba6ae44fe308159cb5518d852f6">&#9670;&nbsp;</a></span>niceTreeDecomposition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::niceTreeDecomposition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A nice tree decomposition of the face pairing graph of this triangulation. </p>

</div>
</div>
<a id="a1739e33bdbb5c52cb77de81ec93c1ec8" name="a1739e33bdbb5c52cb77de81ec93c1ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1739e33bdbb5c52cb77de81ec93c1ec8">&#9670;&nbsp;</a></span>simplices_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-dimensional simplices that form the triangulation. </p>

</div>
</div>
<a id="a2d4df74da91b4d45d63578f525c71415" name="a2d4df74da91b4d45d63578f525c71415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4df74da91b4d45d63578f525c71415">&#9670;&nbsp;</a></span>splittingSurface_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::splittingSurface_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the triangulation have a normal splitting surface? </p>

</div>
</div>
<a id="a35b113d246be7c3d5ea9ba135be00084" name="a35b113d246be7c3d5ea9ba135be00084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b113d246be7c3d5ea9ba135be00084">&#9670;&nbsp;</a></span>threeSphere_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::threeSphere_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a triangulation of a 3-sphere? </p>

</div>
</div>
<a id="a449383159ee760c127c30e39ac22467f" name="a449383159ee760c127c30e39ac22467f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449383159ee760c127c30e39ac22467f">&#9670;&nbsp;</a></span>topologyLock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::topologyLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If non-zero, this will cause Triangulation&lt;dim&gt;::clearAllProperties() to preserve any computed properties that related to the manifold (as opposed to the specific triangulation). </p>
<p >This allows you to avoid recomputing expensive invariants when the underlying manifold is retriangulated.</p>
<p >This property should be managed by creating and destroying TopologyLock objects. The precise value of topologyLock_ indicates the number of TopologyLock objects that currently exist for this triangulation. </p>

</div>
</div>
<a id="a8755e24f93348d2df3d99cd0e1884191" name="a8755e24f93348d2df3d99cd0e1884191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8755e24f93348d2df3d99cd0e1884191">&#9670;&nbsp;</a></span>turaevViroCache_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a75395b2e289bf58155f6b1f94b47530a">TuraevViroSet</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::turaevViroCache_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of Turaev-Viro invariants that have already been calculated. </p>
<p >See <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad43a33c581d838c8d558da03acc290c7" title="Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifo...">allCalculatedTuraevViro()</a> for details. </p>

</div>
</div>
<a id="a8a36e449bdd81e3dd128bcfb19718d51" name="a8a36e449bdd81e3dd128bcfb19718d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a36e449bdd81e3dd128bcfb19718d51">&#9670;&nbsp;</a></span>twoSphereBoundaryComponents_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoSphereBoundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the triangulation contain any 2-sphere boundary components? </p>

</div>
</div>
<a id="a3ee8ffe946a3c1242010492c935ccc7c" name="a3ee8ffe946a3c1242010492c935ccc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee8ffe946a3c1242010492c935ccc7c">&#9670;&nbsp;</a></span>TxI_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::TxI_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a triangulation of the product TxI? </p>

</div>
</div>
<a id="a106dc9d8ffc9e2bd1dd35ad35d52773c" name="a106dc9d8ffc9e2bd1dd35ad35d52773c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106dc9d8ffc9e2bd1dd35ad35d52773c">&#9670;&nbsp;</a></span>valid_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this triangulation valid? See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means. </p>

</div>
</div>
<a id="a44229c6f0efdb7a4f703b0640758c270" name="a44229c6f0efdb7a4f703b0640758c270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44229c6f0efdb7a4f703b0640758c270">&#9670;&nbsp;</a></span>zeroEfficient_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::zeroEfficient_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the triangulation zero-efficient? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>snappea/<a class="el" href="snappeatriangulation_8h.html">snappeatriangulation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
