<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::PacketDescendants&lt; const_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1PacketDescendants-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::PacketDescendants&lt; const_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A lightweight object that gives access to all strict descendants of a given packet.  
 <a href="classregina_1_1PacketDescendants.html#details">More...</a></p>

<p><code>#include &lt;packet/packet.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2f08c60a79bcee881252bda90f623ed5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a2f08c60a79bcee881252bda90f623ed5">packet_type</a> = std::conditional_t&lt; const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;</td></tr>
<tr class="memdesc:a2f08c60a79bcee881252bda90f623ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>.  <a href="classregina_1_1PacketDescendants.html#a2f08c60a79bcee881252bda90f623ed5">More...</a><br /></td></tr>
<tr class="separator:a2f08c60a79bcee881252bda90f623ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a04aabbdb9909956f1b8a78be3d9538"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a0a04aabbdb9909956f1b8a78be3d9538">PacketDescendants</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:a0a04aabbdb9909956f1b8a78be3d9538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the strict descendants of the same packet as the given object.  <a href="classregina_1_1PacketDescendants.html#a0a04aabbdb9909956f1b8a78be3d9538">More...</a><br /></td></tr>
<tr class="separator:a0a04aabbdb9909956f1b8a78be3d9538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8c3455f3368f1d6da671e524b5e8e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a0e8c3455f3368f1d6da671e524b5e8e4">PacketDescendants</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketDescendants.html#a2f08c60a79bcee881252bda90f623ed5">packet_type</a> &gt; subtree)</td></tr>
<tr class="memdesc:a0e8c3455f3368f1d6da671e524b5e8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the strict descendants of the given packet.  <a href="classregina_1_1PacketDescendants.html#a0e8c3455f3368f1d6da671e524b5e8e4">More...</a><br /></td></tr>
<tr class="separator:a0e8c3455f3368f1d6da671e524b5e8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfd8873b47f7c306ae5da9151b16664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a3dfd8873b47f7c306ae5da9151b16664">operator=</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:a3dfd8873b47f7c306ae5da9151b16664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this object to iterate over the strict descendants of the same packet as the given object.  <a href="classregina_1_1PacketDescendants.html#a3dfd8873b47f7c306ae5da9151b16664">More...</a><br /></td></tr>
<tr class="separator:a3dfd8873b47f7c306ae5da9151b16664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fc486600bbb5f250807d470a999c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#ab6fc486600bbb5f250807d470a999c8d">begin</a> () const</td></tr>
<tr class="memdesc:ab6fc486600bbb5f250807d470a999c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator at the beginning of the range of strict descendant packets.  <a href="classregina_1_1PacketDescendants.html#ab6fc486600bbb5f250807d470a999c8d">More...</a><br /></td></tr>
<tr class="separator:ab6fc486600bbb5f250807d470a999c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46217894e6335639fe51804d4d2018a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a46217894e6335639fe51804d4d2018a4">end</a> () const</td></tr>
<tr class="memdesc:a46217894e6335639fe51804d4d2018a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator at the end of the range of strict descendant packets.  <a href="classregina_1_1PacketDescendants.html#a46217894e6335639fe51804d4d2018a4">More...</a><br /></td></tr>
<tr class="separator:a46217894e6335639fe51804d4d2018a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63e8b4937942b52f994405453b6b561"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#ab63e8b4937942b52f994405453b6b561">__iter__</a> () const</td></tr>
<tr class="memdesc:ab63e8b4937942b52f994405453b6b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over all strict descendant packets.  <a href="classregina_1_1PacketDescendants.html#ab63e8b4937942b52f994405453b6b561">More...</a><br /></td></tr>
<tr class="separator:ab63e8b4937942b52f994405453b6b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f5604a2c08bdba6e6bd5928952cd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#abe8f5604a2c08bdba6e6bd5928952cd0">operator==</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;rhs) const</td></tr>
<tr class="memdesc:abe8f5604a2c08bdba6e6bd5928952cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over strict descendants of the same packet.  <a href="classregina_1_1PacketDescendants.html#abe8f5604a2c08bdba6e6bd5928952cd0">More...</a><br /></td></tr>
<tr class="separator:abe8f5604a2c08bdba6e6bd5928952cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cebe34d898f742c1ad5725aa36f6f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html#a65cebe34d898f742c1ad5725aa36f6f8">operator!=</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a65cebe34d898f742c1ad5725aa36f6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over strict descendants of different packets.  <a href="classregina_1_1PacketDescendants.html#a65cebe34d898f742c1ad5725aa36f6f8">More...</a><br /></td></tr>
<tr class="separator:a65cebe34d898f742c1ad5725aa36f6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;bool const_&gt;<br />
class regina::PacketDescendants&lt; const_ &gt;</div><p >A lightweight object that gives access to all strict descendants of a given packet. </p>
<p >The purpose of this class is to support iteration through all strict descendants of a packet <em>p</em> using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; parent = ...;</div>
<div class="line"><span class="keywordflow">for</span> (Packet&amp; desc : parent-&gt;descendants()) { ... }</div>
</div><!-- fragment --><p >In Python, <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> is an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> desc <span class="keywordflow">in</span> parent.descendants():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p >Each object of this class will hold a std::shared_ptr to the packet whose descendants it gives access to. This guarantees that the packet will not be destroyed during iteration, but it also means that you must ensure that you dispose of these objects once you are finished with them.</p>
<p >These are lightweight objects, small enough to pass by value and swap with <a class="el" href="group__algebra.html#ga3d2f68e8a75ce7b663269c104346f937" title="Swaps the contents of the two given abelian groups.">std::swap()</a>, with no need for any specialised move operations or swap functions. Copies of a <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> will iterate over the descendants of the same underlying packet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">const_</td><td>Indicates whether this iterator should offer const or non-const access to the packet tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the C++ interface described here, in Python the classes <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> and <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> together implement the Python iterable/iterator interface. The class <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> has just the single function <code><a class="el" href="classregina_1_1PacketDescendants.html#ab63e8b4937942b52f994405453b6b561" title="Returns a Python iterator over all strict descendant packets.">__iter__()</a></code>, which returns a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a>; then <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> implements <code>__next__()</code>, which either returns the next descendant packet in the iteration or else throws a <code>StopException</code> if there are no more children to return. All iteration in Python is non-const (i.e., Python exclusively uses the classes where <em>const_</em> is <code>false</code>). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2f08c60a79bcee881252bda90f623ed5" name="a2f08c60a79bcee881252bda90f623ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f08c60a79bcee881252bda90f623ed5">&#9670;&nbsp;</a></span>packet_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::packet_type =  std::conditional_t&lt;const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0a04aabbdb9909956f1b8a78be3d9538" name="a0a04aabbdb9909956f1b8a78be3d9538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a04aabbdb9909956f1b8a78be3d9538">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the strict descendants of the same packet as the given object. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> object is via <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>. </dd></dl>

</div>
</div>
<a id="a0e8c3455f3368f1d6da671e524b5e8e4" name="a0e8c3455f3368f1d6da671e524b5e8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8c3455f3368f1d6da671e524b5e8e4">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketDescendants.html#a2f08c60a79bcee881252bda90f623ed5">packet_type</a> &gt;&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the strict descendants of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> object is via <a class="el" href="classregina_1_1Packet.html#a95170e745227f4d171e8850510f18eed" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet whose strict descendants we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab63e8b4937942b52f994405453b6b561" name="ab63e8b4937942b52f994405453b6b561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63e8b4937942b52f994405453b6b561">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over all strict descendant packets. </p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> provides the usual <a class="el" href="classregina_1_1PacketDescendants.html#ab6fc486600bbb5f250807d470a999c8d" title="Returns a C++ iterator at the beginning of the range of strict descendant packets.">begin()</a> and <a class="el" href="classregina_1_1PacketDescendants.html#a46217894e6335639fe51804d4d2018a4" title="Returns a C++ iterator at the end of the range of strict descendant packets.">end()</a> functions instead. In particular, this allows you to iterate through all strict descendant packets in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over all strict descendant packets. </dd></dl>

</div>
</div>
<a id="ab6fc486600bbb5f250807d470a999c8d" name="ab6fc486600bbb5f250807d470a999c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fc486600bbb5f250807d470a999c8d">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator at the beginning of the range of strict descendant packets. </p>
<p >This will point to the first child packet (if one exists) of the packet whose descendants we are iterating over.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> implements the Python iterable interface. You can iterate over the strict descendant packets in the usual Python way, by treating this <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> object as you would any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="a46217894e6335639fe51804d4d2018a4" name="a46217894e6335639fe51804d4d2018a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46217894e6335639fe51804d4d2018a4">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator at the end of the range of strict descendant packets. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> implements the Python iterable interface. You can iterate over the strict descendant packets in the usual Python way, by treating this <a class="el" href="classregina_1_1PacketDescendants.html" title="A lightweight object that gives access to all strict descendants of a given packet.">PacketDescendants</a> object as you would any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="a65cebe34d898f742c1ad5725aa36f6f8" name="a65cebe34d898f742c1ad5725aa36f6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cebe34d898f742c1ad5725aa36f6f8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over strict descendants of different packets. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over descendants of different packets. </dd></dl>

</div>
</div>
<a id="a3dfd8873b47f7c306ae5da9151b16664" name="a3dfd8873b47f7c306ae5da9151b16664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfd8873b47f7c306ae5da9151b16664">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp; <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this object to iterate over the strict descendants of the same packet as the given object. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="abe8f5604a2c08bdba6e6bd5928952cd0" name="abe8f5604a2c08bdba6e6bd5928952cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8f5604a2c08bdba6e6bd5928952cd0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a>&lt; const_ &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over strict descendants of the same packet. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over descendants of the same packet. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="packet_8h.html">packet.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
