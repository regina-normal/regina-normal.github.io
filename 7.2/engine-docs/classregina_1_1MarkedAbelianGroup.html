<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::MarkedAbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1MarkedAbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::MarkedAbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a finitely generated abelian group given by a chain complex.  
 <a href="classregina_1_1MarkedAbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/markedabeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::MarkedAbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1MarkedAbelianGroup.png" usemap="#regina::MarkedAbelianGroup_map" alt=""/>
  <map id="regina::MarkedAbelianGroup_map" name="regina::MarkedAbelianGroup_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; MarkedAbelianGroup, true &gt;" shape="rect" coords="0,56,315,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; MarkedAbelianGroup, supportsUtf8 &gt;" shape="rect" coords="0,0,315,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e0dffd9cee14339a1c5a665fd4ca114"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a2e0dffd9cee14339a1c5a665fd4ca114">MarkedAbelianGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> M, <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> N)</td></tr>
<tr class="memdesc:a2e0dffd9cee14339a1c5a665fd4ca114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#a2e0dffd9cee14339a1c5a665fd4ca114">More...</a><br /></td></tr>
<tr class="separator:a2e0dffd9cee14339a1c5a665fd4ca114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c59fad8ceb9be46c6e9b7483e49fe66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a2c59fad8ceb9be46c6e9b7483e49fe66">MarkedAbelianGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> M, <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> N, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> pcoeff)</td></tr>
<tr class="memdesc:a2c59fad8ceb9be46c6e9b7483e49fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex with coefficients in Z_p.  <a href="classregina_1_1MarkedAbelianGroup.html#a2c59fad8ceb9be46c6e9b7483e49fe66">More...</a><br /></td></tr>
<tr class="separator:a2c59fad8ceb9be46c6e9b7483e49fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583cf235e75faac1cfce065653a9cca4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a583cf235e75faac1cfce065653a9cca4">MarkedAbelianGroup</a> (size_t <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488">rank</a>, const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:a583cf235e75faac1cfce065653a9cca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a free <code>Z_p</code>-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z --p--&gt; Z --&gt; 0</code>.  <a href="classregina_1_1MarkedAbelianGroup.html#a583cf235e75faac1cfce065653a9cca4">More...</a><br /></td></tr>
<tr class="separator:a583cf235e75faac1cfce065653a9cca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf1dea036f81278d7df718d2226c4d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a5bf1dea036f81278d7df718d2226c4d9">MarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:a5bf1dea036f81278d7df718d2226c4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="classregina_1_1MarkedAbelianGroup.html#a5bf1dea036f81278d7df718d2226c4d9">More...</a><br /></td></tr>
<tr class="separator:a5bf1dea036f81278d7df718d2226c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7b768396fe83deec4630af476b7f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#afb7b768396fe83deec4630af476b7f92">MarkedAbelianGroup</a> (<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:afb7b768396fe83deec4630af476b7f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this new group.  <a href="classregina_1_1MarkedAbelianGroup.html#afb7b768396fe83deec4630af476b7f92">More...</a><br /></td></tr>
<tr class="separator:afb7b768396fe83deec4630af476b7f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2893041d2ac9092d49d856373ddbdb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a2893041d2ac9092d49d856373ddbdb7f">operator=</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:a2893041d2ac9092d49d856373ddbdb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given group.  <a href="classregina_1_1MarkedAbelianGroup.html#a2893041d2ac9092d49d856373ddbdb7f">More...</a><br /></td></tr>
<tr class="separator:a2893041d2ac9092d49d856373ddbdb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1adb508d9f07e7be4d36107eedca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a8e1adb508d9f07e7be4d36107eedca8f">operator=</a> (<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a8e1adb508d9f07e7be4d36107eedca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this group.  <a href="classregina_1_1MarkedAbelianGroup.html#a8e1adb508d9f07e7be4d36107eedca8f">More...</a><br /></td></tr>
<tr class="separator:a8e1adb508d9f07e7be4d36107eedca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36837882c0df7a0303522d0ba345074e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a36837882c0df7a0303522d0ba345074e">swap</a> (<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a36837882c0df7a0303522d0ba345074e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given group.  <a href="classregina_1_1MarkedAbelianGroup.html#a36837882c0df7a0303522d0ba345074e">More...</a><br /></td></tr>
<tr class="separator:a36837882c0df7a0303522d0ba345074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82269a3f884c50557e15e1109384159d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a82269a3f884c50557e15e1109384159d">m</a> () const</td></tr>
<tr class="memdesc:a82269a3f884c50557e15e1109384159d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "right" matrix that was used to define the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#a82269a3f884c50557e15e1109384159d">More...</a><br /></td></tr>
<tr class="separator:a82269a3f884c50557e15e1109384159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a23888d82bda7930f2472ede284f0d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a5a23888d82bda7930f2472ede284f0d8">n</a> () const</td></tr>
<tr class="memdesc:a5a23888d82bda7930f2472ede284f0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "left" matrix that was used to define the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#a5a23888d82bda7930f2472ede284f0d8">More...</a><br /></td></tr>
<tr class="separator:a5a23888d82bda7930f2472ede284f0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1d6947da29e7eb4e2765f268da6d64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#abd1d6947da29e7eb4e2765f268da6d64">coefficients</a> () const</td></tr>
<tr class="memdesc:abd1d6947da29e7eb4e2765f268da6d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficients used for the computation of homology.  <a href="classregina_1_1MarkedAbelianGroup.html#abd1d6947da29e7eb4e2765f268da6d64">More...</a><br /></td></tr>
<tr class="separator:abd1d6947da29e7eb4e2765f268da6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e3c2b5071474156f0c794a9361488"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488">rank</a> () const</td></tr>
<tr class="memdesc:ad98e3c2b5071474156f0c794a9361488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the group.  <a href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488">More...</a><br /></td></tr>
<tr class="separator:ad98e3c2b5071474156f0c794a9361488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a387bfcc8de00ab908fb2fc7e19152"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ae9a387bfcc8de00ab908fb2fc7e19152">torsionRank</a> (const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;degree) const</td></tr>
<tr class="memdesc:ae9a387bfcc8de00ab908fb2fc7e19152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <a href="classregina_1_1MarkedAbelianGroup.html#ae9a387bfcc8de00ab908fb2fc7e19152">More...</a><br /></td></tr>
<tr class="separator:ae9a387bfcc8de00ab908fb2fc7e19152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3f8682aebf7aebde3222d051d06c35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#afb3f8682aebf7aebde3222d051d06c35">torsionRank</a> (unsigned long degree) const</td></tr>
<tr class="memdesc:afb3f8682aebf7aebde3222d051d06c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <a href="classregina_1_1MarkedAbelianGroup.html#afb3f8682aebf7aebde3222d051d06c35">More...</a><br /></td></tr>
<tr class="separator:afb3f8682aebf7aebde3222d051d06c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25dc94bfeb64347d3d88ed3505334d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5">countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:aa25dc94bfeb64347d3d88ed3505334d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of invariant factors that describe the torsion elements of this group.  <a href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5">More...</a><br /></td></tr>
<tr class="separator:aa25dc94bfeb64347d3d88ed3505334d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38acb7cedad48b463cb92ba8623f90a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a38acb7cedad48b463cb92ba8623f90a1">unmarked</a> () const</td></tr>
<tr class="memdesc:a38acb7cedad48b463cb92ba8623f90a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns just the underlying abelian group, without any of the chain complex information.  <a href="classregina_1_1MarkedAbelianGroup.html#a38acb7cedad48b463cb92ba8623f90a1">More...</a><br /></td></tr>
<tr class="separator:a38acb7cedad48b463cb92ba8623f90a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1351325721294fa0d73ea55c656b05a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa1351325721294fa0d73ea55c656b05a">ccRank</a> () const</td></tr>
<tr class="memdesc:aa1351325721294fa0d73ea55c656b05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the chain complex supporting the homology computation.  <a href="classregina_1_1MarkedAbelianGroup.html#aa1351325721294fa0d73ea55c656b05a">More...</a><br /></td></tr>
<tr class="separator:aa1351325721294fa0d73ea55c656b05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825a6ef6709bbc7c4eb86c8f861a71ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a825a6ef6709bbc7c4eb86c8f861a71ff">snfRank</a> () const</td></tr>
<tr class="memdesc:a825a6ef6709bbc7c4eb86c8f861a71ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of generators for this group.  <a href="classregina_1_1MarkedAbelianGroup.html#a825a6ef6709bbc7c4eb86c8f861a71ff">More...</a><br /></td></tr>
<tr class="separator:a825a6ef6709bbc7c4eb86c8f861a71ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a1646cf2d9cb4bc31b0b0df1f1f4289a4">invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given invariant factor describing the torsion elements of this group.  <a href="classregina_1_1MarkedAbelianGroup.html#a1646cf2d9cb4bc31b0b0df1f1f4289a4">More...</a><br /></td></tr>
<tr class="separator:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2511bd16caaaeb926df617a731c965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a1b2511bd16caaaeb926df617a731c965">isTrivial</a> () const</td></tr>
<tr class="memdesc:a1b2511bd16caaaeb926df617a731c965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="classregina_1_1MarkedAbelianGroup.html#a1b2511bd16caaaeb926df617a731c965">More...</a><br /></td></tr>
<tr class="separator:a1b2511bd16caaaeb926df617a731c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65d588478bdbfc871d9d8e94d690ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a7c65d588478bdbfc871d9d8e94d690ff">isZ</a> () const</td></tr>
<tr class="memdesc:a7c65d588478bdbfc871d9d8e94d690ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="classregina_1_1MarkedAbelianGroup.html#a7c65d588478bdbfc871d9d8e94d690ff">More...</a><br /></td></tr>
<tr class="separator:a7c65d588478bdbfc871d9d8e94d690ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04a54db050fca088bad38c7b5b9c980"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad04a54db050fca088bad38c7b5b9c980">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ad04a54db050fca088bad38c7b5b9c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are isomorphic.  <a href="classregina_1_1MarkedAbelianGroup.html#ad04a54db050fca088bad38c7b5b9c980">More...</a><br /></td></tr>
<tr class="separator:ad04a54db050fca088bad38c7b5b9c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb69d151d77c5c76f11df172c89e1491"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#afb69d151d77c5c76f11df172c89e1491">operator==</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:afb69d151d77c5c76f11df172c89e1491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given group were formed from identical chain complex constructions.  <a href="classregina_1_1MarkedAbelianGroup.html#afb69d151d77c5c76f11df172c89e1491">More...</a><br /></td></tr>
<tr class="separator:afb69d151d77c5c76f11df172c89e1491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671975d90a65bba71d5f68119ee123f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a9671975d90a65bba71d5f68119ee123f">operator!=</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a9671975d90a65bba71d5f68119ee123f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given group were formed from different chain complex constructions.  <a href="classregina_1_1MarkedAbelianGroup.html#a9671975d90a65bba71d5f68119ee123f">More...</a><br /></td></tr>
<tr class="separator:a9671975d90a65bba71d5f68119ee123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a65c060f74747aaab687824d6ffe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab44a65c060f74747aaab687824d6ffe3">freeRep</a> (size_t index) const</td></tr>
<tr class="memdesc:ab44a65c060f74747aaab687824d6ffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested free generator of this group, represented in the original chain complex defining the group.  <a href="classregina_1_1MarkedAbelianGroup.html#ab44a65c060f74747aaab687824d6ffe3">More...</a><br /></td></tr>
<tr class="separator:ab44a65c060f74747aaab687824d6ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49be11ffe204f0d0613a8f71f164b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a9a49be11ffe204f0d0613a8f71f164b5">torsionRep</a> (size_t index) const</td></tr>
<tr class="memdesc:a9a49be11ffe204f0d0613a8f71f164b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested generator of the torsion subgroup, represented in the original chain complex defining the group.  <a href="classregina_1_1MarkedAbelianGroup.html#a9a49be11ffe204f0d0613a8f71f164b5">More...</a><br /></td></tr>
<tr class="separator:a9a49be11ffe204f0d0613a8f71f164b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84f737b3ab5cb145d61205cfa331318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab84f737b3ab5cb145d61205cfa331318">ccRep</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;snf) const</td></tr>
<tr class="memdesc:ab84f737b3ab5cb145d61205cfa331318"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of freeRep and torsionRep, this routine takes a group element expressed in SNF coordinates and returns a corresponding vector in the original chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#ab84f737b3ab5cb145d61205cfa331318">More...</a><br /></td></tr>
<tr class="separator:ab84f737b3ab5cb145d61205cfa331318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23a0e468a7633236295a0295c1d966f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa23a0e468a7633236295a0295c1d966f">ccRep</a> (size_t snfGen) const</td></tr>
<tr class="memdesc:aa23a0e468a7633236295a0295c1d966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab44a65c060f74747aaab687824d6ffe3" title="Returns the requested free generator of this group, represented in the original chain complex definin...">freeRep()</a> and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a9a49be11ffe204f0d0613a8f71f164b5" title="Returns the requested generator of the torsion subgroup, represented in the original chain complex de...">torsionRep()</a> that expresses a group element as a vector in the original chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#aa23a0e468a7633236295a0295c1d966f">More...</a><br /></td></tr>
<tr class="separator:aa23a0e468a7633236295a0295c1d966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bb0a8ca1ef1c208e5dce270e9e575e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a57bb0a8ca1ef1c208e5dce270e9e575e">snfRep</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;cycle) const</td></tr>
<tr class="memdesc:a57bb0a8ca1ef1c208e5dce270e9e575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given cycle as a combination of free and torsion generators.  <a href="classregina_1_1MarkedAbelianGroup.html#a57bb0a8ca1ef1c208e5dce270e9e575e">More...</a><br /></td></tr>
<tr class="separator:a57bb0a8ca1ef1c208e5dce270e9e575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d7a2422044e8ad54816fef3d28657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa55d7a2422044e8ad54816fef3d28657">cycleProjection</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;ccelt) const</td></tr>
<tr class="memdesc:aa55d7a2422044e8ad54816fef3d28657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an element of the chain complex to the subspace of cycles.  <a href="classregina_1_1MarkedAbelianGroup.html#aa55d7a2422044e8ad54816fef3d28657">More...</a><br /></td></tr>
<tr class="separator:aa55d7a2422044e8ad54816fef3d28657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a4b2f2d5b4d25bbf4d86714dacf47b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a89a4b2f2d5b4d25bbf4d86714dacf47b">cycleProjection</a> (size_t ccindx) const</td></tr>
<tr class="memdesc:a89a4b2f2d5b4d25bbf4d86714dacf47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a standard basis vector of the chain complex to the subspace of cycles.  <a href="classregina_1_1MarkedAbelianGroup.html#a89a4b2f2d5b4d25bbf4d86714dacf47b">More...</a><br /></td></tr>
<tr class="separator:a89a4b2f2d5b4d25bbf4d86714dacf47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3db27d7c1018c2cceadc664084418f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aec3db27d7c1018c2cceadc664084418f">isCycle</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;chain) const</td></tr>
<tr class="memdesc:aec3db27d7c1018c2cceadc664084418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given vector represents a cycle in the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#aec3db27d7c1018c2cceadc664084418f">More...</a><br /></td></tr>
<tr class="separator:aec3db27d7c1018c2cceadc664084418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6249d7a965b554a9822d92cc82fd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a4b6249d7a965b554a9822d92cc82fd4e">boundaryOf</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;chain) const</td></tr>
<tr class="memdesc:a4b6249d7a965b554a9822d92cc82fd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differential of the given vector in the chain complex whose kernel is the cycles.  <a href="classregina_1_1MarkedAbelianGroup.html#a4b6249d7a965b554a9822d92cc82fd4e">More...</a><br /></td></tr>
<tr class="separator:a4b6249d7a965b554a9822d92cc82fd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14370902455f0e168c90ba4ff387c336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a14370902455f0e168c90ba4ff387c336">isBoundary</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;chain) const</td></tr>
<tr class="memdesc:a14370902455f0e168c90ba4ff387c336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given vector represents a boundary in the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#a14370902455f0e168c90ba4ff387c336">More...</a><br /></td></tr>
<tr class="separator:a14370902455f0e168c90ba4ff387c336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90c229de2a01912a1ec15f8a5d0e187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ac90c229de2a01912a1ec15f8a5d0e187">asBoundary</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;bdry) const</td></tr>
<tr class="memdesc:ac90c229de2a01912a1ec15f8a5d0e187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given vector as a boundary in the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#ac90c229de2a01912a1ec15f8a5d0e187">More...</a><br /></td></tr>
<tr class="separator:ac90c229de2a01912a1ec15f8a5d0e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab317071529d06d6d56596f76fd313b4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab317071529d06d6d56596f76fd313b4a">cycleRank</a> () const</td></tr>
<tr class="memdesc:ab317071529d06d6d56596f76fd313b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generators of the kernel of <em>M</em>, where <em>M</em> is the "right" matrix used to define the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#ab317071529d06d6d56596f76fd313b4a">More...</a><br /></td></tr>
<tr class="separator:ab317071529d06d6d56596f76fd313b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602cb11e972a0cc85ffe3f7ebde9ec6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a602cb11e972a0cc85ffe3f7ebde9ec6b">cycleGen</a> (size_t index) const</td></tr>
<tr class="memdesc:a602cb11e972a0cc85ffe3f7ebde9ec6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested generator of the cycles, i.e., the kernel of the "right" matrix <em>M</em> in the chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#a602cb11e972a0cc85ffe3f7ebde9ec6b">More...</a><br /></td></tr>
<tr class="separator:a602cb11e972a0cc85ffe3f7ebde9ec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114b094813f2ec505ba27a19f8be0e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a114b094813f2ec505ba27a19f8be0e67">torsionSubgroup</a> () const</td></tr>
<tr class="memdesc:a114b094813f2ec505ba27a19f8be0e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the torsion subgroup of this group.  <a href="classregina_1_1MarkedAbelianGroup.html#a114b094813f2ec505ba27a19f8be0e67">More...</a><br /></td></tr>
<tr class="separator:a114b094813f2ec505ba27a19f8be0e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a015c866ae6a0a6e3d4c0f0eab88b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a49a015c866ae6a0a6e3d4c0f0eab88b0">torsionInclusion</a> () const</td></tr>
<tr class="memdesc:a49a015c866ae6a0a6e3d4c0f0eab88b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map representing the inclusion of the torsion subgroup into this group.  <a href="classregina_1_1MarkedAbelianGroup.html#a49a015c866ae6a0a6e3d4c0f0eab88b0">More...</a><br /></td></tr>
<tr class="separator:a49a015c866ae6a0a6e3d4c0f0eab88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db2c8ef127dba9ee3717e8660a7da43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a7db2c8ef127dba9ee3717e8660a7da43">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:a7db2c8ef127dba9ee3717e8660a7da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1MarkedAbelianGroup.html#a7db2c8ef127dba9ee3717e8660a7da43">More...</a><br /></td></tr>
<tr class="separator:a7db2c8ef127dba9ee3717e8660a7da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:affec81b08826210c7ee5fa33e4de25e2"><td class="memItemLeft" align="right" valign="top"><a id="affec81b08826210c7ee5fa33e4de25e2" name="affec81b08826210c7ee5fa33e4de25e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HomMarkedAbelianGroup</b></td></tr>
<tr class="separator:affec81b08826210c7ee5fa33e4de25e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a finitely generated abelian group given by a chain complex. </p>
<p >This class is initialized with a chain complex. The chain complex is given in terms of two integer matrices <em>M</em> and <em>N</em> such that M×N=0. These matrices should be thought of as acting on column vectors: this means for example that the product <code>B×A</code> applies the linear transformation <em>A</em>, then the linear transformation <em>B</em>. This is consistent with the convention that Regina uses for for multiplying permutations.</p>
<p >The abelian group that this class computes is the kernel of <em>M</em> modulo the image of <em>N</em>. In other words, we compute the homology of the chain complex <code>Z^a --N--&gt; Z^b --M--&gt; Z^c</code>, where <em>a</em> = N.columns(), <em>b</em> = M.columns() = N.rows(), and <em>c</em> = M.rows(). An additional constructor allows you to take the homology with coefficients in an arbitrary cyclic group.</p>
<p >Like the simpler class <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a>, this group will be isomorphic to some <code>Z_{d0} + ... + Z_{dk} + Z^r</code>, where:</p>
<ul>
<li><em>r</em> is the number of free generators, as returned by <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488" title="Returns the rank of the group.">rank()</a>;</li>
<li><em>d1</em>, ..., <em>dk</em> are the <em>invariant factors</em> that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<p >This class allows you to retrieve the invariant factors, the rank, and the corresponding vectors in the kernel of <em>M</em>. Moreover, given a vector in the kernel of <em>M</em>, it decribes the homology class of the vector (the free part, and its position in the invariant factors).</p>
<p >The purpose of this class is to not just represent homology groups, but also to support coordinates on the group allowing for the construction of homomorphisms, and keeping track of subgroups.</p>
<p >This routine makes frequent use of two coordinate systems:</p>
<ul>
<li><em>Chain complex coordinates</em> describe vectors of length <em>b</em> (using the notation above); that is, elements of the domain of <em>M</em>, or equivalently the codomain of <em>N</em>.</li>
<li><em>SNF (or Smith normal form) coordinates</em> describe elements of this abelian group in terms of the torsion and free generators. A vector in SNF coordinates has length (<em>k</em> + <em>r</em>), again using the notation above, where the first <em>k</em> elements store coefficients for the generators of the torsion components Z_{d1}, ..., Z_{dk}, and the remaining <em>r</em> elements store coefficients for the <em>r</em> free generators. You can see how the torsion and free generators appear in chain complex coordinates by calling <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a9a49be11ffe204f0d0613a8f71f164b5" title="Returns the requested generator of the torsion subgroup, represented in the original chain complex de...">torsionRep()</a> or <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab44a65c060f74747aaab687824d6ffe3" title="Returns the requested free generator of this group, represented in the original chain complex definin...">freeRep()</a> respectively.</li>
</ul>
<p >Be aware that the choice of torsion and free generators is typically not unique, and this will affect the results of many member functions of this class. These choices are subject to change between different versions of Regina; in particular, they depend upon the particular algorithm used for computing Smith normal forms.</p>
<p >Some routines in this class refer to the <em>internal presentation matrix</em>. This is a proper presentation matrix for the abelian group; if you are looking at the implementation details, this refers to the matrix <em>pres</em>, created by taking the product <code>MRi_ * N</code> and then removing the first <em>rankM_</em> rows.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney and B.B.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like.</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2e0dffd9cee14339a1c5a665fd4ca114" name="a2e0dffd9cee14339a1c5a665fd4ca114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0dffd9cee14339a1c5a665fd4ca114">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex. </p>
<p >This constructor assumes you are interested in homology with integer coefficents.</p>
<p >The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>. See the class notes for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M×N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c59fad8ceb9be46c6e9b7483e49fe66" name="a2c59fad8ceb9be46c6e9b7483e49fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c59fad8ceb9be46c6e9b7483e49fe66">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>&#160;</td>
          <td class="paramname"><em>pcoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex with coefficients in Z_p. </p>
<p >The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>. See the class notes for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M×N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">pcoeff</td><td>specifies the coefficient ring, Z_pcoeff. This must be non-negative; a value of 0 indicates that you are using integer coefficients (in which case it is more efficient to use the constructor that just takes two matrices). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583cf235e75faac1cfce065653a9cca4" name="a583cf235e75faac1cfce065653a9cca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583cf235e75faac1cfce065653a9cca4">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a free <code>Z_p</code>-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z --p--&gt; Z --&gt; 0</code>. </p>
<p >This group is isomorphic to <code>n Z_p</code>. Moreover, if constructed using the matrices-with-coefficients constructor, <em>M</em> would be zero and <em>N</em> would be diagonal and square with <em>p</em> down the diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the group as a Z_p-module. That is, if the group is <code>n Z_p</code>, then <em>rank</em> should be <em>n</em>. </td></tr>
    <tr><td class="paramname">p</td><td>describes the type of ring that we use to talk about the "free" module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bf1dea036f81278d7df718d2226c4d9" name="a5bf1dea036f81278d7df718d2226c4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf1dea036f81278d7df718d2226c4d9">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>

</div>
</div>
<a id="afb7b768396fe83deec4630af476b7f92" name="afb7b768396fe83deec4630af476b7f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7b768396fe83deec4630af476b7f92">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this new group. </p>
<p >This is a fast (constant time) operation.</p>
<p >The group that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac90c229de2a01912a1ec15f8a5d0e187" name="ac90c229de2a01912a1ec15f8a5d0e187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90c229de2a01912a1ec15f8a5d0e187">&#9670;&nbsp;</a></span>asBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::asBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given vector as a boundary in the chain complex. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you are using mod <em>p</em> coefficients and if your element projects to a non-trivial element of TOR, then <code>N×v != bdry</code> as elements of TOR are not in the image of <em>N</em>. In this case, (<code>bdry - N×v</code>) represents the projection to TOR.</dd>
<dd>
The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given vector is not a boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdry</td><td>a boundary vector, given in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector <em>v</em> such that <code>N×v=bdry</code>. </dd></dl>

</div>
</div>
<a id="a4b6249d7a965b554a9822d92cc82fd4e" name="a4b6249d7a965b554a9822d92cc82fd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6249d7a965b554a9822d92cc82fd4e">&#9670;&nbsp;</a></span>boundaryOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::boundaryOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the differential of the given vector in the chain complex whose kernel is the cycles. </p>
<p >In other words, this routine returns <code>M×chain</code>, where <em>M</em> is the "right" matrix passed to the class constructor.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given vector is not in chain complex coordinates; that is, its length is not M.columns().</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>any vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the differential, expressed as a vector of length M.rows(). </dd></dl>

</div>
</div>
<a id="aa1351325721294fa0d73ea55c656b05a" name="aa1351325721294fa0d73ea55c656b05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1351325721294fa0d73ea55c656b05a">&#9670;&nbsp;</a></span>ccRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::ccRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the chain complex supporting the homology computation. </p>
<p >This is the dimension of a vector in chain complex coordinates. In the class notes, this is given by M.columns() and N.rows(), where <em>M</em> and <em>N</em> are the matrices used to define the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the chain complex. </dd></dl>

</div>
</div>
<a id="ab84f737b3ab5cb145d61205cfa331318" name="ab84f737b3ab5cb145d61205cfa331318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84f737b3ab5cb145d61205cfa331318">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>snf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of freeRep and torsionRep, this routine takes a group element expressed in SNF coordinates and returns a corresponding vector in the original chain complex. </p>
<p >This routine is, in some sense, an inverse to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a57bb0a8ca1ef1c208e5dce270e9e575e" title="Expresses the given cycle as a combination of free and torsion generators.">snfRep()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The size of the given vector was not precisely <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a825a6ef6709bbc7c4eb86c8f861a71ff" title="Returns the minimum number of generators for this group.">snfRank()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snf</td><td>any vector in SNF coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="aa23a0e468a7633236295a0295c1d966f" name="aa23a0e468a7633236295a0295c1d966f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23a0e468a7633236295a0295c1d966f">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>snfGen</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab44a65c060f74747aaab687824d6ffe3" title="Returns the requested free generator of this group, represented in the original chain complex definin...">freeRep()</a> and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a9a49be11ffe204f0d0613a8f71f164b5" title="Returns the requested generator of the torsion subgroup, represented in the original chain complex de...">torsionRep()</a> that expresses a group element as a vector in the original chain complex. </p>
<p >This is similar to the variant of <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab84f737b3ab5cb145d61205cfa331318" title="A combination of freeRep and torsionRep, this routine takes a group element expressed in SNF coordina...">ccRep()</a> that takes a vector as input, but it assumes that your input is a standard basis vector from SNF coordinates. Calling ccRep(snfGen) is equivalent to passing the (<em>snfGen</em>)th unit vector to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab84f737b3ab5cb145d61205cfa331318" title="A combination of freeRep and torsionRep, this routine takes a group element expressed in SNF coordina...">ccRep()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given index was greater than or equal to the number of generators in SNF coordinates (i.e., greater than or equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a825a6ef6709bbc7c4eb86c8f861a71ff" title="Returns the minimum number of generators for this group.">snfRank()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snfGen</td><td>specifies which standard basis vector to use from SNF coordinates; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a825a6ef6709bbc7c4eb86c8f861a71ff" title="Returns the minimum number of generators for this group.">snfRank()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="abd1d6947da29e7eb4e2765f268da6d64" name="abd1d6947da29e7eb4e2765f268da6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1d6947da29e7eb4e2765f268da6d64">&#9670;&nbsp;</a></span>coefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp; regina::MarkedAbelianGroup::coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coefficients used for the computation of homology. </p>
<p >That is, this routine returns the integer <em>p</em> where we use coefficients in Z_p. If we use coefficients in the integers Z, then this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the coefficients used in the homology calculation. </dd></dl>

</div>
</div>
<a id="aa25dc94bfeb64347d3d88ed3505334d5" name="aa25dc94bfeb64347d3d88ed3505334d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25dc94bfeb64347d3d88ed3505334d5">&#9670;&nbsp;</a></span>countInvariantFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of invariant factors that describe the torsion elements of this group. </p>
<p >This is the minimal number of torsion generators. See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="a602cb11e972a0cc85ffe3f7ebde9ec6b" name="a602cb11e972a0cc85ffe3f7ebde9ec6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602cb11e972a0cc85ffe3f7ebde9ec6b">&#9670;&nbsp;</a></span>cycleGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::cycleGen </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested generator of the cycles, i.e., the kernel of the "right" matrix <em>M</em> in the chain complex. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>index</em> was out of range (i.e., greater than or equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab317071529d06d6d56596f76fd313b4a" title="Returns the number of generators of the kernel of M, where M is the &quot;right&quot; matrix used to define the...">cycleRank()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which generator to return; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab317071529d06d6d56596f76fd313b4a" title="Returns the number of generators of the kernel of M, where M is the &quot;right&quot; matrix used to define the...">cycleRank()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (<em>index</em>)th generator of the cycles, expressed in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="aa55d7a2422044e8ad54816fef3d28657" name="aa55d7a2422044e8ad54816fef3d28657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55d7a2422044e8ad54816fef3d28657">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ccelt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an element of the chain complex to the subspace of cycles. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The length of the given vector was not the dimension of the chain complex (i.e., the number of chain complex coordinates).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccelt</td><td>any vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector, also in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="a89a4b2f2d5b4d25bbf4d86714dacf47b" name="a89a4b2f2d5b4d25bbf4d86714dacf47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a4b2f2d5b4d25bbf4d86714dacf47b">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ccindx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects a standard basis vector of the chain complex to the subspace of cycles. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The index <em>ccindx</em> was greater than or equal to the dimension of the chain complex (i.e., <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa1351325721294fa0d73ea55c656b05a" title="Returns the rank of the chain complex supporting the homology computation.">ccRank()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccindx</td><td>the index of the standard basis vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting projection, in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ab317071529d06d6d56596f76fd313b4a" name="ab317071529d06d6d56596f76fd313b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab317071529d06d6d56596f76fd313b4a">&#9670;&nbsp;</a></span>cycleRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::cycleRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generators of the kernel of <em>M</em>, where <em>M</em> is the "right" matrix used to define the chain complex. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators of ker(<em>M</em>). </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab44a65c060f74747aaab687824d6ffe3" name="ab44a65c060f74747aaab687824d6ffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44a65c060f74747aaab687824d6ffe3">&#9670;&nbsp;</a></span>freeRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::freeRep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested free generator of this group, represented in the original chain complex defining the group. </p>
<p >The generator will be presented in chain complex coordinates.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>index</em> is out of range (i.e., greater than or equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488" title="Returns the rank of the group.">rank()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which free generator to look up; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488" title="Returns the rank of the group.">rank()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (<em>index</em>)th free generator, presented in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="a1646cf2d9cb4bc31b0b0df1f1f4289a4" name="a1646cf2d9cb4bc31b0b0df1f1f4289a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1646cf2d9cb4bc31b0b0df1f1f4289a4">&#9670;&nbsp;</a></span>invariantFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp; regina::MarkedAbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given invariant factor describing the torsion elements of this group. </p>
<p >See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<p >If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="a14370902455f0e168c90ba4ff387c336" name="a14370902455f0e168c90ba4ff387c336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14370902455f0e168c90ba4ff387c336">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given vector represents a boundary in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>any vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a boundary. </dd></dl>

</div>
</div>
<a id="aec3db27d7c1018c2cceadc664084418f" name="aec3db27d7c1018c2cceadc664084418f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3db27d7c1018c2cceadc664084418f">&#9670;&nbsp;</a></span>isCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given vector represents a cycle in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>any vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a cycle. </dd></dl>

</div>
</div>
<a id="ad04a54db050fca088bad38c7b5b9c980" name="ad04a54db050fca088bad38c7b5b9c980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04a54db050fca088bad38c7b5b9c980">&#9670;&nbsp;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are isomorphic. </dd></dl>

</div>
</div>
<a id="a1b2511bd16caaaeb926df617a731c965" name="a1b2511bd16caaaeb926df617a731c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2511bd16caaaeb926df617a731c965">&#9670;&nbsp;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="a7c65d588478bdbfc871d9d8e94d690ff" name="a7c65d588478bdbfc871d9d8e94d690ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65d588478bdbfc871d9d8e94d690ff">&#9670;&nbsp;</a></span>isZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="a82269a3f884c50557e15e1109384159d" name="a82269a3f884c50557e15e1109384159d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82269a3f884c50557e15e1109384159d">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "right" matrix that was used to define the chain complex. </p>
<p >Our group was defined as the kernel of <em>M</em> modulo the image of <em>N</em>. This is the matrix <em>M</em>.</p>
<p >This is the matrix <em>M</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix <em>M</em>. </dd></dl>

</div>
</div>
<a id="a5a23888d82bda7930f2472ede284f0d8" name="a5a23888d82bda7930f2472ede284f0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a23888d82bda7930f2472ede284f0d8">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "left" matrix that was used to define the chain complex. </p>
<p >Our group was defined as the kernel of <em>M</em> modulo the image of <em>N</em>. This is the matrix <em>N</em>.</p>
<p >This is the matrix <em>N</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix <em>N</em>. </dd></dl>

</div>
</div>
<a id="a9671975d90a65bba71d5f68119ee123f" name="a9671975d90a65bba71d5f68119ee123f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671975d90a65bba71d5f68119ee123f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given group were formed from different chain complex constructions. </p>
<p >This is <em>not</em> an isomorphism test. For this comparison to return <code>false</code> (i.e., for the chain complex constructions to be considered identical), both groups must have been constructed from identical matrices <em>M</em> and <em>N</em>, using homology with the same coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given group do not have identical chain complex definitions. </dd></dl>

</div>
</div>
<a id="a2893041d2ac9092d49d856373ddbdb7f" name="a2893041d2ac9092d49d856373ddbdb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2893041d2ac9092d49d856373ddbdb7f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::MarkedAbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given group. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="a8e1adb508d9f07e7be4d36107eedca8f" name="a8e1adb508d9f07e7be4d36107eedca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1adb508d9f07e7be4d36107eedca8f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::MarkedAbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this group. </p>
<p >This is a fast (constant time) operation.</p>
<p >The group that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="afb69d151d77c5c76f11df172c89e1491" name="afb69d151d77c5c76f11df172c89e1491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb69d151d77c5c76f11df172c89e1491">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given group were formed from identical chain complex constructions. </p>
<p >This is <em>not</em> an isomorphism test. For this comparison to return <code>true</code>, both groups must have been constructed from identical matrices <em>M</em> and <em>N</em>, using homology with the same coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given group have identical chain complex definitions. </dd></dl>

</div>
</div>
<a id="ad98e3c2b5071474156f0c794a9361488" name="ad98e3c2b5071474156f0c794a9361488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98e3c2b5071474156f0c794a9361488">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the group. </p>
<p >This is the number of included copies of <em>Z</em>.</p>
<p >Equivalently, the rank is the maximum number of linearly independent elements, and it indicates the size of the largest free abelian subgroup. The rank effectively ignores all torsion elements.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the group. </dd></dl>

</div>
</div>
<a id="a825a6ef6709bbc7c4eb86c8f861a71ff" name="a825a6ef6709bbc7c4eb86c8f861a71ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825a6ef6709bbc7c4eb86c8f861a71ff">&#9670;&nbsp;</a></span>snfRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::snfRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of generators for this group. </p>
<p >This is the dimension of a vector in SNF coordinates. It will always be equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad98e3c2b5071474156f0c794a9361488" title="Returns the rank of the group.">rank()</a> + <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of generators. </dd></dl>

</div>
</div>
<a id="a57bb0a8ca1ef1c208e5dce270e9e575e" name="a57bb0a8ca1ef1c208e5dce270e9e575e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bb0a8ca1ef1c208e5dce270e9e575e">&#9670;&nbsp;</a></span>snfRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::snfRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given cycle as a combination of free and torsion generators. </p>
<p >This routine takes a single argument <em>cycle</em>, which should be a cycle in chain complex coordinates. This routine then returns this cycle as a group element, expressed in SNF coordinates. See the class notes for a full explanation of what these concepts mean.</p>
<p >In the vector that is returned, the coordinates that hold coefficients for the torsion generators will be non-negative integers modulo the corresponding invariant factors <em>d1</em>, ..., <em>dk</em>.</p>
<p >Specifically, using the notation from the class notes, suppose <em>cycle</em> belongs to ker(<em>M</em>) and snfRep(<em>cycle</em>) returns the vector (<em>b1</em>, ..., <em>bk</em>, <em>a1</em>, ..., <em>ar</em>). Suppose furthermore that the free generators returned by freeRep(0..(r-1)) are <em>f1</em>, ..., <em>fr</em> respectively, and that the torsion generators returned by torsionRep(0..(k-1)) are <em>t1</em>, ..., <em>tk</em> respectively. Then <em>cycle</em> = <em>b1.t1</em> + ... + <em>bk.tk</em> + <em>a1.f1</em> + ... + <em>ar.fr</em> modulo img(<em>N</em>).</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given vector was the wrong size, or is not a cycle (i.e., not in the kernel of <em>M</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycle</td><td>a cycle, presented in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group element corresponding to <em>cycle</em>, expressed in SNF coordinates. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a36837882c0df7a0303522d0ba345074e" name="a36837882c0df7a0303522d0ba345074e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36837882c0df7a0303522d0ba345074e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::MarkedAbelianGroup::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49a015c866ae6a0a6e3d4c0f0eab88b0" name="a49a015c866ae6a0a6e3d4c0f0eab88b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a015c866ae6a0a6e3d4c0f0eab88b0">&#9670;&nbsp;</a></span>torsionInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::MarkedAbelianGroup::torsionInclusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map representing the inclusion of the torsion subgroup into this group. </p>
<dl class="section return"><dt>Returns</dt><dd>the inclusion map for the torsion subgroup. </dd></dl>

</div>
</div>
<a id="ae9a387bfcc8de00ab908fb2fc7e19152" name="ae9a387bfcc8de00ab908fb2fc7e19152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a387bfcc8de00ab908fb2fc7e19152">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p >If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p >For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="afb3f8682aebf7aebde3222d051d06c35" name="afb3f8682aebf7aebde3222d051d06c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3f8682aebf7aebde3222d051d06c35">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p >If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p >For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="a9a49be11ffe204f0d0613a8f71f164b5" name="a9a49be11ffe204f0d0613a8f71f164b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a49be11ffe204f0d0613a8f71f164b5">&#9670;&nbsp;</a></span>torsionRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::MarkedAbelianGroup::torsionRep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested generator of the torsion subgroup, represented in the original chain complex defining the group. </p>
<p >The generator will be presented in chain complex coordinates.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value is not unique. The specific choice of vector may change between different versions of Regina.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>index</em> is out of range (i.e., greater than or equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which generator in the torsion subgroup; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (<em>index</em>)th torsion generator, presented in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="a114b094813f2ec505ba27a19f8be0e67" name="a114b094813f2ec505ba27a19f8be0e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114b094813f2ec505ba27a19f8be0e67">&#9670;&nbsp;</a></span>torsionSubgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> regina::MarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the torsion subgroup of this group. </p>
<dl class="section return"><dt>Returns</dt><dd>the torsion subgroup. </dd></dl>

</div>
</div>
<a id="a38acb7cedad48b463cb92ba8623f90a1" name="a38acb7cedad48b463cb92ba8623f90a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38acb7cedad48b463cb92ba8623f90a1">&#9670;&nbsp;</a></span>unmarked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::MarkedAbelianGroup::unmarked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns just the underlying abelian group, without any of the chain complex information. </p>
<dl class="section return"><dt>Returns</dt><dd>the abelian group. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db2c8ef127dba9ee3717e8660a7da43" name="a7db2c8ef127dba9ee3717e8660a7da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db2c8ef127dba9ee3717e8660a7da43">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::MarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p >The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> notes.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> or <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2" title="Returns a short text representation of this object using unicode characters.">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="markedabeliangroup_8h.html">markedabeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
