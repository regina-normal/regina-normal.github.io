<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.2 Calculation Engine: regina::Link Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.2 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Link.html">Link</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1Link-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Link Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a directed knot or link in the 3-sphere.  
 <a href="classregina_1_1Link.html#details">More...</a></p>

<p><code>#include &lt;link/link.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Link:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Link.png" usemap="#regina::Link_map" alt=""/>
  <map id="regina::Link_map" name="regina::Link_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; Link &gt;" shape="rect" coords="0,0,188,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Link &gt;" shape="rect" coords="198,0,386,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Link &gt;" shape="rect" coords="396,0,584,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <a href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">More...</a><br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a99ed44946fb5776f06326bc45a06c23f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a99ed44946fb5776f06326bc45a06c23f">Link</a> ()=default</td></tr>
<tr class="memdesc:a99ed44946fb5776f06326bc45a06c23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty link.  <a href="classregina_1_1Link.html#a99ed44946fb5776f06326bc45a06c23f">More...</a><br /></td></tr>
<tr class="separator:a99ed44946fb5776f06326bc45a06c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b717f99561f93f6b09118cdf770803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa6b717f99561f93f6b09118cdf770803">Link</a> (size_t unknots)</td></tr>
<tr class="memdesc:aa6b717f99561f93f6b09118cdf770803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the unlink with the given number of components.  <a href="classregina_1_1Link.html#aa6b717f99561f93f6b09118cdf770803">More...</a><br /></td></tr>
<tr class="separator:aa6b717f99561f93f6b09118cdf770803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359918be5fb86081d1122cc2f2260a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a359918be5fb86081d1122cc2f2260a5f">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy)</td></tr>
<tr class="memdesc:a359918be5fb86081d1122cc2f2260a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link.  <a href="classregina_1_1Link.html#a359918be5fb86081d1122cc2f2260a5f">More...</a><br /></td></tr>
<tr class="separator:a359918be5fb86081d1122cc2f2260a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aaef22c9d7355dc008bfc0282c1f99e4b">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also.  <a href="classregina_1_1Link.html#aaef22c9d7355dc008bfc0282c1f99e4b">More...</a><br /></td></tr>
<tr class="separator:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2b893b338cbcc1556db7f7e54dfe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a75a2b893b338cbcc1556db7f7e54dfe9">Link</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a75a2b893b338cbcc1556db7f7e54dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given link into this new link.  <a href="classregina_1_1Link.html#a75a2b893b338cbcc1556db7f7e54dfe9">More...</a><br /></td></tr>
<tr class="separator:a75a2b893b338cbcc1556db7f7e54dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b233fb32a24925705b616b5dc23b219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9b233fb32a24925705b616b5dc23b219">Link</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a9b233fb32a24925705b616b5dc23b219"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a link.  <a href="classregina_1_1Link.html#a9b233fb32a24925705b616b5dc23b219">More...</a><br /></td></tr>
<tr class="separator:a9b233fb32a24925705b616b5dc23b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93be82c5a263db9e3dc28a928fb4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aca93be82c5a263db9e3dc28a928fb4ba">~Link</a> ()</td></tr>
<tr class="memdesc:aca93be82c5a263db9e3dc28a928fb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this link.  <a href="classregina_1_1Link.html#aca93be82c5a263db9e3dc28a928fb4ba">More...</a><br /></td></tr>
<tr class="separator:aca93be82c5a263db9e3dc28a928fb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Crossings and Components</div></td></tr>
<tr class="memitem:ad12a7e69700971494486e299bbc39c57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad12a7e69700971494486e299bbc39c57">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad12a7e69700971494486e299bbc39c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link is empty.  <a href="classregina_1_1Link.html#ad12a7e69700971494486e299bbc39c57">More...</a><br /></td></tr>
<tr class="separator:ad12a7e69700971494486e299bbc39c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c6f34794cc62574fcfca388f3f66d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9">size</a> () const</td></tr>
<tr class="memdesc:a32c6f34794cc62574fcfca388f3f66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of crossings in this link.  <a href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9">More...</a><br /></td></tr>
<tr class="separator:a32c6f34794cc62574fcfca388f3f66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60">countComponents</a> () const</td></tr>
<tr class="memdesc:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of components in this link.  <a href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60">More...</a><br /></td></tr>
<tr class="separator:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47712bc419c15659a634ae6ea97b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:a2b47712bc419c15659a634ae6ea97b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the crossing at the given index within this link.  <a href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">More...</a><br /></td></tr>
<tr class="separator:a2b47712bc419c15659a634ae6ea97b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c13af7dff2e92401ff388f3a2eec26"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a25c13af7dff2e92401ff388f3a2eec26">crossings</a> () const</td></tr>
<tr class="memdesc:a25c13af7dff2e92401ff388f3a2eec26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all crossings within this link.  <a href="classregina_1_1Link.html#a25c13af7dff2e92401ff388f3a2eec26">More...</a><br /></td></tr>
<tr class="separator:a25c13af7dff2e92401ff388f3a2eec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3425a2a6994fbc87baf890e9b429ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f">component</a> (size_t index) const</td></tr>
<tr class="memdesc:a3425a2a6994fbc87baf890e9b429ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a strand in the given component of this link.  <a href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f">More...</a><br /></td></tr>
<tr class="separator:a3425a2a6994fbc87baf890e9b429ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ed4ff764fe10462582631b9798d6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a550ed4ff764fe10462582631b9798d6e">components</a> () const</td></tr>
<tr class="memdesc:a550ed4ff764fe10462582631b9798d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all components of this link.  <a href="classregina_1_1Link.html#a550ed4ff764fe10462582631b9798d6e">More...</a><br /></td></tr>
<tr class="separator:a550ed4ff764fe10462582631b9798d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5338200b51df9d368711c7bf3954d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aadb5338200b51df9d368711c7bf3954d">strand</a> (ssize_t id) const</td></tr>
<tr class="memdesc:aadb5338200b51df9d368711c7bf3954d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strand in the link with the given integer ID.  <a href="classregina_1_1Link.html#aadb5338200b51df9d368711c7bf3954d">More...</a><br /></td></tr>
<tr class="separator:aadb5338200b51df9d368711c7bf3954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa4d5e4637efe2ed81e2c9588aaa76591">translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference from some other link into the corresponding strand reference from this link.  <a href="classregina_1_1Link.html#aa4d5e4637efe2ed81e2c9588aaa76591">More...</a><br /></td></tr>
<tr class="separator:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc783777826fcf17af86d21a343118d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#abc783777826fcf17af86d21a343118d5">connected</a> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *a, const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *b) const</td></tr>
<tr class="memdesc:abc783777826fcf17af86d21a343118d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram.  <a href="classregina_1_1Link.html#abc783777826fcf17af86d21a343118d5">More...</a><br /></td></tr>
<tr class="separator:abc783777826fcf17af86d21a343118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca68202fe7b9672c314b5c7f214e9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa7ca68202fe7b9672c314b5c7f214e9f">operator==</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other) const</td></tr>
<tr class="memdesc:aa7ca68202fe7b9672c314b5c7f214e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this link diagram is combinatorially identical to the given link diagram.  <a href="classregina_1_1Link.html#aa7ca68202fe7b9672c314b5c7f214e9f">More...</a><br /></td></tr>
<tr class="separator:aa7ca68202fe7b9672c314b5c7f214e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7f446cea700b313ce2eb4b6d85459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aedc7f446cea700b313ce2eb4b6d85459">operator!=</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other) const</td></tr>
<tr class="memdesc:aedc7f446cea700b313ce2eb4b6d85459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this link diagram is not combinatorially identical to the given link diagram.  <a href="classregina_1_1Link.html#aedc7f446cea700b313ce2eb4b6d85459">More...</a><br /></td></tr>
<tr class="separator:aedc7f446cea700b313ce2eb4b6d85459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980602d950e89b20aba2ba16ebc86521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a980602d950e89b20aba2ba16ebc86521">graph</a> () const</td></tr>
<tr class="memdesc:a980602d950e89b20aba2ba16ebc86521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4-valent planar graph that models this link.  <a href="classregina_1_1Link.html#a980602d950e89b20aba2ba16ebc86521">More...</a><br /></td></tr>
<tr class="separator:a980602d950e89b20aba2ba16ebc86521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Editing</div></td></tr>
<tr class="memitem:af70fd8c81eeca7fdee7af7b16b144b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#af70fd8c81eeca7fdee7af7b16b144b94">operator=</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;src)</td></tr>
<tr class="memdesc:af70fd8c81eeca7fdee7af7b16b144b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given link.  <a href="classregina_1_1Link.html#af70fd8c81eeca7fdee7af7b16b144b94">More...</a><br /></td></tr>
<tr class="separator:af70fd8c81eeca7fdee7af7b16b144b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3fb09880c2f7984d19fc944a3b4b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7e3fb09880c2f7984d19fc944a3b4b50">operator=</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a7e3fb09880c2f7984d19fc944a3b4b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given link into this link.  <a href="classregina_1_1Link.html#a7e3fb09880c2f7984d19fc944a3b4b50">More...</a><br /></td></tr>
<tr class="separator:a7e3fb09880c2f7984d19fc944a3b4b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48595553c44333292ad1948caed0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aeb48595553c44333292ad1948caed0ae">swap</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:aeb48595553c44333292ad1948caed0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given link.  <a href="classregina_1_1Link.html#aeb48595553c44333292ad1948caed0ae">More...</a><br /></td></tr>
<tr class="separator:aeb48595553c44333292ad1948caed0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d386bea941e436ae6548aa8663a005b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0d386bea941e436ae6548aa8663a005b">change</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a0d386bea941e436ae6548aa8663a005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of the given crossing.  <a href="classregina_1_1Link.html#a0d386bea941e436ae6548aa8663a005b">More...</a><br /></td></tr>
<tr class="separator:a0d386bea941e436ae6548aa8663a005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0546dc7f2bde7b63c31f3e057a8c04db">changeAll</a> ()</td></tr>
<tr class="memdesc:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the diagram.  <a href="classregina_1_1Link.html#a0546dc7f2bde7b63c31f3e057a8c04db">More...</a><br /></td></tr>
<tr class="separator:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da54fa7f3352392989e34629c314a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6da54fa7f3352392989e34629c314a91">resolve</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a6da54fa7f3352392989e34629c314a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the given crossing.  <a href="classregina_1_1Link.html#a6da54fa7f3352392989e34629c314a91">More...</a><br /></td></tr>
<tr class="separator:a6da54fa7f3352392989e34629c314a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8b4396c9fcb99dbb3bb4ba7176b859c4">reflect</a> ()</td></tr>
<tr class="memdesc:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this link into its reflection.  <a href="classregina_1_1Link.html#a8b4396c9fcb99dbb3bb4ba7176b859c4">More...</a><br /></td></tr>
<tr class="separator:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b8f0dd10461df6f5b535fb3991bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a078b8f0dd10461df6f5b535fb3991bce">rotate</a> ()</td></tr>
<tr class="memdesc:a078b8f0dd10461df6f5b535fb3991bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this link diagram, converting it into a different diagram of the same link.  <a href="classregina_1_1Link.html#a078b8f0dd10461df6f5b535fb3991bce">More...</a><br /></td></tr>
<tr class="separator:a078b8f0dd10461df6f5b535fb3991bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326a4e30a7cfb373020c4c6084775fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9326a4e30a7cfb373020c4c6084775fc">reverse</a> ()</td></tr>
<tr class="memdesc:a9326a4e30a7cfb373020c4c6084775fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of every component of this link.  <a href="classregina_1_1Link.html#a9326a4e30a7cfb373020c4c6084775fc">More...</a><br /></td></tr>
<tr class="separator:a9326a4e30a7cfb373020c4c6084775fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a23a70af4f63bbd4f7dea13a04a3b984a">r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to remove a crossing.  <a href="classregina_1_1Link.html#a23a70af4f63bbd4f7dea13a04a3b984a">More...</a><br /></td></tr>
<tr class="separator:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9535918349c0ada298fcabeac5638ec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9535918349c0ada298fcabeac5638ec8">r1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a9535918349c0ada298fcabeac5638ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to add a new crossing.  <a href="classregina_1_1Link.html#a9535918349c0ada298fcabeac5638ec8">More...</a><br /></td></tr>
<tr class="separator:a9535918349c0ada298fcabeac5638ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf3e0d6eaa504eba071e3950a939028"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#afaf3e0d6eaa504eba071e3950a939028">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:afaf3e0d6eaa504eba071e3950a939028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="classregina_1_1Link.html#afaf3e0d6eaa504eba071e3950a939028">More...</a><br /></td></tr>
<tr class="separator:afaf3e0d6eaa504eba071e3950a939028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050794f44093f3ec4740eb6b2653d40e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a050794f44093f3ec4740eb6b2653d40e">r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a050794f44093f3ec4740eb6b2653d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="classregina_1_1Link.html#a050794f44093f3ec4740eb6b2653d40e">More...</a><br /></td></tr>
<tr class="separator:a050794f44093f3ec4740eb6b2653d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a92d15fe6c6ad9a04ae0e05c9fea67cea">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to add two new crossings.  <a href="classregina_1_1Link.html#a92d15fe6c6ad9a04ae0e05c9fea67cea">More...</a><br /></td></tr>
<tr class="separator:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29467a23ac123cbab680b1e406e34bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad29467a23ac123cbab680b1e406e34bc">r3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ad29467a23ac123cbab680b1e406e34bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="classregina_1_1Link.html#ad29467a23ac123cbab680b1e406e34bc">More...</a><br /></td></tr>
<tr class="separator:ad29467a23ac123cbab680b1e406e34bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ba90169324b005d88587e4597ad129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae0ba90169324b005d88587e4597ad129">r3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ae0ba90169324b005d88587e4597ad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="classregina_1_1Link.html#ae0ba90169324b005d88587e4597ad129">More...</a><br /></td></tr>
<tr class="separator:ae0ba90169324b005d88587e4597ad129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6293eb60b5477b5cac84363c43286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#acb6293eb60b5477b5cac84363c43286a">hasReducingPass</a> () const</td></tr>
<tr class="memdesc:acb6293eb60b5477b5cac84363c43286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this knot has a pass move that will reduce the number of crossings.  <a href="classregina_1_1Link.html#acb6293eb60b5477b5cac84363c43286a">More...</a><br /></td></tr>
<tr class="separator:acb6293eb60b5477b5cac84363c43286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c2bc382ec2dd1d7717a21d5cdbe263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a20c2bc382ec2dd1d7717a21d5cdbe263">selfFrame</a> ()</td></tr>
<tr class="memdesc:a20c2bc382ec2dd1d7717a21d5cdbe263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds trivial twists to this link to ensure that each component has zero writhe.  <a href="classregina_1_1Link.html#a20c2bc382ec2dd1d7717a21d5cdbe263">More...</a><br /></td></tr>
<tr class="separator:a20c2bc382ec2dd1d7717a21d5cdbe263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc961ba707da75f2b71d3585c994cc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:a5fc961ba707da75f2b71d3585c994cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the link diagram using fast and greedy heuristics.  <a href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9">More...</a><br /></td></tr>
<tr class="separator:a5fc961ba707da75f2b71d3585c994cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf6c87c3dc80de018d659e686b48ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3adf6c87c3dc80de018d659e686b48ef">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:a3adf6c87c3dc80de018d659e686b48ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings.  <a href="classregina_1_1Link.html#a3adf6c87c3dc80de018d659e686b48ef">More...</a><br /></td></tr>
<tr class="separator:a3adf6c87c3dc80de018d659e686b48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fe044c436e5e1a8861de2ccb106e1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c">simplifyExhaustive</a> (int height=1, unsigned threads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a60fe044c436e5e1a8861de2ccb106e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph.  <a href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c">More...</a><br /></td></tr>
<tr class="separator:a60fe044c436e5e1a8861de2ccb106e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf8a5945cde27790b9538bcbc7cfd9c"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:acaf8a5945cde27790b9538bcbc7cfd9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#acaf8a5945cde27790b9538bcbc7cfd9c">rewrite</a> (int height, unsigned threads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:acaf8a5945cde27790b9538bcbc7cfd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings.  <a href="classregina_1_1Link.html#acaf8a5945cde27790b9538bcbc7cfd9c">More...</a><br /></td></tr>
<tr class="separator:acaf8a5945cde27790b9538bcbc7cfd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a28355f40d08c312c5f2e6cceb68bc1b4">composeWith</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the composition of this with the given link.  <a href="classregina_1_1Link.html#a28355f40d08c312c5f2e6cceb68bc1b4">More...</a><br /></td></tr>
<tr class="separator:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Links</div></td></tr>
<tr class="memitem:a805821d3da773fdd9a69f75916dbd90e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e">brief</a> () const</td></tr>
<tr class="memdesc:a805821d3da773fdd9a69f75916dbd90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this link in Regina's own brief write-only format.  <a href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e">More...</a><br /></td></tr>
<tr class="separator:a805821d3da773fdd9a69f75916dbd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af770913610307338a7a319f38628981c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#af770913610307338a7a319f38628981c">brief</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af770913610307338a7a319f38628981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this link in Regina's own brief format to the given output stream.  <a href="classregina_1_1Link.html#af770913610307338a7a319f38628981c">More...</a><br /></td></tr>
<tr class="separator:af770913610307338a7a319f38628981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05b65401950517d86be107268233b09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09">gauss</a> () const</td></tr>
<tr class="memdesc:ac05b65401950517d86be107268233b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a classical Gauss code for this knot, presented as a string.  <a href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09">More...</a><br /></td></tr>
<tr class="separator:ac05b65401950517d86be107268233b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb54431be1dd0e3295ef9ac07ecb739"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6fb54431be1dd0e3295ef9ac07ecb739">gaussData</a> () const</td></tr>
<tr class="memdesc:a6fb54431be1dd0e3295ef9ac07ecb739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a classical Gauss code for this knot, presented as a vector of integers.  <a href="classregina_1_1Link.html#a6fb54431be1dd0e3295ef9ac07ecb739">More...</a><br /></td></tr>
<tr class="separator:a6fb54431be1dd0e3295ef9ac07ecb739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8c0d2be78044e3fc4108e092d086a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5d8c0d2be78044e3fc4108e092d086a5">gauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5d8c0d2be78044e3fc4108e092d086a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a classical Gauss code for this knot to the given output stream.  <a href="classregina_1_1Link.html#a5d8c0d2be78044e3fc4108e092d086a5">More...</a><br /></td></tr>
<tr class="separator:a5d8c0d2be78044e3fc4108e092d086a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d81af83901af217da0bee17b6bf120"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120">orientedGauss</a> () const</td></tr>
<tr class="memdesc:ab8d81af83901af217da0bee17b6bf120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an oriented Gauss code for this knot, presented as a string.  <a href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120">More...</a><br /></td></tr>
<tr class="separator:ab8d81af83901af217da0bee17b6bf120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c104bb3fa0b1cf4a73d85be984eac46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5c104bb3fa0b1cf4a73d85be984eac46">orientedGaussData</a> () const</td></tr>
<tr class="memdesc:a5c104bb3fa0b1cf4a73d85be984eac46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an oriented Gauss code for this knot, presented as a vector of string tokens.  <a href="classregina_1_1Link.html#a5c104bb3fa0b1cf4a73d85be984eac46">More...</a><br /></td></tr>
<tr class="separator:a5c104bb3fa0b1cf4a73d85be984eac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a21eaa9351a071dc7ddcf8e4d1101d584">orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this knot to the given output stream.  <a href="classregina_1_1Link.html#a21eaa9351a071dc7ddcf8e4d1101d584">More...</a><br /></td></tr>
<tr class="separator:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8">jenkins</a> () const</td></tr>
<tr class="memdesc:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link using Bob Jenkins' text format, returning a single string.  <a href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8">More...</a><br /></td></tr>
<tr class="separator:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2e96eaaf8284a8f6afc0094ccd793"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a73f2e96eaaf8284a8f6afc0094ccd793">jenkinsData</a> () const</td></tr>
<tr class="memdesc:a73f2e96eaaf8284a8f6afc0094ccd793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link using Bob Jenkins' text format, returning a vector of integers.  <a href="classregina_1_1Link.html#a73f2e96eaaf8284a8f6afc0094ccd793">More...</a><br /></td></tr>
<tr class="separator:a73f2e96eaaf8284a8f6afc0094ccd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6509ca2eaf2920bf4dc7e69eb5f5f499">jenkins</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link to the given output stream using Bob Jenkins' text format.  <a href="classregina_1_1Link.html#a6509ca2eaf2920bf4dc7e69eb5f5f499">More...</a><br /></td></tr>
<tr class="separator:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478">dt</a> (bool alpha=false) const</td></tr>
<tr class="memdesc:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this knot in either numerical or alphabetical Dowker-Thistlethwaite notation, returning a string.  <a href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478">More...</a><br /></td></tr>
<tr class="separator:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d3896af6c9aa96a53ab1ad68db95ab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab">dtData</a> () const</td></tr>
<tr class="memdesc:a05d3896af6c9aa96a53ab1ad68db95ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.  <a href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab">More...</a><br /></td></tr>
<tr class="separator:a05d3896af6c9aa96a53ab1ad68db95ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6e48b3891b1ec16cff1190f781e3ebd0">dt</a> (std::ostream &amp;out, bool alpha=false) const</td></tr>
<tr class="memdesc:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this knot to the given output stream using Dowker-Thistlethwaite notation.  <a href="classregina_1_1Link.html#a6e48b3891b1ec16cff1190f781e3ebd0">More...</a><br /></td></tr>
<tr class="separator:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64e5e12c443073dda93c1a23d1be9e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e">pd</a> () const</td></tr>
<tr class="memdesc:aab64e5e12c443073dda93c1a23d1be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a planar diagram code for this link, presented as a string.  <a href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e">More...</a><br /></td></tr>
<tr class="separator:aab64e5e12c443073dda93c1a23d1be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf406224f5959aeab3bbe877f2498b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; int, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#abaf406224f5959aeab3bbe877f2498b0">pdData</a> () const</td></tr>
<tr class="memdesc:abaf406224f5959aeab3bbe877f2498b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a planar diagram code for this link, presented as vector of 4-tuples.  <a href="classregina_1_1Link.html#abaf406224f5959aeab3bbe877f2498b0">More...</a><br /></td></tr>
<tr class="separator:abaf406224f5959aeab3bbe877f2498b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4429732bcfb4c8a26a69e06caa217413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a4429732bcfb4c8a26a69e06caa217413">pd</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a4429732bcfb4c8a26a69e06caa217413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a planar diagram code for this link to the given output stream.  <a href="classregina_1_1Link.html#a4429732bcfb4c8a26a69e06caa217413">More...</a><br /></td></tr>
<tr class="separator:a4429732bcfb4c8a26a69e06caa217413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92">writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the underlying planar 4-valent multigraph using the PACE text format.  <a href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92">More...</a><br /></td></tr>
<tr class="separator:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b21aaa8020908478576e1f9325d4f91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91">pace</a> () const</td></tr>
<tr class="memdesc:a6b21aaa8020908478576e1f9325d4f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a text representation of the underlying planar 4-valent multigraph, using the PACE text format.  <a href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91">More...</a><br /></td></tr>
<tr class="separator:a6b21aaa8020908478576e1f9325d4f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718258433d47de780e6905585a00bd29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a718258433d47de780e6905585a00bd29">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:a718258433d47de780e6905585a00bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C++ code that can be used to reconstruct this link.  <a href="classregina_1_1Link.html#a718258433d47de780e6905585a00bd29">More...</a><br /></td></tr>
<tr class="separator:a718258433d47de780e6905585a00bd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e305e2721276730a7783e84bc0bc04"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04">knotSig</a> (bool useReflection=true, bool useReversal=true) const</td></tr>
<tr class="memdesc:a96e305e2721276730a7783e84bc0bc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <em>signature</em> for this knot diagram.  <a href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04">More...</a><br /></td></tr>
<tr class="separator:a96e305e2721276730a7783e84bc0bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31d64de793d9791c85f7ce04ae903f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae31d64de793d9791c85f7ce04ae903f8">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ae31d64de793d9791c85f7ce04ae903f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this link to the given output stream.  <a href="classregina_1_1Link.html#ae31d64de793d9791c85f7ce04ae903f8">More...</a><br /></td></tr>
<tr class="separator:ae31d64de793d9791c85f7ce04ae903f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ed6330752dc62de8a611075e05280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a228ed6330752dc62de8a611075e05280">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a228ed6330752dc62de8a611075e05280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this link to the given output stream.  <a href="classregina_1_1Link.html#a228ed6330752dc62de8a611075e05280">More...</a><br /></td></tr>
<tr class="separator:a228ed6330752dc62de8a611075e05280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075bf4f759b540961ee47b1e5364b492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a075bf4f759b540961ee47b1e5364b492">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a075bf4f759b540961ee47b1e5364b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this link to the given output stream.  <a href="classregina_1_1Link.html#a075bf4f759b540961ee47b1e5364b492">More...</a><br /></td></tr>
<tr class="separator:a075bf4f759b540961ee47b1e5364b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <a href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">More...</a><br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a365f08df3a98992ccc0c2c22f23958c6"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a365f08df3a98992ccc0c2c22f23958c6">jonesVar</a> = &quot;\u221At&quot;</td></tr>
<tr class="memdesc:a365f08df3a98992ccc0c2c22f23958c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Jones polynomial, as returned by <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>.  <a href="classregina_1_1Link.html#a365f08df3a98992ccc0c2c22f23958c6">More...</a><br /></td></tr>
<tr class="separator:a365f08df3a98992ccc0c2c22f23958c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f761ba1c3d1badabc9638c27192db"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a> = &quot;\u03B1&quot;</td></tr>
<tr class="memdesc:ad65f761ba1c3d1badabc9638c27192db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="classregina_1_1Link.html#ad65f761ba1c3d1badabc9638c27192db">More...</a><br /></td></tr>
<tr class="separator:ad65f761ba1c3d1badabc9638c27192db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acb282c9b668b106d63b5180e34f7f2"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a> = &quot;z&quot;</td></tr>
<tr class="memdesc:a7acb282c9b668b106d63b5180e34f7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="classregina_1_1Link.html#a7acb282c9b668b106d63b5180e34f7f2">More...</a><br /></td></tr>
<tr class="separator:a7acb282c9b668b106d63b5180e34f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce5812b285b56f767c8b3863c13b0c"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#af9ce5812b285b56f767c8b3863c13b0c">homflyLMVarX</a> = &quot;\U0001D4C1&quot;</td></tr>
<tr class="memdesc:af9ce5812b285b56f767c8b3863c13b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="classregina_1_1Link.html#af9ce5812b285b56f767c8b3863c13b0c">More...</a><br /></td></tr>
<tr class="separator:af9ce5812b285b56f767c8b3863c13b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73f30e80276f03658f7d733827631d3"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#af73f30e80276f03658f7d733827631d3">homflyLMVarY</a> = &quot;m&quot;</td></tr>
<tr class="memdesc:af73f30e80276f03658f7d733827631d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="classregina_1_1Link.html#af73f30e80276f03658f7d733827631d3">More...</a><br /></td></tr>
<tr class="separator:af73f30e80276f03658f7d733827631d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0447b2d9ec84403a4e07f09198c0d3"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6b0447b2d9ec84403a4e07f09198c0d3">homflyVarX</a> = <a class="el" href="classregina_1_1Link.html#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a></td></tr>
<tr class="memdesc:a6b0447b2d9ec84403a4e07f09198c0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="classregina_1_1Link.html#a6b0447b2d9ec84403a4e07f09198c0d3">More...</a><br /></td></tr>
<tr class="separator:a6b0447b2d9ec84403a4e07f09198c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e77ac33d5598dac3aeca46abc71cde"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae3e77ac33d5598dac3aeca46abc71cde">homflyVarY</a> = <a class="el" href="classregina_1_1Link.html#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a></td></tr>
<tr class="memdesc:ae3e77ac33d5598dac3aeca46abc71cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="classregina_1_1Link.html#ae3e77ac33d5598dac3aeca46abc71cde">More...</a><br /></td></tr>
<tr class="separator:ae3e77ac33d5598dac3aeca46abc71cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Links</h2></td></tr>
<tr class="memitem:a152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="a152f80ab20cfd6daa9bb33498700957f" name="a152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ModelLinkGraph</b></td></tr>
<tr class="separator:a152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="a5b0f99129b1f0437af4889ff9e1bd486" name="a5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Tangle</b></td></tr>
<tr class="separator:a5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memItemLeft" align="right" valign="top"><a id="ac427ed4036a7fdf0f108da0bbf1ca863" name="ac427ed4036a7fdf0f108da0bbf1ca863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkCrossingsReader</b></td></tr>
<tr class="separator:ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3f892e9d18731f9bee8f2a197e904"><td class="memItemLeft" align="right" valign="top"><a id="acab3f892e9d18731f9bee8f2a197e904" name="acab3f892e9d18731f9bee8f2a197e904"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkComponentsReader</b></td></tr>
<tr class="separator:acab3f892e9d18731f9bee8f2a197e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af7ff9e26b814bb897bfcea95afabe"><td class="memItemLeft" align="right" valign="top"><a id="a10af7ff9e26b814bb897bfcea95afabe" name="a10af7ff9e26b814bb897bfcea95afabe"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLWriter&lt; Link &gt;</b></td></tr>
<tr class="separator:a10af7ff9e26b814bb897bfcea95afabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d6d31315c7b000cb653901a0a711c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa11d6d31315c7b000cb653901a0a711c">insertTorusLink</a> (int p, int q, bool positive=true)</td></tr>
<tr class="memdesc:aa11d6d31315c7b000cb653901a0a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new (<em>p</em>, <em>q</em>) torus link into this link.  <a href="classregina_1_1Link.html#aa11d6d31315c7b000cb653901a0a711c">More...</a><br /></td></tr>
<tr class="separator:aa11d6d31315c7b000cb653901a0a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce">fromData</a> (std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... <a class="el" href="classregina_1_1Link.html#a550ed4ff764fe10462582631b9798d6e">components</a>)</td></tr>
<tr class="memdesc:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a link from hard-coded information about its crossings and components.  <a href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce">More...</a><br /></td></tr>
<tr class="separator:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memTemplParams" colspan="2">template&lt;typename SignIterator , typename ComponentIterator &gt; </td></tr>
<tr class="memitem:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9d9fd529b5fc4e76b2e0ee3acbef8968">fromData</a> (SignIterator beginSigns, SignIterator endSigns, ComponentIterator beginComponents, ComponentIterator endComponents)</td></tr>
<tr class="memdesc:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from information about its crossings and components.  <a href="classregina_1_1Link.html#a9d9fd529b5fc4e76b2e0ee3acbef8968">More...</a><br /></td></tr>
<tr class="separator:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae508c34ea5f9de157496161cd989a963"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963">fromKnotSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ae508c34ea5f9de157496161cd989a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a knot diagram from its signature.  <a href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963">More...</a><br /></td></tr>
<tr class="separator:ae508c34ea5f9de157496161cd989a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb55121bb4d10b35b199b820569041"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ac3cb55121bb4d10b35b199b820569041">fromSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ac3cb55121bb4d10b35b199b820569041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a>, to recover a knot diagram from its signature.  <a href="classregina_1_1Link.html#ac3cb55121bb4d10b35b199b820569041">More...</a><br /></td></tr>
<tr class="separator:ac3cb55121bb4d10b35b199b820569041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac540c07f819bf0c967867bf04463cafc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ac540c07f819bf0c967867bf04463cafc">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:ac540c07f819bf0c967867bf04463cafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a link from its given tight encoding.  <a href="classregina_1_1Link.html#ac540c07f819bf0c967867bf04463cafc">More...</a><br /></td></tr>
<tr class="separator:ac540c07f819bf0c967867bf04463cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a3be3af017e42c2230fb8f847bf4d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ab6a3be3af017e42c2230fb8f847bf4d1">fromGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ab6a3be3af017e42c2230fb8f847bf4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code, presented as a string.  <a href="classregina_1_1Link.html#ab6a3be3af017e42c2230fb8f847bf4d1">More...</a><br /></td></tr>
<tr class="separator:ab6a3be3af017e42c2230fb8f847bf4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a00fb45e8afa12a93a62a6f032479"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3c6a00fb45e8afa12a93a62a6f032479"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3c6a00fb45e8afa12a93a62a6f032479">fromGauss</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a3c6a00fb45e8afa12a93a62a6f032479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code, presented as an integer sequence.  <a href="classregina_1_1Link.html#a3c6a00fb45e8afa12a93a62a6f032479">More...</a><br /></td></tr>
<tr class="separator:a3c6a00fb45e8afa12a93a62a6f032479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb0b58804ab890b9de49ee36380d31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0efb0b58804ab890b9de49ee36380d31">fromOrientedGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a0efb0b58804ab890b9de49ee36380d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code, presented as string.  <a href="classregina_1_1Link.html#a0efb0b58804ab890b9de49ee36380d31">More...</a><br /></td></tr>
<tr class="separator:a0efb0b58804ab890b9de49ee36380d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade13362ee37b779804e4d0da60353516"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ade13362ee37b779804e4d0da60353516"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ade13362ee37b779804e4d0da60353516">fromOrientedGauss</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ade13362ee37b779804e4d0da60353516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code, presented as a sequence of string tokens.  <a href="classregina_1_1Link.html#ade13362ee37b779804e4d0da60353516">More...</a><br /></td></tr>
<tr class="separator:ade13362ee37b779804e4d0da60353516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5">fromJenkins</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from Bob Jenkins' format, presented as a string.  <a href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5">More...</a><br /></td></tr>
<tr class="separator:a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632cc9fb94359bb3f2f9c10d6a500208"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a632cc9fb94359bb3f2f9c10d6a500208">fromJenkins</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a632cc9fb94359bb3f2f9c10d6a500208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from Bob Jenkins' format, read directly from an input stream.  <a href="classregina_1_1Link.html#a632cc9fb94359bb3f2f9c10d6a500208">More...</a><br /></td></tr>
<tr class="separator:a632cc9fb94359bb3f2f9c10d6a500208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6b1f11ca592dda9f6ac900e9bf09fd65">fromJenkins</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from Bob Jenkins' format, presented as an integer sequence.  <a href="classregina_1_1Link.html#a6b1f11ca592dda9f6ac900e9bf09fd65">More...</a><br /></td></tr>
<tr class="separator:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24bdd53db84c7fcbb4c40a51180111f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f">fromDT</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ae24bdd53db84c7fcbb4c40a51180111f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation, presented as a string.  <a href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f">More...</a><br /></td></tr>
<tr class="separator:ae24bdd53db84c7fcbb4c40a51180111f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523518b438fc7884f28075a76851515a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a523518b438fc7884f28075a76851515a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a523518b438fc7884f28075a76851515a">fromDT</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a523518b438fc7884f28075a76851515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from numerical Dowker-Thistlethwaite notation, presented as an integer sequence.  <a href="classregina_1_1Link.html#a523518b438fc7884f28075a76851515a">More...</a><br /></td></tr>
<tr class="separator:a523518b438fc7884f28075a76851515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a67c18fe7de681acb6cec84a6e922"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9a9a67c18fe7de681acb6cec84a6e922">fromPD</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a9a9a67c18fe7de681acb6cec84a6e922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from a planar diagram code, presented as a string.  <a href="classregina_1_1Link.html#a9a9a67c18fe7de681acb6cec84a6e922">More...</a><br /></td></tr>
<tr class="separator:a9a9a67c18fe7de681acb6cec84a6e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb770fccc62c80b32d751d8c45b1c113"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:acb770fccc62c80b32d751d8c45b1c113"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#acb770fccc62c80b32d751d8c45b1c113">fromPD</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:acb770fccc62c80b32d751d8c45b1c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from a planar diagram code, presented as a sequence of 4-tuples.  <a href="classregina_1_1Link.html#acb770fccc62c80b32d751d8c45b1c113">More...</a><br /></td></tr>
<tr class="separator:acb770fccc62c80b32d751d8c45b1c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Invariants and Related Properties</h2></td></tr>
<tr class="memitem:a821a3c1d060bdc5f3807ee1a64064775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a821a3c1d060bdc5f3807ee1a64064775">isAlternating</a> () const</td></tr>
<tr class="memdesc:a821a3c1d060bdc5f3807ee1a64064775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this knot diagram is alternating.  <a href="classregina_1_1Link.html#a821a3c1d060bdc5f3807ee1a64064775">More...</a><br /></td></tr>
<tr class="separator:a821a3c1d060bdc5f3807ee1a64064775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdacd0939c10de129dcf4c9a72f209c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8cdacd0939c10de129dcf4c9a72f209c">linking</a> () const</td></tr>
<tr class="memdesc:a8cdacd0939c10de129dcf4c9a72f209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linking number of this link.  <a href="classregina_1_1Link.html#a8cdacd0939c10de129dcf4c9a72f209c">More...</a><br /></td></tr>
<tr class="separator:a8cdacd0939c10de129dcf4c9a72f209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e5a318a8fdab39ebea49912074d19"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aed6e5a318a8fdab39ebea49912074d19">writhe</a> () const</td></tr>
<tr class="memdesc:aed6e5a318a8fdab39ebea49912074d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of this link diagram.  <a href="classregina_1_1Link.html#aed6e5a318a8fdab39ebea49912074d19">More...</a><br /></td></tr>
<tr class="separator:aed6e5a318a8fdab39ebea49912074d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a069ee95598f2e1f27ab15a9de07dc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a93a069ee95598f2e1f27ab15a9de07dc">writheOfComponent</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> <a class="el" href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f">component</a>) const</td></tr>
<tr class="memdesc:a93a069ee95598f2e1f27ab15a9de07dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of a single component of this link diagram.  <a href="classregina_1_1Link.html#a93a069ee95598f2e1f27ab15a9de07dc">More...</a><br /></td></tr>
<tr class="separator:a93a069ee95598f2e1f27ab15a9de07dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe822e89589e9d9295299dd95d53e8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa8fe822e89589e9d9295299dd95d53e8">writheOfComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:aa8fe822e89589e9d9295299dd95d53e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of a single component of this link diagram.  <a href="classregina_1_1Link.html#aa8fe822e89589e9d9295299dd95d53e8">More...</a><br /></td></tr>
<tr class="separator:aa8fe822e89589e9d9295299dd95d53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac532f70e281f305bafaceb8c627b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7ac532f70e281f305bafaceb8c627b94">complement</a> (bool simplify=true) const</td></tr>
<tr class="memdesc:a7ac532f70e281f305bafaceb8c627b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ideal triangulation of the complement of this link in the 3-sphere.  <a href="classregina_1_1Link.html#a7ac532f70e281f305bafaceb8c627b94">More...</a><br /></td></tr>
<tr class="separator:a7ac532f70e281f305bafaceb8c627b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4f6dadc771af3f89aa9728472919e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a4a4f6dadc771af3f89aa9728472919e2">parallel</a> (int k, <a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a> framing=<a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a>) const</td></tr>
<tr class="memdesc:a4a4f6dadc771af3f89aa9728472919e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>k</em> cables of this link, all parallel to each other using the given framing.  <a href="classregina_1_1Link.html#a4a4f6dadc771af3f89aa9728472919e2">More...</a><br /></td></tr>
<tr class="separator:a4a4f6dadc771af3f89aa9728472919e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e533094b847777857aa17c499c4473"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473">bracket</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ae4e533094b847777857aa17c499c4473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Kauffman bracket polynomial of this link diagram.  <a href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473">More...</a><br /></td></tr>
<tr class="separator:ae4e533094b847777857aa17c499c4473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a432a4f3024e537920770c0eb60d2e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6a432a4f3024e537920770c0eb60d2e2">knowsBracket</a> () const</td></tr>
<tr class="memdesc:a6a432a4f3024e537920770c0eb60d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details.  <a href="classregina_1_1Link.html#a6a432a4f3024e537920770c0eb60d2e2">More...</a><br /></td></tr>
<tr class="separator:a6a432a4f3024e537920770c0eb60d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f95c8720f9fced7843664aef522116f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f">jones</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a0f95c8720f9fced7843664aef522116f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jones polynomial of this link, but with all exponents doubled.  <a href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f">More...</a><br /></td></tr>
<tr class="separator:a0f95c8720f9fced7843664aef522116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2acb5efa330841a89e91d28e5d64a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a13a2acb5efa330841a89e91d28e5d64a">knowsJones</a> () const</td></tr>
<tr class="memdesc:a13a2acb5efa330841a89e91d28e5d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Jones polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details.  <a href="classregina_1_1Link.html#a13a2acb5efa330841a89e91d28e5d64a">More...</a><br /></td></tr>
<tr class="separator:a13a2acb5efa330841a89e91d28e5d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff8f1b5e4a911f2d104b2427d7b3e5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f">homflyAZ</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a5ff8f1b5e4a911f2d104b2427d7b3e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f">More...</a><br /></td></tr>
<tr class="separator:a5ff8f1b5e4a911f2d104b2427d7b3e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9a3da0fd25d5f0ccfe95a51462c5ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef">homflyLM</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:afb9a3da0fd25d5f0ccfe95a51462c5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>.  <a href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef">More...</a><br /></td></tr>
<tr class="separator:afb9a3da0fd25d5f0ccfe95a51462c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cdae63725a633c32868737d44cb7c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7">homfly</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:aa3cdae63725a633c32868737d44cb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7">More...</a><br /></td></tr>
<tr class="separator:aa3cdae63725a633c32868737d44cb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae7100ef279d1f9a4ed7a739e76d5c5d4">knowsHomfly</a> () const</td></tr>
<tr class="memdesc:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details.  <a href="classregina_1_1Link.html#ae7100ef279d1f9a4ed7a739e76d5c5d4">More...</a><br /></td></tr>
<tr class="separator:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4">group</a> (bool simplify=true) const</td></tr>
<tr class="memdesc:a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group of this link; that is, the fundamental group of the link exterior.  <a href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4">More...</a><br /></td></tr>
<tr class="separator:a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9867163e5b6defa9aa85d9bd8d9963"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#adf9867163e5b6defa9aa85d9bd8d9963">niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:adf9867163e5b6defa9aa85d9bd8d9963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.  <a href="classregina_1_1Link.html#adf9867163e5b6defa9aa85d9bd8d9963">More...</a><br /></td></tr>
<tr class="separator:adf9867163e5b6defa9aa85d9bd8d9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e380e04a7b375d081aeafab5d05eb51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0e380e04a7b375d081aeafab5d05eb51">useTreeDecomposition</a> (<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> td)</td></tr>
<tr class="memdesc:a0e380e04a7b375d081aeafab5d05eb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link.  <a href="classregina_1_1Link.html#a0e380e04a7b375d081aeafab5d05eb51">More...</a><br /></td></tr>
<tr class="separator:a0e380e04a7b375d081aeafab5d05eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf01ac5bd43984ba0530b5548e24755"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3cf01ac5bd43984ba0530b5548e24755">homflyAZtoLM</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f">homflyAZ</a>)</td></tr>
<tr class="memdesc:a3cf01ac5bd43984ba0530b5548e24755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between the (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) representations of the HOMFLY polynomial.  <a href="classregina_1_1Link.html#a3cf01ac5bd43984ba0530b5548e24755">More...</a><br /></td></tr>
<tr class="separator:a3cf01ac5bd43984ba0530b5548e24755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a directed knot or link in the 3-sphere. </p>
<p >This class supports links with any number of components (including zero), and it also supports components with no crossings (which form additional unknot components of the overall link).</p>
<p >Since Regina 7.0, this is no longer a "packet type" that can be inserted directly into the packet tree. Instead a <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include a <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> in the packet tree, you must create a new PacketOf&lt;Link&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>, and so inherits the full <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> interface.</li>
<li>If you are adding new functions to this class that edit the link, you must still remember to create a ChangeEventSpan. This will ensure that, if the link is being managed by a PacketOf&lt;Link&gt;, then the appropriate packet change events will be fired. All other events (aside from packetToBeChanged() and packetWasChanged() are managed directly by the PacketOf&lt;Link&gt; wrapper class.</li>
</ul>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a99ed44946fb5776f06326bc45a06c23f" name="a99ed44946fb5776f06326bc45a06c23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ed44946fb5776f06326bc45a06c23f">&#9670;&nbsp;</a></span>Link() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty link. </p>
<p >This will have zero components. </p>

</div>
</div>
<a id="aa6b717f99561f93f6b09118cdf770803" name="aa6b717f99561f93f6b09118cdf770803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b717f99561f93f6b09118cdf770803">&#9670;&nbsp;</a></span>Link() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unknots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the unlink with the given number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unknots</td><td>the number of (unknotted) components in the new unlink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359918be5fb86081d1122cc2f2260a5f" name="a359918be5fb86081d1122cc2f2260a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359918be5fb86081d1122cc2f2260a5f">&#9670;&nbsp;</a></span>Link() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link. </p>
<p >This will clone any computed properties (such as Jones polynomial and so on) of the given link also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef22c9d7355dc008bfc0282c1f99e4b" name="aaef22c9d7355dc008bfc0282c1f99e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef22c9d7355dc008bfc0282c1f99e4b">&#9670;&nbsp;</a></span>Link() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given link (such as Jones polynomial and so on), or <code>false</code> if the new link should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75a2b893b338cbcc1556db7f7e54dfe9" name="a75a2b893b338cbcc1556db7f7e54dfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a2b893b338cbcc1556db7f7e54dfe9">&#9670;&nbsp;</a></span>Link() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given link into this new link. </p>
<p >This is a fast (constant time) operation.</p>
<p >All crossings that belong to <em>src</em> will be moved into this link, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this link.</p>
<p >The link that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this link is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b233fb32a24925705b616b5dc23b219" name="a9b233fb32a24925705b616b5dc23b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b233fb32a24925705b616b5dc23b219">&#9670;&nbsp;</a></span>Link() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a link. </p>
<p >At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>knot signatures, as used by <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a>;</li>
<li>oriented Gauss codes, as used by <a class="el" href="classregina_1_1Link.html#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code, presented as string.">fromOrientedGauss()</a>;</li>
<li>classical Gauss codes, as used by <a class="el" href="classregina_1_1Link.html#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new knot from a classical Gauss code, presented as a string.">fromGauss()</a>;</li>
<li>numeric or alphabetical Dowker-Thistlethwaite strings, as used by <a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a>;</li>
<li>planar diagram codes, as used by <a class="el" href="classregina_1_1Link.html#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new link from a planar diagram code, presented as a string.">fromPD()</a>.</li>
</ul>
<p >This list may grow in future versions of Regina.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Regina could not interpret the given string as representing a link using any of the supported string types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a knot or link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca93be82c5a263db9e3dc28a928fb4ba" name="aca93be82c5a263db9e3dc28a928fb4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca93be82c5a263db9e3dc28a928fb4ba">&#9670;&nbsp;</a></span>~Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::~Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this link. </p>
<p >The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this link will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="ae4e533094b847777857aa17c499c4473" name="ae4e533094b847777857aa17c499c4473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e533094b847777857aa17c499c4473">&#9670;&nbsp;</a></span>bracket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp; regina::Link::bracket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Kauffman bracket polynomial of this link diagram. </p>
<p >Note that the bracket polynomial is not an invariant - it is preserved under Reidemeister moves II and III, but not I.</p>
<p >If this is the empty link, then this routine will return the zero polynomial.</p>
<p >Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> should be called again; this will be instantaneous if the bracket polynomial has already been calculated.</p>
<p >If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p >Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently at most 63). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the maximum possible strand ID cannot fit into an <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bracket polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a805821d3da773fdd9a69f75916dbd90e" name="a805821d3da773fdd9a69f75916dbd90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805821d3da773fdd9a69f75916dbd90e">&#9670;&nbsp;</a></span>brief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::brief </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this link in Regina's own brief write-only format. </p>
<p >This format is concise, but contains enough information to manually reconstruct the complete link diagram.</p>
<p >This format cannot (yet) be used to read links back into Regina, and so it is not good for external storage, or for passing links between different programs (or even different instances of Regina). It was originally designed for use with the test suite, where it was used to ensure that links with being created and/or manipulated correctly.</p>
<p >The output will contain the following elements, separated by single spaces:</p>
<ul>
<li>a sequence of signs (<code>+</code> or <code>-</code>), concatenated together, giving the signs of the crossings in order from crossing 0 to crossing <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1;</li>
<li>a description of each component of the link, in order from component 0 to component <a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1. Each component will be written in the form <code>( a b c ... )</code>, indicating the crossings that are encountered as we follow the component in the forward direction from its starting strand. Each element <em>a</em>, <em>b</em>, <em>c</em> and so on will be written in the format used by the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> class: either <code>^n</code> when passing over crossing <em>n</em>, or <code>_n</code> when passing under crossing <em>n</em>.</li>
</ul>
<p >For example, the Whitehead link as returned by <a class="el" href="classregina_1_1ExampleLink.html#aa2cc05e6f13c8d1d77ecfcce2bd4a72e" title="Returns a five-crossing diagram of the Whitehead link.">ExampleLink.whitehead()</a> will give the following brief output:</p>
<pre class="fragment">--++- ( ^0 _1 ^4 _3 ^2 _4 ) ( _0 ^1 _2 ^3 )
</pre><p >As a special case, if the link contains no crossings, then the output will not begin with a space; instead it will simply be a sequence of the form <code>( ) ( ) ... ( )</code>.</p>
<p >The string will not end in a newline.</p>
<p >There is also a variant of <a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link in Regina's brief format. </dd></dl>

</div>
</div>
<a id="af770913610307338a7a319f38628981c" name="af770913610307338a7a319f38628981c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af770913610307338a7a319f38628981c">&#9670;&nbsp;</a></span>brief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::brief </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this link in Regina's own brief format to the given output stream. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> for a full description of Regina's brief format, as well as its limitations.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a>. In particular, the output does not contain any newlines.</p>
<p >See also <a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a>, which returns the brief format as a string.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d386bea941e436ae6548aa8663a005b" name="a0d386bea941e436ae6548aa8663a005b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d386bea941e436ae6548aa8663a005b">&#9670;&nbsp;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of the given crossing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0546dc7f2bde7b63c31f3e057a8c04db" name="a0546dc7f2bde7b63c31f3e057a8c04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546dc7f2bde7b63c31f3e057a8c04db">&#9670;&nbsp;</a></span>changeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::changeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the diagram. </p>
<p >This operation corresponds to reflecting the link diagram through the plane on which it is drawn. </p>

</div>
</div>
<a id="a7ac532f70e281f305bafaceb8c627b94" name="a7ac532f70e281f305bafaceb8c627b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac532f70e281f305bafaceb8c627b94">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::Link::complement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an ideal triangulation of the complement of this link in the 3-sphere. </p>
<p >The triangulation will have one ideal vertex for each link component. Assuming you pass <em>simplify</em> as <code>true</code> (the default), there will typically be no internal vertices; however, this is not guaranteed.</p>
<p >Initially, each tetrahedron will be oriented according to a right-hand rule: the thumb of the right hand points from vertices 0 to 1, and the fingers curl around to point from vertices 2 to 3. If you pass <em>simplify</em> as <code>true</code>, then Regina will attempt to simplify the triangulation to as few tetrahedra as possible: this may relabel the tetrahedra, though their orientations will be preserved.</p>
<p >This is the same triangulation that would be produced by passing this link to the <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if and only if the triangulation of the complement should be simplified to use as few tetrahedra as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complement of this link. </dd></dl>

</div>
</div>
<a id="a3425a2a6994fbc87baf890e9b429ef6f" name="a3425a2a6994fbc87baf890e9b429ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3425a2a6994fbc87baf890e9b429ef6f">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a strand in the given component of this link. </p>
<p >For each component of the link, this routine returns a "starting strand". You can traverse the entire component by beginning at this starting strand and repeatedly incrementing it through a routine such as <a class="el" href="classregina_1_1StrandRef.html#aca9f21431143267c5f4d7142f604559f" title="Moves this reference forward along the direction of the link until it reaches the next crossing.">StrandRef::operator++</a> or <a class="el" href="classregina_1_1StrandRef.html#a0f3ce62d47997b0e320735c7e32fd54a" title="Returns the crossing reference that comes immediately after this when walking forward along the direc...">StrandRef::next()</a>.</p>
<p >If a component has no crossings (which means it must be a separate unknot component), then this routine will return a null reference (i.e., <a class="el" href="classregina_1_1StrandRef.html#abe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">StrandRef::crossing()</a> will return <code>null</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a "starting strand" for traversing the component at the given index, or a null reference if the requested component has no crossings. </dd></dl>

</div>
</div>
<a id="a550ed4ff764fe10462582631b9798d6e" name="a550ed4ff764fe10462582631b9798d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ed4ff764fe10462582631b9798d6e">&#9670;&nbsp;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Link::components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all components of this link. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Each element of the list will be a starting strand for some components; more precisely, iterating through this list is equivalent to calling <code>component(0)</code>, <code>component(1)</code>, ..., <code>component(<a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1)</code> in turn. As an example, your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> StrandRef&amp; c : link.components()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the link exists: even as components are added and/or removed, it will always reflect the components that are currently in the link. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="classregina_1_1Link.html#a550ed4ff764fe10462582631b9798d6e" title="Returns an object that allows iteration through and random access to all components of this link.">components()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all components. </dd></dl>

</div>
</div>
<a id="a28355f40d08c312c5f2e6cceb68bc1b4" name="a28355f40d08c312c5f2e6cceb68bc1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28355f40d08c312c5f2e6cceb68bc1b4">&#9670;&nbsp;</a></span>composeWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::composeWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the composition of this with the given link. </p>
<p >This link will be altered directly.</p>
<p >Specifically, the first component of the given link will be grafted into the first component of this link, in a way that preserves orientations and crossing signs. If the given link has any additional components, then they will be copied into this link directly with no modification.</p>
<p >This routine may be expanded in future versions of Regina to allow more flexibility (in particular, to allow you to choose which components of the two links to graft together, and/or at which strands to graft them).</p>
<p >If either link is empty (i.e., contains no components at all), then the result will simply be a clone of the other link (with no composition operation performed).</p>
<p >It is allowed to pass this link as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link with which this should be composed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc783777826fcf17af86d21a343118d5" name="abc783777826fcf17af86d21a343118d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc783777826fcf17af86d21a343118d5">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram. </p>
<p >Here "the underlying 4-valent graph" means the multigraph whose vertices are the crossings and whose edges are the arcs between crossings. In particular</p>
<ul>
<li>two crossings may be connected even if they involve entirely different components of the link;</li>
<li>if two crossings are not connected then the underlying link must be splittable (though this need not happen in the other direction: one can have a diagram of a splittable link in which all crossings are connected with each other).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow (linear time), since it may need to perform a depth-first search through the graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first of the two crossings to examine. </td></tr>
    <tr><td class="paramname">b</td><td>the second of the two crossings to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two given crossings are connected. </dd></dl>

</div>
</div>
<a id="ab4fb9a0932d786dfca9eef2f6e45ec60" name="ab4fb9a0932d786dfca9eef2f6e45ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb9a0932d786dfca9eef2f6e45ec60">&#9670;&nbsp;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of components in this link. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="a2b47712bc419c15659a634ae6ea97b91" name="a2b47712bc419c15659a634ae6ea97b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47712bc419c15659a634ae6ea97b91">&#9670;&nbsp;</a></span>crossing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Link::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the crossing at the given index within this link. </p>
<p >For a link with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="a25c13af7dff2e92401ff388f3a2eec26" name="a25c13af7dff2e92401ff388f3a2eec26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c13af7dff2e92401ff388f3a2eec26">&#9670;&nbsp;</a></span>crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Link::crossings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all crossings within this link. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Crossing* c : link.crossings()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the link exists: even as crossings are added and/or removed, it will always reflect the crossings that are currently in the link. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="classregina_1_1Link.html#a25c13af7dff2e92401ff388f3a2eec26" title="Returns an object that allows iteration through and random access to all crossings within this link.">crossings()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all crossings. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7394cd7aa9cb8d14cb4d7d39f9d96478" name="a7394cd7aa9cb8d14cb4d7d39f9d96478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7394cd7aa9cb8d14cb4d7d39f9d96478">&#9670;&nbsp;</a></span>dt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this knot in either numerical or alphabetical Dowker-Thistlethwaite notation, returning a string. </p>
<p >Like classical Gauss codes, Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not the particular embedding in the plane. It comes with two major restrictions:</p>
<ul>
<li>In general, it does not carry enough information to uniquely reconstruct a knot. For instance, both a knot and its reflection can be described by the same Dowker-Thistlethwaite notation; moreover, for composite knots, the same notation can describe inequivalent knots (even when allowing for reflections).</li>
<li>Parsing Dowker-Thistlethwaite notation is complex, since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</li>
</ul>
<p >If you need a code that specifies the knot uniquely and/or that is fast to parse, consider using the <em>oriented</em> Gauss code instead, which resolves both of these issues.</p>
<p >For an <em>n</em>-crossing knot, Regina supports two variants of Dowker-Thistlethwaite notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will throw an exception if the alphabetical variant is requested.</li>
</ul>
<p >As an example, you can describe the trefoil using numerical Dowker-Thistlethwaite notation as:</p>
<pre class="fragment">4 6 2
</pre><p >In alphabetical Dowker-Thistlethwaite notation, this becomes:</p>
<pre class="fragment">bca
</pre><p >Currently Regina only supports Dowker-Thistlethwaite codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Dowker-Thistlethwaite codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p >For numerical Dowker-Thistlethwaite notation, this routine will format the list of integers as a string. The integers will be separated by single spaces, and there will be no newlines. For alphabetical Dowker-Thistlethwaite notation, the string that is returned will not contain any whitespace at all.</p>
<p >For the numerical variant, the routine <a class="el" href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.">dtData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478" title="Exports this knot in either numerical or alphabetical Dowker-Thistlethwaite notation,...">dt()</a> that can write either the numerical or the alphabetical variant directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this link is empty or has multiple components, or <em>alpha</em> is true and it has more than 26 crossings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Dowker-Thistlethwaite notation for this knot diagram. </dd></dl>

</div>
</div>
<a id="a6e48b3891b1ec16cff1190f781e3ebd0" name="a6e48b3891b1ec16cff1190f781e3ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e48b3891b1ec16cff1190f781e3ebd0">&#9670;&nbsp;</a></span>dt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this knot to the given output stream using Dowker-Thistlethwaite notation. </p>
<p >See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p >This routine can write either numerical or alphabetical Dowker-Thistlethwaite notation, as indicated by the optional argument <em>alpha</em>.</p>
<p >The output from this routine is precisely the string that would be returned by dt(bool). In particular, the output does not contain any newlines.</p>
<p >See also dtBool(bool), which can export either the numerical or alphabetical variant of Dowker-Thistlethwaite notation as a human-readable string, and <a class="el" href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.">dtData()</a>, which exports the numerical variant only as a machine-readable sequence of integers.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this link is empty or has multiple components, or <em>alpha</em> is true and it has more than 26 crossings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants dt(bool) or <a class="el" href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.">dtData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05d3896af6c9aa96a53ab1ad68db95ab" name="a05d3896af6c9aa96a53ab1ad68db95ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d3896af6c9aa96a53ab1ad68db95ab">&#9670;&nbsp;</a></span>dtData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::dtData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers. </p>
<p >See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p >Although Regina can work with both the numerical and alphabetical variants of Dowker-Thistlethwaite notation, this <a class="el" href="classregina_1_1Link.html#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.">dtData()</a> routine exports the numerical variant only. If you wish to export the alphabetical variant, you can call <code>dt(true)</code>.</p>
<p >This routine returns machine-readable data (as a C++ vector); in contrast, calling <code><a class="el" href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478" title="Exports this knot in either numerical or alphabetical Dowker-Thistlethwaite notation,...">dt()</a></code> returns the same integer sequence in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty, or has multiple components, or has so many crossings that the Dowker-Thistlethwaite notation cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numerical Dowker-Thistlethwaite notation in machine-readable form. </dd></dl>

</div>
</div>
<a id="a718258433d47de780e6905585a00bd29" name="a718258433d47de780e6905585a00bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718258433d47de780e6905585a00bd29">&#9670;&nbsp;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns C++ code that can be used to reconstruct this link. </p>
<p >This code will call <a class="el" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a link from hard-coded information about its crossings and components.">Link::fromData()</a>, passing a series of hard-coded C++ initialiser lists.</p>
<p >The main purpose of this routine is to generate these hard-coded initialiser lists, which can be tedious and error-prone to write by hand.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="a9d9fd529b5fc4e76b2e0ee3acbef8968" name="a9d9fd529b5fc4e76b2e0ee3acbef8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9fd529b5fc4e76b2e0ee3acbef8968">&#9670;&nbsp;</a></span>fromData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignIterator , typename ComponentIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">SignIterator&#160;</td>
          <td class="paramname"><em>beginSigns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignIterator&#160;</td>
          <td class="paramname"><em>endSigns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentIterator&#160;</td>
          <td class="paramname"><em>beginComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentIterator&#160;</td>
          <td class="paramname"><em>endComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from information about its crossings and components. </p>
<p >This routine is an analogue to the variant of <a class="el" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a link from hard-coded information about its crossings and components.">fromData()</a> that takes C++ initialiser lists; however, here the input data may be constructed at runtime (which makes it accessible to Python, amongst other things).</p>
<p >For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The information that you must pass to this routine is the following:</p>
<ul>
<li>The first iterator range (<em>beginSigns</em>, <em>endSigns</em>) encodes the signs of crossings 1, ..., <em>n</em> in order. Each iterator in this range must dereference to either +1 or -1.</li>
<li>The second iterator range (<em>beginComponents</em>, <em>endComponents</em>) identifies the individual components of the link. Each iterator in this range must dereference to a container that has a <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a> function and supports range-based <code>for</code> loops (so standard C++ container classes such as std::vector&lt;int&gt; and std::list&lt;int&gt; are fine).</li>
<li>The container for each component must be filled with integers, which identify the crossings you visit in order when traversing the component. A positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>.</li>
<li>To encode a component with no crossings, you may use either an empty container or a container containing the single integer 0.</li>
</ul>
<p >Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p >As an example, Python users can construct the left-hand trefoil and the Hopf link as follows:</p>
<div class="fragment"><div class="line">trefoil = Link.fromData([ -1, -1, -1 ], [[ 1, -2, 3, -1, 2, -3 ]])</div>
<div class="line">hopf = Link.fromData([ +1, +1 ], [[ 1, -2 ], [ -1, 2 ]])</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>A link could not be reconstructed from the given data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The signs should be passed as a single Python list of integers (not an iterator pair). Likewise, the components should be passed as a Python list of lists of integers (not an iterator pair). In the case of a knot (which has only one component), you are welcome to replace the list of lists <code>[[...]]</code> with a single list <code>[...]</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginSigns</td><td>the beginning of the list of crossing signs. </td></tr>
    <tr><td class="paramname">endSigns</td><td>a past-the-end iterator indicating the end of the list of crossing signs. </td></tr>
    <tr><td class="paramname">beginComponents</td><td>the beginning of the list of containers describing each link component. </td></tr>
    <tr><td class="paramname">endComponents</td><td>a past-the-end iterator indicating the end of the list of link components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a13f44d669e5b4139ad6bc8955ef9f5ce" name="a13f44d669e5b4139ad6bc8955ef9f5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f44d669e5b4139ad6bc8955ef9f5ce">&#9670;&nbsp;</a></span>fromData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>crossingSigns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Args &gt;...&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a link from hard-coded information about its crossings and components. </p>
<p >This routine takes a series of C++ initialiser lists (each a list of integers), which makes it useful for creating hard-coded examples directly in C++ code.</p>
<p >For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The lists that you must pass to this routine are as follows:</p>
<ul>
<li>The first list contains the signs of crossings 1, ..., <em>n</em> in order, where each sign is either +1 or -1.</li>
<li>Each subsequent list describes a single component of the link. The list identifies which crossings you visit in order when traversing the component; a positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>. Empty lists are allowed (these denote separate unknot components).</li>
<li>If a component has no crossings, then you should pass the list { 0 }, not the empty list. (This is because the C++ compiler cannot deduce the type of an empty list.)</li>
</ul>
<p >Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p >As an example, you can construct the left-hand trefoil and the Hopf link as follows:</p>
<div class="fragment"><div class="line">trefoil = <a class="code hl_function" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce">Link::fromData</a>({ -1, -1, -1 }, { 1, -2, 3, -1, 2, -3 });</div>
<div class="line">hopf = <a class="code hl_function" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce">Link::fromData</a>({ +1, +1 }, { 1, -2 }, { -1, 2 });</div>
<div class="ttc" id="aclassregina_1_1Link_html_a13f44d669e5b4139ad6bc8955ef9f5ce"><div class="ttname"><a href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce">regina::Link::fromData</a></div><div class="ttdeci">static Link fromData(std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... components)</div><div class="ttdoc">Creates a link from hard-coded information about its crossings and components.</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you have an existing link that you would like to hard-code, the routine <a class="el" href="classregina_1_1Link.html#a718258433d47de780e6905585a00bd29" title="Returns C++ code that can be used to reconstruct this link.">dumpConstruction()</a> will output C++ code that can reconstruct the link by calling this routine.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>A link could not be reconstructed from the given data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the variant of <a class="el" href="classregina_1_1Link.html#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a link from hard-coded information about its crossings and components.">fromData()</a> that takes this same data using two Python lists (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossingSigns</td><td>a list containing the signs of the crossings; each sign must be either +1 or -1. </td></tr>
    <tr><td class="paramname">components</td><td>one list for each link component that describes the crossings that are visited along that component, as described in the detailed notes above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="ae24bdd53db84c7fcbb4c40a51180111f" name="ae24bdd53db84c7fcbb4c40a51180111f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24bdd53db84c7fcbb4c40a51180111f">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation, presented as a string. </p>
<p >Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be topological ambiguities when a knot is reconstructed from Dowker-Thistlethwaite notation; these are described in the warnings below.</p>
<p >Dowker-Thistlethwaite notation comes in two forms: numerical and alphabetical. For an <em>n</em>-crossing knot, the numerical form is a sequence of <em>n</em> even signed integers, and the alphabetical form is a sequence of <em>n</em> case-sensitive letters. As an example, you can construct the trefoil using either of the following strings:</p>
<pre class="fragment">4 6 2
bca
</pre><p >See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p >There are two variants of this routine. This variant takes a single string, which is either (i) the alphabetical notation, in which any whitespace within the string will be ignored; or (ii) the numerical notation, in which the integers are combined together and separated by whitespace. The other variant of this routine is only for numerical Dowker-Thistlethwaite notation, and it takes a sequence of integers defined by a pair of iterators.</p>
<p >In this variant (the string variant), the string may contain additional leading or trailing whitespace; moreover, for numerical Dowker-Thistlethwaite notation, the exact form of the whitespace that separates the integers does not matter.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid Dowker-Thistlethwaite code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>either the alphabetical or numerical Dowker-Thistlethwaite notation for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a523518b438fc7884f28075a76851515a" name="a523518b438fc7884f28075a76851515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523518b438fc7884f28075a76851515a">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from numerical Dowker-Thistlethwaite notation, presented as an integer sequence. </p>
<p >See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, and see <a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs knots from such notation.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<p >This variant of <a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a> can only work with <em>numerical</em> Dowker-Thistlethwaite notation. Regina does understand alphabetic Dowker-Thistlethwaite notation, but for this you will need to use the string-based variant of <a class="el" href="classregina_1_1Link.html#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid Dowker-Thistlethwaite code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="ab6a3be3af017e42c2230fb8f847bf4d1" name="ab6a3be3af017e42c2230fb8f847bf4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a3be3af017e42c2230fb8f847bf4d1">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code, presented as a string. </p>
<p >Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be topological ambiguities when a knot is reconstructed from a gauss code; these are described in the warnings below.</p>
<p >The Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers. As an example, you can construct the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p >See <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p >Regina imposes the following restrictions when reconstructing a knot from a classical Gauss code:</p>
<ul>
<li>This can only be done for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot be arbitrary natural numbers with "gaps", and the numbering cannot use a different starting point).</li>
</ul>
<p >Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p >There are two variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variant takes a sequence of integers, defined by a pair of iterators.</p>
<p >In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid classical Gauss code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a classical Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a3c6a00fb45e8afa12a93a62a6f032479" name="a3c6a00fb45e8afa12a93a62a6f032479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6a00fb45e8afa12a93a62a6f032479">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code, presented as an integer sequence. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, and see <a class="el" href="classregina_1_1Link.html#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new knot from a classical Gauss code, presented as a string.">fromGauss(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs knots from such codes.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new knot from a classical Gauss code, presented as a string.">fromGauss(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid classical Gauss code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for a classical Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for a classical Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a9b39ba67b388f3b69f28c00fdb7c54a5" name="a9b39ba67b388f3b69f28c00fdb7c54a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39ba67b388f3b69f28c00fdb7c54a5">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from Bob Jenkins' format, presented as a string. </p>
<p >Jenkins' format overcomes the limitations of classical Gauss codes by encoding all of the data needed to quickly and correctly reconstruct a link diagram. It can work with links as well as knots.</p>
<p >In Jenkins' format, a link is described by a sequence of integers. As an example, you could construct the Hopf link using the sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p >See <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format (and in particular, what these integers represent).</p>
<p >There are three variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variants take (i) a sequence of integers defined by a pair of iterators, or (ii) an input stream from which the integers will be read.</p>
<p >In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid encoding of a link in Jenkins' format. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string describing a link in Jenkins' format, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a6b1f11ca592dda9f6ac900e9bf09fd65" name="a6b1f11ca592dda9f6ac900e9bf09fd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1f11ca592dda9f6ac900e9bf09fd65">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from Bob Jenkins' format, presented as an integer sequence. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Bob Jenkins' format as it is used in Regina, and see <a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from this format.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a forward iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid encoding of a link in Jenkins' format. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers that describes a link. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a632cc9fb94359bb3f2f9c10d6a500208" name="a632cc9fb94359bb3f2f9c10d6a500208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632cc9fb94359bb3f2f9c10d6a500208">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from Bob Jenkins' format, read directly from an input stream. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Bob Jenkins' format as it is used in Regina, and see <a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from this format.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> which, instead of taking a string as input, takes an input stream from which the sequence of integers describing the link will be read.</p>
<p >Once this routine reads the integers that describe the link, or as soon as it encounters an error (e.g., invalid input data), it will stop reading and leave the remainder of the input stream untouched. This means that the stream may contain additional material, which can be read by the user after this routine has finished.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given input was not a valid encoding of a link in Jenkins' format. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Link.html#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a>, which takes the input as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that begins with a sequence of integers separated by whitespace that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="ae508c34ea5f9de157496161cd989a963" name="ae508c34ea5f9de157496161cd989a963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae508c34ea5f9de157496161cd989a963">&#9670;&nbsp;</a></span>fromKnotSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromKnotSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a knot diagram from its signature. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> for more information on knot signatures.</p>
<p >Calling <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> followed by <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> is not guaranteed to produce an <em>identical</em> knot diagram to the original, but it is guaranteed to produce one that is related by relabelling, rotation, and optionally (according to the arguments that were passed to <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a>) reflection and/or reversal.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid knot signature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the knot diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a0efb0b58804ab890b9de49ee36380d31" name="a0efb0b58804ab890b9de49ee36380d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efb0b58804ab890b9de49ee36380d31">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code, presented as string. </p>
<p >Oriented gauss codes overcome the limitations of classical Gauss codes by encoding all of the data needed to quickly and correctly reconstruct a knot diagram.</p>
<p >The oriented Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> string tokens. As an example, you can construct the left-hand trefoil using the code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p >See <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina (and in particular, what these tokens represent).</p>
<p >Regina imposes the following restrictions when reconstructing a knot from an oriented Gauss code:</p>
<ul>
<li>This can only be done for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot be arbitrary natural numbers with "gaps", and the numbering cannot use a different starting point).</li>
</ul>
<p >Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p >There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p >In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid oriented Gauss code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an "oriented" Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="ade13362ee37b779804e4d0da60353516" name="ade13362ee37b779804e4d0da60353516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade13362ee37b779804e4d0da60353516">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code, presented as a sequence of string tokens. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, and see <a class="el" href="classregina_1_1Link.html#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code, presented as string.">fromOrientedGauss(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs knots from such codes.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code, presented as string.">fromOrientedGauss(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of string tokens. This sequence is given by passing a pair of begin/end iterators.</p>
<p >The tokens in the input sequence should be the individual tokens of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code> that would normally be joined with whitespace to form a complete oriented Gauss code. For example, to describe the left-hand trefoil, the input sequence could be a vector containing the six tokens:</p>
<pre class="fragment">{ "+&gt;1", "-&lt;2", "+&gt;3", "-&lt;1", "+&gt;2", "-&lt;3" }
</pre><p >Each individual token should <em>not</em> contain any whitespace; otherwise this routine may fail to parse the token(s) and could throw an exception as a result.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces either a C-style string (which can be cast to <code>const char*</code>) or a C++-style string (which can be cast to <code>const std::string&amp;</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid oriented Gauss code for a knot. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an "oriented" Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an "oriented" Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a9a9a67c18fe7de681acb6cec84a6e922" name="a9a9a67c18fe7de681acb6cec84a6e922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9a67c18fe7de681acb6cec84a6e922">&#9670;&nbsp;</a></span>fromPD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromPD </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from a planar diagram code, presented as a string. </p>
<p >Planar diagram codes overcome the limitations of classical Gauss codes by encoding the local information at each crossing, though they do introduce their own (less severe) ambiguities and computational difficulties, as described in the warnings below. They can work with links as well as knots, though they cannot encode zero-crossing unknot components.</p>
<p >A planar diagram code for an <em>n</em>-crossing link is formed from a sequence of <em>n</em> 4-tuples of integers. An example, you can construct the right-handed trefoil using the sequence:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
</pre><p >See <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes (and in particular, what these integers represent).</p>
<p >Regina imposes the following restrictions when reconstructing a link from a planar diagram code:</p>
<ul>
<li>The integers used in the input sequence (which denote the 2<em>n</em> strands in the link diagram) must be in the range 1, 2, ..., 2<em>n</em>. That is, they cannot be arbitrary natural numbers with "gaps", and the numbering of strands cannot use a different starting point.</li>
</ul>
<p >When Regina builds the resulting link, it numbers the crossings and components (but not the strands). It will do this as follows:</p>
<ul>
<li>Each 4-tuple in the given sequence represents a single crossing. Regina will number the crossings 0, 1, ..., <em>n</em> in the same order as the corresponding 4-tuples appear in the sequence.</li>
<li>The integers in the given sequence represent strands in the link diagram. The strand numbered 1 will become the starting point of component 0 in the final link. Of the strands not in that component, the lowest numbered strand remaining will become the starting point of component 1, and so on.</li>
<li>In particular be aware that <a class="el" href="classregina_1_1StrandRef.html#a2b631379159b6e14758a932d14d0a090" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> will in general have no relation to the strand numbers used in the planar diagram code.</li>
</ul>
<p >There are two variants of this routine. This variant takes a single string containing all 4<em>n</em> integers (see below for how this string may be formatted). The other variant takes a sequence of 4-tuples of integers, defined by a pair of iterators.</p>
<p >In this variant (the string variant), the integers may be separated by any combination of the following:</p>
<ul>
<li>any whitespace;</li>
<li>commas;</li>
<li>open or close round brackets, square brackets and/or braces;</li>
<li>the special symbols <code>PD</code>, <code>X</code>, <code>Xp</code>, <code>Xm</code> and <code>P</code>, which are used by other sources (such as the Knot Atlas), but which are ignored here.</li>
</ul>
<p >Thus the following strings all describe the same sequence:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
PD[X[1, 5, 2, 4], X[3, 1, 4, 6], X[5, 3, 6, 2]]
1 5 2 4 3 1 4 6 5 3 6 2
</pre><p >The string may containin separators (as defined above) at the beginning and/or the end; these will be ignored.</p>
<p >Note that some sources (again, such as the Knot Atlas) use the special symbols <code>Xp</code>, <code>Xm</code> and <code>P</code> to change the meaning of the tuples. Regina does <em>not</em> attribute any meaning to these symbols, and will treat them as nothing more than separators.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the link contains an unknotted loop that sits completely above all other link components (in other words, a link components that consists entirely of over-crossings), then the orientation of this loop might not be reconstructed correctly. This is unavoidable: the planar diagram code simply does not contain this information.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid planar diagram code. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a planar diagram code for a link, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="acb770fccc62c80b32d751d8c45b1c113" name="acb770fccc62c80b32d751d8c45b1c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb770fccc62c80b32d751d8c45b1c113">&#9670;&nbsp;</a></span>fromPD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromPD </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from a planar diagram code, presented as a sequence of 4-tuples. </p>
<p >See <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, and see <a class="el" href="classregina_1_1Link.html#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new link from a planar diagram code, presented as a string.">fromPD(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from such codes.</p>
<p >This routine is a variant of <a class="el" href="classregina_1_1Link.html#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new link from a planar diagram code, presented as a string.">fromPD(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of 4-tuples of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
If <em>it</em> is such an iterator, then <code>(*it)[0]</code>, <code>(*it)[1]</code>, <code>(*it)[2]</code> and <code>(*it)[3]</code> will give the elements of the corresponding 4-tuple, which can then be treated as native C++ integers. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the link contains an unknotted loop that sits completely above all other link components (in other words, a link components that consists entire of over-crossings), then the orientation of this loop might not be reconstructed correctly. This is unavoidable: the planar diagram code simply does not contain this information.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid planar diagram code. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list. Each element of the list should be convertible to a tuple of integers. In particular, a list of Python lists is fine, and a list of Python tuples is fine also.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of 4-tuples for a planar diagram code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of 4-tuples for a planar diagram code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="ac3cb55121bb4d10b35b199b820569041" name="ac3cb55121bb4d10b35b199b820569041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cb55121bb4d10b35b199b820569041">&#9670;&nbsp;</a></span>fromSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a>, to recover a knot diagram from its signature. </p>
<p >This alias <a class="el" href="classregina_1_1Link.html#ac3cb55121bb4d10b35b199b820569041" title="Alias for fromKnotSig(), to recover a knot diagram from its signature.">fromSig()</a> is provided to assist with generic code that can work with both knots and triangulations.</p>
<p >See <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid knot signature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the knot diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="ac05b65401950517d86be107268233b09" name="ac05b65401950517d86be107268233b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05b65401950517d86be107268233b09">&#9670;&nbsp;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::gauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a classical Gauss code for this knot, presented as a string. </p>
<p >Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. These codes come with two major restrictions:</p>
<ul>
<li>In general, they do not carry enough information to uniquely reconstruct a knot. For instance, both a knot and its reflection can be described by the same Gauss code; moreover, for composite knots, the Gauss code can describe inequivalent knots (even when allowing for reflections).</li>
<li>Parsing a Gauss code is complex, since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</li>
</ul>
<p >If you need a code that specifies the knot uniquely and/or that is fast to parse, consider using the <em>oriented</em> Gauss code instead, which resolves both of these issues.</p>
<p >A Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers, representing strands that pass over and under crossings respectively. The code is constructed as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. Whenever you pass crossing <em>k</em>, write the integer <code>k</code> if you pass over the crossing, or <code>-k</code> if you pass under the crossing.</li>
</ul>
<p >As an example, you can represent the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p >Currently Regina only supports Gauss codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Gauss codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p >This routine formats the list of integers as a string. The integers will be separated by single spaces, and there will be no newlines.</p>
<p >The routine <a class="el" href="classregina_1_1Link.html#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> that writes directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code as described above. </dd></dl>

</div>
</div>
<a id="a5d8c0d2be78044e3fc4108e092d086a5" name="a5d8c0d2be78044e3fc4108e092d086a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8c0d2be78044e3fc4108e092d086a5">&#9670;&nbsp;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::gauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a classical Gauss code for this knot to the given output stream. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a>. In particular, the output does not contain any newlines.</p>
<p >See also <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a>, which returns the Gauss code as a human-readable string, and <a class="el" href="classregina_1_1Link.html#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a>, which returns it as a machine-readable sequence of integers.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> or <a class="el" href="classregina_1_1Link.html#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb54431be1dd0e3295ef9ac07ecb739" name="a6fb54431be1dd0e3295ef9ac07ecb739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb54431be1dd0e3295ef9ac07ecb739">&#9670;&nbsp;</a></span>gaussData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::gaussData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a classical Gauss code for this knot, presented as a vector of integers. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p >This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty, or has multiple components, or has so many crossings that the Gauss code cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code for this knot in machine-readable form. </dd></dl>

</div>
</div>
<a id="a980602d950e89b20aba2ba16ebc86521" name="a980602d950e89b20aba2ba16ebc86521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980602d950e89b20aba2ba16ebc86521">&#9670;&nbsp;</a></span>graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::Link::graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 4-valent planar graph that models this link. </p>
<p >Any zero-component unknot components of this link will be ignored.</p>
<p >The nodes of the resulting graph will be numbered in the same way as the crossings of this link. For each node, arc 0 will represent the outgoing lower strand of the corresponding crossing.</p>
<p >Calling <a class="el" href="classregina_1_1Link.html#a980602d950e89b20aba2ba16ebc86521" title="Returns the 4-valent planar graph that models this link.">graph()</a> is identical to passing this link to the <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>the graph that models this link. </dd></dl>

</div>
</div>
<a id="a5b1b29f281cb385e01ca2310d9ca8ad4" name="a5b1b29f281cb385e01ca2310d9ca8ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1b29f281cb385e01ca2310d9ca8ad4">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> regina::Link::group </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the group of this link; that is, the fundamental group of the link exterior. </p>
<p >This routine builds the Wirtinger presentation, where all relations are some variant of the form <code>xy=yz</code>.</p>
<p >If you pass <em>simplify</em> as <code>false</code>, it will leave the presentation in exactly this form (i.e., the Wirtinger presentation), and not simplify it further. If you pass <em>simplify</em> as <code>true</code> (the default), this routine will attempt to simplify the group presentation before returning.</p>
<dl class="section note"><dt>Note</dt><dd>If you are finding the resulting group presentation too large for your liking even after simplification, then you could also try calling <a class="el" href="classregina_1_1Link.html#a7ac532f70e281f305bafaceb8c627b94" title="Returns an ideal triangulation of the complement of this link in the 3-sphere.">complement()</a> and computing the fundamental group of the resulting 3-manifold triangulation. Sometimes the presentation obtained via the complement is better, and sometimes it is worse.</dd></dl>
<p>Currently this group is <em>not</em> cached; instead it is reconstructed every time this function is called. This behaviour may change in future versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>the group of this link. </dd></dl>

</div>
</div>
<a id="acb6293eb60b5477b5cac84363c43286a" name="acb6293eb60b5477b5cac84363c43286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6293eb60b5477b5cac84363c43286a">&#9670;&nbsp;</a></span>hasReducingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasReducingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether this knot has a pass move that will reduce the number of crossings. </p>
<p >Currently this routine is only available for knots, not multiple-component links.</p>
<p >A <em>pass</em> move involves taking a section of the knot that involves only over-crossings (or only under-crossings), and then lifting that section above (or beneath respectively) the diagram and placing it back again in a different location. In particular, this routine searches for a different location that will involve fewer crossings than the original location.</p>
<p >This routine does not actually <em>perform</em> the pass move; it simply determines whether one exists.</p>
<p >The running time is cubic in the number of crossings.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link is actually a knot (i.e., it contains exactly one component).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is a pass move that reduces the number of crossings. </dd></dl>

</div>
</div>
<a id="aa3cdae63725a633c32868737d44cb7c7" name="aa3cdae63725a633c32868737d44cb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cdae63725a633c32868737d44cb7c7">&#9670;&nbsp;</a></span>homfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp; regina::Link::homfly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p >This routine is simply an alias for <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. See the documentation for <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> for further details.</p>
<p >To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyVarX, Link::homflyVarY)</code>.</p>
<p >Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the maximum possible strand ID cannot fit into an <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a5ff8f1b5e4a911f2d104b2427d7b3e5f" name="a5ff8f1b5e4a911f2d104b2427d7b3e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff8f1b5e4a911f2d104b2427d7b3e5f">&#9670;&nbsp;</a></span>homflyAZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp; regina::Link::homflyAZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p >This variant of the HOMFLY polynomial is described (amongst other places) in G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p >The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p >This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>alpha</em> and <em>z</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p >If this is the empty link, then this routine will return the zero polynomial.</p>
<p >To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>.</p>
<p >The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p >Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p >If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p >Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the maximum possible strand ID cannot fit into an <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a3cf01ac5bd43984ba0530b5548e24755" name="a3cf01ac5bd43984ba0530b5548e24755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf01ac5bd43984ba0530b5548e24755">&#9670;&nbsp;</a></span>homflyAZtoLM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::Link::homflyAZtoLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>homflyAZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts between the (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) representations of the HOMFLY polynomial. </p>
<p >The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p >See <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homflyAZ</td><td>the HOMFLY polynomial of a link as a polynomial in <em>alpha</em> and <em>z</em>, where (<em>alpha</em>, <em>z</em>) are represented by (<em>x</em>, <em>y</em>) in the class Laurent2&lt;Integer&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial of the same link as a polynomial in <em>l</em> and <em>m</em>, where (<em>l</em>, <em>m</em>) are represented by (<em>x</em>, <em>y</em>) in the class Laurent2&lt;Integer&gt;. </dd></dl>

</div>
</div>
<a id="afb9a3da0fd25d5f0ccfe95a51462c5ef" name="afb9a3da0fd25d5f0ccfe95a51462c5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9a3da0fd25d5f0ccfe95a51462c5ef">&#9670;&nbsp;</a></span>homflyLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp; regina::Link::homflyLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>. </p>
<p >This variant of the HOMFLY polynomial is described (amongst other places) in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p >The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p >This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>l</em> and <em>m</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p >If this is the empty link, then this routine will return the zero polynomial.</p>
<p >To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>.</p>
<p >The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p >Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p >If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p >Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the maximum possible strand ID cannot fit into an <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="aa11d6d31315c7b000cb653901a0a711c" name="aa11d6d31315c7b000cb653901a0a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d6d31315c7b000cb653901a0a711c">&#9670;&nbsp;</a></span>insertTorusLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertTorusLink </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new (<em>p</em>, <em>q</em>) torus link into this link. </p>
<p >The parameters <em>p</em> and <em>q</em> must be non-negative, but they do not need to be coprime.</p>
<p >All of the crossings in the new torus link component(s) will be positive if the argument <em>positive</em> is <code>true</code>, or negative otherwise.</p>
<p >The new crossings and components will be inserted at the end of the respective lists in this link.</p>
<p >If your aim is to create a new torus link (as opposed to inserting one into an existing link), it is simpler to just call <a class="el" href="classregina_1_1ExampleLink.html#a5320898a2ce801f9d5ae1d9684b0c954" title="Returns the (p,q) torus link.">ExampleLink::torus()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the first parameter of the new torus link; this must be non-negative. </td></tr>
    <tr><td class="paramname">q</td><td>the second parameter of the new torus link; this must also be non-negative. </td></tr>
    <tr><td class="paramname">positive</td><td><code>true</code> if the crossings in the new torus link should be positive, or <code>false</code> if they should be negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc961ba707da75f2b71d3585c994cc9" name="a5fc961ba707da75f2b71d3585c994cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc961ba707da75f2b71d3585c994cc9">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the link diagram using fast and greedy heuristics. </p>
<p >Specifically, this routine tries combinations of Reidemeister moves with the aim of reducing the number of crossings.</p>
<p >Currently this routine uses <a class="el" href="classregina_1_1Link.html#a3adf6c87c3dc80de018d659e686b48ef" title="Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number o...">simplifyToLocalMinimum()</a> in combination with random type III Reidemeister moves.</p>
<p >Although <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> often works well, it can sometimes get stuck. If this link is a knot (i.e., it has precisely one component), then in such cases you can try the more powerful but (much) slower <a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> instead.</p>
<p >This routine will never reflect or reverse the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same link may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina. </dd></dl>

</div>
</div>
<a id="a821a3c1d060bdc5f3807ee1a64064775" name="a821a3c1d060bdc5f3807ee1a64064775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821a3c1d060bdc5f3807ee1a64064775">&#9670;&nbsp;</a></span>isAlternating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isAlternating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this knot diagram is alternating. </p>
<p >Note that this routine cannot tell whether the <em>knot</em> is alternating (i.e., whether there <em>exists</em> an alternating diagram). Instead, it simply returns whether this specific diagram is alternating or not.</p>
<p >The empty diagram and any zero-crossing unknot components will be considered alternating.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an alternating diagram, or <code>false</code> if this is a non-alternating diagram. </dd></dl>

</div>
</div>
<a id="ad12a7e69700971494486e299bbc39c57" name="ad12a7e69700971494486e299bbc39c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12a7e69700971494486e299bbc39c57">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link is empty. </p>
<p >An empty link is one with no components at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link is empty. </dd></dl>

</div>
</div>
<a id="a194f84f5ad2fb28ab1a0da34aa69d8a8" name="a194f84f5ad2fb28ab1a0da34aa69d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f84f5ad2fb28ab1a0da34aa69d8a8">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link using Bob Jenkins' text format, returning a single string. </p>
<p >Jenkins' format is lengthy. However, in contrast to classical Gauss codes or Dowker-Thistlethwaite notation, there are no topological ambiguities in the format, and reconstructing a link from Jenkins' format is simple. Moreover, the format is suitable for links with any number of components.</p>
<p >Jenkins' format is described in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>. The format consists of a sequence of integers separated by whitespace, constructed as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 0, 1, ..., <em>n</em>-1.</li>
<li>Write the number of components in the link.</li>
<li>Next, for each link component:<ul>
<li>write the number of times you pass a crossing when traversing the component (i.e., the length of the component);</li>
<li>write two integers for each crossing that you pass in such a traversal: the crossing label, and then +1 if you pass over the crossing or -1 if you pass under the crossing.</li>
</ul>
</li>
<li>Finally, for each crossing:<ul>
<li>write the crossing label;</li>
<li>write the sign of the crossing (either +1 or -1).</li>
</ul>
</li>
</ul>
<p >As an example, you could describe the left-hand trefoil using the following sequence:</p>
<pre class="fragment">1
6   0 1   1 -1   2 1   0 -1   1 1   2 -1
0 -1   1 -1   2 -1
</pre><p >Another example is the Hopf link, which you could describe using the following sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p >The string that is returned will contain multiple lines, and will end in a newline. The specific choice of whitespace (i.e., the "formatting" of the sequence) may change in future versions of Regina.</p>
<p >The routine <a class="el" href="classregina_1_1Link.html#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' text format. </dd></dl>

</div>
</div>
<a id="a6509ca2eaf2920bf4dc7e69eb5f5f499" name="a6509ca2eaf2920bf4dc7e69eb5f5f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6509ca2eaf2920bf4dc7e69eb5f5f499">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link to the given output stream using Bob Jenkins' text format. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format as it is used in Regina.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a>. In particular, the output will typically span multiple lines, and will finish with a newline.</p>
<p >See also <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a>, which exports this link in Jenkins' format as a human-readable string, and <a class="el" href="classregina_1_1Link.html#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a>, which exports it as a machine-readable sequence of integers.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> or <a class="el" href="classregina_1_1Link.html#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f2e96eaaf8284a8f6afc0094ccd793" name="a73f2e96eaaf8284a8f6afc0094ccd793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f2e96eaaf8284a8f6afc0094ccd793">&#9670;&nbsp;</a></span>jenkinsData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::jenkinsData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link using Bob Jenkins' text format, returning a vector of integers. </p>
<p >See <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format as it is used in Regina.</p>
<p >This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link has so many crossings and/or components that its description in Jenkins' format cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' format in machine-readable form. </dd></dl>

</div>
</div>
<a id="a0f95c8720f9fced7843664aef522116f" name="a0f95c8720f9fced7843664aef522116f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f95c8720f9fced7843664aef522116f">&#9670;&nbsp;</a></span>jones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp; regina::Link::jones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jones polynomial of this link, but with all exponents doubled. </p>
<p >By "all exponents doubled", we are indicating that the Jones polynomial is in fact a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>. So, for example:</p>
<ul>
<li>The right-hand trefoil has Jones polynomial <code>1/t + 1/t^3 - 1/t^4</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>x^-2 + x^-6 - x^-8</code>.</li>
<li>The Hopf link has Jones polynomial <code>-1/sqrt(x) - 1/sqrt(x^5)</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>-x^-1 - x^-5</code>.</li>
</ul>
<p >If this is the empty link, then this routine will return the zero polynomial.</p>
<p >Regina follows the conventions described in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994. If you wish to convert to the conventions used by Khovanov as described in Dror Bar-Natan, "On Khovanov's categorifiction of the Jones
polynomial", Algebraic &amp; Geometric Topology 2 (2002), 337-370, you can simply take the polynomial returned by this routine and replace the variable <em>x</em> (which represents the square root of <em>t</em>) with the expression -<em>q</em>.</p>
<p >To pretty-print this polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>.</p>
<p >Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> should be called again; this will be instantaneous if the Jones polynomial has already been calculated.</p>
<p >If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p >Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently at most 63). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the maximum possible strand ID cannot fit into an <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jones polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a96e305e2721276730a7783e84bc0bc04" name="a96e305e2721276730a7783e84bc0bc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e305e2721276730a7783e84bc0bc04">&#9670;&nbsp;</a></span>knotSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::knotSig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReflection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReversal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <em>signature</em> for this knot diagram. </p>
<p >A <em>signature</em> is a compact text representation of a knot diagram that unique determines the knot up to relabelling, rotation, and (optionally) reflection and/or reversal.</p>
<p >Currently signatures are only implemented for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, knot signatures will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p >The signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of crossings.</p>
<p >The routine <a class="el" href="classregina_1_1Link.html#ae508c34ea5f9de157496161cd989a963" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> can be used to recover a knot from its signature. The resulting knot might not be identical to the original, but it will be related by zero or more applications of relabelling, rotation, and/or (according to the arguments) reflection and reversal.</p>
<p >This routine runs in quadratic time.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useReflection</td><td><code>true</code> if the reflection of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reflection). </td></tr>
    <tr><td class="paramname">useReversal</td><td><code>true</code> if the reversal of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reversal). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature for this knot diagram. </dd></dl>

</div>
</div>
<a id="a6a432a4f3024e537920770c0eb60d2e2" name="a6a432a4f3024e537920770c0eb60d2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a432a4f3024e537920770c0eb60d2e2">&#9670;&nbsp;</a></span>knowsBracket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsBracket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details. </p>
<p >If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#ae4e533094b847777857aa17c499c4473" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="ae7100ef279d1f9a4ed7a739e76d5c5d4" name="ae7100ef279d1f9a4ed7a739e76d5c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7100ef279d1f9a4ed7a739e76d5c5d4">&#9670;&nbsp;</a></span>knowsHomfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsHomfly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details. </p>
<p >If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>, <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> will all be very fast (simply returning the precalculated values).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a13a2acb5efa330841a89e91d28e5d64a" name="a13a2acb5efa330841a89e91d28e5d64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a2acb5efa330841a89e91d28e5d64a">&#9670;&nbsp;</a></span>knowsJones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsJones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Jones polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details. </p>
<p >If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a8cdacd0939c10de129dcf4c9a72f209c" name="a8cdacd0939c10de129dcf4c9a72f209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdacd0939c10de129dcf4c9a72f209c">&#9670;&nbsp;</a></span>linking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::linking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the linking number of this link. </p>
<p >This is an invariant of the link, computed as half the sum of the signs of all crossings that involve different link components.</p>
<p >The algorithm to compute linking number is linear time.</p>
<dl class="section return"><dt>Returns</dt><dd>the linking number. </dd></dl>

</div>
</div>
<a id="adf9867163e5b6defa9aa85d9bd8d9963" name="adf9867163e5b6defa9aa85d9bd8d9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9867163e5b6defa9aa85d9bd8d9963">&#9670;&nbsp;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::Link::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram. </p>
<p >This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of this graph.</p>
<p >See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="classregina_1_1TreeDecomposition.html#a2d545347437905541151b6c112bad03f" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p >This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p >The tree decomposition will be cached, so that if this routine is called a second time (and the underlying link has not been changed) then the same tree decomposition will be returned immediately.</p>
<p >If you wish to supply your own tree decomposition (as opposed to relying on the greedy heuristics that Regina implements), then you can supply it by calling <a class="el" href="classregina_1_1Link.html#a0e380e04a7b375d081aeafab5d05eb51" title="Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree d...">useTreeDecomposition()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of this link diagram. </dd></dl>

</div>
</div>
<a id="aedc7f446cea700b313ce2eb4b6d85459" name="aedc7f446cea700b313ce2eb4b6d85459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc7f446cea700b313ce2eb4b6d85459">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this link diagram is not combinatorially identical to the given link diagram. </p>
<p >Here "identical" means that:</p>
<ul>
<li>the link diagrams have the same number of crossings and the same number of components;</li>
<li>the same numbered crossings are positive and negative in both diagrams;</li>
<li>the same pairs of numbered crossings have their under/over-strands connected, with the same orientations;</li>
<li>for each <em>i</em>, the starting strand for the <em>th</em> component is the same (under/over) strand of the same numbered crossing in both diagrams.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link diagram to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two link diagrams are not combinatorially identical. </dd></dl>

</div>
</div>
<a id="af70fd8c81eeca7fdee7af7b16b144b94" name="af70fd8c81eeca7fdee7af7b16b144b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70fd8c81eeca7fdee7af7b16b144b94">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> &amp; regina::Link::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="a7e3fb09880c2f7984d19fc944a3b4b50" name="a7e3fb09880c2f7984d19fc944a3b4b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3fb09880c2f7984d19fc944a3b4b50">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> &amp; regina::Link::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given link into this link. </p>
<p >This is a fast (constant time) operation.</p>
<p >All crossings that belong to <em>src</em> will be moved into this link, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this link.</p>
<p >The link that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this link which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="aa7ca68202fe7b9672c314b5c7f214e9f" name="aa7ca68202fe7b9672c314b5c7f214e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ca68202fe7b9672c314b5c7f214e9f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this link diagram is combinatorially identical to the given link diagram. </p>
<p >Here "identical" means that:</p>
<ul>
<li>the link diagrams have the same number of crossings and the same number of components;</li>
<li>the same numbered crossings are positive and negative in both diagrams;</li>
<li>the same pairs of numbered crossings have their under/over-strands connected, with the same orientations;</li>
<li>for each <em>i</em>, the starting strand for the <em>th</em> component is the same (under/over) strand of the same numbered crossing in both diagrams.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link diagram to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two link diagrams are combinatorially identical. </dd></dl>

</div>
</div>
<a id="ab8d81af83901af217da0bee17b6bf120" name="ab8d81af83901af217da0bee17b6bf120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d81af83901af217da0bee17b6bf120">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an oriented Gauss code for this knot, presented as a string. </p>
<p >The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. This extra information removes both the topological ambiguities and the complexity in the reconstruction procedure for classical Gauss codes.</p>
<p >This "oriented" format is described at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>, and it works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. At every crossing that you pass, write a token of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right;</li>
<li><em>k</em> is replaced with the integer crossing label.</li>
</ul>
</li>
</ul>
<p >As an example, you can represent the left-hand trefoil using the code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p >Currently Regina only supports Gauss codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Gauss codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p >This routine joins the tokens together as a single string. The tokens will be separated by single spaces, and there will be no newlines.</p>
<p >The routine <a class="el" href="classregina_1_1Link.html#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a> returns this same data in machine-readable format (as a C++ vector of string tokens), instead of the human-readable format used here (a single long string). There is also another variant of <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> that writes directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code as described above. </dd></dl>

</div>
</div>
<a id="a21eaa9351a071dc7ddcf8e4d1101d584" name="a21eaa9351a071dc7ddcf8e4d1101d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eaa9351a071dc7ddcf8e4d1101d584">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this knot to the given output stream. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, as well as their limitations.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a>. In particular, the output does not contain any newlines.</p>
<p >See also <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a>, which returns the oriented Gauss code as a human-readable string, and <a class="el" href="classregina_1_1Link.html#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a>, which returns it as a machine-readable sequence of tokens.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> or <a class="el" href="classregina_1_1Link.html#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c104bb3fa0b1cf4a73d85be984eac46" name="a5c104bb3fa0b1cf4a73d85be984eac46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c104bb3fa0b1cf4a73d85be984eac46">&#9670;&nbsp;</a></span>orientedGaussData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; regina::Link::orientedGaussData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an oriented Gauss code for this knot, presented as a vector of string tokens. </p>
<p >See <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, as well as their limitations.</p>
<p >For an <em>n</em>-crossing knot, the elements of the returned vector will be the 2<em>n</em> individual tokens of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code> that would normally be joined with whitespace to form a complete oriented Gauss code. For example, for the left-hand trefoil, the vector might contain the six tokens:</p>
<pre class="fragment">{ "+&gt;1", "-&lt;2", "+&gt;3", "-&lt;1", "+&gt;2", "-&lt;3" }
</pre><p >This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this knot in machine-readable form. </dd></dl>

</div>
</div>
<a id="a6b21aaa8020908478576e1f9325d4f91" name="a6b21aaa8020908478576e1f9325d4f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b21aaa8020908478576e1f9325d4f91">&#9670;&nbsp;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a text representation of the underlying planar 4-valent multigraph, using the PACE text format. </p>
<p >This text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a>.</p>
<p >In summary, the PACE text representation will consist of several lines of text:</p>
<ul>
<li>The first line will be of the form <code>p tw &lt;num_vertices&gt; &lt;num_edges&gt;</code>. Note that, since the underlying graph comes from a link diagram, we will always have <em>num_edges</em> equal to twice <em>num_vertices</em>.</li>
<li>Following this will be <em>num_edges</em> lines, one for each edge, each of the form <code>&lt;u&gt; &lt;v&gt;</code>, indicating an edge from vertex number <em>u</em> to vertex number <em>v</em>. In this format, vertices are numbered 1,2,...,<em>num_vertices</em>.</li>
</ul>
<p >An example of this text format is as follows:</p>
<pre class="fragment">p tw 4 8
1 2
1 4
1 2
2 3
3 4
1 3
3 4
2 4
</pre><p >If you are writing this text representation to an output stream then you should call <a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a> instead, which is more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>the PACE text representation of the underlying 4-valent multigraph, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a4a4f6dadc771af3f89aa9728472919e2" name="a4a4f6dadc771af3f89aa9728472919e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4f6dadc771af3f89aa9728472919e2">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::parallel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a>&#160;</td>
          <td class="paramname"><em>framing</em> = <code><a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <em>k</em> cables of this link, all parallel to each other using the given framing. </p>
<p >This routine creates a new link by:</p>
<ul>
<li>treating each component of this link as a ribbon, using the given framing;</li>
<li>creating <em>k</em> parallel copies of the original link, following each other side-by-side along these ribbons.</li>
</ul>
<p >This link will not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of parallel copies to create. This must be non-negative. </td></tr>
    <tr><td class="paramname">framing</td><td>the framing under which these copies will be parallel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>k</em> parallel copies of this link. </dd></dl>

</div>
</div>
<a id="aab64e5e12c443073dda93c1a23d1be9e" name="aab64e5e12c443073dda93c1a23d1be9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab64e5e12c443073dda93c1a23d1be9e">&#9670;&nbsp;</a></span>pd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a planar diagram code for this link, presented as a string. </p>
<p >Planar diagram codes encode the local information at each crossing, and present this information as a list of 4-tuples. These codes are available for links as well as knots, but they do come with some minor restrictions:</p>
<ul>
<li>They cannot encode zero-crossing unknot components (i.e., components for which the <a class="el" href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f" title="Returns a strand in the given component of this link.">component()</a> function returns a null strand). Any such components will simply be omitted from the code.</li>
<li>If a link has any components that consist entirely of over-crossings (which must be unknots "placed on top of" the link diagram), a planar diagram code does not carry enough data to reconstruct the <em>orientation</em> of these components. The topology will be preserved, but in general the combinatorics of such a link diagram cannot be reconstructed faithfully.</li>
</ul>
<p >If you need a text code that can work with these types of link diagrams, you can always use Jenkins' format instead.</p>
<p >Regina adheres to a tight specification for the planar diagram codes that it outputs, in order to ensure compatibility with other software. In particular, Regina's codes are compatible with the Knot Atlas, as seen at <a href="http://katlas.org/wiki/Planar_Diagrams">http://katlas.org/wiki/Planar_Diagrams</a>.</p>
<p >In detail: a planar diagram code for an <em>n</em>-crossing link is formed from a sequence of <em>n</em> 4-tuples of integers. Regina constructs this sequence as follows:</p>
<ul>
<li>Throw away any zero-crossing unknot components.</li>
<li>Let <em>n</em> denote the number of crossings.</li>
<li>Number the strands from 1 to 2<em>n</em> in order as we walk along each component, in order from the first component to the last.</li>
<li>For each crossing <em>c</em>, construct a 4-tuple that lists the four strands that meet at that <em>c</em>, in counter-clockwise order, beginning from the incoming lower strand.</li>
<li>Return the resulting list of <em>n</em> 4-tuples.</li>
</ul>
<p >An example, you can represent the right-hand trefoil using the code:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
</pre><p >Some points to be aware of:</p>
<ul>
<li>When building the list of 4-tuples, Regina orders the crossings as follows: again we walk along each component, in order from the first component to the last, and process each crossing when we enter it at the lower strand.</li>
<li>When building each individual 4-tuple, some sources order the strands clockwise instead of counter-clockwise. Regina follows the same counter-clockwise convention that is used by the Knot Atlas and SnapPy.</li>
</ul>
<p >This routine formats the list of 4-tuples as a string, in a way that is consistent with the description in the Knot Atlas at <a href="http://katlas.org/wiki/Planar_Diagrams">http://katlas.org/wiki/Planar_Diagrams</a>.</p>
<p >In particular, each 4-tuple will be formatted with square brackets, commas, and the prefix <code>X</code>, and the main list will be formatted with square brackets, commas, and the prefix <code>PD</code>. An example (for the right-handed trefoil) is:</p>
<pre class="fragment">PD[X[1, 5, 2, 4], X[3, 1, 4, 6], X[5, 3, 6, 2]]
</pre><p >The routine <a class="el" href="classregina_1_1Link.html#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a> returns this same data in machine-readable format (as a C++ vector of 4-tuples of integers), instead of the human-readable format used here (a single string). There is also another variant of <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>the planar diagram code, as described above. </dd></dl>

</div>
</div>
<a id="a4429732bcfb4c8a26a69e06caa217413" name="a4429732bcfb4c8a26a69e06caa217413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429732bcfb4c8a26a69e06caa217413">&#9670;&nbsp;</a></span>pd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::pd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a planar diagram code for this link to the given output stream. </p>
<p >See <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, as well as their limitations.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a>. In particular, the output does not contain any newlines.</p>
<p >See also <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a>, which returns the planar diagram code as a human-readable string, and <a class="el" href="classregina_1_1Link.html#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a>, which returns it as a machine-readable sequence of 4-tuples of integers.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> or <a class="el" href="classregina_1_1Link.html#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaf406224f5959aeab3bbe877f2498b0" name="abaf406224f5959aeab3bbe877f2498b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf406224f5959aeab3bbe877f2498b0">&#9670;&nbsp;</a></span>pdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; int, 4 &gt; &gt; regina::Link::pdData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a planar diagram code for this link, presented as vector of 4-tuples. </p>
<p >See <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, as well as their limitations.</p>
<p >This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="classregina_1_1Link.html#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link has so many crossings that the planar diagram code cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the planar diagram code in machine-readable form. </dd></dl>

</div>
</div>
<a id="a23a70af4f63bbd4f7dea13a04a3b984a" name="a23a70af4f63bbd4f7dea13a04a3b984a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a70af4f63bbd4f7dea13a04a3b984a">&#9670;&nbsp;</a></span>r1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to remove a crossing. </p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the argument <em>crossing</em>, which indicates the crossing that will be removed. Specifically, this move involves undoing a trivial twist at the given crossing.</p>
<p >You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because one crossing is being removed, the other crossings in the link may be reindexed. However, no crossings other than the one involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a9535918349c0ada298fcabeac5638ec8" name="a9535918349c0ada298fcabeac5638ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9535918349c0ada298fcabeac5638ec8">&#9670;&nbsp;</a></span>r1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to add a new crossing. </p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves adding a trivial twist to the given arc; the arguments <em>side</em> and <em>sign</em> indicate on which side of the arc and with which orientation the new twist will be made. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p >If <em>arc</em> is a null reference, then the new twist will be added to a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If <em>arc</em> is null but there is no zero-crossing component then the move cannot be performed, and if <em>arc</em> is null but there are multiple zero-crossing components then the first such component will be used.</p>
<p >This move is almost always able to be performed: the only situation in which it <em>cannot</em> be performed is if <em>arc</em> is a null reference but this link contains no zero-crossing components, as discussed above.</p>
<p >The existing crossings in this link will keep the same indices, and the new crossing will be given the next index that is available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a050794f44093f3ec4740eb6b2653d40e" name="a050794f44093f3ec4740eb6b2653d40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050794f44093f3ec4740eb6b2653d40e">&#9670;&nbsp;</a></span>r2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p >There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the argument <em>crossing</em>, Specifically, this move involves pulling apart two arcs of the link (one upper, one lower) that both run between the same pair of crossings. The given crossing should be the start point of the upper arc; that is, when following the upper arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. Note that <em>crossing</em> is one of the two crossings that will be removed by this move.</p>
<p >You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="afaf3e0d6eaa504eba071e3950a939028" name="afaf3e0d6eaa504eba071e3950a939028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf3e0d6eaa504eba071e3950a939028">&#9670;&nbsp;</a></span>r2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p >There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves pulling apart two arcs of the link that surround a bigon; the given arc must be one of these two arcs. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p >You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a92d15fe6c6ad9a04ae0e05c9fea67cea" name="a92d15fe6c6ad9a04ae0e05c9fea67cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d15fe6c6ad9a04ae0e05c9fea67cea">&#9670;&nbsp;</a></span>r2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>upperArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>lowerArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to add two new crossings. </p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the arguments <em>upperArc</em>, <em>upperSide</em>, <em>lowerArc</em> and <em>lowerSide</em>. Specifically, this move involves taking the arc <em>upperArc</em> and pushing it over <em>lowerArc</em> so that the two arcs overlap. The arguments <em>upperSide</em> and <em>lowerSide</em> indicate on which side of each arc the overlap takes place. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p >If either <em>upperArc</em> or <em>lowerArc</em> is a null reference, then the move will be performed upon a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If one of these arguments is a null reference but there is no zero-crossing component then the move cannot be performed, and if there are multiple zero-crossing components then the first such component will be used.</p>
<p >Likewise, if <em>both</em> arcs are null references, then the move will be performed upon two <em>different</em> zero-crossing unknot components. In this case, if there are fewer than two such components then the move cannot be performed, and otherwise <em>upperArc</em> will be the first such component and <em>lowerArc</em> will be the second.</p>
<p >Currently, Regina cannot perform the move when <em>upperArc</em> and <em>lowerArc</em> represent the same arc (or the same zero-crossing unknot component). In this case there is a workaround: you can achieve the same effect by performing two type I Reidemeister moves (i.e., by adding two twists).</p>
<p >The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for this move is expensive (linear time), since it includes testing whether both sides-of-arcs belong to the same 2-cell of the knot diagram.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies the arc of the link which will be passed over the other, as described above. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies the arc of the link which will be passed beneath the other, as described above. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae0ba90169324b005d88587e4597ad129" name="ae0ba90169324b005d88587e4597ad129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ba90169324b005d88587e4597ad129">&#9670;&nbsp;</a></span>r3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p >There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the arguments <em>crossing</em> and <em>side</em>. Specifically, this move takes place around a triangle, and one of the arcs of this triangle is <em>uppermost</em> (in that it passes above the other two arcs). The given crossing should be the start point of this uppermost arc; that is, when following the arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. The additional argument <em>side</em> indicates on which side of the uppermost arc the third crossing is located.</p>
<p >You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p >All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ad29467a23ac123cbab680b1e406e34bc" name="ad29467a23ac123cbab680b1e406e34bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29467a23ac123cbab680b1e406e34bc">&#9670;&nbsp;</a></span>r3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p >There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p >There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p >The location of this move is specified by the arguments <em>arc</em> and <em>side</em>. Specifically, this move takes place around a triangle; the given arc must form one of the three edges of this triangle. The argument <em>side</em> indicates on which side of the arc the third crossing is located. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p >You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p >All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a8b4396c9fcb99dbb3bb4ba7176b859c4" name="a8b4396c9fcb99dbb3bb4ba7176b859c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4396c9fcb99dbb3bb4ba7176b859c4">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this link into its reflection. </p>
<p >This routine changes the sign of every crossing, but leaves the upper and lower strands the same. This operation corresponds to reflecting the link diagram about some axis in the plane. </p>

</div>
</div>
<a id="a6da54fa7f3352392989e34629c314a91" name="a6da54fa7f3352392989e34629c314a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da54fa7f3352392989e34629c314a91">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves the given crossing. </p>
<p >The two incoming strands will switch connections with the two outgoing strands, with the result that the given crossing is removed entirely.</p>
<dl class="section note"><dt>Note</dt><dd>The number of components in the link <em>will</em> change as a result of this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to resolve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9326a4e30a7cfb373020c4c6084775fc" name="a9326a4e30a7cfb373020c4c6084775fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9326a4e30a7cfb373020c4c6084775fc">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of every component of this link. </p>
<p >This routine preserves both the sign and the upper/lower positions at every crossing, but switches all incoming strands with outgoing strands and vice versa (so next() becomes prev(), and prev() becomes next()). </p>

</div>
</div>
<a id="acaf8a5945cde27790b9538bcbc7cfd9c" name="acaf8a5945cde27790b9538bcbc7cfd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf8a5945cde27790b9538bcbc7cfd9c">&#9670;&nbsp;</a></span>rewrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::rewrite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings. </p>
<p >This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will throw an exception (as described below).</p>
<p >This routine iterates through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number. With the current implementation, these diagrams <b>could become reflected and/or reversed</b>, and moreover each diagram will only be considered once up to reflection and/or reversal; be aware that this behaviour could change and/or become configurable in a future version of Regina.</p>
<p >For every such knot diagram (including this starting diagram), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take the following initial argument(s). Either (a) the first argument must be a link (the precise type is discussed below), representing the knot diagram that has been found; or else (b) the first two arguments must be of types const std::string&amp; followed by a link, representing both the knot diagram and its knot signature. The second form is offered in order to avoid unnecessarily recomputation within the <em>action</em> function. If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li>The link argument will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more knot diagrams will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this knot (i.e., the original knot upon which <a class="el" href="classregina_1_1Link.html#acaf8a5945cde27790b9538bcbc7cfd9c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a> was called). This will not affect the search: all knot diagrams that this routine visits will be obtained via Reidemeister moves from the original knot diagram, before any subsequent changes (if any) were made.</li>
<li><em>action</em> will only be called once for each knot diagram (including this starting diagram). In other words, no knot diagram will be revisited a second time in a single call to <a class="el" href="classregina_1_1Link.html#acaf8a5945cde27790b9538bcbc7cfd9c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a>.</li>
</ul>
<p >This routine can be very slow and very memory-intensive, since the number of knot diagrams it visits may be exponential in the number of crossings, and it records every knot diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p >If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some knot diagram that is passed to it.</p>
<p >Since Regina 7.0, this routine will not return until the exploration of knot diagrams is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the enumeration to start in the background), simply call this routine in a new detached thread.</p>
<p >To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time); as a corollary, the action should avoid expensive operations where possible (otherwise it will become a serialisation bottleneck in the multithreading).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has precisely one component (i.e., it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty or has more than one component. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the arguments <em>tracker</em> and <em>args</em> are removed, so you simply call it as rewrite(height, threads, action). Moreover, <em>action</em> must take exactly two arguments (const std::string&amp;, <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>&amp;&amp;) representing the knot signature and the knot diagram, as described in option (b) above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this knot diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each knot diagram that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial knot argument(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="a078b8f0dd10461df6f5b535fb3991bce" name="a078b8f0dd10461df6f5b535fb3991bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078b8f0dd10461df6f5b535fb3991bce">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::rotate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this link diagram, converting it into a different diagram of the same link. </p>
<p >This routine keeps the sign of each crossing fixed, but switches the upper and lower strands. This operation corresponds to a 3-dimensional rotation about some axis in the plane. </p>

</div>
</div>
<a id="a20c2bc382ec2dd1d7717a21d5cdbe263" name="a20c2bc382ec2dd1d7717a21d5cdbe263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c2bc382ec2dd1d7717a21d5cdbe263">&#9670;&nbsp;</a></span>selfFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::selfFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds trivial twists to this link to ensure that each component has zero writhe. </p>
<p >Here the <em>writhe</em> of a component <em>c</em> is the sum of the signs of all crossings at which <em>c</em> crosses itself.</p>
<p >Any component(s) that already have zero writhe will be left unchanged.</p>
<p >This link will be modified directly. </p>

</div>
</div>
<a id="a60fe044c436e5e1a8861de2ccb106e1c" name="a60fe044c436e5e1a8861de2ccb106e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fe044c436e5e1a8861de2ccb106e1c">&#9670;&nbsp;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph. </p>
<p >This routine is more powerful but much slower than <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p >Unlike <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>, this routine <b>could potentially reflect or reverse the link</b>.</p>
<p >This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will throw an exception (as described below).</p>
<p >This routine will iterate through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number.</p>
<p >If at any stage it finds a diagram with <em>fewer</em> crossings than the original, then this routine will call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> to simplify the diagram further if possible and will then return <code>true</code>. If it cannot find a diagram with fewer crossings then it will leave this knot diagram unchanged and return <code>false</code>.</p>
<p >This routine can be very slow and very memory-intensive: the number of knot diagrams it visits may be exponential in the number of crossings, and it records every diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p >If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will not terminate until a simpler diagram is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p >If you want a <em>fast</em> simplification routine, you should call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> instead. The benefit of <a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is that, for very stubborn knot diagrams where <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> finds itself stuck at a local minimum, <a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p >Since Regina 7.0, this routine will not return until either the knot diagram is simplified or the exhaustive search is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the exhaustive search to start in the background), simply call this routine in a new detached thread.</p>
<p >To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either the diagram was simplified or the search was exhausted).</p>
<p >If this routine is unable to simplify the knot diagram, then this knot diagram will not be changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has at most one component (i.e., it is empty or it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link has more than one component. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this diagram was successfully simplified to fewer crossings. </dd></dl>

</div>
</div>
<a id="a3adf6c87c3dc80de018d659e686b48ef" name="a3adf6c87c3dc80de018d659e686b48ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adf6c87c3dc80de018d659e686b48ef">&#9670;&nbsp;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings. </p>
<p >End users will probably not want to call this routine. You should call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> if you want a fast (and usually effective) means of simplifying a link. If this link is a knot (i.e., it has precisely one component), then you can also call <a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p >Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine. Such moves do however feature in <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p >This routine will never reflect or reverse the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="a32c6f34794cc62574fcfca388f3f66d9" name="a32c6f34794cc62574fcfca388f3f66d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c6f34794cc62574fcfca388f3f66d9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of crossings in this link. </p>
<p >Note that a link can have more components than crossings (since it may contain additional zero-crossing unknot components).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aadb5338200b51df9d368711c7bf3954d" name="aadb5338200b51df9d368711c7bf3954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5338200b51df9d368711c7bf3954d">&#9670;&nbsp;</a></span>strand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::strand </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the strand in the link with the given integer ID. </p>
<p >Each strand ID is of the form 2<em>c</em>+<em>s</em>, where <em>c</em> is the index of the crossing, and <em>s</em> is 0 or 1 for the lower or upper strand respectively. A null strand reference (as used to indicate 0-crossing unknot components) has an ID of -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an integer between -1 and 2*size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the strand of this link with the corresponding ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1StrandRef.html#a2b631379159b6e14758a932d14d0a090" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> </dd></dl>

</div>
</div>
<a id="aeb48595553c44333292ad1948caed0ae" name="aeb48595553c44333292ad1948caed0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb48595553c44333292ad1948caed0ae">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given link. </p>
<p >All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link. Likewise, all cached properties (e.g., tree decompositions) will be swapped.</p>
<p >In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p >This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both links which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac540c07f819bf0c967867bf04463cafc" name="ac540c07f819bf0c967867bf04463cafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac540c07f819bf0c967867bf04463cafc">&#9670;&nbsp;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a link from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c" title="Reconstructs an object of type T from its given tight encoding.">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the link represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&nbsp;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>  <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ae31d64de793d9791c85f7ce04ae903f8" name="ae31d64de793d9791c85f7ce04ae903f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31d64de793d9791c85f7ce04ae903f8">&#9670;&nbsp;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this link to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d" title="Returns the tight encoding of this object.">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&nbsp;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function <a class="el" href="group__utilities.html#ga588cb4d07d97f9a53e86859e4e233aab" title="Writes the tight encoding of the given boolean to the given output stream.">T::tightEncode()</a>. See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="aa4d5e4637efe2ed81e2c9588aaa76591" name="aa4d5e4637efe2ed81e2c9588aaa76591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e4637efe2ed81e2c9588aaa76591">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference from some other link into the corresponding strand reference from this link. </p>
<p >Typically this routine would be used when the given strand comes from a link that is combinatorially identical to this, and you wish to obtain the corresponding strand in this link.</p>
<p >Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other link, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this link.</p>
<p >This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link contains at least as many crossings as the link containing <em>other</em> (though, as noted above, in typical scenarios both links would actually be combinatorially identical).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this link. </dd></dl>

</div>
</div>
<a id="a0e380e04a7b375d081aeafab5d05eb51" name="a0e380e04a7b375d081aeafab5d05eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e380e04a7b375d081aeafab5d05eb51">&#9670;&nbsp;</a></span>useTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::useTreeDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>&#160;</td>
          <td class="paramname"><em>td</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link. </p>
<p >For some link routines, including <a class="el" href="classregina_1_1Link.html#adf9867163e5b6defa9aa85d9bd8d9963" title="Returns a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.">niceTreeDecomposition()</a> as well as computations such as <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> that support the option ALG_TREEWIDTH, Regina needs a tree decomposition of the planar 4-valent multigraph formed by this link diagram.</p>
<p >By default, Regina will compute (and then cache) such a tree decomposition itself, using in-built greedy heuristics. This routine allows you to supply your <em>own</em> tree decomposition (which, for example, might be a smaller-width tree decomposition that you found using third-party software). By supplying your own tree decomposition <em>td</em> through this routine, Regina will throw away any pre-computed tree decomposition that it has cached, and will instead cache <em>td</em> for future use instead.</p>
<p >Regina may modify the given tree decomposition for its purposes. In particular, <em>td</em> does not need to be a <em>nice</em> tree decomposition (indeed, it does not need to have any special properties beyond the definition of a tree decomposition). Regina will automatically create a nice tree decomposition from it if <em>td</em> is not nice already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">td</td><td>a tree decomposition of the planar 4-valent multigraph formed by this link diagram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a8f682deb7aeb5c9e3b06c8db4aec3b92" name="a8f682deb7aeb5c9e3b06c8db4aec3b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f682deb7aeb5c9e3b06c8db4aec3b92">&#9670;&nbsp;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the underlying planar 4-valent multigraph using the PACE text format. </p>
<p >This text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a>, and is documented in detail by the routine <a class="el" href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying planar 4-valent multigraph, using the PACE text forma...">pace()</a>.</p>
<p >Calling <code>link.writePACE(out)</code> is equivalent to <code>out &lt;&lt; link.pace()</code>. However, this routine is more efficient.</p>
<p >See the <a class="el" href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying planar 4-valent multigraph, using the PACE text forma...">pace()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying planar 4-valent multigraph, using the PACE text forma...">pace()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a075bf4f759b540961ee47b1e5364b492" name="a075bf4f759b540961ee47b1e5364b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075bf4f759b540961ee47b1e5364b492">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a228ed6330752dc62de8a611075e05280" name="a228ed6330752dc62de8a611075e05280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228ed6330752dc62de8a611075e05280">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed6e5a318a8fdab39ebea49912074d19" name="aed6e5a318a8fdab39ebea49912074d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e5a318a8fdab39ebea49912074d19">&#9670;&nbsp;</a></span>writhe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writhe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the writhe of this link diagram. </p>
<p >This is <em>not</em> an invariant of the link; instead it depends on the particular link diagram. It is computed as the sum of the signs of all crossings. It is preserved under Reidemeister moves II and III, but not I.</p>
<dl class="section return"><dt>Returns</dt><dd>the writhe. </dd></dl>

</div>
</div>
<a id="aa8fe822e89589e9d9295299dd95d53e8" name="aa8fe822e89589e9d9295299dd95d53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fe822e89589e9d9295299dd95d53e8">&#9670;&nbsp;</a></span>writheOfComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writheOfComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the writhe of a single component of this link diagram. </p>
<p >This is the writhe of the diagram when all <em>other</em> components are removed. It is computed as the sum of the signs of all crossings at which the given component crosses itself.</p>
<p >In this version of <a class="el" href="classregina_1_1Link.html#a93a069ee95598f2e1f27ab15a9de07dc" title="Returns the writhe of a single component of this link diagram.">writheOfComponent()</a>, the component is indicated by its index. This function is equivalent to calling <code>writheOfComponent(component(index))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the writhe of the given component. </dd></dl>

</div>
</div>
<a id="a93a069ee95598f2e1f27ab15a9de07dc" name="a93a069ee95598f2e1f27ab15a9de07dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a069ee95598f2e1f27ab15a9de07dc">&#9670;&nbsp;</a></span>writheOfComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writheOfComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the writhe of a single component of this link diagram. </p>
<p >This is the writhe of the diagram when all <em>other</em> components are removed. It is computed as the sum of the signs of all crossings at which the given component crosses itself.</p>
<p >In this version of <a class="el" href="classregina_1_1Link.html#a93a069ee95598f2e1f27ab15a9de07dc" title="Returns the writhe of a single component of this link diagram.">writheOfComponent()</a>, the component is indicated by the argument <em>strand</em>, which may be any strand along the component. In particular, <em>strand</em> does not need to be the "starting strand" returned by <a class="el" href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f" title="Returns a strand in the given component of this link.">component()</a>.</p>
<p >The given strand may be a null strand, in which case the return value will be 0 (since Regina uses null strands to refer to zero-crossing unknot components). This is always allowed, regardless of whether the link actually contains any zero-crossing unknot components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>any strand along the component of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the writhe of the component containing the given strand, or 0 if the given strand is a null strand. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="ad65f761ba1c3d1badabc9638c27192db" name="ad65f761ba1c3d1badabc9638c27192db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f761ba1c3d1badabc9638c27192db">&#9670;&nbsp;</a></span>homflyAZVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyAZVarX = &quot;\u03B1&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p >This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p >Since <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the mathematical symbol <em>alpha</em> (encoded in UTF-8).</p>
<p >To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="a7acb282c9b668b106d63b5180e34f7f2" name="a7acb282c9b668b106d63b5180e34f7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acb282c9b668b106d63b5180e34f7f2">&#9670;&nbsp;</a></span>homflyAZVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyAZVarY = &quot;z&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p >This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p >Since <a class="el" href="classregina_1_1Link.html#a5ff8f1b5e4a911f2d104b2427d7b3e5f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the single character <em>z</em>.</p>
<p >To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="af9ce5812b285b56f767c8b3863c13b0c" name="af9ce5812b285b56f767c8b3863c13b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce5812b285b56f767c8b3863c13b0c">&#9670;&nbsp;</a></span>homflyLMVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyLMVarX = &quot;\U0001D4C1&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p >This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p >Since <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the mathematical script symbol for <em>l</em> (encoded in UTF-8).</p>
<p >To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="af73f30e80276f03658f7d733827631d3" name="af73f30e80276f03658f7d733827631d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73f30e80276f03658f7d733827631d3">&#9670;&nbsp;</a></span>homflyLMVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyLMVarY = &quot;m&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p >This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p >Since <a class="el" href="classregina_1_1Link.html#afb9a3da0fd25d5f0ccfe95a51462c5ef" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the single character <em>m</em>.</p>
<p >To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="a6b0447b2d9ec84403a4e07f09198c0d3" name="a6b0447b2d9ec84403a4e07f09198c0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0447b2d9ec84403a4e07f09198c0d3">&#9670;&nbsp;</a></span>homflyVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyVarX = <a class="el" href="classregina_1_1Link.html#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p >This is simply an alias for homflyAZVarX. See the documentation for homflyAZVarX for further details. </p>

</div>
</div>
<a id="ae3e77ac33d5598dac3aeca46abc71cde" name="ae3e77ac33d5598dac3aeca46abc71cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e77ac33d5598dac3aeca46abc71cde">&#9670;&nbsp;</a></span>homflyVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::homflyVarY = <a class="el" href="classregina_1_1Link.html#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p >This is simply an alias for homflyAZVarY. See the documentation for homflyAZVarY for further details. </p>

</div>
</div>
<a id="a365f08df3a98992ccc0c2c22f23958c6" name="a365f08df3a98992ccc0c2c22f23958c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365f08df3a98992ccc0c2c22f23958c6">&#9670;&nbsp;</a></span>jonesVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* regina::Link::jonesVar = &quot;\u221At&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Jones polynomial, as returned by <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>. </p>
<p >This is provided to help with pretty-printing Jones polynomials for human consumption.</p>
<p >Since <a class="el" href="classregina_1_1Link.html#a0f95c8720f9fced7843664aef522116f" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>, this string is just a human-readable representation of the square root of <em>t</em> (encoded in UTF-8).</p>
<p >To pretty-print the Jones polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
