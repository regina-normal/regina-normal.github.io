<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::detail::TriangulationBase&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="namespaceregina_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1detail_1_1TriangulationBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::detail::TriangulationBase&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__detail.html">Implementation details</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Provides core functionality for <em>dim</em>-dimensional triangulations.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/detail/triangulation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::detail::TriangulationBase&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1detail_1_1TriangulationBase.png" usemap="#regina::detail::TriangulationBase_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::detail::TriangulationBase_3C_20dim_20_3E_map" name="regina::detail::TriangulationBase_3C_20dim_20_3E_map">
<area href="classregina_1_1Snapshottable.html" alt="regina::Snapshottable&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="0,0,281,24"/>
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="291,0,572,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="582,0,863,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Triangulation&lt; dim &gt; &gt;" shape="rect" coords="873,0,1154,24"/>
<area href="classregina_1_1TopologyLockable.html" title="A base class for objects that support topology locks, such as triangulations or links." alt="regina::TopologyLockable" shape="rect" coords="1164,0,1445,24"/>
<area href="classregina_1_1Triangulation.html" alt="regina::Triangulation&lt; dim-1 &gt;" shape="rect" coords="436,112,717,136"/>
<area href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-..." alt="regina::Triangulation&lt; dim &gt;" shape="rect" coords="727,112,1008,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase_1_1ChangeAndClearSpan.html">ChangeAndClearSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that facilitates taking snapshots, firing change events, and calling clearAllProperties().  <a href="classregina_1_1detail_1_1TriangulationBase_1_1ChangeAndClearSpan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d10f79dd6c4de1c8b90b77ab0953d9c" id="r_a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a0d10f79dd6c4de1c8b90b77ab0953d9c">PacketChangeGroup</a></td></tr>
<tr class="memdesc:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.  <br /></td></tr>
<tr class="separator:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9a076c6b4eb0edc40694aedaf5bd3c4" id="r_ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#ae9a076c6b4eb0edc40694aedaf5bd3c4">isReadOnlySnapshot</a> () const</td></tr>
<tr class="memdesc:ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this object is a read-only deep copy that was created by a snapshot.  <br /></td></tr>
<tr class="separator:ae9a076c6b4eb0edc40694aedaf5bd3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247" id="r_ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88" id="r_a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1" id="r_ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51197dbd112bb60b7893cc51a09003" id="r_a2c51197dbd112bb60b7893cc51a09003"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a2c51197dbd112bb60b7893cc51a09003">hash</a> () const</td></tr>
<tr class="memdesc:a2c51197dbd112bb60b7893cc51a09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:a2c51197dbd112bb60b7893cc51a09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:aaa79cc9e7f5b4f6ea27045ebf3c8fabc" id="r_aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">TriangulationBase</a> ()</td></tr>
<tr class="memdesc:aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7c30e319925152d112df42cb225dd4" id="r_aea7c30e319925152d112df42cb225dd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea7c30e319925152d112df42cb225dd4">TriangulationBase</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;src)</td></tr>
<tr class="memdesc:aea7c30e319925152d112df42cb225dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation.  <br /></td></tr>
<tr class="separator:aea7c30e319925152d112df42cb225dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641595fc60bdd54117af630c9b5a6e0b" id="r_a641595fc60bdd54117af630c9b5a6e0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a641595fc60bdd54117af630c9b5a6e0b">TriangulationBase</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;src, bool cloneProps, bool cloneLocks)</td></tr>
<tr class="memdesc:a641595fc60bdd54117af630c9b5a6e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties and/or locks also.  <br /></td></tr>
<tr class="separator:a641595fc60bdd54117af630c9b5a6e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f506c035852c5df99ef37167a9a881" id="r_af0f506c035852c5df99ef37167a9a881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0f506c035852c5df99ef37167a9a881">TriangulationBase</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:af0f506c035852c5df99ef37167a9a881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given triangulation into this new triangulation.  <br /></td></tr>
<tr class="separator:af0f506c035852c5df99ef37167a9a881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace45d0a52d9a2a853f890d1006fedf7c" id="r_ace45d0a52d9a2a853f890d1006fedf7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace45d0a52d9a2a853f890d1006fedf7c">~TriangulationBase</a> ()</td></tr>
<tr class="memdesc:ace45d0a52d9a2a853f890d1006fedf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <br /></td></tr>
<tr class="separator:ace45d0a52d9a2a853f890d1006fedf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simplices</div></td></tr>
<tr class="memitem:a3871caa1f02ccda957f22ebd9a646ff5" id="r_a3871caa1f02ccda957f22ebd9a646ff5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5">size</a> () const</td></tr>
<tr class="memdesc:a3871caa1f02ccda957f22ebd9a646ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of top-dimensional simplices in the triangulation.  <br /></td></tr>
<tr class="separator:a3871caa1f02ccda957f22ebd9a646ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a7d5c459569dbf66147b62f695c2d" id="r_a7d7a7d5c459569dbf66147b62f695c2d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d">simplices</a> () const</td></tr>
<tr class="memdesc:a7d7a7d5c459569dbf66147b62f695c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all top-dimensional simplices in this triangulation.  <br /></td></tr>
<tr class="separator:a7d7a7d5c459569dbf66147b62f695c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e269a7332e80aeec3603881fd175d3" id="r_ae2e269a7332e80aeec3603881fd175d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e269a7332e80aeec3603881fd175d3">simplex</a> (size_t index)</td></tr>
<tr class="memdesc:ae2e269a7332e80aeec3603881fd175d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <br /></td></tr>
<tr class="separator:ae2e269a7332e80aeec3603881fd175d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdadce4ea703518064241597cf1514b" id="r_a7cdadce4ea703518064241597cf1514b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cdadce4ea703518064241597cf1514b">simplex</a> (size_t index) const</td></tr>
<tr class="memdesc:a7cdadce4ea703518064241597cf1514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <br /></td></tr>
<tr class="separator:a7cdadce4ea703518064241597cf1514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107a418e2691dc5ad7bb9e90dcba437" id="r_ad107a418e2691dc5ad7bb9e90dcba437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437">newSimplex</a> ()</td></tr>
<tr class="memdesc:ad107a418e2691dc5ad7bb9e90dcba437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex and adds it to this triangulation.  <br /></td></tr>
<tr class="separator:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e0403df58ea41ee87cfeb3e111845e" id="r_a80e0403df58ea41ee87cfeb3e111845e"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a80e0403df58ea41ee87cfeb3e111845e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *, k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e">newSimplices</a> ()</td></tr>
<tr class="memdesc:a80e0403df58ea41ee87cfeb3e111845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <em>k</em> new top-dimensional simplices, adds them to this triangulation, and returns them in a std::array.  <br /></td></tr>
<tr class="separator:a80e0403df58ea41ee87cfeb3e111845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911cdc0a8942418d4e257a81ce24a110" id="r_a911cdc0a8942418d4e257a81ce24a110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a911cdc0a8942418d4e257a81ce24a110">newSimplices</a> (size_t k)</td></tr>
<tr class="memdesc:a911cdc0a8942418d4e257a81ce24a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <em>k</em> new top-dimensional simplices and adds them to this triangulation.  <br /></td></tr>
<tr class="separator:a911cdc0a8942418d4e257a81ce24a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829224a264241e43a8f2bbdf5bfcb253" id="r_a829224a264241e43a8f2bbdf5bfcb253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a829224a264241e43a8f2bbdf5bfcb253">newSimplex</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a829224a264241e43a8f2bbdf5bfcb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex with the given description and adds it to this triangulation.  <br /></td></tr>
<tr class="separator:a829224a264241e43a8f2bbdf5bfcb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b349c4e1fb4b27a9b20ed53b277a7ba" id="r_a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b349c4e1fb4b27a9b20ed53b277a7ba">removeSimplex</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *<a class="el" href="#ae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given top-dimensional simplex from this triangulation.  <br /></td></tr>
<tr class="separator:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f36b004ba6af3d6ce11bdb655650ec" id="r_ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9f36b004ba6af3d6ce11bdb655650ec">removeSimplexAt</a> (size_t index)</td></tr>
<tr class="memdesc:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-dimensional simplex at the given index in this triangulation.  <br /></td></tr>
<tr class="separator:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91a640743f9ce2710d17eda77d520a" id="r_a3e91a640743f9ce2710d17eda77d520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e91a640743f9ce2710d17eda77d520a">removeAllSimplices</a> ()</td></tr>
<tr class="memdesc:a3e91a640743f9ce2710d17eda77d520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simplices from the triangulation.  <br /></td></tr>
<tr class="separator:a3e91a640743f9ce2710d17eda77d520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa3daf9672da64a0fa8a82a439d65b" id="r_ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3fa3daf9672da64a0fa8a82a439d65b">moveContentsTo</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this triangulation into the given destination triangulation, leaving this triangulation empty but otherwise usable.  <br /></td></tr>
<tr class="separator:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a47a823d15f016cd0efeb9d1b1644" id="r_ac40a47a823d15f016cd0efeb9d1b1644"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac40a47a823d15f016cd0efeb9d1b1644">hasLocks</a> () const</td></tr>
<tr class="memdesc:ac40a47a823d15f016cd0efeb9d1b1644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether any top-dimensional simplices and/or any of their facets are locked.  <br /></td></tr>
<tr class="separator:ac40a47a823d15f016cd0efeb9d1b1644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b54eef1e8fbbc831ebbef998c663b2" id="r_ab6b54eef1e8fbbc831ebbef998c663b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6b54eef1e8fbbc831ebbef998c663b2">lockBoundary</a> ()</td></tr>
<tr class="memdesc:ab6b54eef1e8fbbc831ebbef998c663b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks all boundary facets of this triangulation.  <br /></td></tr>
<tr class="separator:ab6b54eef1e8fbbc831ebbef998c663b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66330cee32127dad0c2ac14874acd71" id="r_ac66330cee32127dad0c2ac14874acd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66330cee32127dad0c2ac14874acd71">unlockAll</a> ()</td></tr>
<tr class="memdesc:ac66330cee32127dad0c2ac14874acd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks all top-dimensional simplices and their facets.  <br /></td></tr>
<tr class="separator:ac66330cee32127dad0c2ac14874acd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Queries</div></td></tr>
<tr class="memitem:a20e5dba7654710e79eecaf849f248d38" id="r_a20e5dba7654710e79eecaf849f248d38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e5dba7654710e79eecaf849f248d38">countComponents</a> () const</td></tr>
<tr class="memdesc:a20e5dba7654710e79eecaf849f248d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in this triangulation.  <br /></td></tr>
<tr class="separator:a20e5dba7654710e79eecaf849f248d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658bf830fdf052e1beaa5423298c51b2" id="r_a658bf830fdf052e1beaa5423298c51b2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658bf830fdf052e1beaa5423298c51b2">countBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:a658bf830fdf052e1beaa5423298c51b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary components in this triangulation.  <br /></td></tr>
<tr class="separator:a658bf830fdf052e1beaa5423298c51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d32300a09aa008d03099e4b84e873" id="r_a929d32300a09aa008d03099e4b84e873"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a929d32300a09aa008d03099e4b84e873"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a929d32300a09aa008d03099e4b84e873">countFaces</a> () const</td></tr>
<tr class="memdesc:a929d32300a09aa008d03099e4b84e873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this triangulation.  <br /></td></tr>
<tr class="separator:a929d32300a09aa008d03099e4b84e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51bc921de7b1971061a1a2353f9ad96" id="r_ad51bc921de7b1971061a1a2353f9ad96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad51bc921de7b1971061a1a2353f9ad96">countFaces</a> (int subdim) const</td></tr>
<tr class="memdesc:ad51bc921de7b1971061a1a2353f9ad96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:ad51bc921de7b1971061a1a2353f9ad96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4978fb0aeb2d208806404431e445a567" id="r_a4978fb0aeb2d208806404431e445a567"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4978fb0aeb2d208806404431e445a567">countVertices</a> () const</td></tr>
<tr class="memdesc:a4978fb0aeb2d208806404431e445a567"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;0&gt;()</a>.  <br /></td></tr>
<tr class="separator:a4978fb0aeb2d208806404431e445a567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf438f54b1ccec5a42916b00132ed2f" id="r_addf438f54b1ccec5a42916b00132ed2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addf438f54b1ccec5a42916b00132ed2f">countEdges</a> () const</td></tr>
<tr class="memdesc:addf438f54b1ccec5a42916b00132ed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;1&gt;()</a>.  <br /></td></tr>
<tr class="separator:addf438f54b1ccec5a42916b00132ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1fb3c66e81c2d533e1fac79439126" id="r_a0ff1fb3c66e81c2d533e1fac79439126"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff1fb3c66e81c2d533e1fac79439126">countTriangles</a> () const</td></tr>
<tr class="memdesc:a0ff1fb3c66e81c2d533e1fac79439126"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;2&gt;()</a>.  <br /></td></tr>
<tr class="separator:a0ff1fb3c66e81c2d533e1fac79439126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4329504df39fb7dbf796600329146d" id="r_a2e4329504df39fb7dbf796600329146d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4329504df39fb7dbf796600329146d">countTetrahedra</a> () const</td></tr>
<tr class="memdesc:a2e4329504df39fb7dbf796600329146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;3&gt;()</a>.  <br /></td></tr>
<tr class="separator:a2e4329504df39fb7dbf796600329146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f6885850adfdf4c8c278dd241f5f90" id="r_a10f6885850adfdf4c8c278dd241f5f90"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f6885850adfdf4c8c278dd241f5f90">countPentachora</a> () const</td></tr>
<tr class="memdesc:a10f6885850adfdf4c8c278dd241f5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;4&gt;()</a>.  <br /></td></tr>
<tr class="separator:a10f6885850adfdf4c8c278dd241f5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c48ed1736e27aa09620cd924507ef4" id="r_ad5c48ed1736e27aa09620cd924507ef4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5c48ed1736e27aa09620cd924507ef4">fVector</a> () const</td></tr>
<tr class="memdesc:ad5c48ed1736e27aa09620cd924507ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the f-vector of this triangulation, which counts the number of faces of all dimensions.  <br /></td></tr>
<tr class="separator:ad5c48ed1736e27aa09620cd924507ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9f1a9b278dd911add0d10351e8089d" id="r_aca9f1a9b278dd911add0d10351e8089d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca9f1a9b278dd911add0d10351e8089d">components</a> () const</td></tr>
<tr class="memdesc:aca9f1a9b278dd911add0d10351e8089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all components of this triangulation.  <br /></td></tr>
<tr class="separator:aca9f1a9b278dd911add0d10351e8089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76267c6a893785e1fe396e5b439806" id="r_a2b76267c6a893785e1fe396e5b439806"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b76267c6a893785e1fe396e5b439806">boundaryComponents</a> () const</td></tr>
<tr class="memdesc:a2b76267c6a893785e1fe396e5b439806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all boundary components of this triangulation.  <br /></td></tr>
<tr class="separator:a2b76267c6a893785e1fe396e5b439806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a59c70ef42fd731d7167df4973f389" id="r_ac4a59c70ef42fd731d7167df4973f389"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ac4a59c70ef42fd731d7167df4973f389"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4a59c70ef42fd731d7167df4973f389">faces</a> () const</td></tr>
<tr class="memdesc:ac4a59c70ef42fd731d7167df4973f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for C++ programmers.  <br /></td></tr>
<tr class="separator:ac4a59c70ef42fd731d7167df4973f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0813f17eb6b6c91802b73403a5258d6" id="r_ae0813f17eb6b6c91802b73403a5258d6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0813f17eb6b6c91802b73403a5258d6">faces</a> (int subdim) const</td></tr>
<tr class="memdesc:ae0813f17eb6b6c91802b73403a5258d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for Python programmers.  <br /></td></tr>
<tr class="separator:ae0813f17eb6b6c91802b73403a5258d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ec5cdb434c3119eb68ce0deae76c8" id="r_ad44ec5cdb434c3119eb68ce0deae76c8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad44ec5cdb434c3119eb68ce0deae76c8">vertices</a> () const</td></tr>
<tr class="memdesc:ad44ec5cdb434c3119eb68ce0deae76c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;0&gt;()</a>.  <br /></td></tr>
<tr class="separator:ad44ec5cdb434c3119eb68ce0deae76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935e2e6267aab03599c1eeacee2dc78" id="r_ae935e2e6267aab03599c1eeacee2dc78"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae935e2e6267aab03599c1eeacee2dc78">edges</a> () const</td></tr>
<tr class="memdesc:ae935e2e6267aab03599c1eeacee2dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;1&gt;()</a>.  <br /></td></tr>
<tr class="separator:ae935e2e6267aab03599c1eeacee2dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce900ea2eb29bfac1b9c93ca78f9ea3" id="r_acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acce900ea2eb29bfac1b9c93ca78f9ea3">triangles</a> () const</td></tr>
<tr class="memdesc:acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;2&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 2.  <br /></td></tr>
<tr class="separator:acce900ea2eb29bfac1b9c93ca78f9ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff42c3c6b43c59759b08be17d7e269" id="r_a93ff42c3c6b43c59759b08be17d7e269"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93ff42c3c6b43c59759b08be17d7e269">tetrahedra</a> () const</td></tr>
<tr class="memdesc:a93ff42c3c6b43c59759b08be17d7e269"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;3&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 3.  <br /></td></tr>
<tr class="separator:a93ff42c3c6b43c59759b08be17d7e269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c5adb83f7790b90bb1a63ec960a4a" id="r_ab87c5adb83f7790b90bb1a63ec960a4a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87c5adb83f7790b90bb1a63ec960a4a">pentachora</a> () const</td></tr>
<tr class="memdesc:ab87c5adb83f7790b90bb1a63ec960a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;4&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 4.  <br /></td></tr>
<tr class="separator:ab87c5adb83f7790b90bb1a63ec960a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd435c05fdb9ad2ce0229c08965e87d" id="r_a4dd435c05fdb9ad2ce0229c08965e87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dd435c05fdb9ad2ce0229c08965e87d">component</a> (size_t index) const</td></tr>
<tr class="memdesc:a4dd435c05fdb9ad2ce0229c08965e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested connected component of this triangulation.  <br /></td></tr>
<tr class="separator:a4dd435c05fdb9ad2ce0229c08965e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6eee4278d413b28cc3519ea07d90d0" id="r_aef6eee4278d413b28cc3519ea07d90d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef6eee4278d413b28cc3519ea07d90d0">boundaryComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:aef6eee4278d413b28cc3519ea07d90d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested boundary component of this triangulation.  <br /></td></tr>
<tr class="separator:aef6eee4278d413b28cc3519ea07d90d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ea1cdd46af32418fb76c49712ccb8" id="r_a802ea1cdd46af32418fb76c49712ccb8"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a802ea1cdd46af32418fb76c49712ccb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8">face</a> (size_t index) const</td></tr>
<tr class="memdesc:a802ea1cdd46af32418fb76c49712ccb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for C++ programmers.  <br /></td></tr>
<tr class="separator:a802ea1cdd46af32418fb76c49712ccb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4df33248af1794170e1ca76cd59256" id="r_a4c4df33248af1794170e1ca76cd59256"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4df33248af1794170e1ca76cd59256">face</a> (int subdim, size_t index) const</td></tr>
<tr class="memdesc:a4c4df33248af1794170e1ca76cd59256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for Python programmers.  <br /></td></tr>
<tr class="separator:a4c4df33248af1794170e1ca76cd59256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b86e0d3a00fa5da038c6cce117b343f" id="r_a9b86e0d3a00fa5da038c6cce117b343f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b86e0d3a00fa5da038c6cce117b343f">vertex</a> (size_t index) const</td></tr>
<tr class="memdesc:a9b86e0d3a00fa5da038c6cce117b343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;0&gt;()</a>.  <br /></td></tr>
<tr class="separator:a9b86e0d3a00fa5da038c6cce117b343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e675a24773baa6ddca79a6ae7e2899" id="r_a25e675a24773baa6ddca79a6ae7e2899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e675a24773baa6ddca79a6ae7e2899">edge</a> (size_t index) const</td></tr>
<tr class="memdesc:a25e675a24773baa6ddca79a6ae7e2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;1&gt;()</a>.  <br /></td></tr>
<tr class="separator:a25e675a24773baa6ddca79a6ae7e2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d82c1572359a3075cfe47d2916e1f8" id="r_a19d82c1572359a3075cfe47d2916e1f8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d82c1572359a3075cfe47d2916e1f8">triangle</a> (size_t index)</td></tr>
<tr class="memdesc:a19d82c1572359a3075cfe47d2916e1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2.  <br /></td></tr>
<tr class="separator:a19d82c1572359a3075cfe47d2916e1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7536b6eef07a72d344053560d06594" id="r_a5c7536b6eef07a72d344053560d06594"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c7536b6eef07a72d344053560d06594">triangle</a> (size_t index) const</td></tr>
<tr class="memdesc:a5c7536b6eef07a72d344053560d06594"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2.  <br /></td></tr>
<tr class="separator:a5c7536b6eef07a72d344053560d06594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cfbc6303920dc017eaf102d272ba4e" id="r_ad2cfbc6303920dc017eaf102d272ba4e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2cfbc6303920dc017eaf102d272ba4e">tetrahedron</a> (size_t index)</td></tr>
<tr class="memdesc:ad2cfbc6303920dc017eaf102d272ba4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3.  <br /></td></tr>
<tr class="separator:ad2cfbc6303920dc017eaf102d272ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2272099afa80eff2b1aed22237df0147" id="r_a2272099afa80eff2b1aed22237df0147"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2272099afa80eff2b1aed22237df0147">tetrahedron</a> (size_t index) const</td></tr>
<tr class="memdesc:a2272099afa80eff2b1aed22237df0147"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3.  <br /></td></tr>
<tr class="separator:a2272099afa80eff2b1aed22237df0147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa44d0c8bd040dd76885df3743803a49" id="r_afa44d0c8bd040dd76885df3743803a49"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa44d0c8bd040dd76885df3743803a49">pentachoron</a> (size_t index)</td></tr>
<tr class="memdesc:afa44d0c8bd040dd76885df3743803a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4.  <br /></td></tr>
<tr class="separator:afa44d0c8bd040dd76885df3743803a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4af8fb72bfe82006ab8997ce0bccd" id="r_ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8b4af8fb72bfe82006ab8997ce0bccd">pentachoron</a> (size_t index) const</td></tr>
<tr class="memdesc:ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4.  <br /></td></tr>
<tr class="separator:ac8b4af8fb72bfe82006ab8997ce0bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a1bdc2c2e643c8c424cd31f557207" id="r_a2a9a1bdc2c2e643c8c424cd31f557207"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a9a1bdc2c2e643c8c424cd31f557207">translate</a> (const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *other) const</td></tr>
<tr class="memdesc:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a face of some other triangulation into the corresponding face of this triangulation, using simplex numbers for the translation.  <br /></td></tr>
<tr class="separator:a2a9a1bdc2c2e643c8c424cd31f557207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b0522d4a3195257f4d5409253b524a" id="r_a52b0522d4a3195257f4d5409253b524a"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a52b0522d4a3195257f4d5409253b524a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, subdim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52b0522d4a3195257f4d5409253b524a">translate</a> (const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a52b0522d4a3195257f4d5409253b524a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a face embedding from some other triangulation into the corresponding face embedding with respect to this triangulation, using simplex numbers for the translation.  <br /></td></tr>
<tr class="separator:a52b0522d4a3195257f4d5409253b524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839950f320f6f0ca655e7a880a66c2ee" id="r_a839950f320f6f0ca655e7a880a66c2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a839950f320f6f0ca655e7a880a66c2ee">pairing</a> () const</td></tr>
<tr class="memdesc:a839950f320f6f0ca655e7a880a66c2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dual graph of this triangulation, expressed as a facet pairing.  <br /></td></tr>
<tr class="separator:a839950f320f6f0ca655e7a880a66c2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:a6b111a8470576f19f950a2347ff9f3f5" id="r_a6b111a8470576f19f950a2347ff9f3f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b111a8470576f19f950a2347ff9f3f5">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6b111a8470576f19f950a2347ff9f3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is empty.  <br /></td></tr>
<tr class="separator:a6b111a8470576f19f950a2347ff9f3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cf08805f1b496f644e75c1a0b34dde" id="r_ab6cf08805f1b496f644e75c1a0b34dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde">isValid</a> () const</td></tr>
<tr class="memdesc:ab6cf08805f1b496f644e75c1a0b34dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is valid.  <br /></td></tr>
<tr class="separator:ab6cf08805f1b496f644e75c1a0b34dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffca92f7a401c3beb7a603d997a088e" id="r_a5ffca92f7a401c3beb7a603d997a088e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ffca92f7a401c3beb7a603d997a088e">hasBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a5ffca92f7a401c3beb7a603d997a088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation has any boundary facets.  <br /></td></tr>
<tr class="separator:a5ffca92f7a401c3beb7a603d997a088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a05fe022a95b928a068f9909b036c" id="r_a8c1a05fe022a95b928a068f9909b036c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c1a05fe022a95b928a068f9909b036c">countBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a8c1a05fe022a95b928a068f9909b036c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of boundary facets in this triangulation.  <br /></td></tr>
<tr class="separator:a8c1a05fe022a95b928a068f9909b036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cea5a70cdc8bf81306e413b69a472c" id="r_a38cea5a70cdc8bf81306e413b69a472c"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a38cea5a70cdc8bf81306e413b69a472c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38cea5a70cdc8bf81306e413b69a472c">countBoundaryFaces</a> () const</td></tr>
<tr class="memdesc:a38cea5a70cdc8bf81306e413b69a472c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary <em>subdim</em>-faces in this triangulation.  <br /></td></tr>
<tr class="separator:a38cea5a70cdc8bf81306e413b69a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0734a644b899ff1ff8f58554547452" id="r_a7a0734a644b899ff1ff8f58554547452"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a0734a644b899ff1ff8f58554547452">countBoundaryFaces</a> (int subdim) const</td></tr>
<tr class="memdesc:a7a0734a644b899ff1ff8f58554547452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:a7a0734a644b899ff1ff8f58554547452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223875697502990070b0e7587f63ce7" id="r_a6223875697502990070b0e7587f63ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6223875697502990070b0e7587f63ce7">isOrientable</a> () const</td></tr>
<tr class="memdesc:a6223875697502990070b0e7587f63ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is orientable.  <br /></td></tr>
<tr class="separator:a6223875697502990070b0e7587f63ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576e6c66cfbb7fabd21cc782c38f300d" id="r_a576e6c66cfbb7fabd21cc782c38f300d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576e6c66cfbb7fabd21cc782c38f300d">isConnected</a> () const</td></tr>
<tr class="memdesc:a576e6c66cfbb7fabd21cc782c38f300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is connected.  <br /></td></tr>
<tr class="separator:a576e6c66cfbb7fabd21cc782c38f300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab712e58bba1242110e49b2fac979e98f" id="r_ab712e58bba1242110e49b2fac979e98f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab712e58bba1242110e49b2fac979e98f">isOriented</a> () const</td></tr>
<tr class="memdesc:ab712e58bba1242110e49b2fac979e98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets.  <br /></td></tr>
<tr class="separator:ab712e58bba1242110e49b2fac979e98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063bd8d3c1ff8d896ae0a24db2203d5" id="r_a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8063bd8d3c1ff8d896ae0a24db2203d5">eulerCharTri</a> () const</td></tr>
<tr class="memdesc:a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euler characteristic of this triangulation.  <br /></td></tr>
<tr class="separator:a8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Properties</div></td></tr>
<tr class="memitem:a419c0f6e468ad24cfc450775c6a19b81" id="r_a419c0f6e468ad24cfc450775c6a19b81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81">group</a> () const</td></tr>
<tr class="memdesc:a419c0f6e468ad24cfc450775c6a19b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fundamental group of this triangulation.  <br /></td></tr>
<tr class="separator:a419c0f6e468ad24cfc450775c6a19b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408718df2c6cc65f21adabc50850ec63" id="r_a408718df2c6cc65f21adabc50850ec63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a408718df2c6cc65f21adabc50850ec63">fundamentalGroup</a> () const</td></tr>
<tr class="memdesc:a408718df2c6cc65f21adabc50850ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>, which returns the fundamental group of this triangulation.  <br /></td></tr>
<tr class="separator:a408718df2c6cc65f21adabc50850ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb2d416c0af527bf91b2b5f2128ed83" id="r_abcb2d416c0af527bf91b2b5f2128ed83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb2d416c0af527bf91b2b5f2128ed83">setGroupPresentation</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> pres)</td></tr>
<tr class="memdesc:abcb2d416c0af527bf91b2b5f2128ed83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the specific presentation of the fundamental group to be changed by some other (external) means.  <br /></td></tr>
<tr class="separator:abcb2d416c0af527bf91b2b5f2128ed83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa0e8cb1b4938a51deaedeea236dc56" id="r_a7fa0e8cb1b4938a51deaedeea236dc56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa0e8cb1b4938a51deaedeea236dc56">simplifiedFundamentalGroup</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> pres)</td></tr>
<tr class="memdesc:a7fa0e8cb1b4938a51deaedeea236dc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="#abcb2d416c0af527bf91b2b5f2128ed83" title="Allows the specific presentation of the fundamental group to be changed by some other (external) mean...">setGroupPresentation()</a>, which allows the specific presentation of the fundamental group to be changed by some other (external) means.  <br /></td></tr>
<tr class="separator:a7fa0e8cb1b4938a51deaedeea236dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a72bfac6207c6ac044d98cd6ec2081" id="r_a34a72bfac6207c6ac044d98cd6ec2081"><td class="memTemplParams" colspan="2">template&lt;int k = 1&gt; </td></tr>
<tr class="memitem:a34a72bfac6207c6ac044d98cd6ec2081"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34a72bfac6207c6ac044d98cd6ec2081">homology</a> () const</td></tr>
<tr class="memdesc:a34a72bfac6207c6ac044d98cd6ec2081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated.  <br /></td></tr>
<tr class="separator:a34a72bfac6207c6ac044d98cd6ec2081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb67028a0ade026c03ffdc4665f2871" id="r_adbb67028a0ade026c03ffdc4665f2871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb67028a0ade026c03ffdc4665f2871">homology</a> (int k) const</td></tr>
<tr class="memdesc:adbb67028a0ade026c03ffdc4665f2871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated, where the parameter <em>k</em> does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:adbb67028a0ade026c03ffdc4665f2871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6dde5a1cad6b5a763af7ee662eba28" id="r_ada6dde5a1cad6b5a763af7ee662eba28"><td class="memTemplParams" colspan="2">template&lt;int k = 1&gt; </td></tr>
<tr class="memitem:ada6dde5a1cad6b5a763af7ee662eba28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada6dde5a1cad6b5a763af7ee662eba28">markedHomology</a> () const</td></tr>
<tr class="memdesc:ada6dde5a1cad6b5a763af7ee662eba28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation.  <br /></td></tr>
<tr class="separator:ada6dde5a1cad6b5a763af7ee662eba28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9273c04a7cf7c89831bce0aa12da15" id="r_adb9273c04a7cf7c89831bce0aa12da15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb9273c04a7cf7c89831bce0aa12da15">markedHomology</a> (int k) const</td></tr>
<tr class="memdesc:adb9273c04a7cf7c89831bce0aa12da15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation, where the parameter <em>k</em> does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:adb9273c04a7cf7c89831bce0aa12da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfa4594ab1ba473360ff7b91750f49a" id="r_abdfa4594ab1ba473360ff7b91750f49a"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:abdfa4594ab1ba473360ff7b91750f49a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdfa4594ab1ba473360ff7b91750f49a">boundaryMap</a> () const</td></tr>
<tr class="memdesc:abdfa4594ab1ba473360ff7b91750f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation.  <br /></td></tr>
<tr class="separator:abdfa4594ab1ba473360ff7b91750f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200793f011759542228bbe3c44f3df85" id="r_a200793f011759542228bbe3c44f3df85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a200793f011759542228bbe3c44f3df85">boundaryMap</a> (int subdim) const</td></tr>
<tr class="memdesc:a200793f011759542228bbe3c44f3df85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:a200793f011759542228bbe3c44f3df85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9418f87d687dd5e488b972a5ff7992a" id="r_ae9418f87d687dd5e488b972a5ff7992a"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ae9418f87d687dd5e488b972a5ff7992a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9418f87d687dd5e488b972a5ff7992a">dualBoundaryMap</a> () const</td></tr>
<tr class="memdesc:ae9418f87d687dd5e488b972a5ff7992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation.  <br /></td></tr>
<tr class="separator:ae9418f87d687dd5e488b972a5ff7992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346459be4eb9fbb487340a7d3441e1ef" id="r_a346459be4eb9fbb487340a7d3441e1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a346459be4eb9fbb487340a7d3441e1ef">dualBoundaryMap</a> (int subdim) const</td></tr>
<tr class="memdesc:a346459be4eb9fbb487340a7d3441e1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:a346459be4eb9fbb487340a7d3441e1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61a040faab0610d2dbfc515c94abb04" id="r_ae61a040faab0610d2dbfc515c94abb04"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ae61a040faab0610d2dbfc515c94abb04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae61a040faab0610d2dbfc515c94abb04">dualToPrimal</a> () const</td></tr>
<tr class="memdesc:ae61a040faab0610d2dbfc515c94abb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from dual chains to primal chains that preserves homology classes.  <br /></td></tr>
<tr class="separator:ae61a040faab0610d2dbfc515c94abb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2f61c320f8f9da4ea89715f3c2873" id="r_aaef2f61c320f8f9da4ea89715f3c2873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaef2f61c320f8f9da4ea89715f3c2873">dualToPrimal</a> (int subdim) const</td></tr>
<tr class="memdesc:aaef2f61c320f8f9da4ea89715f3c2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from dual chains to primal chains that preserves homology classes, where the chain dimension does not need to be known until runtime.  <br /></td></tr>
<tr class="separator:aaef2f61c320f8f9da4ea89715f3c2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:a2711fd7c7115ce19b6833f0d61c42bec" id="r_a2711fd7c7115ce19b6833f0d61c42bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2711fd7c7115ce19b6833f0d61c42bec">orient</a> ()</td></tr>
<tr class="memdesc:a2711fd7c7115ce19b6833f0d61c42bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible.  <br /></td></tr>
<tr class="separator:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5583fe8731e5186eac30bb7dfeafa6" id="r_a3f5583fe8731e5186eac30bb7dfeafa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5583fe8731e5186eac30bb7dfeafa6">reflect</a> ()</td></tr>
<tr class="memdesc:a3f5583fe8731e5186eac30bb7dfeafa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation.  <br /></td></tr>
<tr class="separator:a3f5583fe8731e5186eac30bb7dfeafa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1863936f9553bd33901d5fe7d71e2856" id="r_a1863936f9553bd33901d5fe7d71e2856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1863936f9553bd33901d5fe7d71e2856">reorderBFS</a> (bool reverse=false)</td></tr>
<tr class="memdesc:a1863936f9553bd33901d5fe7d71e2856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the top-dimensional simplices of this triangulation using a breadth-first search, so that small-numbered simplices are adjacent to other small-numbered simplices.  <br /></td></tr>
<tr class="separator:a1863936f9553bd33901d5fe7d71e2856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223828de2d256717b5f000da08c9222" id="r_a1223828de2d256717b5f000da08c9222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1223828de2d256717b5f000da08c9222">randomiseLabelling</a> (bool preserveOrientation=true)</td></tr>
<tr class="memdesc:a1223828de2d256717b5f000da08c9222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly relabels the top-dimensional simplices and their vertices.  <br /></td></tr>
<tr class="separator:a1223828de2d256717b5f000da08c9222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1e72e8b2ac09786a36bc0c97aa16aa" id="r_a9b1e72e8b2ac09786a36bc0c97aa16aa"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a9b1e72e8b2ac09786a36bc0c97aa16aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa">pachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f)</td></tr>
<tr class="memdesc:a9b1e72e8b2ac09786a36bc0c97aa16aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face.  <br /></td></tr>
<tr class="separator:a9b1e72e8b2ac09786a36bc0c97aa16aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d61577f10db36988746db8c6e2bb89d" id="r_a7d61577f10db36988746db8c6e2bb89d"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a7d61577f10db36988746db8c6e2bb89d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d61577f10db36988746db8c6e2bb89d">pachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, <a class="el" href="structregina_1_1Unprotected.html">Unprotected</a>)</td></tr>
<tr class="memdesc:a7d61577f10db36988746db8c6e2bb89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face, without any safety checks.  <br /></td></tr>
<tr class="separator:a7d61577f10db36988746db8c6e2bb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e874f14510689aa9db756ddc8611ca3" id="r_a1e874f14510689aa9db756ddc8611ca3"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a1e874f14510689aa9db756ddc8611ca3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e874f14510689aa9db756ddc8611ca3">move20</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f)</td></tr>
<tr class="memdesc:a1e874f14510689aa9db756ddc8611ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a 2-0 move about the given <em>k</em>-face of degree two.  <br /></td></tr>
<tr class="separator:a1e874f14510689aa9db756ddc8611ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa795373077b40844b3e960ab551f861" id="r_afa795373077b40844b3e960ab551f861"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa795373077b40844b3e960ab551f861">shellBoundary</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *s)</td></tr>
<tr class="memdesc:afa795373077b40844b3e960ab551f861"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangulation.  <br /></td></tr>
<tr class="separator:afa795373077b40844b3e960ab551f861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39868427de3611c179664cdef49539b" id="r_ad39868427de3611c179664cdef49539b"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ad39868427de3611c179664cdef49539b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39868427de3611c179664cdef49539b">hasPachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f) const</td></tr>
<tr class="memdesc:ad39868427de3611c179664cdef49539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation, without violating any simplex and/or facet locks.  <br /></td></tr>
<tr class="separator:ad39868427de3611c179664cdef49539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797ccce735aa5a4eab9433f64b848faa" id="r_a797ccce735aa5a4eab9433f64b848faa"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a797ccce735aa5a4eab9433f64b848faa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a797ccce735aa5a4eab9433f64b848faa">has20</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f) const</td></tr>
<tr class="memdesc:a797ccce735aa5a4eab9433f64b848faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a 2-0 move about the given <em>k</em>-face of this triangulation, without violating any simplex and/or facet locks.  <br /></td></tr>
<tr class="separator:a797ccce735aa5a4eab9433f64b848faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285440f69d71e964ec70c897298850ca" id="r_a285440f69d71e964ec70c897298850ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285440f69d71e964ec70c897298850ca">hasShellBoundary</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *s) const</td></tr>
<tr class="memdesc:a285440f69d71e964ec70c897298850ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a boundary shelling move upon the given top-dimensional simplex of this triangulation, without violating any simplex and/or facet locks.  <br /></td></tr>
<tr class="separator:a285440f69d71e964ec70c897298850ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da934e97035b4b4d5eb27f0cb156c6e" id="r_a4da934e97035b4b4d5eb27f0cb156c6e"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a4da934e97035b4b4d5eb27f0cb156c6e"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4da934e97035b4b4d5eb27f0cb156c6e">withPachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f) const</td></tr>
<tr class="memdesc:a4da934e97035b4b4d5eb27f0cb156c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the triangulation obtained by performing a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation.  <br /></td></tr>
<tr class="separator:a4da934e97035b4b4d5eb27f0cb156c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1820f61089b2dd96808420c7cbf383bc" id="r_a1820f61089b2dd96808420c7cbf383bc"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a1820f61089b2dd96808420c7cbf383bc"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1820f61089b2dd96808420c7cbf383bc">with20</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f) const</td></tr>
<tr class="memdesc:a1820f61089b2dd96808420c7cbf383bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the triangulation obtained by performing a 2-0 move about the given <em>k</em>-face of this triangulation.  <br /></td></tr>
<tr class="separator:a1820f61089b2dd96808420c7cbf383bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b3c1559b9efd6989b2f71f0fa48940" id="r_a75b3c1559b9efd6989b2f71f0fa48940"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b3c1559b9efd6989b2f71f0fa48940">withShellBoundary</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *s) const</td></tr>
<tr class="memdesc:a75b3c1559b9efd6989b2f71f0fa48940"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the triangulation obtained by performing a boundary shelling move on the given top-dimensional simplex of this triangulation.  <br /></td></tr>
<tr class="separator:a75b3c1559b9efd6989b2f71f0fa48940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d347fbe4c9dca73eca5a6c986186e5" id="r_a52d347fbe4c9dca73eca5a6c986186e5"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a52d347fbe4c9dca73eca5a6c986186e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52d347fbe4c9dca73eca5a6c986186e5">pachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a52d347fbe4c9dca73eca5a6c986186e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation.  <br /></td></tr>
<tr class="separator:a52d347fbe4c9dca73eca5a6c986186e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca59a5a9f5b041d2159cc995f643c0f" id="r_afca59a5a9f5b041d2159cc995f643c0f"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:afca59a5a9f5b041d2159cc995f643c0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afca59a5a9f5b041d2159cc995f643c0f">twoZeroMove</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:afca59a5a9f5b041d2159cc995f643c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a 2-0 move about the given <em>k</em>-face of this triangulation.  <br /></td></tr>
<tr class="separator:afca59a5a9f5b041d2159cc995f643c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03a55bb0527a9604604be099ed5f14" id="r_a4b03a55bb0527a9604604be099ed5f14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b03a55bb0527a9604604be099ed5f14">shellBoundary</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *s, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a4b03a55bb0527a9604604be099ed5f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a boundary shelling move on the given top-dimensional simplex.  <br /></td></tr>
<tr class="separator:a4b03a55bb0527a9604604be099ed5f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions, Extensions and Covers</div></td></tr>
<tr class="memitem:aa378edda664e87c4052114248722857b" id="r_aa378edda664e87c4052114248722857b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa378edda664e87c4052114248722857b">doubleCover</a> () const</td></tr>
<tr class="memdesc:aa378edda664e87c4052114248722857b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientable double cover of this triangulation.  <br /></td></tr>
<tr class="separator:aa378edda664e87c4052114248722857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5afdac1c0dee2db962be81e187d973" id="r_a0c5afdac1c0dee2db962be81e187d973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5afdac1c0dee2db962be81e187d973">doubleOverBoundary</a> () const</td></tr>
<tr class="memdesc:a0c5afdac1c0dee2db962be81e187d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns two copies of this triangulation joined together along their boundary facets.  <br /></td></tr>
<tr class="separator:a0c5afdac1c0dee2db962be81e187d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae061e36e8ecbfa2f1edc36ed9eb99a51" id="r_ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae061e36e8ecbfa2f1edc36ed9eb99a51">makeDoubleCover</a> ()</td></tr>
<tr class="memdesc:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that converts this triangulation into its orientable double cover.  <br /></td></tr>
<tr class="separator:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7139822eb449840c13dbcc304f8491" id="r_a0e7139822eb449840c13dbcc304f8491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e7139822eb449840c13dbcc304f8491">subdivide</a> ()</td></tr>
<tr class="memdesc:a0e7139822eb449840c13dbcc304f8491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a barycentric subdivision of the triangulation.  <br /></td></tr>
<tr class="separator:a0e7139822eb449840c13dbcc304f8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13345c67f4c82d9976863c8c5372db5b" id="r_a13345c67f4c82d9976863c8c5372db5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13345c67f4c82d9976863c8c5372db5b">barycentricSubdivision</a> ()</td></tr>
<tr class="memdesc:a13345c67f4c82d9976863c8c5372db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that performs a barycentric subdivision of the triangulation.  <br /></td></tr>
<tr class="separator:a13345c67f4c82d9976863c8c5372db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c6b8c7500d6604eee71065addf0aa" id="r_a3c2c6b8c7500d6604eee71065addf0aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c2c6b8c7500d6604eee71065addf0aa">makeIdeal</a> ()</td></tr>
<tr class="memdesc:a3c2c6b8c7500d6604eee71065addf0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each real boundary component into a cusp (i.e., an ideal vertex).  <br /></td></tr>
<tr class="separator:a3c2c6b8c7500d6604eee71065addf0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25a58b48e39f3c7f8621b84432d294" id="r_adc25a58b48e39f3c7f8621b84432d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc25a58b48e39f3c7f8621b84432d294">finiteToIdeal</a> ()</td></tr>
<tr class="memdesc:adc25a58b48e39f3c7f8621b84432d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="#a3c2c6b8c7500d6604eee71065addf0aa" title="Converts each real boundary component into a cusp (i.e., an ideal vertex).">makeIdeal()</a>, which converts each real boundary component into an ideal vertex.  <br /></td></tr>
<tr class="separator:adc25a58b48e39f3c7f8621b84432d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompositions</div></td></tr>
<tr class="memitem:a8c9bc864e2b45447e3fcc92f99d3840e" id="r_a8c9bc864e2b45447e3fcc92f99d3840e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9bc864e2b45447e3fcc92f99d3840e">triangulateComponents</a> () const</td></tr>
<tr class="memdesc:a8c9bc864e2b45447e3fcc92f99d3840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the individual connected components of this triangulation.  <br /></td></tr>
<tr class="separator:a8c9bc864e2b45447e3fcc92f99d3840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphism Testing</div></td></tr>
<tr class="memitem:a306a4532309eabe53267868d1ff544ea" id="r_a306a4532309eabe53267868d1ff544ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a306a4532309eabe53267868d1ff544ea">operator==</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a306a4532309eabe53267868d1ff544ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially identical to the given triangulation.  <br /></td></tr>
<tr class="separator:a306a4532309eabe53267868d1ff544ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568895b8abeb672289fcee779ebf01a" id="r_ac568895b8abeb672289fcee779ebf01a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac568895b8abeb672289fcee779ebf01a">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac568895b8abeb672289fcee779ebf01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially isomorphic to the given triangulation.  <br /></td></tr>
<tr class="separator:ac568895b8abeb672289fcee779ebf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e42b826a392816a796e0e15f85ded" id="r_a868e42b826a392816a796e0e15f85ded"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a868e42b826a392816a796e0e15f85ded">isContainedIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a868e42b826a392816a796e0e15f85ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <br /></td></tr>
<tr class="separator:a868e42b826a392816a796e0e15f85ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0481813042dab2c6140fc8d6fbbd189d" id="r_a0481813042dab2c6140fc8d6fbbd189d"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a0481813042dab2c6140fc8d6fbbd189d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0481813042dab2c6140fc8d6fbbd189d">findAllIsomorphisms</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a0481813042dab2c6140fc8d6fbbd189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.  <br /></td></tr>
<tr class="separator:a0481813042dab2c6140fc8d6fbbd189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea60c854787cc26a39618dcdf2196b" id="r_ac3ea60c854787cc26a39618dcdf2196b"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ac3ea60c854787cc26a39618dcdf2196b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3ea60c854787cc26a39618dcdf2196b">findAllSubcomplexesIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ac3ea60c854787cc26a39618dcdf2196b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <br /></td></tr>
<tr class="separator:ac3ea60c854787cc26a39618dcdf2196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe58df75da67242635ddcea5398d1b77" id="r_abe58df75da67242635ddcea5398d1b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe58df75da67242635ddcea5398d1b77">makeCanonical</a> ()</td></tr>
<tr class="memdesc:abe58df75da67242635ddcea5398d1b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form.  <br /></td></tr>
<tr class="separator:abe58df75da67242635ddcea5398d1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Building Triangulations</div></td></tr>
<tr class="memitem:a2bf93dbca6715c1a455a2d47f66a6476" id="r_a2bf93dbca6715c1a455a2d47f66a6476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf93dbca6715c1a455a2d47f66a6476">insertTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="#a969c32d5436daaee2e541628559c775b">source</a>)</td></tr>
<tr class="memdesc:a2bf93dbca6715c1a455a2d47f66a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given triangulation into this triangulation.  <br /></td></tr>
<tr class="separator:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783e33260b58b579886797a0216a7c79" id="r_a783e33260b58b579886797a0216a7c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a783e33260b58b579886797a0216a7c79">insertTriangulation</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&amp;<a class="el" href="#a969c32d5436daaee2e541628559c775b">source</a>)</td></tr>
<tr class="memdesc:a783e33260b58b579886797a0216a7c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given triangulation into this triangulation.  <br /></td></tr>
<tr class="separator:a783e33260b58b579886797a0216a7c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Triangulations</div></td></tr>
<tr class="memitem:a9ad4d1c374ad8abd557bd087251a0eb6" id="r_a9ad4d1c374ad8abd557bd087251a0eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad4d1c374ad8abd557bd087251a0eb6">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a9ad4d1c374ad8abd557bd087251a0eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a9ad4d1c374ad8abd557bd087251a0eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a36c856a443ff64609e1b7761bf875" id="r_a60a36c856a443ff64609e1b7761bf875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a36c856a443ff64609e1b7761bf875">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a60a36c856a443ff64609e1b7761bf875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a60a36c856a443ff64609e1b7761bf875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3133ab83d943df1dd216dc2fbde58c6c" id="r_a3133ab83d943df1dd216dc2fbde58c6c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>  = IsoSigClassic&lt;dim&gt;, class Encoding  = IsoSigPrintable&lt;dim&gt;&gt; </td></tr>
<tr class="memitem:a3133ab83d943df1dd216dc2fbde58c6c"><td class="memTemplItemLeft" align="right" valign="top">Encoding::Signature&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c">isoSig</a> () const</td></tr>
<tr class="memdesc:a3133ab83d943df1dd216dc2fbde58c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature of the given type for this triangulation.  <br /></td></tr>
<tr class="separator:a3133ab83d943df1dd216dc2fbde58c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220763a5656748e7d75e79485a5acbde" id="r_a220763a5656748e7d75e79485a5acbde"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>  = IsoSigClassic&lt;dim&gt;, class Encoding  = IsoSigPrintable&lt;dim&gt;&gt; </td></tr>
<tr class="memitem:a220763a5656748e7d75e79485a5acbde"><td class="memTemplItemLeft" align="right" valign="top">Encoding::Signature&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a220763a5656748e7d75e79485a5acbde">sig</a> () const</td></tr>
<tr class="memdesc:a220763a5656748e7d75e79485a5acbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>, which constructs the isomorphism signature of the given type for this triangulation.  <br /></td></tr>
<tr class="separator:a220763a5656748e7d75e79485a5acbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3939293964c4646c7f60cacd94c52" id="r_a47a3939293964c4646c7f60cacd94c52"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>  = IsoSigClassic&lt;dim&gt;, class Encoding  = IsoSigPrintable&lt;dim&gt;&gt; </td></tr>
<tr class="memitem:a47a3939293964c4646c7f60cacd94c52"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename Encoding::Signature, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47a3939293964c4646c7f60cacd94c52">isoSigDetail</a> () const</td></tr>
<tr class="memdesc:a47a3939293964c4646c7f60cacd94c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature for this triangulation, along with the relabelling that will occur when the triangulation is reconstructed from it.  <br /></td></tr>
<tr class="separator:a47a3939293964c4646c7f60cacd94c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393121abbf7a159a21ffca9deb9fb824" id="r_a393121abbf7a159a21ffca9deb9fb824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393121abbf7a159a21ffca9deb9fb824">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a393121abbf7a159a21ffca9deb9fb824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this triangulation to the given output stream.  <br /></td></tr>
<tr class="separator:a393121abbf7a159a21ffca9deb9fb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969c32d5436daaee2e541628559c775b" id="r_a969c32d5436daaee2e541628559c775b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969c32d5436daaee2e541628559c775b">source</a> (<a class="el" href="group__engine.html#ga4042b3d9832af20a99be34899e313442">Language</a> language=<a class="el" href="group__engine.html#gga4042b3d9832af20a99be34899e313442a222a267cc5778206b253be35ee3ddab5">Language::Current</a>) const</td></tr>
<tr class="memdesc:a969c32d5436daaee2e541628559c775b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C++ or Python source code that can be used to reconstruct this triangulation.  <br /></td></tr>
<tr class="separator:a969c32d5436daaee2e541628559c775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7c9ec1168ef9e7cb34b3e4a5b9b873" id="r_ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace7c9ec1168ef9e7cb34b3e4a5b9b873">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns C++ code to reconstruct this triangulation.  <br /></td></tr>
<tr class="separator:ace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856a84ed29cd61f1b3bea9df595fb981" id="r_a856a84ed29cd61f1b3bea9df595fb981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a856a84ed29cd61f1b3bea9df595fb981">writeDot</a> (std::ostream &amp;out, bool labels=false) const</td></tr>
<tr class="memdesc:a856a84ed29cd61f1b3bea9df595fb981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the dual graph of this triangulation in the Graphviz DOT language.  <br /></td></tr>
<tr class="separator:a856a84ed29cd61f1b3bea9df595fb981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085f589f5d63dbbac25978cf350ff459" id="r_a085f589f5d63dbbac25978cf350ff459"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085f589f5d63dbbac25978cf350ff459">dot</a> (bool labels=false) const</td></tr>
<tr class="memdesc:a085f589f5d63dbbac25978cf350ff459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz DOT representation of the dual graph of this triangulation.  <br /></td></tr>
<tr class="separator:a085f589f5d63dbbac25978cf350ff459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa177dda3276927267a3ae0130765a6f1" id="r_aa177dda3276927267a3ae0130765a6f1"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa177dda3276927267a3ae0130765a6f1">dimension</a> = dim</td></tr>
<tr class="memdesc:aa177dda3276927267a3ae0130765a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of the triangulation.  <br /></td></tr>
<tr class="separator:aa177dda3276927267a3ae0130765a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a111c0d2dfaba45d86517ba04bb7aa019" id="r_a111c0d2dfaba45d86517ba04bb7aa019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#a111c0d2dfaba45d86517ba04bb7aa019">swap</a> (<a class="el" href="classregina_1_1Snapshottable.html">Snapshottable</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a111c0d2dfaba45d86517ba04bb7aa019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation.  <br /></td></tr>
<tr class="separator:a111c0d2dfaba45d86517ba04bb7aa019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e625e918d497e1a006bc13b64a1d4f" id="r_ac7e625e918d497e1a006bc13b64a1d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f">takeSnapshot</a> ()</td></tr>
<tr class="memdesc:ac7e625e918d497e1a006bc13b64a1d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called before modification and/or destruction of the type <em>T</em> contents.  <br /></td></tr>
<tr class="separator:ac7e625e918d497e1a006bc13b64a1d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5857fcc6d1187bc8d72b900fef3161d6" id="r_a5857fcc6d1187bc8d72b900fef3161d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TopologyLockable.html#a5857fcc6d1187bc8d72b900fef3161d6">topologyLocked</a> () const</td></tr>
<tr class="memdesc:a5857fcc6d1187bc8d72b900fef3161d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not there are any topology locks currently held on this object.  <br /></td></tr>
<tr class="separator:a5857fcc6d1187bc8d72b900fef3161d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1739e33bdbb5c52cb77de81ec93c1ec8" id="r_a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1739e33bdbb5c52cb77de81ec93c1ec8">simplices_</a></td></tr>
<tr class="memdesc:a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-dimensional simplices that form the triangulation.  <br /></td></tr>
<tr class="separator:a1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cab33bd8fb5910570468b60fe4f18b" id="r_a17cab33bd8fb5910570468b60fe4f18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17cab33bd8fb5910570468b60fe4f18b">components_</a></td></tr>
<tr class="memdesc:a17cab33bd8fb5910570468b60fe4f18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The connected components that form the triangulation.  <br /></td></tr>
<tr class="separator:a17cab33bd8fb5910570468b60fe4f18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e46682d3ce5b05f7e693f863018f66" id="r_aa6e46682d3ce5b05f7e693f863018f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e46682d3ce5b05f7e693f863018f66">boundaryComponents_</a></td></tr>
<tr class="memdesc:aa6e46682d3ce5b05f7e693f863018f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The components that form the boundary of the triangulation.  <br /></td></tr>
<tr class="separator:aa6e46682d3ce5b05f7e693f863018f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db8e55f59788fbb27cb5a15c44f127a" id="r_a1db8e55f59788fbb27cb5a15c44f127a"><td class="memItemLeft" align="right" valign="top">std::array&lt; size_t, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db8e55f59788fbb27cb5a15c44f127a">nBoundaryFaces_</a></td></tr>
<tr class="memdesc:a1db8e55f59788fbb27cb5a15c44f127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary faces of each dimension.  <br /></td></tr>
<tr class="separator:a1db8e55f59788fbb27cb5a15c44f127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106dc9d8ffc9e2bd1dd35ad35d52773c" id="r_a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a106dc9d8ffc9e2bd1dd35ad35d52773c">valid_</a></td></tr>
<tr class="memdesc:a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this triangulation valid? See <a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means.  <br /></td></tr>
<tr class="separator:a106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b" id="r_a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f83f8f5e9df2281cb7b65b1d46bd4c" id="r_a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TopologyLockable.html#a11f83f8f5e9df2281cb7b65b1d46bd4c">topologyLock_</a> { 0 }</td></tr>
<tr class="memdesc:a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of topology locks currently held on this object.  <br /></td></tr>
<tr class="separator:a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Importing Triangulations</h2></td></tr>
<tr class="memitem:a18b800abaa549d41b2f16af312c57d08" id="r_a18b800abaa549d41b2f16af312c57d08"><td class="memTemplParams" colspan="2"><a id="a18b800abaa549d41b2f16af312c57d08" name="a18b800abaa549d41b2f16af312c57d08"></a>
template&lt;int &gt; </td></tr>
<tr class="memitem:a18b800abaa549d41b2f16af312c57d08"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BoundaryComponentBase</b></td></tr>
<tr class="separator:a18b800abaa549d41b2f16af312c57d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab186aa21574f0257f825a1200b635af2" id="r_ab186aa21574f0257f825a1200b635af2"><td class="memItemLeft" align="right" valign="top"><a id="ab186aa21574f0257f825a1200b635af2" name="ab186aa21574f0257f825a1200b635af2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLLegacySimplicesReader&lt; dim &gt;</b></td></tr>
<tr class="separator:ab186aa21574f0257f825a1200b635af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02d35e7992eff6bd43e68de6864065" id="r_a2f02d35e7992eff6bd43e68de6864065"><td class="memItemLeft" align="right" valign="top"><a id="a2f02d35e7992eff6bd43e68de6864065" name="a2f02d35e7992eff6bd43e68de6864065"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLSimplexReader&lt; dim &gt;</b></td></tr>
<tr class="separator:a2f02d35e7992eff6bd43e68de6864065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac377521d7bc0dc2b8ac276195d4b2e" id="r_a7ac377521d7bc0dc2b8ac276195d4b2e"><td class="memItemLeft" align="right" valign="top"><a id="a7ac377521d7bc0dc2b8ac276195d4b2e" name="a7ac377521d7bc0dc2b8ac276195d4b2e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTriangulationReader&lt; dim &gt;</b></td></tr>
<tr class="separator:a7ac377521d7bc0dc2b8ac276195d4b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e5a9e56f5a9aa0ef4b71048e55f6a" id="r_a2e7e5a9e56f5a9aa0ef4b71048e55f6a"><td class="memItemLeft" align="right" valign="top"><a id="a2e7e5a9e56f5a9aa0ef4b71048e55f6a" name="a2e7e5a9e56f5a9aa0ef4b71048e55f6a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLWriter&lt; Triangulation&lt; dim &gt; &gt;</b></td></tr>
<tr class="separator:a2e7e5a9e56f5a9aa0ef4b71048e55f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91567ffbe224dcd1f1da3cb273efe49" id="r_ad91567ffbe224dcd1f1da3cb273efe49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91567ffbe224dcd1f1da3cb273efe49">fromGluings</a> (size_t <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5">size</a>, std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &gt; &gt; gluings)</td></tr>
<tr class="memdesc:ad91567ffbe224dcd1f1da3cb273efe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a triangulation from a hard-coded list of gluings.  <br /></td></tr>
<tr class="separator:ad91567ffbe224dcd1f1da3cb273efe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25408f7eb0b1c5bc3a87b1e93e7d0d2" id="r_af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af25408f7eb0b1c5bc3a87b1e93e7d0d2">fromGluings</a> (size_t <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5">size</a>, Iterator beginGluings, Iterator endGluings)</td></tr>
<tr class="memdesc:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a triangulation from a list of gluings.  <br /></td></tr>
<tr class="separator:af25408f7eb0b1c5bc3a87b1e93e7d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91da7bdae05981c20c2e3ee234cc48d" id="r_af91da7bdae05981c20c2e3ee234cc48d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d">fromIsoSig</a> (const std::string &amp;<a class="el" href="#a220763a5656748e7d75e79485a5acbde">sig</a>)</td></tr>
<tr class="memdesc:af91da7bdae05981c20c2e3ee234cc48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a full triangulation from an isomorphism signature.  <br /></td></tr>
<tr class="separator:af91da7bdae05981c20c2e3ee234cc48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776984602dd80817c160e797aeca67c3" id="r_a776984602dd80817c160e797aeca67c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776984602dd80817c160e797aeca67c3">fromSig</a> (const std::string &amp;<a class="el" href="#a220763a5656748e7d75e79485a5acbde">sig</a>)</td></tr>
<tr class="memdesc:a776984602dd80817c160e797aeca67c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, to recover a full triangulation from an isomorphism signature.  <br /></td></tr>
<tr class="separator:a776984602dd80817c160e797aeca67c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eedc0b1fc037af0d9c6c23c32d79f2b" id="r_a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eedc0b1fc037af0d9c6c23c32d79f2b">isoSigComponentSize</a> (const std::string &amp;<a class="el" href="#a220763a5656748e7d75e79485a5acbde">sig</a>)</td></tr>
<tr class="memdesc:a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature.  <br /></td></tr>
<tr class="separator:a0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e807b7e562aeafd28ca506bd78f7b4" id="r_a93e807b7e562aeafd28ca506bd78f7b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e807b7e562aeafd28ca506bd78f7b4">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a93e807b7e562aeafd28ca506bd78f7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a triangulation from its given tight encoding.  <br /></td></tr>
<tr class="separator:a93e807b7e562aeafd28ca506bd78f7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6089593f5dd4390f786f16b09d21de3" id="r_aa6089593f5dd4390f786f16b09d21de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6089593f5dd4390f786f16b09d21de3">operator=</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;src)</td></tr>
<tr class="memdesc:aa6089593f5dd4390f786f16b09d21de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given triangulation.  <br /></td></tr>
<tr class="separator:aa6089593f5dd4390f786f16b09d21de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46980847f4f9adae8be8101dcc6fe914" id="r_a46980847f4f9adae8be8101dcc6fe914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46980847f4f9adae8be8101dcc6fe914">operator=</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a46980847f4f9adae8be8101dcc6fe914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given triangulation into this triangulation.  <br /></td></tr>
<tr class="separator:a46980847f4f9adae8be8101dcc6fe914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6791255912384494b7e2b76f44eee61a" id="r_a6791255912384494b7e2b76f44eee61a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6791255912384494b7e2b76f44eee61a">newSimplexRaw</a> ()</td></tr>
<tr class="memdesc:a6791255912384494b7e2b76f44eee61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> with no management of the underlying triangulation.  <br /></td></tr>
<tr class="separator:a6791255912384494b7e2b76f44eee61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0522a4175469aa2b3ecdc188542c1a" id="r_a4a0522a4175469aa2b3ecdc188542c1a"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a4a0522a4175469aa2b3ecdc188542c1a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *, k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a0522a4175469aa2b3ecdc188542c1a">newSimplicesRaw</a> ()</td></tr>
<tr class="memdesc:a4a0522a4175469aa2b3ecdc188542c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> with no lock management, and no management of the underlying triangulation.  <br /></td></tr>
<tr class="separator:a4a0522a4175469aa2b3ecdc188542c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb72ee7b952682ed019ef48bb79f0f7" id="r_abfb72ee7b952682ed019ef48bb79f0f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfb72ee7b952682ed019ef48bb79f0f7">removeSimplexRaw</a> (<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *<a class="el" href="#ae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:abfb72ee7b952682ed019ef48bb79f0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> with no lock management, and no management of the underlying triangulation.  <br /></td></tr>
<tr class="separator:abfb72ee7b952682ed019ef48bb79f0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b9f9c40a48cee3a1ee9c71bd70fef" id="r_aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87b9f9c40a48cee3a1ee9c71bd70fef">ensureSkeleton</a> () const</td></tr>
<tr class="memdesc:aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all "on demand" skeletal objects have been calculated.  <br /></td></tr>
<tr class="separator:aa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eccc799a49667455b78f790f258098" id="r_a99eccc799a49667455b78f790f258098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99eccc799a49667455b78f790f258098">calculatedSkeleton</a> () const</td></tr>
<tr class="memdesc:a99eccc799a49667455b78f790f258098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the skeletal objects and properties of this triangulation have been calculated.  <br /></td></tr>
<tr class="separator:a99eccc799a49667455b78f790f258098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04b371303f07f238af57faf82c9402" id="r_a1d04b371303f07f238af57faf82c9402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d04b371303f07f238af57faf82c9402">calculateSkeleton</a> ()</td></tr>
<tr class="memdesc:a1d04b371303f07f238af57faf82c9402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all skeletal objects for this triangulation.  <br /></td></tr>
<tr class="separator:a1d04b371303f07f238af57faf82c9402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa434aa25d90713a8dd49d2fef1946210" id="r_aa434aa25d90713a8dd49d2fef1946210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa434aa25d90713a8dd49d2fef1946210">cloneSkeleton</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;src)</td></tr>
<tr class="memdesc:aa434aa25d90713a8dd49d2fef1946210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.  <br /></td></tr>
<tr class="separator:aa434aa25d90713a8dd49d2fef1946210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571569a34bb4173bd5eb6b521ff503cb" id="r_a571569a34bb4173bd5eb6b521ff503cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a571569a34bb4173bd5eb6b521ff503cb">clearBaseProperties</a> ()</td></tr>
<tr class="memdesc:a571569a34bb4173bd5eb6b521ff503cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all properties that are managed by this base class.  <br /></td></tr>
<tr class="separator:a571569a34bb4173bd5eb6b521ff503cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16509c98bc3e4b38f673aff15337f5" id="r_a8b16509c98bc3e4b38f673aff15337f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b16509c98bc3e4b38f673aff15337f5">swapBaseData</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:a8b16509c98bc3e4b38f673aff15337f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all data that is managed by this base class, including simplices, skeletal data, cached properties and the snapshotting data, with the given triangulation.  <br /></td></tr>
<tr class="separator:a8b16509c98bc3e4b38f673aff15337f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d1a2ca27fd966c3c7403f0a1c6080d" id="r_ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d1a2ca27fd966c3c7403f0a1c6080d">writeXMLBaseProperties</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing properties of this triangulation.  <br /></td></tr>
<tr class="separator:ad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::detail::TriangulationBase&lt; dim &gt;</div><p>Provides core functionality for <em>dim</em>-dimensional triangulations. </p>
<p>Such a triangulation is represented by the class Triangulation&lt;dim&gt;, which uses this as a base class. End users should not need to refer to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> directly.</p>
<p>See the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> class notes for further information.</p>
<p>Note that this class does not derive from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a>. This is to avoid clashes with the output code inherited from <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a>. Specifically:</p>
<ul>
<li>for those dimensions where Triangulation&lt;dim&gt; derives from <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a>, the output routines are inherited from <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> (which derives from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a>).</li>
<li>for other dimensions, Triangulation&lt;dim&gt; derives from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> directly.</li>
</ul>
<dl class="section user"><dt>Python</dt><dd>This base class is not present, but the "end user" class Triangulation&lt;dim&gt; is.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0d10f79dd6c4de1c8b90b77ab0953d9c" name="a0d10f79dd6c4de1c8b90b77ab0953d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10f79dd6c4de1c8b90b77ab0953d9c">&#9670;&#160;</a></span>PacketChangeGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::PacketChangeGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes. </p>
<p>This type alias is used in the same way as <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a>: it is purely for the benefit of the human reader, used to indicate that an event span is present purely for optimisation (and in particular, that the code would still be correct without it).</p>
<p>See <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a> for further details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa79cc9e7f5b4f6ea27045ebf3c8fabc" name="aaa79cc9e7f5b4f6ea27045ebf3c8fabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">&#9670;&#160;</a></span>TriangulationBase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TriangulationBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty triangulation. </p>

</div>
</div>
<a id="aea7c30e319925152d112df42cb225dd4" name="aea7c30e319925152d112df42cb225dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7c30e319925152d112df42cb225dd4">&#9670;&#160;</a></span>TriangulationBase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TriangulationBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation. </p>
<p>This will also clone any computed properties (such as homology, fundamental group, and so on), as well as the skeleton (vertices, edges, components, etc.). In particular, the same numbering and labelling will be used for all skeletal objects.</p>
<p>If <em>src</em> has any locks on top-dimensional simplices and/or their facets, these locks will also be copied across.</p>
<p>If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641595fc60bdd54117af630c9b5a6e0b" name="a641595fc60bdd54117af630c9b5a6e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641595fc60bdd54117af630c9b5a6e0b">&#9670;&#160;</a></span>TriangulationBase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TriangulationBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cloneProps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cloneLocks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties and/or locks also. </p>
<p>If <em>cloneProps</em> is <code>true</code>, then this constructor will also clone any computed properties (such as homology, fundamental group, and so on). If <em>cloneProps</em> is <code>false</code>, then these properties will be marked as unknown in the new triangulation, and will be recomputed on demand if/when they are required.</p>
<p>Regardless of <em>cloneProps</em>, the skeleton (vertices, edges, components, etc.) will <em>always</em> be cloned. This is to ensure that the same numbering and labelling will be used for all skeletal objects in both triangulations.</p>
<p>If <em>cloneLocks</em> is <code>true</code> then any locks on the top-dimensional simplices and/or facets of <em>src</em> will be copied across. If <em>cloneLocks</em> is <code>false</code> then the new triangulation will have no locks at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties as well as the skeleton of the given triangulation, or <code>false</code> if the new triangulation should have such properties and skeletal data marked as unknown. </td></tr>
    <tr><td class="paramname">cloneLocks</td><td><code>true</code> if this should also clone any simplex and/or facet locks from the given triangulation, or <code>false</code> if the new triangulation should have no locks at all. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0f506c035852c5df99ef37167a9a881" name="af0f506c035852c5df99ef37167a9a881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f506c035852c5df99ef37167a9a881">&#9670;&#160;</a></span>TriangulationBase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TriangulationBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given triangulation into this new triangulation. </p>
<p>This is much faster than the copy constructor, but is still linear time. This is because every top-dimensional simplex must be adjusted to point back to this triangulation instead of <em>src</em>.</p>
<p>All top-dimensional simplices and skeletal objects (faces, components and boundary components) that belong to <em>src</em> will be moved into this triangulation, and so any pointers or references to Simplex&lt;dim&gt;, Face&lt;dim, subdim&gt;, Component&lt;dim&gt; or BoundaryComponent&lt;dim&gt; objects will remain valid. Likewise, all cached properties will be moved into this triangulation.</p>
<p>If <em>src</em> has any locks on top-dimensional simplices and/or their facets, these locks will also be moved across.</p>
<p>The triangulation that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this triangulation is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace45d0a52d9a2a853f890d1006fedf7c" name="ace45d0a52d9a2a853f890d1006fedf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace45d0a52d9a2a853f890d1006fedf7c">&#9670;&#160;</a></span>~TriangulationBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p>The simplices within this triangulation will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&#160;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::anonID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p>This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p>The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p>These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="a13345c67f4c82d9976863c8c5372db5b" name="a13345c67f4c82d9976863c8c5372db5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13345c67f4c82d9976863c8c5372db5b">&#9670;&#160;</a></span>barycentricSubdivision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::barycentricSubdivision </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that performs a barycentric subdivision of the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000227">Deprecated</a></b></dt><dd>This routine has been renamed to <a class="el" href="#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">subdivide()</a>, both to shorten the name but also to make it clearer that this triangulation will be modified directly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This triangulation contains at least one locked top-dimensional simplex and/or facet. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef6eee4278d413b28cc3519ea07d90d0" name="aef6eee4278d413b28cc3519ea07d90d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6eee4278d413b28cc3519ea07d90d0">&#9670;&#160;</a></span>boundaryComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested boundary component of this triangulation. </p>
<p>Note that each time the triangulation changes, all boundary components will be deleted and replaced with new ones. Therefore this object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired boundary component; this must be between 0 and <a class="el" href="#a658bf830fdf052e1beaa5423298c51b2" title="Returns the number of boundary components in this triangulation.">countBoundaryComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested boundary component. </dd></dl>

</div>
</div>
<a id="a2b76267c6a893785e1fe396e5b439806" name="a2b76267c6a893785e1fe396e5b439806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b76267c6a893785e1fe396e5b439806">&#9670;&#160;</a></span>boundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all boundary components of this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1BoundaryComponent.html">BoundaryComponent&lt;dim&gt;</a>* b : tri.<a class="code hl_function" href="#a2b76267c6a893785e1fe396e5b439806">boundaryComponents</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1BoundaryComponent_html"><div class="ttname"><a href="classregina_1_1BoundaryComponent.html">regina::BoundaryComponent</a></div><div class="ttdoc">A component of the boundary of a dim-manifold triangulation.</div><div class="ttdef"><b>Definition</b> boundarycomponent.h:123</div></div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_a2b76267c6a893785e1fe396e5b439806"><div class="ttname"><a href="#a2b76267c6a893785e1fe396e5b439806">regina::detail::TriangulationBase::boundaryComponents</a></div><div class="ttdeci">auto boundaryComponents() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all boundary components of this ...</div><div class="ttdef"><b>Definition</b> triangulation.h:4929</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual boundary components <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="#a2b76267c6a893785e1fe396e5b439806" title="Returns an object that allows iteration through and random access to all boundary components of this ...">boundaryComponents()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all boundary components. </dd></dl>

</div>
</div>
<a id="abdfa4594ab1ba473360ff7b91750f49a" name="abdfa4594ab1ba473360ff7b91750f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfa4594ab1ba473360ff7b91750f49a">&#9670;&#160;</a></span>boundaryMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>boundaryMap&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>boundaryMap(subdim)</code>.</p>
<p>See the non-templated boundaryMap(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>boundaryMap(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 1 and <em>dim</em> inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a200793f011759542228bbe3c44f3df85" name="a200793f011759542228bbe3c44f3df85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200793f011759542228bbe3c44f3df85">&#9670;&#160;</a></span>boundaryMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryMap </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <code>boundaryMap&lt;subdim&gt;()</code> instead, which is slightly faster.</p>
<p>This is the boundary map that you would use if you were building the homology groups manually from a chain complex.</p>
<p>Unlike <a class="el" href="#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a>, this code does <em>not</em> use the dual skeleton: instead it uses the primal (i.e., ordinary) skeleton.</p>
<ul>
<li>The main advantage of this is that you can easily match rows and columns of the returned matrix to faces of this triangulation.</li>
<li>The main disadvantage is that ideal vertices are <em>not</em> treated as though they were truncated; instead they are just treated as 0-faces that appear as part of the chain complex.</li>
</ul>
<p>The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th (<em>subdim</em>-1)-face of this triangulation.</p>
<p>For the boundary map, we fix orientations as follows. In simplicial homology, for any <em>k</em>, the orientation of a <em>k</em>-simplex is determined by assigning labels 0,...,<em>k</em> to its vertices. For this routine, since every <em>k</em>-face <em>f</em> is already a <em>k</em>-simplex, these labels will just be the inherent vertex labels 0,...,<em>k</em> of the corresponding Face&lt;k&gt; object. If you need to convert these labels into vertex numbers of a top-dimensional simplex containing <em>f</em>, you can use either <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">Simplex&lt;dim&gt;::faceMapping&lt;k&gt;()</a>, or the equivalent routine <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html#a8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;k&gt;::vertices()</a>.</p>
<p>If you wish to convert these boundary maps to homology groups yourself, either the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class (if you do not need to track which face is which) or the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class (if you do need to track individual faces) can help you do this.</p>
<p>Note that, unlike many of the templated face-related routines, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., less than 1 or greater than <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 1 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from <em>subdim</em>-faces to (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a99eccc799a49667455b78f790f258098" name="a99eccc799a49667455b78f790f258098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eccc799a49667455b78f790f258098">&#9670;&#160;</a></span>calculatedSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculatedSkeleton </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the skeletal objects and properties of this triangulation have been calculated. </p>
<p>These are only calculated "on demand", when a skeletal property is first queried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the skeleton has been calculated. </dd></dl>

</div>
</div>
<a id="a1d04b371303f07f238af57faf82c9402" name="a1d04b371303f07f238af57faf82c9402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d04b371303f07f238af57faf82c9402">&#9670;&#160;</a></span>calculateSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculateSkeleton </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all skeletal objects for this triangulation. </p>
<p>For this parent class, <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> computes properties such as connected components, orientability, and lower-dimensional faces. Some Triangulation&lt;dim&gt; subclasses may track additional skeletal data, in which case they should reimplement this function. Their reimplementations <em>must</em> call this parent implementation.</p>
<p>You should never call this function directly; instead call <a class="el" href="#aa87b9f9c40a48cee3a1ee9c71bd70fef" title="Ensures that all &quot;on demand&quot; skeletal objects have been calculated.">ensureSkeleton()</a> instead.</p>
<p>For developers: any data members that are computed and stored by <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> would typically also need to be cloned by <a class="el" href="#aa434aa25d90713a8dd49d2fef1946210" title="Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.">cloneSkeleton()</a>. Therefore any changes or extensions to <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> would typically need to come with analogous changes or extensions to <a class="el" href="#aa434aa25d90713a8dd49d2fef1946210" title="Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.">cloneSkeleton()</a> also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>No skeletal objects have been computed, and the corresponding internal lists are all empty.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any call to <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> must first cast down to Triangulation&lt;dim&gt;, to ensure that you are catching the subclass implementation if this exists. You should never directly call this parent implementation (unless of course you are reimplementing <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> in a Triangulation&lt;dim&gt; subclass). </dd></dl>

</div>
</div>
<a id="a571569a34bb4173bd5eb6b521ff503cb" name="a571569a34bb4173bd5eb6b521ff503cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571569a34bb4173bd5eb6b521ff503cb">&#9670;&#160;</a></span>clearBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::clearBaseProperties </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all properties that are managed by this base class. </p>
<p>This includes deleting all skeletal objects and emptying the corresponding internal lists, as well as clearing other cached properties and deallocating the corresponding memory where required.</p>
<p>Note that <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> almost never calls this routine itself (the one exception is the copy assignment operator). Typically <a class="el" href="#a571569a34bb4173bd5eb6b521ff503cb" title="Clears all properties that are managed by this base class.">clearBaseProperties()</a> is only ever called by Triangulation&lt;dim&gt;::clearAllProperties(), which in turn is called by "atomic" routines that change the triangluation (before firing packet change events), as well as the Triangulation&lt;dim&gt; destructor. </p>

</div>
</div>
<a id="aa434aa25d90713a8dd49d2fef1946210" name="aa434aa25d90713a8dd49d2fef1946210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa434aa25d90713a8dd49d2fef1946210">&#9670;&#160;</a></span>cloneSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::cloneSkeleton </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation. </p>
<p>This clones all skeletal objects (e.g., faces, components and boundary components) and skeletal properties (e.g., validity and orientability). In general, this function clones the same properties and data that <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> computes.</p>
<p>For this parent class, <a class="el" href="#aa434aa25d90713a8dd49d2fef1946210" title="Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.">cloneSkeleton()</a> clones properties and data that are common to all dimensions. Some Triangulation&lt;dim&gt; subclasses may track additional skeletal properties or data, in which case they should reimplement this function (just as they also reimplement <a class="el" href="#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a>). Their reimplementations <em>must</em> call this parent implementation.</p>
<p>This function is intended only for use by the copy constructor (and related "copy-like" constructors), and the copy assignment operator. Other code should typically <em>not</em> need to call this function directly.</p>
<p>The real point of this routine is to ensure that, when a triangulation is cloned, its skeleton is cloned with exactly the same numbering/labelling of its skeletal objects. To this end, it is fine to leave some "large" skeletal properties to be computed on demand where this is allowed (e.g., triangulated vertex links or triangulated boundary components, which are allowed to remain uncomputed until required, even when the full skeleton <em>has</em> been computed).</p>
<dl class="section pre"><dt>Precondition</dt><dd>No skeletal objects have been computed for this triangulation, and the corresponding internal lists are all empty. </dd>
<dd>
The skeleton has been fully computed for the given source triangulation. </dd>
<dd>
The given source triangulation is combinatorially identical to this triangulation (i.e., both triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any call to <a class="el" href="#aa434aa25d90713a8dd49d2fef1946210" title="Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.">cloneSkeleton()</a> must first cast down to Triangulation&lt;dim&gt;, to ensure that you are catching the subclass implementation if this exists. You should never directly call this parent implementation (unless of course you are reimplementing <a class="el" href="#aa434aa25d90713a8dd49d2fef1946210" title="Builds the skeleton of this triangulation as a clone of the skeleton of the given triangulation.">cloneSkeleton()</a> in a Triangulation&lt;dim&gt; subclass).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation whose skeleton should be cloned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dd435c05fdb9ad2ce0229c08965e87d" name="a4dd435c05fdb9ad2ce0229c08965e87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd435c05fdb9ad2ce0229c08965e87d">&#9670;&#160;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested connected component of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore this component object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired component; this must be between 0 and <a class="el" href="#a20e5dba7654710e79eecaf849f248d38" title="Returns the number of connected components in this triangulation.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested component. </dd></dl>

</div>
</div>
<a id="aca9f1a9b278dd911add0d10351e8089d" name="aca9f1a9b278dd911add0d10351e8089d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9f1a9b278dd911add0d10351e8089d">&#9670;&#160;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::components </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all components of this triangulation. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1Component.html">Component&lt;dim&gt;</a>* c : tri.<a class="code hl_function" href="#aca9f1a9b278dd911add0d10351e8089d">components</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Component_html"><div class="ttname"><a href="classregina_1_1Component.html">regina::Component</a></div><div class="ttdoc">A connected component of a dim-manifold triangulation.</div><div class="ttdef"><b>Definition</b> component.h:79</div></div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_aca9f1a9b278dd911add0d10351e8089d"><div class="ttname"><a href="#aca9f1a9b278dd911add0d10351e8089d">regina::detail::TriangulationBase::components</a></div><div class="ttdeci">auto components() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all components of this triangula...</div><div class="ttdef"><b>Definition</b> triangulation.h:4923</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual component objects <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="#aca9f1a9b278dd911add0d10351e8089d" title="Returns an object that allows iteration through and random access to all components of this triangula...">components()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all components. </dd></dl>

</div>
</div>
<a id="a658bf830fdf052e1beaa5423298c51b2" name="a658bf830fdf052e1beaa5423298c51b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658bf830fdf052e1beaa5423298c51b2">&#9670;&#160;</a></span>countBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary components in this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary components. </dd></dl>

</div>
</div>
<a id="a38cea5a70cdc8bf81306e413b69a472c" name="a38cea5a70cdc8bf81306e413b69a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cea5a70cdc8bf81306e413b69a472c">&#9670;&#160;</a></span>countBoundaryFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary <em>subdim</em>-faces in this triangulation. </p>
<p>This is the fastest way to count faces if you know <em>subdim</em> at compile time.</p>
<p>Specifically, this counts the number of <em>subdim</em>-faces for which isBoundary() returns <code>true</code>. This may lead to some unexpected results in non-standard scenarios; see the documentation for the non-templated countBoundaryFaces(int) for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>countBoundaryFaces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a7a0734a644b899ff1ff8f58554547452" name="a7a0734a644b899ff1ff8f58554547452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0734a644b899ff1ff8f58554547452">&#9670;&#160;</a></span>countBoundaryFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFaces </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime. </p>
<p>This routine takes linear time in the dimension <em>dim</em>. For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <code>countBoundaryFaces&lt;subdim&gt;()</code> instead, which is fast constant time.</p>
<p>Specifically, this counts the number of <em>subdim</em>-faces for which isBoundary() returns <code>true</code>. This may lead to some unexpected results in non-standard scenarios; for example:</p>
<ul>
<li>In <a class="el" href="stddim.html">non-standard dimensions</a>, ideal vertices are not recognised and so will not be counted as boundary;</li>
<li>In an invalid triangulation, the number of boundary faces reported here may be smaller than the number of faces obtained when you triangulate the boundary using <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#aa2d51205dc9900043de370654f2c097c" title="Returns the full (dim-1)-dimensional triangulation of this boundary component.">BoundaryComponent::build()</a>. This is because "pinched" faces (where separate parts of the boundary are identified together) will only be counted once here, but will "spring apart" into multiple faces when the boundary is triangulated.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative or greater than <em>dim</em>-1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a8c1a05fe022a95b928a068f9909b036c" name="a8c1a05fe022a95b928a068f9909b036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1a05fe022a95b928a068f9909b036c">&#9670;&#160;</a></span>countBoundaryFacets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of boundary facets in this triangulation. </p>
<p>This routine counts facets of top-dimensional simplices that are not glued to some adjacent top-dimensional simplex.</p>
<p>This is equivalent to calling countBoundaryFaces&lt;dim-1&gt;().</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a id="a20e5dba7654710e79eecaf849f248d38" name="a20e5dba7654710e79eecaf849f248d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e5dba7654710e79eecaf849f248d38">&#9670;&#160;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of connected components in this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a id="addf438f54b1ccec5a42916b00132ed2f" name="addf438f54b1ccec5a42916b00132ed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf438f54b1ccec5a42916b00132ed2f">&#9670;&#160;</a></span>countEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;1&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a929d32300a09aa008d03099e4b84e873" name="a929d32300a09aa008d03099e4b84e873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929d32300a09aa008d03099e4b84e873">&#9670;&#160;</a></span>countFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this triangulation. </p>
<p>This is the fastest way to count faces if you know <em>subdim</em> at compile time.</p>
<p>For convenience, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>. This is <em>not</em> the case for the routines <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> and <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a>, which give access to individual faces (the reason relates to the fact that top-dimensional simplices are built manually, whereas lower-dimensional faces are deduced properties).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>countFaces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em> inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ad51bc921de7b1971061a1a2353f9ad96" name="ad51bc921de7b1971061a1a2353f9ad96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51bc921de7b1971061a1a2353f9ad96">&#9670;&#160;</a></span>countFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this triangulation, where the face dimension does not need to be known until runtime. </p>
<p>This routine takes linear time in the dimension <em>dim</em>. For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <code>countFaces&lt;subdim&gt;()</code> instead, which is fast constant time.</p>
<p>For convenience, this routine explicitly supports the case <em>subdim</em> = <em>dim</em>. This is <em>not</em> the case for the routines <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> and <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a>, which give access to individual faces (the reason relates to the fact that top-dimensional simplices are built manually, whereas lower-dimensional faces are deduced properties).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative or greater than <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a10f6885850adfdf4c8c278dd241f5f90" name="a10f6885850adfdf4c8c278dd241f5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f6885850adfdf4c8c278dd241f5f90">&#9670;&#160;</a></span>countPentachora()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countPentachora </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;4&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p>See <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a2e4329504df39fb7dbf796600329146d" name="a2e4329504df39fb7dbf796600329146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4329504df39fb7dbf796600329146d">&#9670;&#160;</a></span>countTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countTetrahedra </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;3&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p>See <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a0ff1fb3c66e81c2d533e1fac79439126" name="a0ff1fb3c66e81c2d533e1fac79439126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1fb3c66e81c2d533e1fac79439126">&#9670;&#160;</a></span>countTriangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countTriangles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;2&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="a4978fb0aeb2d208806404431e445a567" name="a4978fb0aeb2d208806404431e445a567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4978fb0aeb2d208806404431e445a567">&#9670;&#160;</a></span>countVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countVertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;0&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further information. </p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a085f589f5d63dbbac25978cf350ff459" name="a085f589f5d63dbbac25978cf350ff459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085f589f5d63dbbac25978cf350ff459">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Graphviz DOT representation of the dual graph of this triangulation. </p>
<p>Every vertex of this graph represents a top-dimensional simplex, and every edge represents a pair of simplex facets that are joined together. Note that for a closed triangulation this graph will be entirely (<em>dim</em> + 1)-valent; for triangulations with boundary facets, some graph vertices will have degree <em>dim</em> or less.</p>
<p>The output from this routine can be used as a standalone DOT file, ready for use with Graphviz. This DOT file will describe an <em>undirected</em> graph, and should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<p>The functions <a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">Triangulation&lt;dim&gt;::dot()</a> and <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">FacetPairing&lt;dim&gt;::dot()</a> differ in a few ways:</p>
<ul>
<li><a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">Triangulation&lt;dim&gt;::dot()</a> does not support <em>subgraph</em> output (where you construct a large DOT file containing the dual graphs of many independent triangulations). If you need subgraph output, you can always call <code><a class="el" href="#a839950f320f6f0ca655e7a880a66c2ee" title="Returns the dual graph of this triangulation, expressed as a facet pairing.">pairing()</a>.<a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">dot()</a></code> instead.</li>
<li><a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">Triangulation&lt;dim&gt;::dot()</a> makes more use of colour, in particular to indicate locked top-dimensional simplices and/or facets.</li>
</ul>
<p>If you are simply writing this string to an output stream then you should call <a class="el" href="#a856a84ed29cd61f1b3bea9df595fb981" title="Writes the dual graph of this triangulation in the Graphviz DOT language.">writeDot()</a> instead, which is more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="#a856a84ed29cd61f1b3bea9df595fb981" title="Writes the dual graph of this triangulation in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="aa378edda664e87c4052114248722857b" name="aa378edda664e87c4052114248722857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa378edda664e87c4052114248722857b">&#9670;&#160;</a></span>doubleCover()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::doubleCover </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the orientable double cover of this triangulation. </p>
<p>Each orientable component will be duplicated, and each non-orientable component will be converted into its orientable double cover.</p>
<p>In general, the resulting double cover will <em>not</em> be oriented (though of course it will always be orientable).</p>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, then these locks will be duplicated alongside their corresponding simplices and/or facets (i.e., they will appear in both sheets of the double cover).</p>
<dl class="section return"><dt>Returns</dt><dd>the orientable double cover. </dd></dl>

</div>
</div>
<a id="a0c5afdac1c0dee2db962be81e187d973" name="a0c5afdac1c0dee2db962be81e187d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5afdac1c0dee2db962be81e187d973">&#9670;&#160;</a></span>doubleOverBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::doubleOverBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns two copies of this triangulation joined together along their boundary facets. </p>
<p>Specifically: the resulting triangulation is obtained by taking two copies <em>S</em> and <em>T</em> of this triangulation, and then gluing each boundary facet of <em>S</em> to the corresponding boundary facet of <em>T</em> using the identity permutation.</p>
<p>Any ideal vertices will be left alone (i.e., the ideal boundary components of <em>S</em> and <em>T</em> will <em>not</em> be joined together).</p>
<p>The resulting triangulation will not have any boundary facets. It will also not be oriented, even if this original triangulation <em>is</em> oriented, since <em>S</em> and <em>T</em> will be reflections of each other through the original triangulation boundary.</p>
<p>If this triangulation has no boundary facets (even if it <em>does</em> have ideal boundary components, then the result will simply be two disjoint copies of this original triangulation.</p>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, then these locks will be duplicated alongside their corresponding simplices and/or facets (i.e., they will appear in both copies of the original triangulation). Any locks on boundary facets will <em>not</em> prevent this operation from completing successfully (i.e., they will not prevent the two copies <em>S</em> and <em>T</em> from being glued together).</p>
<dl class="section return"><dt>Returns</dt><dd>two copies of this triangulation joined along their boundary facets. </dd></dl>

</div>
</div>
<a id="ae9418f87d687dd5e488b972a5ff7992a" name="ae9418f87d687dd5e488b972a5ff7992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9418f87d687dd5e488b972a5ff7992a">&#9670;&#160;</a></span>dualBoundaryMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualBoundaryMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>dualBoundaryMap&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>dualBoundaryMap(subdim)</code>.</p>
<p>See the non-templated dualBoundaryMap(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>dualBoundaryMap(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dual face dimension; this must be between 1 and <em>dim</em> inclusive if <em>dim</em> is one of Regina's standard dimensions, or between 1 and (<em>dim</em> - 1) inclusive otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="a346459be4eb9fbb487340a7d3441e1ef" name="a346459be4eb9fbb487340a7d3441e1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346459be4eb9fbb487340a7d3441e1ef">&#9670;&#160;</a></span>dualBoundaryMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualBoundaryMap </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces of the triangulation, where the face dimension does not need to be known until runtime. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <code>dualBoundaryMap&lt;subdim&gt;()</code> instead, which is slightly faster.</p>
<p>This function is analogous to <a class="el" href="#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a>, but is designed to work with dual faces instead of ordinary (primal) faces. In particular, this is used in the implementation of <a class="el" href="#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology()</a>, which works with the dual skeleton in order to effectively truncate ideal vertices.</p>
<p>The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th dual <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th dual (<em>subdim</em>-1)-face of this triangulation. Here we index dual faces in the same order as the (primal) faces of the triangulation that they are dual to, except that we omit primal <em>boundary</em> faces (i.e., primal faces for which <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a2fc849ef77244993696cbfe08083f336" title="Determines if this face lies entirely on the boundary of the triangulation.">Face::isBoundary()</a> returns <code>true</code>). Therefore, for triangulations with boundary, the dual face indices and the corresponding primal face indices might not be equal.</p>
<p>For this dual boundary map, for positive dual face dimensions <em>k</em>, we fix the orientations of the dual <em>k</em>-faces as follows:</p>
<ul>
<li>In simplicial homology, the orientation of a <em>k</em>-simplex is determined by assigning labels 0,...,<em>k</em> to its vertices.</li>
<li>Consider a dual <em>k</em>-face <em>d</em>, and let this be dual to the primal (<em>dim</em>-<em>k</em>)-face <em>f</em>. In general, <em>d</em> will <em>not</em> be a simplex. Let <em>B</em> denote the barycentre of <em>f</em> (which also appears as the "centre" point of <em>d</em>).</li>
<li>Let <em>emb</em> be an arbitrary <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a>&lt;dim-k&gt; for <em>f</em> (i.e., chosen from <code>f.embeddings()</code>), and let <em>s</em> be the corresponding top-dimensional simplex containing <em>f</em> (i.e., <code>emb.simplex()</code>). For the special case of dual edges (<em>k</em> = 1), this choice matters; here we choose <em>emb</em> to be the first embedding (that is, <code>f.front()</code>). For larger <em>k</em> this choice does not matter; see below for the reasons why.</li>
<li>Now consider how <em>d</em> intersects the top-dimensional simplex <em>s</em>. This intersection is a <em>k</em>-polytope with <em>B</em> as one of its vertices. We can extend this polytope away from <em>B</em>, pushing it all the way through the simplex <em>s</em>, until it becomes a <em>k</em>-simplex <em>g</em> whose vertices are <em>B</em> along with the <em>k</em> "unused" vertices of <em>s</em> that do <em>not</em> appear in <em>f</em>.</li>
<li>We can now define the orientation of the dual <em>k</em>-face <em>d</em> to be the orientation of this <em>k</em>-simplex <em>g</em> that contains it. All that remains now is to orient <em>g</em> by choosing a labelling 0,...,<em>k</em> for its vertices.</li>
<li>To orient <em>g</em>, we assign the label 0 to <em>B</em>, and we assign the labels 1,...,<em>k</em> to the "unused" vertices <code>v[dim-k+1]</code>,...,<code>v[dim]</code> of <em>s</em> respectively, where <em>v</em> is the permutation <code>emb.vertices()</code>.</li>
<li>Finally, we note that for <em>k</em> &gt; 1, the orientation for <em>d</em> does not depend on the particular choice of <em>s</em> and <em>emb:</em> by the preconditions and the fact that this routine only considers duals of non-boundary faces, the link of <em>f</em> must be a sphere, and therefore the images of those "other" vertices are fixed in a way that preserves orientation as you walk around the link. See the documentation for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">Simplex&lt;dim&gt;::faceMapping()</a> for details.</li>
<li>For the special case of dual edges (<em>k</em> = 1), the conditions above can be described more simply: the two endpoints of the dual edge <em>d</em> correspond to the two top-dimensional simplices on either side of the (<em>dim</em>-1)-face <em>f</em>, and we orient <em>d</em> by labelling these endpoints (0, 1) in the order (<code>f.back()</code>, <code>f.front()</code>).</li>
</ul>
<p>If you wish to convert these boundary maps to homology groups yourself, either the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class (if you do not need to track which dual face is which) or the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class (if you do need to track individual dual faces) can help you do this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (as documented for the <em>subdim</em> argument below).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the dual face dimension; this must be between 1 and <em>dim</em> inclusive if <em>dim</em> is one of Regina's standard dimensions, or between 1 and (<em>dim</em> - 1) inclusive otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary map from dual <em>subdim</em>-faces to dual (<em>subdim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="ae61a040faab0610d2dbfc515c94abb04" name="ae61a040faab0610d2dbfc515c94abb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61a040faab0610d2dbfc515c94abb04">&#9670;&#160;</a></span>dualToPrimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualToPrimal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map from dual chains to primal chains that preserves homology classes. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>dualToPrimal&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>dualToPrimal(subdim)</code>.</p>
<p>See the non-templated dualToPrimal(int) for full details on what this function computes and how the matrix it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This trianguation is valid, non-empty, and non-ideal. Note that Regina can only detect ideal triangulations in <a class="el" href="stddim.html">standard dimensions</a>; for higher dimensions it is the user's reponsibility to confirm this some other way.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>dualToPrimal(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the chain dimension; this must be between 0 and (<em>dim</em> - 1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from dual <em>subdim</em>-chains to primal <em>subdim</em>-chains. </dd></dl>

</div>
</div>
<a id="aaef2f61c320f8f9da4ea89715f3c2873" name="aaef2f61c320f8f9da4ea89715f3c2873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef2f61c320f8f9da4ea89715f3c2873">&#9670;&#160;</a></span>dualToPrimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dualToPrimal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map from dual chains to primal chains that preserves homology classes, where the chain dimension does not need to be known until runtime. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you are better off using the template function <code>dualToPrimal&lt;subdim&gt;()</code> instead, which is slightly faster.</p>
<p>The matrix that is returned should be thought of as acting on column vectors. Specifically, the <em>c</em>th column of the matrix corresponds to the <em>c</em>th dual <em>subdim</em>-face of this triangulation, and the <em>r</em>th row corresponds to the <em>r</em>th primal <em>subdim</em>-face of this triangulation.</p>
<p>We index and orient these dual and primal faces in the same manner as <a class="el" href="#ae9418f87d687dd5e488b972a5ff7992a" title="Returns the boundary map from dual subdim-faces to dual (subdim-1)-faces of the triangulation.">dualBoundaryMap()</a> and <a class="el" href="#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a> respectively. In particular, dual faces are indexed in the same order as the primal (<em>dim</em>-<em>subdim</em>)-faces of the triangulation that they are dual to, except that we omit primal boundary faces. See <a class="el" href="#ae9418f87d687dd5e488b972a5ff7992a" title="Returns the boundary map from dual subdim-faces to dual (subdim-1)-faces of the triangulation.">dualBoundaryMap()</a> and <a class="el" href="#abdfa4594ab1ba473360ff7b91750f49a" title="Returns the boundary map from subdim-faces to (subdim-1)-faces of the triangulation.">boundaryMap()</a> for further details.</p>
<p>The key feature of this map is that, if a column vector <em>v</em> represents a cycle <em>c</em> in the dual chain complex (i.e., it is a chain with zero boundary), and if this map is represented by the matrix <em>M</em>, then the vector <code>M×v</code> represents a cycle in the primal chain complex that belongs to the same <em>subdim</em>th homology class as <em>c</em>.</p>
<p>Regarding implementation: the map is constructed by (i) subdividing each dual face into smaller <em>subdim</em>-simplices whose vertices are barycentres of primal faces of different dimensions, (ii) moving each barycentre to vertex 0 of the corresponding face, and then (iii) discarding any resulting simplices with repeated vertices (which become "flattened" to a dimension less than <em>subdim</em>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This trianguation is valid, non-empty, and non-ideal. Note that Regina can only detect ideal triangulations in <a class="el" href="stddim.html">standard dimensions</a>; for higher dimensions it is the user's reponsibility to confirm this some other way.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The chain dimension <em>subdim</em> is outside the supported range (as documented for the <em>subdim</em> argument below).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the chain dimension; this must be between 0 and (<em>dim</em> - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the map from dual <em>subdim</em>-chains to primal <em>subdim</em>-chains. </dd></dl>

</div>
</div>
<a id="ace7c9ec1168ef9e7cb34b3e4a5b9b873" name="ace7c9ec1168ef9e7cb34b3e4a5b9b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7c9ec1168ef9e7cb34b3e4a5b9b873">&#9670;&#160;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that returns C++ code to reconstruct this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000228">Deprecated</a></b></dt><dd>This is equivalent to calling <code>source(Language::Cxx)</code>, for compatibility with older versions of Regina. In particular, it is <em>not</em> equivalent to calling <code><a class="el" href="#a969c32d5436daaee2e541628559c775b" title="Returns C++ or Python source code that can be used to reconstruct this triangulation.">source()</a></code> (which defaults to the programming language currently being used). See <a class="el" href="#a969c32d5436daaee2e541628559c775b" title="Returns C++ or Python source code that can be used to reconstruct this triangulation.">source()</a> for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="a25e675a24773baa6ddca79a6ae7e2899" name="a25e675a24773baa6ddca79a6ae7e2899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e675a24773baa6ddca79a6ae7e2899">&#9670;&#160;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;1&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ae935e2e6267aab03599c1eeacee2dc78" name="ae935e2e6267aab03599c1eeacee2dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935e2e6267aab03599c1eeacee2dc78">&#9670;&#160;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;1&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="aa87b9f9c40a48cee3a1ee9c71bd70fef" name="aa87b9f9c40a48cee3a1ee9c71bd70fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87b9f9c40a48cee3a1ee9c71bd70fef">&#9670;&#160;</a></span>ensureSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::ensureSkeleton </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all "on demand" skeletal objects have been calculated. </p>

</div>
</div>
<a id="a8063bd8d3c1ff8d896ae0a24db2203d5" name="a8063bd8d3c1ff8d896ae0a24db2203d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8063bd8d3c1ff8d896ae0a24db2203d5">&#9670;&#160;</a></span>eulerCharTri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::eulerCharTri </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euler characteristic of this triangulation. </p>
<p>This will be evaluated strictly as the alternating sum of the number of <em>i</em>-faces (that is, <code><a class="el" href="#a4978fb0aeb2d208806404431e445a567" title="A dimension-specific alias for countFaces&lt;0&gt;().">countVertices()</a> - <a class="el" href="#addf438f54b1ccec5a42916b00132ed2f" title="A dimension-specific alias for countFaces&lt;1&gt;().">countEdges()</a> + <a class="el" href="#a0ff1fb3c66e81c2d533e1fac79439126" title="A dimension-specific alias for countFaces&lt;2&gt;().">countTriangles()</a> - ...</code>).</p>
<p>Note that this routine handles ideal triangulations in a non-standard way. Since it computes the Euler characteristic of the triangulation (and not the underlying manifold), this routine will treat each ideal boundary component as a single vertex, and <em>not</em> as an entire (<em>dim</em>-1)-dimensional boundary component.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, for a routine that handles ideal boundary components properly (by treating them as (<em>dim</em>-1)-dimensional boundary components when computing Euler characteristic), you can use the routine eulerCharManifold() instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of this triangulation. </dd></dl>

</div>
</div>
<a id="a4c4df33248af1794170e1ca76cd59256" name="a4c4df33248af1794170e1ca76cd59256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4df33248af1794170e1ca76cd59256">&#9670;&#160;</a></span>face() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for Python programmers. </p>
<p>For C++ users, this routine is not very useful: since precise types must be know at compile time, this routine returns a std::variant <em>v</em> that could store a pointer to any class Face&lt;dim, ...&gt;. This means you cannot access the face directly: you will still need some kind of compile-time knowledge of <em>subdim</em> before you can extract and use an appropriate Face&lt;dim, subdim&gt; object from <em>v</em>. However, once you know <em>subdim</em> at compile time, you are better off using the (simpler and faster) routine <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;subdim&gt;()</a> instead.</p>
<p>For Python users, this routine is much more useful: the return type can be chosen at runtime, and so this routine simply returns a Face&lt;dim, subdim&gt; object of the appropriate face dimension that you can use immediately.</p>
<p>The specific return type for C++ programmers will be std::variant&lt;Face&lt;dim, 0&gt;*, ..., <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a>&lt;dim, dim-1&gt;*&gt;.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative, or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="a802ea1cdd46af32418fb76c49712ccb8" name="a802ea1cdd46af32418fb76c49712ccb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802ea1cdd46af32418fb76c49712ccb8">&#9670;&#160;</a></span>face() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face of this triangulation, in a way that is optimised for C++ programmers. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>face(subdim, index)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ac4a59c70ef42fd731d7167df4973f389" name="ac4a59c70ef42fd731d7167df4973f389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a59c70ef42fd731d7167df4973f389">&#9670;&#160;</a></span>faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for C++ programmers. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1Face.html">Face&lt;dim, subdim&gt;</a>* f : tri.<a class="code hl_function" href="#ac4a59c70ef42fd731d7167df4973f389">faces</a>&lt;subdim&gt;()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Face_html"><div class="ttname"><a href="classregina_1_1Face.html">regina::Face</a></div><div class="ttdoc">Represents a subdim-face in the skeleton of a dim-dimensional triangulation.</div><div class="ttdef"><b>Definition</b> face.h:116</div></div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_ac4a59c70ef42fd731d7167df4973f389"><div class="ttname"><a href="#ac4a59c70ef42fd731d7167df4973f389">regina::detail::TriangulationBase::faces</a></div><div class="ttdeci">auto faces() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all subdim-faces of this triangu...</div><div class="ttdef"><b>Definition</b> triangulation.h:4936</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the triangulation exists. In contrast, however, remember that the individual faces <em>within</em> this list will be deleted and replaced each time the triangulation changes. Therefore it is best to treat this object as temporary only, and to call <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> again each time you need it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>faces(subdim)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ae0813f17eb6b6c91802b73403a5258d6" name="ae0813f17eb6b6c91802b73403a5258d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0813f17eb6b6c91802b73403a5258d6">&#9670;&#160;</a></span>faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subdim</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation, in a way that is optimised for Python programmers. </p>
<p>C++ users should not use this routine. The return type must be fixed at compile time, and so it is a std::variant that can hold any of the lightweight return types from the templated <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;subdim&gt;()</a> function. This means that the return value will still need compile-time knowledge of <em>subdim</em> to extract and use the appropriate face objects. However, once you know <em>subdim</em> at compile time, you are much better off using the (simpler and faster) routine <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;subdim&gt;()</a> instead.</p>
<p>For Python users, this routine is much more useful: the return type can be chosen at runtime, and so this routine returns a Python list of Face&lt;dim, subdim&gt; objects (holding all the <em>subdim</em>-faces of the triangulation), which you can use immediately.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The face dimension <em>subdim</em> is outside the supported range (i.e., negative, or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="a0481813042dab2c6140fc8d6fbbd189d" name="a0481813042dab2c6140fc8d6fbbd189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0481813042dab2c6140fc8d6fbbd189d">&#9670;&#160;</a></span>findAllIsomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllIsomorphisms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>This routine behaves identically to <a class="el" href="#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a>, except that instead of returning just one isomorphism, all such isomorphisms will be found and processed. See the <a class="el" href="#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> notes for details on this.</p>
<p>For each isomorphism that is found, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be of type <code>(const <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a>&lt;dim&gt;&amp;)</code>; this will be a reference to the isomorphism that was found. If <em>action</em> wishes to keep the isomorphism, it should take a deep copy (not a reference), since the isomorphism may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that the search for isomorphisms should continue, and a return value of <code>true</code> indicates that the search should terminate immediately.</li>
<li>This triangulation <em>must</em> remain constant while the search runs (i.e., <em>action</em> must not modify the triangulation).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>findAllIsomorphisms(other, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, the return value indicates whether <em>action</em> ever terminated the search, but it does <em>not</em> take an additonal argument list (<em>args</em>). The second form is <code>findAllIsomorphisms(other)</code>, which returns a Python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each isomorphism that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial isomorphism argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="ac3ea60c854787cc26a39618dcdf2196b" name="ac3ea60c854787cc26a39618dcdf2196b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ea60c854787cc26a39618dcdf2196b">&#9670;&#160;</a></span>findAllSubcomplexesIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllSubcomplexesIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>This routine behaves identically to <a class="el" href="#a868e42b826a392816a796e0e15f85ded" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a>, except that instead of returning just one isomorphism (which may be boundary incomplete and need not be onto), all such isomorphisms will be found and processed. See the <a class="el" href="#a868e42b826a392816a796e0e15f85ded" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a> notes for details on this.</p>
<p>For each isomorphism that is found, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be of type <code>(const <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a>&lt;dim&gt;&amp;)</code>; this will be a reference to the isomorphism that was found. If <em>action</em> wishes to keep the isomorphism, it should take a deep copy (not a reference), since the isomorphism may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that the search for isomorphisms should continue, and a return value of <code>true</code> indicates that the search should terminate immediately.</li>
<li>This triangulation <em>must</em> remain constant while the search runs (i.e., <em>action</em> must not modify the triangulation).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>findAllSubcomplexesIn(other, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, the return value indicates whether <em>action</em> ever terminated the search, but it does <em>not</em> take an additonal argument list (<em>args</em>). The second form is <code>findAllSubcomplexesIn(other)</code>, which returns a Python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for isomorphic copies of this triangulation. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each isomorphism that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial isomorphism argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="adc25a58b48e39f3c7f8621b84432d294" name="adc25a58b48e39f3c7f8621b84432d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25a58b48e39f3c7f8621b84432d294">&#9670;&#160;</a></span>finiteToIdeal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::finiteToIdeal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="#a3c2c6b8c7500d6604eee71065addf0aa" title="Converts each real boundary component into a cusp (i.e., an ideal vertex).">makeIdeal()</a>, which converts each real boundary component into an ideal vertex. </p>
<p>This alias <a class="el" href="#adc25a58b48e39f3c7f8621b84432d294" title="Alias for makeIdeal(), which converts each real boundary component into an ideal vertex.">finiteToIdeal()</a> is provided for compatibility with older versions of Regina. (It is <em>not</em> deprecated, and so this alias should remain part of Regina for a long time.)</p>
<p>See <a class="el" href="#a3c2c6b8c7500d6604eee71065addf0aa" title="Converts each real boundary component into a cusp (i.e., an ideal vertex).">makeIdeal()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This triangulation contains at least one locked boundary facet. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a id="af25408f7eb0b1c5bc3a87b1e93e7d0d2" name="af25408f7eb0b1c5bc3a87b1e93e7d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25408f7eb0b1c5bc3a87b1e93e7d0d2">&#9670;&#160;</a></span>fromGluings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromGluings </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>beginGluings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>endGluings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a triangulation from a list of gluings. </p>
<p>This routine is an analogue to the variant of <a class="el" href="#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">fromGluings()</a> that takes a C++ initialiser list; however, here the input data may be constructed at runtime (which makes it accessible to Python, amongst other things).</p>
<p>The iterator range (<em>beginGluings</em>, <em>endGluings</em>) should encode the list of gluings for the triangulation. Each iterator in this range must dereference to a tuple of the form (<em>simp</em>, <em>facet</em>, <em>adj</em>, <em>gluing</em>); here <em>simp</em>, <em>facet</em> and <em>adj</em> are all integers, and <em>gluing</em> is of type <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;. Each such tuple indicates that facet <em>facet</em> of top-dimensional simplex number <em>simp</em> should be glued to top-dimensional simplex number <em>adj</em> using the permutation <em>gluing</em>. In other words, such a tuple encodes the same information as calling <code>simplex(simp).join(facet, simplex(adj), gluing)</code> upon the triangulation being constructed.</p>
<p>Every gluing should be encoded from <em>one direction only</em>. This means, for example, that to build a closed 3-manifold triangulation with <em>n</em> tetrahedra, you would pass a list of 2<em>n</em> such tuples. If you attempt to make the same gluing twice (e.g., once from each direction), then this routine will throw an exception.</p>
<p>Any facet of a simplex that does not feature in the given list of gluings (either as a source or a destination) will be left as a boundary facet.</p>
<p>Note that, as usual, the top-dimensional simplices are numbered 0,...,(<em>size</em>-1), and the facets of each simplex are numbered 0,...,<em>dim</em>.</p>
<p>As an example, Python users can construct the figure eight knot complement as follows:</p>
<div class="fragment"><div class="line">tri = Triangulation3.fromGluings(2, [</div>
<div class="line">    ( 0, 0, 1, Perm4(1,3,0,2) ), ( 0, 1, 1, Perm4(2,0,3,1) ),</div>
<div class="line">    ( 0, 2, 1, Perm4(0,3,2,1) ), ( 0, 3, 1, Perm4(2,1,0,3) )])</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The assumption is that the iterators dereference to a std::tuple&lt;size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;&gt;. However, this is not strictly necessary - the dereferenced type may be any type that supports std::get (and for which std::get&lt;0..3&gt;() yields suitable integer/permutation types).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given list of gluings does not correctly describe a triangulation with <em>size</em> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The gluings should be passed as a single Python list of tuples (not an iterator pair).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of top-dimensional simplices in the triangulation to construct. </td></tr>
    <tr><td class="paramname">beginGluings</td><td>the beginning of the list of gluings, as described above. </td></tr>
    <tr><td class="paramname">endGluings</td><td>a past-the-end iterator indicating the end of the list of gluings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="ad91567ffbe224dcd1f1da3cb273efe49" name="ad91567ffbe224dcd1f1da3cb273efe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91567ffbe224dcd1f1da3cb273efe49">&#9670;&#160;</a></span>fromGluings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromGluings </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>gluings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a triangulation from a hard-coded list of gluings. </p>
<p>This routine takes a C++ initialiser list, which makes it useful for creating hard-coded examples directly in C++ code without needing to write a tedious sequence of calls to <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">Simplex&lt;dim&gt;::join()</a>.</p>
<p>Each element of the initialiser list should be a tuple of the form (<em>simp</em>, <em>facet</em>, <em>adj</em>, <em>gluing</em>), which indicates that facet <em>facet</em> of top-dimensional simplex number <em>simp</em> should be glued to top-dimensional simplex number <em>adj</em> using the permutation <em>gluing</em>. In other words, such a tuple encodes the same information as calling <code>simplex(simp).join(facet, simplex(adj), gluing)</code> upon the triangulation being constructed.</p>
<p>Every gluing should be encoded from <em>one direction only</em>. This means, for example, that to build a closed 3-manifold triangulation with <em>n</em> tetrahedra, you would pass a list of 2<em>n</em> such tuples. If you attempt to make the same gluing twice (e.g., once from each direction), then this routine will throw an exception.</p>
<p>Any facet of a simplex that does not feature in the given list of gluings (either as a source or a destination) will be left as a boundary facet.</p>
<p>Note that, as usual, the top-dimensional simplices are numbered 0,...,(<em>size</em>-1), and the facets of each simplex are numbered 0,...,<em>dim</em>.</p>
<p>As an example, you can construct the figure eight knot complement using the following code:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classregina_1_1Triangulation.html">Triangulation&lt;3&gt;</a> tri = <a class="code hl_function" href="#ad91567ffbe224dcd1f1da3cb273efe49">Triangulation&lt;3&gt;::fromGluings</a>(2, {</div>
<div class="line">    { 0, 0, 1, {1,3,0,2} }, { 0, 1, 1, {2,0,3,1} },</div>
<div class="line">    { 0, 2, 1, {0,3,2,1} }, { 0, 3, 1, {2,1,0,3} }});</div>
<div class="ttc" id="aclassregina_1_1Triangulation_html"><div class="ttname"><a href="classregina_1_1Triangulation.html">regina::Triangulation</a></div><div class="ttdoc">A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...</div><div class="ttdef"><b>Definition</b> triangulation.h:159</div></div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_ad91567ffbe224dcd1f1da3cb273efe49"><div class="ttname"><a href="#ad91567ffbe224dcd1f1da3cb273efe49">regina::detail::TriangulationBase::fromGluings</a></div><div class="ttdeci">static Triangulation&lt; dim &gt; fromGluings(size_t size, std::initializer_list&lt; std::tuple&lt; size_t, int, size_t, Perm&lt; dim+1 &gt; &gt; &gt; gluings)</div><div class="ttdoc">Creates a triangulation from a hard-coded list of gluings.</div><div class="ttdef"><b>Definition</b> triangulation.h:5465</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you have an existing triangulation that you would like to hard-code in this way, you can call <a class="el" href="#a969c32d5436daaee2e541628559c775b" title="Returns C++ or Python source code that can be used to reconstruct this triangulation.">source()</a> to generate the corresponding source code.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given list of gluings does not correctly describe a triangulation with <em>size</em> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the variant of <a class="el" href="#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">fromGluings()</a> that takes this same data using a Python list (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of top-dimensional simplices in the triangulation to construct. </td></tr>
    <tr><td class="paramname">gluings</td><td>describes the gluings between these top-dimensional simplices, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="af91da7bdae05981c20c2e3ee234cc48d" name="af91da7bdae05981c20c2e3ee234cc48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91da7bdae05981c20c2e3ee234cc48d">&#9670;&#160;</a></span>fromIsoSig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromIsoSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a full triangulation from an isomorphism signature. </p>
<p>See <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>Currently this routine only supports isomorphism signatures that were created with the default encoding (i.e., there was no <em>Encoding</em> template parameter passed to <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>).</p>
<p>Calling <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> followed by <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> is not guaranteed to produce an <em>identical</em> triangulation to the original, but it is guaranteed to produce a combinatorially <em>isomorphic</em> triangulation. In other words, <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> may reconstruct the triangulation with its simplices and/or vertices relabelled. The optional argument to <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> allows you to determine the precise relabelling that will be used, if you need to know it.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid <em>dim</em>-dimensional isomorphism signature created using the default encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signatures are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="a776984602dd80817c160e797aeca67c3" name="a776984602dd80817c160e797aeca67c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776984602dd80817c160e797aeca67c3">&#9670;&#160;</a></span>fromSig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, to recover a full triangulation from an isomorphism signature. </p>
<p>This alias <a class="el" href="#a776984602dd80817c160e797aeca67c3" title="Alias for fromIsoSig(), to recover a full triangulation from an isomorphism signature.">fromSig()</a> is provided to assist with generic code that can work with both triangulations and links.</p>
<p>See <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid <em>dim</em>-dimensional isomorphism signature created using the default encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signatures are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed triangulation. </dd></dl>

</div>
</div>
<a id="a408718df2c6cc65f21adabc50850ec63" name="a408718df2c6cc65f21adabc50850ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408718df2c6cc65f21adabc50850ec63">&#9670;&#160;</a></span>fundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fundamentalGroup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>, which returns the fundamental group of this triangulation. </p>
<p>See <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for further details, including how ideal vertices and invalid faces are managed.</p>
<dl class="section note"><dt>Note</dt><dd>In Regina 7.2, the routine <a class="el" href="#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> was renamed to <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for brevity and for consistency with <a class="el" href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">Link::group()</a>. This more expressive name <a class="el" href="#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> will be kept as a long-term alias, and you are welcome to continue using it if you prefer.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute the fundamental group with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::fundamentalGroupFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a id="ad5c48ed1736e27aa09620cd924507ef4" name="ad5c48ed1736e27aa09620cd924507ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c48ed1736e27aa09620cd924507ef4">&#9670;&#160;</a></span>fVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the f-vector of this triangulation, which counts the number of faces of all dimensions. </p>
<p>The vector that is returned will have length <em>dim</em>+1. If this vector is <em>f</em>, then <em>f</em>[<em>k</em>] will be the number of <em>k</em>-faces for each 0 ≤ <em>k</em> ≤ <em>dim</em>.</p>
<p>This routine is significantly more heavyweight than <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>. Its advantage is that, unlike the templatised <a class="el" href="#a929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>, it allows you to count faces whose dimensions are not known until runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>the f-vector of this triangulation. </dd></dl>

</div>
</div>
<a id="a419c0f6e468ad24cfc450775c6a19b81" name="a419c0f6e468ad24cfc450775c6a19b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c0f6e468ad24cfc450775c6a19b81">&#9670;&#160;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::group </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fundamental group of this triangulation. </p>
<p>The fundamental group is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the fundamental group will be calculated as if each such vertex had been truncated.</li>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the fundamental group will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the fundamental group will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> might change.</li>
</ul>
<p>Bear in mind that each time the triangulation changes, the fundamental group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<p>Before Regina 7.2, this routine was called <a class="el" href="#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a>. It has since been renamed to <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> for brevity and for consistency with <a class="el" href="classregina_1_1Link.html#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">Link::group()</a>. The more expressive name <a class="el" href="#a408718df2c6cc65f21adabc50850ec63" title="An alias for group(), which returns the fundamental group of this triangulation.">fundamentalGroup()</a> will be kept, and you are welcome to use that instead if you prefer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute the fundamental group with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a8486cf851a69f057505860cda7a92a65" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::fundamentalGroupFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a id="a797ccce735aa5a4eab9433f64b848faa" name="a797ccce735aa5a4eab9433f64b848faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797ccce735aa5a4eab9433f64b848faa">&#9670;&#160;</a></span>has20()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::has20 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a 2-0 move about the given <em>k</em>-face of this triangulation, without violating any simplex and/or facet locks. </p>
<p>For more detail on 2-0 moves and when they can be performed, see <a class="el" href="#a1e874f14510689aa9db756ddc8611ca3" title="If possible, performs a 2-0 move about the given k-face of degree two.">move20()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be 0, 1 or 2, and must not exceed <code>dim - 2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the candidate move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a5ffca92f7a401c3beb7a603d997a088e" name="a5ffca92f7a401c3beb7a603d997a088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffca92f7a401c3beb7a603d997a088e">&#9670;&#160;</a></span>hasBoundaryFacets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation has any boundary facets. </p>
<p>This routine returns <code>true</code> if and only if the triangulation contains some top-dimension simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there are boundary facets. </dd></dl>

</div>
</div>
<a id="a2c51197dbd112bb60b7893cc51a09003" name="a2c51197dbd112bb60b7893cc51a09003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51197dbd112bb60b7893cc51a09003">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>This hash function makes use of Regina's tight encodings. In particular, any two objects with the same tight encoding will have equal hashes. This implementation (and therefore the specific hash value for each object) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows objects of this type to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this object. </dd></dl>

</div>
</div>
<a id="ac40a47a823d15f016cd0efeb9d1b1644" name="ac40a47a823d15f016cd0efeb9d1b1644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40a47a823d15f016cd0efeb9d1b1644">&#9670;&#160;</a></span>hasLocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasLocks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies whether any top-dimensional simplices and/or any of their facets are locked. </p>
<p>In short, locking a top-dimensional simplex and/or some of its facets means that that the simplex and/or facets must not be changed. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for full details on how locks work and what their implications are.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is at least one locked top-dimensional simplex or at least one locked facet of a top-dimensional simplex within this triangulation. </dd></dl>

</div>
</div>
<a id="ad39868427de3611c179664cdef49539b" name="ad39868427de3611c179664cdef49539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39868427de3611c179664cdef49539b">&#9670;&#160;</a></span>hasPachner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasPachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation, without violating any simplex and/or facet locks. </p>
<p>For more detail on Pachner moves and when they can be performed, see <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the candidate move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a285440f69d71e964ec70c897298850ca" name="a285440f69d71e964ec70c897298850ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285440f69d71e964ec70c897298850ca">&#9670;&#160;</a></span>hasShellBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasShellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a boundary shelling move upon the given top-dimensional simplex of this triangulation, without violating any simplex and/or facet locks. </p>
<p>This test is <em>only available in standard dimensions</em>, since Regina's notion of "valid faces" is weaker in higher dimensions (due to the need to solve undecidable problems). See <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face::isValid()</a> for further discussion.</p>
<p>For more detail on boundary shelling moves and when they can be performed, see <a class="el" href="#afa795373077b40844b3e960ab551f861" title="If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangu...">shellBoundary()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. </dd>
<dd>
The given simplex is a simplex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the top-dimensional simplex upon which to perform the candidate move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a34a72bfac6207c6ac044d98cd6ec2081" name="a34a72bfac6207c6ac044d98cd6ec2081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a72bfac6207c6ac044d98cd6ec2081">&#9670;&#160;</a></span>homology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homology </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>homology&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>homology(subdim)</code>.</p>
<p>See the non-templated homology(int) for full details on exactly what this function computes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Unless you are computing first homology (<em>k</em> = 1), this triangulation must be valid, and every face that is not a vertex must have a ball or sphere link. The link condition already forms part of the validity test if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, but in higher dimensions it is the user's own responsibility to ensure this. See <a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid, and the homology dimension <em>k</em> is not 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>homology(k)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to return; this must be between 1 and (<em>dim</em> - 1) inclusive if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, or between 1 and (<em>dim</em> - 2) inclusive if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group. </dd></dl>

</div>
</div>
<a id="adbb67028a0ade026c03ffdc4665f2871" name="adbb67028a0ade026c03ffdc4665f2871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb67028a0ade026c03ffdc4665f2871">&#9670;&#160;</a></span>homology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homology </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, treating any ideal vertices as though they had been truncated, where the parameter <em>k</em> does not need to be known until runtime. </p>
<p>For C++ programmers who know <em>k</em> at compile time, you are better off using the template function <code>homology&lt;k&gt;()</code> instead, which is slightly faster.</p>
<p>A problem with computing homology is that, if <em>dim</em> is not one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, then Regina cannot actually <em>detect</em> ideal vertices (since in general this requires solving undecidable problems). Currently we resolve this by insisting that, in higher dimensions, the homology dimension <em>k</em> is at most (<em>dim</em>-2); the underlying algorithm will then effectively truncate <em>all</em> vertices (since truncating "ordinary" vertices whose links are spheres or balls does not affect the <em>k</em>th homology in such cases).</p>
<p>In general, this routine insists on working with a valid triangulation (see <a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for what this means). However, for historical reasons, if you are computing first homology (<em>k</em> = 1) then your triangulation is allowed to be invalid, though the results might or might not be useful to you. The homology will be computed using the dual skeleton: what this means is that any invalid faces of dimension 0,1,...,(<em>dim</em>-3) will be treated as though their centroids had been truncated, but any invalid (<em>dim</em>-2)-faces will be treated <em>without</em> such truncation. A side-effect is that, after performing a barycentric on an invalid triangulation, the group returned by <a class="el" href="#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">homology&lt;1&gt;()</a> might change.</p>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute homology with fillings, call <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a6347d1e9433a27bd969049d8ca8ef01d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::homologyFilled()</a> instead.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Unless you are computing first homology (<em>k</em> = 1), this triangulation must be valid, and every face that is not a vertex must have a ball or sphere link. The link condition already forms part of the validity test if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, but in higher dimensions it is the user's own responsibility to ensure this. See <a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is invalid, and the homology dimension <em>k</em> is not 1.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The homology dimension <em>k</em> is outside the supported range. This range depends upon the triangulation dimension <em>dim</em>; for details see the documentation below for the argument <em>k</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Like the C++ template function <code>homology&lt;k&gt;()</code>, you can omit the homology dimension <em>k</em>; this will default to 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to return; this must be between 1 and (<em>dim</em> - 1) inclusive if <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, or between 1 and (<em>dim</em> - 2) inclusive if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group. </dd></dl>

</div>
</div>
<a id="a2bf93dbca6715c1a455a2d47f66a6476" name="a2bf93dbca6715c1a455a2d47f66a6476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf93dbca6715c1a455a2d47f66a6476">&#9670;&#160;</a></span>insertTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given triangulation into this triangulation. </p>
<p>The top-dimensional simplices of <em>source</em> will be copied into this triangulation, and placed after any pre-existing simplices. Specifically, if the original size of this triangulation was <em>N</em>, then <code>source.simplex(i)</code> will be copied to a new simplex which will appear as <code>simplex(N+i)</code> of this triangulation.</p>
<p>The copies will use the same vertex numbering and descriptions as the original simplices from <em>source</em>, and any gluings between the simplices of <em>source</em> will likewise be copied across as gluings between their copies in this triangulation.</p>
<p>As a trivial consequence, if this and the given triangulation are both oriented, then the result will preserve these orientations.</p>
<p>If <em>source</em> has locks on any top-dimensional simplices and/or their facets, these locks will also be copied over to this triangulation.</p>
<p>This routine behaves correctly when <em>source</em> is this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a783e33260b58b579886797a0216a7c79" name="a783e33260b58b579886797a0216a7c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783e33260b58b579886797a0216a7c79">&#9670;&#160;</a></span>insertTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given triangulation into this triangulation. </p>
<p>The top-dimensional simplices of <em>source</em> will be moved directly into this triangulation, and placed after any pre-existing simplices. Specifically, if the original size of this triangulation was <em>N</em>, then <code>source.simplex(i)</code> will become <code>simplex(N+i)</code> of this triangulation.</p>
<p>As is normal for an rvalue reference, after calling this function <em>source</em> will be unusable. Any simplex pointers that referred to either this triangulation or <em>source</em> will remain valid (and will all now refer to this triangulation), though if they originally referred to <em>source</em> then they will now return different indices. Any locks on top-dimensional simplices and/or their facets will be preserved.</p>
<p>Calling <code>tri.insertTriangulation(source)</code> (where <em>source</em> is an rvalue reference) is similar to calling <code>source.moveContentsTo(tri)</code>, but it is a little faster since it does not need to leave <em>source</em> in a usable state.</p>
<p>Regarding packet change events: this function does <em>not</em> fire a change event on <em>source</em>, since it assumes that <em>source</em> is about to be destroyed (which will fire a destruction event instead).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>source</em> is not this triangulation.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Only the copying version of this function is available (i.e., the version that takes <em>source</em> as a const reference). If you want a fast move operation, call <code>source.moveContentsTo(this)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a576e6c66cfbb7fabd21cc782c38f300d" name="a576e6c66cfbb7fabd21cc782c38f300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576e6c66cfbb7fabd21cc782c38f300d">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is connected. </p>
<p>This routine returns <code>false</code> only if there is more than one connected component. In particular, it returns <code>true</code> for the empty triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is connected. </dd></dl>

</div>
</div>
<a id="a868e42b826a392816a796e0e15f85ded" name="a868e42b826a392816a796e0e15f85ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868e42b826a392816a796e0e15f85ded">&#9670;&#160;</a></span>isContainedIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>Specifically, this routine determines if there is a boundary incomplete combinatorial isomorphism from this triangulation to <em>other</em>. Boundary incomplete isomorphisms are described in detail in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, note that facets of top-dimensional simplices that lie on the boundary of this triangulation need not correspond to boundary facets of <em>other</em>, and that <em>other</em> may contain more top-dimensional simplices than this triangulation.</p>
<p>Like <a class="el" href="#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> and the equality test, this routine does <em>not</em> examine or compare simplex/facet locks.</p>
<p>If a boundary incomplete isomorphism is found, the details of this isomorphism are returned. Thus, to test whether an isomorphism exists, you can just call <code>if (isContainedIn(other))</code>.</p>
<p>If more than one such isomorphism exists, only one will be returned. For a routine that returns all such isomorphisms, see <a class="el" href="#ac3ea60c854787cc26a39618dcdf2196b" title="Finds all ways in which an isomorphic copy of this triangulation is contained within the given triang...">findAllSubcomplexesIn()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for an isomorphic copy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if such a copy is found, or no value otherwise. </dd></dl>

</div>
</div>
<a id="a6b111a8470576f19f950a2347ff9f3f5" name="a6b111a8470576f19f950a2347ff9f3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b111a8470576f19f950a2347ff9f3f5">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation is empty. </p>
<p>An empty triangulation is one with no simplices at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is empty. </dd></dl>

</div>
</div>
<a id="ac568895b8abeb672289fcee779ebf01a" name="ac568895b8abeb672289fcee779ebf01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac568895b8abeb672289fcee779ebf01a">&#9670;&#160;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>Two triangulations are <em>isomorphic</em> if and only it is possible to relabel their top-dimensional simplices and the (<em>dim</em>+1) vertices of each simplex in a way that makes the two triangulations combinatorially identical, as returned by the equality test <code>t1 == t2</code>.</p>
<p>Equivalently, two triangulations are isomorphic if and only if there is a one-to-one and onto boundary complete combinatorial isomorphism from this triangulation to <em>other</em>, as described in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, like the equality test, this routine does <em>not</em> examine or compare simplex/facet locks.</p>
<p>If the triangulations are isomorphic, then this routine returns one such boundary complete isomorphism (i.e., one such relabelling). Otherwise it returns no value . Thus, to test whether an isomorphism exists, you can just call <code>if (isIsomorphicTo(other))</code>.</p>
<p>There may be many such isomorphisms between the two triangulations. If you need to find <em>all</em> such isomorphisms, you may call <a class="el" href="#a0481813042dab2c6140fc8d6fbbd189d" title="Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.">findAllIsomorphisms()</a> instead.</p>
<p>If you need to ensure that top-dimensional simplices are labelled the same in both triangulations (i.e., that the triangulations are related by the <em>identity</em> isomorphism), you should use the stricter equality test <code>t1 == t2</code> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo</a></b></dt><dd><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if the two triangulations are combinatorially isomorphic, or no value otherwise. </dd></dl>

</div>
</div>
<a id="a6223875697502990070b0e7587f63ce7" name="a6223875697502990070b0e7587f63ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223875697502990070b0e7587f63ce7">&#9670;&#160;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOrientable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is orientable. </dd></dl>

</div>
</div>
<a id="ab712e58bba1242110e49b2fac979e98f" name="ab712e58bba1242110e49b2fac979e98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab712e58bba1242110e49b2fac979e98f">&#9670;&#160;</a></span>isOriented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOriented </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets. </p>
<p>Specifically, this routine returns <code>true</code> if and only if every gluing permutation has negative sign.</p>
<p>Note that <em>orientable</em> triangulations are not always <em>oriented</em> by default. You can call <a class="el" href="#a2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> if you need the top-dimensional simplices to be oriented consistently as described above.</p>
<p>A non-orientable triangulation can never be oriented.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all top-dimensional simplices are oriented consistently.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="a3133ab83d943df1dd216dc2fbde58c6c" name="a3133ab83d943df1dd216dc2fbde58c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3133ab83d943df1dd216dc2fbde58c6c">&#9670;&#160;</a></span>isoSig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>  = IsoSigClassic&lt;dim&gt;, class Encoding  = IsoSigPrintable&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Encoding::Signature <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSig </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature of the given type for this triangulation. </p>
<p>Support for different <em>types</em> of signature is new to Regina 7.0 (see below for details); all isomorphism signatures created in Regina 6.0.1 or earlier are of the default type <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a>.</p>
<p>An <em>isomorphism signature</em> is a compact representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. That is, for any fixed signature type <em>T</em>, two triangulations of dimension <em>dim</em> are combinatorially isomorphic if and only if their isomorphism signatures of type <em>T</em> are the same.</p>
<p>By default, isomorphism signatures support simplex and facet locks: this means that locks are encoded in the isomorphism signature, and the "combinatorial isomorphisms" mentioned above must respect not just the gluings between simplices but also any simplex and/or facet locks. You can change this behaviour by requesting a different encoding (such as IsoSigPrintableLockFree). Under the default encoding, if this triangulation does not have any simplex and/or facet locks then the isomorphism signature will look the same as it did in Regina 7.3.x and earlier, before locks were supported.</p>
<p>The length of an isomorphism signature is proportional to <code>n log n</code>, where <em>n</em> is the number of top-dimenisonal simplices. The time required to construct it is worst-case <code>O((dim!) n² log² n)</code>. Whilst this is fine for large triangulations, it becomes very slow for large <em>dimensions</em>; the main reason for introducing different signature types is that some alternative types can be much faster to compute in practice.</p>
<p>Whilst the format of an isomorphism signature bears some similarity to dehydration strings for 3-manifolds, they are more general: isomorphism signatures can be used with any triangulations, including closed, bounded and/or disconnected triangulations, as well as triangulations with many simplices. Note also that 3-manifold dehydration strings are not unique up to isomorphism (they depend on the particular labelling of tetrahedra).</p>
<p>The routine <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> can be used to recover a triangulation from an isomorphism signature (only if the default encoding has been used, but it does not matter which signature type was used). The triangulation recovered might not be identical to the original, but it <em>will</em> be combinatorially isomorphic. If you need the precise relabelling, you can call <a class="el" href="#a47a3939293964c4646c7f60cacd94c52" title="Constructs the isomorphism signature for this triangulation, along with the relabelling that will occ...">isoSigDetail()</a> instead.</p>
<p>Regina supports several different variants of isomorphism signatures, which are tailored to different computational needs; these are currently determined by the template parameters <em>Type</em> and <em>Encoding:</em> </p>
<ul>
<li>The <em>Type</em> parameter identifies which signature type is to be constructed. Essentially, different signature types use different rules to determine which labelling of a triangulation is "canonical". The default type <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a> is slow (it never does better than the worst-case time described above); its main advantage is that it is consistent with the original implementation of isomorphism signatures in Regina 4.90.</li>
<li>The <em>Encoding</em> parameter controls how Regina encodes a canonical labelling into a final signature. The default encoding <a class="el" href="classregina_1_1IsoSigPrintable.html" title="The default encoding to use for isomorphism signatures.">IsoSigPrintable</a> returns a std::string consisting entirely of printable characters in the 7-bit ASCII range. Importantly, this default encoding is currently the only encoding from which Regina can <em>reconstruct</em> a triangulation (including any simplex and/or facet locks) from its isomorphism signature.</li>
</ul>
<p>You may instead pass your own type and/or encoding parameters as template arguments. Currently this facility is for internal use only, and the requirements for type and encoding parameters may change in future versions of Regina. At present:</p>
<ul>
<li>The <em>Type</em> parameter should be a class that is constructible from a componenent reference, and that offers the member functions <code><a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a></code>, <code>perm()</code> and <code>next()</code>; see the implementation of <a class="el" href="classregina_1_1IsoSigClassic.html" title="The default signature type to use for isomorphism signatures.">IsoSigClassic</a> for details.</li>
<li>The <em>Encoding</em> parameter should be a class that offers a <em><a class="el" href="classregina_1_1Signature.html" title="Represents a signature of a splitting surface in a closed 3-manifold triangulation.">Signature</a></em> type alias, and static functions <code>emptySig()</code> and <code>encode()</code>. See the implementation of <a class="el" href="classregina_1_1IsoSigPrintable.html" title="The default encoding to use for isomorphism signatures.">IsoSigPrintable</a> for details.</li>
<li>If you wish to produce an isomorphism signature that ignores simplex and/or facet locks then you can use an encoding whose <code>encode()</code> function ignores the final <em>locks</em> argument, such as IsoSigPrintableLockFree.</li>
</ul>
<p>For a full and precise description of the classic isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section user"><dt>Python</dt><dd>Although this is a templated function, all of the variants supplied with Regina are available to Python users. To use the default signature type and encoding, just call <code><a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a></code>. To use a non-default signature type, add a suffix <code>_Type</code> where <em>Type</em> is an abbreviated version of the signature type (e.g., <code>isoSig_EdgeDegrees()</code> for the signature type IsoSigEdgeDegrees). To use the encoding IsoSigPrintableLockFree (the only non-default encoding available at present), add another suffix <code>_LockFree</code> (e.g., <code>isoSig_LockFree()</code>, or <code>isoSig_EdgeDegrees_LockFree()</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a id="a0eedc0b1fc037af0d9c6c23c32d79f2b" name="a0eedc0b1fc037af0d9c6c23c32d79f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eedc0b1fc037af0d9c6c23c32d79f2b">&#9670;&#160;</a></span>isoSigComponentSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSigComponentSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature. </p>
<p>See <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>Currently this routine only supports isomorphism signatures that were created with the default encoding (i.e., there was no <em>Encoding</em> template parameter passed to <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>).</p>
<p>If the signature describes a connected triangulation, this routine will simply return the size of that triangulation (e.g., the number of tetrahedra in the case <em>dim</em> = 3). You can also pass an isomorphism signature that describes a disconnected triangulation; however, this routine will only return the number of top-dimensional simplices in the first connected component. If you need the total size of a disconnected triangulation, you will need to reconstruct the full triangulation by calling <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead.</p>
<p>This routine is very fast, since it only examines the first few characters of the isomorphism signature (in which the size of the first component is encoded). However, a side-effect of this is that it is possible to pass an <em>invalid</em> isomorphism signature and still receive a positive result. If you need to test whether a signature is valid or not, you must call <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead, which will examine the entire signature in full.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of a <em>dim</em>-dimensional triangulation. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices in the first connected component, or 0 if this could not be determined because the given string was not a valid isomorphism signature created using the default encoding. </dd></dl>

</div>
</div>
<a id="a47a3939293964c4646c7f60cacd94c52" name="a47a3939293964c4646c7f60cacd94c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a3939293964c4646c7f60cacd94c52">&#9670;&#160;</a></span>isoSigDetail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a>  = IsoSigClassic&lt;dim&gt;, class Encoding  = IsoSigPrintable&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Encoding::Signature, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSigDetail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature for this triangulation, along with the relabelling that will occur when the triangulation is reconstructed from it. </p>
<p>Essentially, an isomorphism signature is a compact representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. See <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for much more detail on isomorphism signatures as well as the support for different signature types and encodings.</p>
<p>As described in the <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> notes, you can call <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> to recover a triangulation from an isomorphism signature (assuming the default encoding was used). Whilst the triangulation that is recovered will be combinatorially isomorphic to the original, it might not be identical. This routine returns not only the isomorphism signature, but also an isomorphism that describes the precise relationship between this triangulation and the reconstruction from <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>.</p>
<p>Specifically, if this routine returns the pair (<em>sig</em>, <em>relabelling</em>), this means that the triangulation reconstructed from <code>fromIsoSig(sig)</code> will be identical to <code>relabelling(this)</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Although this is a templated function, all of the variants supplied with Regina are available to Python users. To use the default signature type and encoding, just call <code><a class="el" href="#a47a3939293964c4646c7f60cacd94c52" title="Constructs the isomorphism signature for this triangulation, along with the relabelling that will occ...">isoSigDetail()</a></code>. To use a non-default signature type, add a suffix <code>_Type</code> where <em>Type</em> is an abbreviated version of the signature type (e.g., <code>isoSigDetail_EdgeDegrees()</code> for the signature type IsoSigEdgeDegrees). To use the encoding IsoSigPrintableLockFree (the only non-default encoding available at present), add another suffix <code>_LockFree</code> (e.g., <code>isoSigDetail_LockFree()</code>, or <code>isoSigDetail_EdgeDegrees_LockFree()</code>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation must be non-empty and connected. The facility to return a relabelling for disconnected triangulations may be added to Regina in a later release.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is either empty or disconnected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing (i) the isomorphism signature of this triangulation, and (ii) the isomorphism between this triangulation and the triangulation that would be reconstructed from <a class="el" href="#af91da7bdae05981c20c2e3ee234cc48d" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>. </dd></dl>

</div>
</div>
<a id="ae9a076c6b4eb0edc40694aedaf5bd3c4" name="ae9a076c6b4eb0edc40694aedaf5bd3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a076c6b4eb0edc40694aedaf5bd3c4">&#9670;&#160;</a></span>isReadOnlySnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::isReadOnlySnapshot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this object is a read-only deep copy that was created by a snapshot. </p>
<p>Recall that, if an image <em>I</em> of type <em>T</em> has a snapshot pointing to it, and if that image <em>I</em> is about to be modified or destroyed, then the snapshot will make an internal deep copy of <em>I</em> and refer to that instead.</p>
<p>The purpose of this routine is to identify whether the current object is such a deep copy. This may be important information, since a snapshot's deep copy is read-only: it must not be modified or destroyed by the outside world. (Of course the only way to access this deep copy is via const reference from the <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> dereference operators, but there are settings in which this constness is "forgotten", such as Regina's Python bindings.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object is a deep copy that was taken by a <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> object of some original type <em>T</em> image. </dd></dl>

</div>
</div>
<a id="ab6cf08805f1b496f644e75c1a0b34dde" name="ab6cf08805f1b496f644e75c1a0b34dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cf08805f1b496f644e75c1a0b34dde">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is valid. </p>
<p>There are several conditions that might make a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if some face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if some <em>subdim</em>-face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of this triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> ≥ 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If a triangulation is invalid then you can call <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face&lt;dim, subdim&gt;::isValid()</a> to discover exactly which face(s) are responsible, and you can call <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a5249e464a3fbf13b0426260a62f91488" title="Determines if this face is identified with itself under a non-identity permutation.">Face&lt;dim, subdim&gt;::hasBadIdentification()</a> and/or <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ad5e55cae9e13a88139dc9794617f938b" title="Determines if this face does not have an appropriate link.">Face&lt;dim, subdim&gt;::hasBadLink()</a> to discover exactly which conditions fail.</p>
<p>Note that all invalid vertices are considered to be on the boundary; see isBoundary() for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is valid. </dd></dl>

</div>
</div>
<a id="ab6b54eef1e8fbbc831ebbef998c663b2" name="ab6b54eef1e8fbbc831ebbef998c663b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b54eef1e8fbbc831ebbef998c663b2">&#9670;&#160;</a></span>lockBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::lockBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks all boundary facets of this triangulation. </p>
<p>In short, this means that the boundary facets must not be changed. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>If there are any other locks on top-dimensional simplices and/or their facets, these other locks will be left intact.</p>
<p>Note that this only locks the facets of real boundary components. Ideal boundary components are not affected (since they have no facets to lock). </p>

</div>
</div>
<a id="abe58df75da67242635ddcea5398d1b77" name="abe58df75da67242635ddcea5398d1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe58df75da67242635ddcea5398d1b77">&#9670;&#160;</a></span>makeCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeCanonical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form. </p>
<p>This is essentially the lexicographically smallest labelling when the facet gluings are written out in order.</p>
<p>Two triangulations are isomorphic if and only if their canonical forms are identical.</p>
<p>The lexicographic ordering assumes that the facet gluings are written in order of simplex index and then facet number. Each gluing is written as the destination simplex index followed by the gluing permutation (which in turn is written as the images of 0,1,...,<em>dim</em> in order).</p>
<p>If this triangulation has any locks on its top-dimensional simplices and/or their facets, this routine will carry the locks through the relabelling correctly. Locks do not play any role in determining which labelling is canonical (i.e., the canonical labelling will be the same regardles of whether or not there are locks present).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This routine currently works only when the triangulation is connected. It may be extended to work with disconnected triangulations in later versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the triangulation was in canonical form to begin with. </dd></dl>

</div>
</div>
<a id="ae061e36e8ecbfa2f1edc36ed9eb99a51" name="ae061e36e8ecbfa2f1edc36ed9eb99a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae061e36e8ecbfa2f1edc36ed9eb99a51">&#9670;&#160;</a></span>makeDoubleCover()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeDoubleCover </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that converts this triangulation into its orientable double cover. </p>
<p>This triangulation wll be modified directly.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000226">Deprecated</a></b></dt><dd>This routine has been replaced by <a class="el" href="#aa378edda664e87c4052114248722857b" title="Returns the orientable double cover of this triangulation.">doubleCover()</a>, which returns the result as a new triangulation and leaves the original triangulation untouched.</dd></dl>
<p>See <a class="el" href="#aa378edda664e87c4052114248722857b" title="Returns the orientable double cover of this triangulation.">doubleCover()</a> for further details. </p>

</div>
</div>
<a id="a3c2c6b8c7500d6604eee71065addf0aa" name="a3c2c6b8c7500d6604eee71065addf0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2c6b8c7500d6604eee71065addf0aa">&#9670;&#160;</a></span>makeIdeal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeIdeal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts each real boundary component into a cusp (i.e., an ideal vertex). </p>
<p>Only boundary components formed from real (<em>dim</em>-1)-faces will be affected; ideal boundary components are already cusps and so will not be changed.</p>
<p>One side-effect of this operation is that all spherical boundary components will be filled in with balls.</p>
<p>This operation is performed by attaching a new <em>dim</em>-simplex to each boundary (<em>dim</em>-1)-face, and then gluing these new simplices together in a way that mirrors the adjacencies of the underlying boundary facets. Each boundary component will thereby be pushed up through the new simplices and converted into a cusp formed using vertices of these new simplices.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, where triangulations also support a truncateIdeal() operation, this routine is a loose converse of that operation.</p>
<p>In dimension 2, every boundary component is spherical and so this routine simply fills all the punctures in the underlying surface. (In dimension 2, triangulations cannot have cusps).</p>
<p>A note: this operation does <em>not</em> preserve orientedness. That is, even if this triangulation was oriented before calling this function, it might not be oriented after. This behaviour may change in a future version of Regina.</p>
<dl class="section warning"><dt>Warning</dt><dd>If a real boundary component contains vertices whose links are not discs, this operation may have unexpected results.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This triangulation contains at least one locked boundary facet. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a id="ada6dde5a1cad6b5a763af7ee662eba28" name="ada6dde5a1cad6b5a763af7ee662eba28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6dde5a1cad6b5a763af7ee662eba28">&#9670;&#160;</a></span>markedHomology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::markedHomology </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation. </p>
<p>For C++ programmers who know <em>subdim</em> at compile time, you should use this template function <code>markedHomology&lt;subdim&gt;()</code>, which is slightly faster than passing <em>subdim</em> as an ordinary runtime argument to <code>markedHomology(subdim)</code>.</p>
<p>See the non-templated markedHomology(int) for full details on what this function computes, some important caveats to be aware of, and how the group that it returns should be interpreted.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is empty or invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <code>markedHomology(k)</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to compute; this must be between 1 and (<em>dim</em>-1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group of the union of all simplices in this triangulation, as described above. </dd></dl>

</div>
</div>
<a id="adb9273c04a7cf7c89831bce0aa12da15" name="adb9273c04a7cf7c89831bce0aa12da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9273c04a7cf7c89831bce0aa12da15">&#9670;&#160;</a></span>markedHomology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::markedHomology </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>k</em>th homology group of this triangulation, without truncating ideal vertices, but with explicit coordinates that track the individual <em>k</em>-faces of this triangulation, where the parameter <em>k</em> does not need to be known until runtime. </p>
<p>For C++ programmers who know <em>k</em> at compile time, you are better off using the template function <code>markedHomology&lt;k&gt;()</code> instead, which is slightly faster.</p>
<p>This is a specialised homology routine; you should only use it if you need to understand how individual <em>k</em>-faces (or chains of <em>k</em>-faces) appear within the homology group.</p>
<ul>
<li>The major disadvantage of this routine is that it does not truncate ideal vertices. Instead it computes the homology of the union of all top-dimensional simplices, working directly with the boundary maps between (<em>k</em>+1)-faces, <em>k</em>-faces and (<em>k</em>-1)-faces of the triangulation. If your triangulation is ideal, then this routine will almost certainly <em>not</em> give the correct homology group for the underlying manifold. If, however, all of your vertex links are spheres or balls (i.e., the triangulation is closed or all of its boundary components are built from unglued (<em>dim</em>-1)-faces), then the homology of the manifold will be computed correctly.</li>
<li>The major advantage is that, instead of returning a simpler <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a>, this routine returns a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a>. This allows you to track chains of individual <em>k</em>-faces of the triangulation as they appear within the homology group. Specifically, the chain complex cordinates with this <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> represent precisely the <em>k</em>-faces of the triangulation in the same order as they appear in the list <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;k&gt;()</a>, using the inherent orientation provided by Face&lt;dim, k&gt;.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This triangulation is empty or invalid.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The homology dimension <em>k</em> is outside the supported range (i.e., less than 1 or greater than or equal to <em>dim</em>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Like the C++ template function <code>markedHomology&lt;k&gt;()</code>, you can omit the homology dimension <em>k</em>; this will default to 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the dimension of the homology group to compute; this must be between 1 and (<em>dim</em>-1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>k</em>th homology group of the union of all simplices in this triangulation, as described above. </dd></dl>

</div>
</div>
<a id="a1e874f14510689aa9db756ddc8611ca3" name="a1e874f14510689aa9db756ddc8611ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e874f14510689aa9db756ddc8611ca3">&#9670;&#160;</a></span>move20()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::move20 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a 2-0 move about the given <em>k</em>-face of degree two. </p>
<p>This involves taking the two top-dimensional simplices joined along that face and squashing them flat.</p>
<p>This move is currently only implemented for vertices, edges and triangles (i.e., facial dimension <code>k ≤ 2</code>).</p>
<p>This triangulation will be changed directly.</p>
<p>This move will only be performed if it will not change the topology of the manifold (as outlined below), <em>and</em> it will not violate any simplex and/or facet locks. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks.</p>
<p>The requirements for the move to not change the topology depend upon the facial dimension <em>k</em>. In all cases:</p>
<ul>
<li>the face <em>f</em> must be valid and non-boundary, and must have degree 2;</li>
<li>the two top-dimensional simplices on either side of <em>f</em> must be distinct;</li>
<li>the link of <em>f</em> must be the standard sphere obtained by identifying the boundaries of two <code>(dim - k - 1)</code>-simplices using the identity map;</li>
<li>the two <code>(dim - k - 1)</code>-faces opposite <em>f</em> in each top-dimensional simplex must be distinct and not both boundary.</li>
</ul>
<p>Moreover, there are further requirements depending on the facial dimension <em>k:</em> </p>
<ul>
<li>When performing the move on a vertex (<code>k = 0</code>), there are no additional requirements.</li>
<li>When performing the move on an edge (<code>k = 1</code>), there are additional requirements on the <code>(dim - 1)</code>-faces. Specifically: the move would effectively flatten facets <em>f1</em> and <em>f2</em> of one top-dimensional simplex onto facets <em>g1</em> and <em>g2</em> of the other top-dimensional simplex respectiveyl, and we require that: (a) <em>f1</em> and <em>g1</em> are distinct, (b) <em>f2</em> and <em>g2</em> are distinct, (c) we do not have both <em>f1</em> = <em>g2</em> and <em>g1</em> = <em>f2</em>, (d) we do not have both <em>f1</em> = <em>f2</em> and <em>g1</em> = <em>g2</em>, and (e) we do not have two of the facets boundary and the other two identified.</li>
<li>When performing the move on a triangle (<code>k = 2</code>), there are additional requirements on both the <code>(dim - 1)</code>-faces and the <code>(dim - 2)</code>-faces. These are move involved, and are discussed in detail in the source code for those who are interested.</li>
</ul>
<p>If this triangulation is currently oriented, then this 2-0 move will preserve the orientation.</p>
<p>Note that after performing this move, all skeletal objects (faces, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be 0, 1 or 2, and must not exceed <code>dim - 2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="ae3fa3daf9672da64a0fa8a82a439d65b" name="ae3fa3daf9672da64a0fa8a82a439d65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fa3daf9672da64a0fa8a82a439d65b">&#9670;&#160;</a></span>moveContentsTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of this triangulation into the given destination triangulation, leaving this triangulation empty but otherwise usable. </p>
<p>The top-dimensional simplices of this triangulation will be moved directly into <em>dest</em>, and placed after any pre-existing simplices. Specifically, if the original size of <em>dest</em> was <em>N</em>, then <code>simplex(i)</code> of this triangulation will become <code>dest.simplex(N+i)</code>.</p>
<p>This triangulation will become empty as a result, but it will otherwise remain a valid and usable <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> object. Any simplex pointers that referred to either this triangulation or <em>dest</em> will remain valid (and will all now refer to <em>dest</em>), though if they originally referred to this triangulation then they will now return different indices. Any locks on top-dimensional simplices and/or their facets will be preserved.</p>
<p>Calling <code>tri.moveContentsTo(dest)</code> is similar to calling <code>dest.insertTriangulation(std::move(tri))</code>; it is a little slower but it comes with the benefit of leaving this triangulation in a usable state.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the triangulation into which the contents of this triangulation should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad107a418e2691dc5ad7bb9e90dcba437" name="ad107a418e2691dc5ad7bb9e90dcba437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107a418e2691dc5ad7bb9e90dcba437">&#9670;&#160;</a></span>newSimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex and adds it to this triangulation. </p>
<p>The new simplex will have an empty description. All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="a829224a264241e43a8f2bbdf5bfcb253" name="a829224a264241e43a8f2bbdf5bfcb253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829224a264241e43a8f2bbdf5bfcb253">&#9670;&#160;</a></span>newSimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex with the given description and adds it to this triangulation. </p>
<p>All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>Descriptions are optional, may have any format, and may be empty. How descriptions are used is entirely up to the user.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give to the new simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="a6791255912384494b7e2b76f44eee61a" name="a6791255912384494b7e2b76f44eee61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6791255912384494b7e2b76f44eee61a">&#9670;&#160;</a></span>newSimplexRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplexRaw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> with no management of the underlying triangulation. </p>
<p>This routine adjusts the internal list of simplices, just like <a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> does. However, this is <em>all</em> it does. In particular:</p>
<ul>
<li>it does not manage the underlying triangulation in any way: it does not take snapshots, fire change events, or clear computed properties.</li>
</ul>
<p>This should <em>only</em> be used in settings where the other missing tasks such as snapshots, change events and computed properties are being taken care of in some other manner (possibly manually). An example of such a setting might be the implementation of a local move (such as a Pachner move).</p>
<p>Such a "raw" routine would typically be safe to use <em>without</em> any manual error/lock/triangulation management in the following scenarios:</p>
<ul>
<li>triangulation constructors, but only in settings where no properties (including the skeleton) have been computed yet;</li>
<li>routines that create a "staging" triangulation, without computing its skeleton or any other properties, and then swap or move this staging triangulation into the triangulation actually being worked upon (see <a class="el" href="#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">subdivide()</a> for an example).</li>
</ul>
<p>The return value for this routine is the same as for <a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. See <a class="el" href="#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further details. </p>

</div>
</div>
<a id="a80e0403df58ea41ee87cfeb3e111845e" name="a80e0403df58ea41ee87cfeb3e111845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e0403df58ea41ee87cfeb3e111845e">&#9670;&#160;</a></span>newSimplices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *, k &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <em>k</em> new top-dimensional simplices, adds them to this triangulation, and returns them in a std::array. </p>
<p>The main purpose of this routine is to support structured binding; for example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [r, s, t] = ans.newSimplices&lt;3&gt;();</div>
<div class="line">r-&gt;join(0, s, {1, 2, 3, 0});</div>
<div class="line">...</div>
</div><!-- fragment --><p>All new simplices will have empty descriptions, and all facets of each new simplex will be boundary facets.</p>
<p>The new simplices will become the last <em>k</em> simplices in this triangulation. Specifically, if the return value is the array <em>ret</em>, then each simplex <code>ret[i]</code> will have index <code><a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-k+i</code> in the overall triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the two variants of <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> are essentially merged: the argument <em>k</em> is passed as an ordinary runtime argument, and the new top-dimensional simplices will be returned in a Python tuple of size <em>k</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the number of new top-dimensional simplices to add; this must be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing all of the new simplices, in the order in which they were added. </dd></dl>

</div>
</div>
<a id="a911cdc0a8942418d4e257a81ce24a110" name="a911cdc0a8942418d4e257a81ce24a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911cdc0a8942418d4e257a81ce24a110">&#9670;&#160;</a></span>newSimplices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplices </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <em>k</em> new top-dimensional simplices and adds them to this triangulation. </p>
<p>This is similar to the templated routine <code>newSimplices&lt;k&gt;()</code>, but with two key differences:</p>
<ul>
<li>This routine has the disadvantage that it does not return the new top-dimensional simplices, which means you cannot use it with structured binding.</li>
<li>This routine has the advantage that <em>k</em> does not need to be known until runtime, which means this routine is accessible to Python users.</li>
</ul>
<p>All new simplices will have empty descriptions, and all facets of each new simplex will be boundary facets.</p>
<p>The new simplices will become the last <em>k</em> simplices in this triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the two variants of <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> are essentially merged: the argument <em>k</em> is passed as an ordinary runtime argument, and the new top-dimensional simplices will be returned in a Python tuple of size <em>k</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of new top-dimensional simplices to add; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0522a4175469aa2b3ecdc188542c1a" name="a4a0522a4175469aa2b3ecdc188542c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0522a4175469aa2b3ecdc188542c1a">&#9670;&#160;</a></span>newSimplicesRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *, k &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplicesRaw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> with no lock management, and no management of the underlying triangulation. </p>
<p>See <a class="el" href="#a6791255912384494b7e2b76f44eee61a" title="A variant of newSimplex() with no management of the underlying triangulation.">newSimplexRaw()</a> for further details on what these "raw" routines do and where they can be used.</p>
<p>The return value for this routine is the same as for <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a>. See <a class="el" href="#a80e0403df58ea41ee87cfeb3e111845e" title="Creates k new top-dimensional simplices, adds them to this triangulation, and returns them in a std::...">newSimplices()</a> for further details. </p>

</div>
</div>
<a id="aa6089593f5dd4390f786f16b09d21de3" name="aa6089593f5dd4390f786f16b09d21de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6089593f5dd4390f786f16b09d21de3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given triangulation. </p>
<p>This will also clone any computed properties (such as homology, fundamental group, and so on), as well as the skeleton (vertices, edges, components, etc.). In particular, this triangulation will use the same numbering and labelling for all skeletal objects as in the source triangulation.</p>
<p>If <em>src</em> has any locks on top-dimensional simplices and/or their facets, these locks will also be copied across.</p>
<p><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this operator itself; it is only ever called by the Triangulation&lt;dim&gt; assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this triangulation. </dd></dl>

</div>
</div>
<a id="a46980847f4f9adae8be8101dcc6fe914" name="a46980847f4f9adae8be8101dcc6fe914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46980847f4f9adae8be8101dcc6fe914">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given triangulation into this triangulation. </p>
<p>This is much faster than copy assignment, but is still linear time. This is because every top-dimensional simplex must be adjusted to point back to this triangulation instead of <em>src</em>.</p>
<p>All top-dimensional simplices and skeletal objects (faces, components and boundary components) that belong to <em>src</em> will be moved into this triangulation, and so any pointers or references to Simplex&lt;dim&gt;, Face&lt;dim, subdim&gt;, Component&lt;dim&gt; or BoundaryComponent&lt;dim&gt; objects will remain valid. Likewise, all cached properties will be moved into this triangulation.</p>
<p>If <em>src</em> has any locks on top-dimensional simplices and/or their facets, these locks will also be moved across.</p>
<p><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this operator itself; it is only ever called by the Triangulation&lt;dim&gt; assignment operator.</p>
<p>The triangulation that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not touch any properties managed by the derived class Triangulation&lt;dim&gt;. It is assumed that this is being called by the Triangulation&lt;dim&gt; assignment operator, and that this derived class operator will manage its own properties in whatever way it deems best.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this triangulation which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the triangulation to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this triangulation. </dd></dl>

</div>
</div>
<a id="a306a4532309eabe53267868d1ff544ea" name="a306a4532309eabe53267868d1ff544ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306a4532309eabe53267868d1ff544ea">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially identical to the given triangulation. </p>
<p>Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p>For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see <a class="el" href="#ac568895b8abeb672289fcee779ebf01a" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> instead.</p>
<p>This test does <em>not</em> examine the textual simplex descriptions or simplex/facet locks, as seen in <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a00178392c44456529f5250de6bc448ef" title="Returns the description associated with this simplex.">Simplex&lt;dim&gt;::description()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a7da080b2d13e92b72f295e8a01cb01bf" title="Returns a bitmask indicating which of this simplex and/or its individual facets are locked.">Simplex&lt;dim&gt;::lockMask()</a>; these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p>(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<p>In Regina 6.0.1 and earlier, this comparison was called isIdenticalTo().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are combinatorially identical. </dd></dl>

</div>
</div>
<a id="a2711fd7c7115ce19b6833f0d61c42bec" name="a2711fd7c7115ce19b6833f0d61c42bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2711fd7c7115ce19b6833f0d61c42bec">&#9670;&#160;</a></span>orient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::orient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible. </p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of each top-dimensional simplex that has negative orientation. The result will be a triangulation where the top-dimensional simplices have their vertices labelled in a way that preserves orientation across adjacent facets. In particular, every gluing permutation will have negative sign.</p>
<p>If this triangulation includes both orientable and non-orientable components, the orientable components will be oriented as described above and the non-orientable components will be left untouched.</p>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, these will not prevent the orientation from taking place. Instead, any locks will be transformed accordingly (i.e., facets (<em>dim</em> - 1) and <em>dim</em> will exchange their lock states for those simplices that originally had negative orientation). </p>

</div>
</div>
<a id="a9b1e72e8b2ac09786a36bc0c97aa16aa" name="a9b1e72e8b2ac09786a36bc0c97aa16aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1e72e8b2ac09786a36bc0c97aa16aa">&#9670;&#160;</a></span>pachner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face. </p>
<p>This involves replacing the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices meeting that <em>k</em>-face with (<em>k</em> + 1) new top-dimensional simplices joined along a new internal (<em>dim</em> - <em>k</em>)-face.</p>
<p>This triangulation will be changed directly.</p>
<p>This move will only be performed if it will not change the topology of the manifold (as outlined below), <em>and</em> it will not violate any simplex and/or facet locks. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks.</p>
<p>In order to not change the topology, we require that:</p><ul>
<li>the given <em>k</em>-face is valid and non-boundary;</li>
<li>the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices that contain it are distinct; and</li>
<li>these simplices are joined in such a way that the link of the given <em>k</em>-face is the standard triangulation of the <code>(dim - 1 - k)</code>-sphere as the boundary of a <code>(dim - k)</code>-simplex.</li>
</ul>
<p>If this triangulation is currently oriented, then this Pachner move will label the new top-dimensional simplices in a way that preserves the orientation.</p>
<p>Note that after performing this move, all skeletal objects (faces, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be formed from vertices 0,1,...,(<em>dim</em> - <em>k</em>) of <code><a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The check for this move takes quadratic time in the number of top-dimensional simplices involved (which may become expensive when <em>dim</em> is large and <em>k</em> is small). If you are certain that the move is legal, and you wish to circumvent this check, C++ users can call the variant of this function that takes an extra <a class="el" href="structregina_1_1Unprotected.html" title="An empty type that can be used to disable in-built safety checks in some specific circumstances.">Unprotected</a> argument.</dd>
<dd>
For the case <em>k</em> = <em>dim</em> in Regina's <a class="el" href="stddim.html">standard dimensions</a>, the labelling of the belt face has changed as of Regina 5.96 (the first prerelease for Regina 6.0). In versions 5.1 and earlier, the belt face was <code><a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()-&gt;vertex(dim)</code>, and as of version 5.96 it is now <code><a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a>.back()-&gt;vertex(0)</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a52d347fbe4c9dca73eca5a6c986186e5" name="a52d347fbe4c9dca73eca5a6c986186e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d347fbe4c9dca73eca5a6c986186e5">&#9670;&#160;</a></span>pachner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation. </p>
<p>For more detail on Pachner moves and when they can be performed, see the variant of <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a> without the extra boolean arguments.</p>
<p>This routine will always <em>check</em> whether the requested move is legal and will not violate any simplex and/or facet locks (see <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks). If the move <em>is</em> allowed, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000223">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#ad39868427de3611c179664cdef49539b" title="Determines whether it is possible to perform a (dim + 1 - k)-(k + 1) Pachner move about the given k-f...">hasPachner()</a>. If you wish to both check and perform the move, call <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a> without the two extra boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a7d61577f10db36988746db8c6e2bb89d" name="a7d61577f10db36988746db8c6e2bb89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d61577f10db36988746db8c6e2bb89d">&#9670;&#160;</a></span>pachner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregina_1_1Unprotected.html">Unprotected</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face, without any safety checks. </p>
<p>This variant of <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a> is offered because it can become expensive to test whether a Pachner move can be performed on a given face when <em>dim</em> is large and <em>k</em> is small (and therefore there are many top-dimensional simplices involved in the move).</p>
<p>This function will <em>always</em> perform the requested Pachner move directy on this triangulation, <em>without</em> first testing whether it is legal. The onus is on the programmer to ensure the legality of the move beforehand. Getting this wrong could be disastrous: you could change the topology of the manifold, or possibly end up with an invalid triangulation, or this function could throw an exception if you attempt to violate a simplex and/or facet lock.</p>
<p>The (unnamed) <a class="el" href="structregina_1_1Unprotected.html" title="An empty type that can be used to disable in-built safety checks in some specific circumstances.">Unprotected</a> argument would typically be the constant <code><a class="el" href="namespaceregina.html#a544c1a355ae7bb1e08da0e14c41e158c" title="An empty object that can be used to disable Regina&#39;s in-built safety checks in some specific circumst...">regina::unprotected</a></code>.</p>
<p>For more detail on Pachner moves and when they can be performed, see the variant of <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a> that does not take an extra <a class="el" href="structregina_1_1Unprotected.html" title="An empty type that can be used to disable in-built safety checks in some specific circumstances.">Unprotected</a> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. By design, Python users are not able to circumvent the legality checks for Pachner moves. If speed is essential, you should be using C++.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This move would violate a simplex or facet lock. This exception will be thrown before any changes are made.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&#160;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p>There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine Triangulation&lt;3&gt;::inAnyPacket() will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p>The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&#160;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a839950f320f6f0ca655e7a880a66c2ee" name="a839950f320f6f0ca655e7a880a66c2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839950f320f6f0ca655e7a880a66c2ee">&#9670;&#160;</a></span>pairing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pairing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dual graph of this triangulation, expressed as a facet pairing. </p>
<p>Calling <code>tri.pairing()</code> is equivalent to calling <code><a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a>&lt;dim&gt;(tri)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not empty.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the dual graph of this triangulation. </dd></dl>

</div>
</div>
<a id="ab87c5adb83f7790b90bb1a63ec960a4a" name="ab87c5adb83f7790b90bb1a63ec960a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87c5adb83f7790b90bb1a63ec960a4a">&#9670;&#160;</a></span>pentachora()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachora </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;4&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 4. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p>See <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="afa44d0c8bd040dd76885df3743803a49" name="afa44d0c8bd040dd76885df3743803a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa44d0c8bd040dd76885df3743803a49">&#9670;&#160;</a></span>pentachoron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachoron </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4. It returns a non-const pentachoron pointer.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ac8b4af8fb72bfe82006ab8997ce0bccd" name="ac8b4af8fb72bfe82006ab8997ce0bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4af8fb72bfe82006ab8997ce0bccd">&#9670;&#160;</a></span>pentachoron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pentachoron </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;4&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 4. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4. It returns a const pentachoron pointer in dimension <em>dim</em> = 4, and a non-const pentachoron pointer in all higher dimensions.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a1223828de2d256717b5f000da08c9222" name="a1223828de2d256717b5f000da08c9222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223828de2d256717b5f000da08c9222">&#9670;&#160;</a></span>randomiseLabelling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::randomiseLabelling </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preserveOrientation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly relabels the top-dimensional simplices and their vertices. </p>
<p>Essentially, this routine creates a random isomorphism of the correct size and applies it in-place to this triangulation.</p>
<p>The advantage of using this routine instead of working directly through the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class is that this routine preserves any computed topological properties of the triangulation (as opposed to the isomorphism bracket operator, which at the time of writing does not).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserveOrientation</td><td>if <code>true</code>, then every top-dimensional simplex will have its vertices permuted with an even permutation. This means that, if this triangulation is oriented, then <a class="el" href="#a1223828de2d256717b5f000da08c9222" title="Randomly relabels the top-dimensional simplices and their vertices.">randomiseLabelling()</a> will preserve the orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the random isomorphism that was applied; that is, the isomorphism from the original triangulation to the final triangulation. </dd></dl>

</div>
</div>
<a id="a3f5583fe8731e5186eac30bb7dfeafa6" name="a3f5583fe8731e5186eac30bb7dfeafa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5583fe8731e5186eac30bb7dfeafa6">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::reflect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation. </p>
<p>In particular, if this triangulation is oriented, then it will be converted into an isomorphic triangulation with the opposite orientation.</p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of every top-dimensional simplex.</p>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, these will not prevent the reflection from taking place. Instead, any locks will be transformed accordingly (i.e., facets (<em>dim</em> - 1) and <em>dim</em> will exchange their lock states in every top-dimensional simplex). </p>

</div>
</div>
<a id="a3e91a640743f9ce2710d17eda77d520a" name="a3e91a640743f9ce2710d17eda77d520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91a640743f9ce2710d17eda77d520a">&#9670;&#160;</a></span>removeAllSimplices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeAllSimplices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simplices from the triangulation. </p>
<p>As a result, this triangulation will become empty.</p>
<p>All of the simplices that belong to this triangulation will be destroyed immediately.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This triangulation contains at least one locked top-dimensional simplex and/or facet. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b349c4e1fb4b27a9b20ed53b277a7ba" name="a7b349c4e1fb4b27a9b20ed53b277a7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b349c4e1fb4b27a9b20ed53b277a7ba">&#9670;&#160;</a></span>removeSimplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>simplex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given top-dimensional simplex from this triangulation. </p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is a top-dimensional simplex in this triangulation.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>The given simplex and/or one of its facets is currently locked. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f36b004ba6af3d6ce11bdb655650ec" name="ac9f36b004ba6af3d6ce11bdb655650ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f36b004ba6af3d6ce11bdb655650ec">&#9670;&#160;</a></span>removeSimplexAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplexAt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-dimensional simplex at the given index in this triangulation. </p>
<p>This is equivalent to calling <code>removeSimplex(simplex(index))</code>.</p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>The requested simplex and/or one of its facets is currently locked. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which top-dimensional simplex to remove; this must be between 0 and <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb72ee7b952682ed019ef48bb79f0f7" name="abfb72ee7b952682ed019ef48bb79f0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb72ee7b952682ed019ef48bb79f0f7">&#9670;&#160;</a></span>removeSimplexRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplexRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>simplex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> with no lock management, and no management of the underlying triangulation. </p>
<p>See <a class="el" href="#a6791255912384494b7e2b76f44eee61a" title="A variant of newSimplex() with no management of the underlying triangulation.">newSimplexRaw()</a> for further details on what these "raw" routines do and where they can be used.</p>
<p>The arguments for this routine are the same as for <a class="el" href="#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>. See <a class="el" href="#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> for further details. </p>

</div>
</div>
<a id="a1863936f9553bd33901d5fe7d71e2856" name="a1863936f9553bd33901d5fe7d71e2856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1863936f9553bd33901d5fe7d71e2856">&#9670;&#160;</a></span>reorderBFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::reorderBFS </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reverse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the top-dimensional simplices of this triangulation using a breadth-first search, so that small-numbered simplices are adjacent to other small-numbered simplices. </p>
<p>Specifically, the reordering will operate as follows. Simplex 0 will remain simplex 0. Its immediate neighbours will be numbered 1,2,...,(<em>dim+1</em>) (though if these neighbours are not distinct then of course fewer labels will be required). Their immediate neighbours will in turn be numbered (<em>dim+2</em>), (<em>dim+3</em>) and so on, ultimately following a breadth-first search throughout the entire triangulation.</p>
<p>If the optional argument <em>reverse</em> is <code>true</code>, then simplex numbers will be assigned in reverse order. That is, simplex 0 will become simplex <em>n-1</em>, its immediate neighbours will become simplices <em>n-2</em>, <em>n-3</em>, etc., and so on.</p>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, these will not prevent the reordering from taking place. Instead, any locks will be transformed accordingly; that is, all top-dimensional simplices will carry their own locks and their facets' locks around with them as they are reordered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td><code>true</code> if the new simplex numbers should be assigned in reverse order, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcb2d416c0af527bf91b2b5f2128ed83" name="abcb2d416c0af527bf91b2b5f2128ed83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb2d416c0af527bf91b2b5f2128ed83">&#9670;&#160;</a></span>setGroupPresentation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::setGroupPresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a></td>          <td class="paramname"><span class="paramname"><em>pres</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the specific presentation of the fundamental group to be changed by some other (external) means. </p>
<p>Specifically, this routine assumes that you have changed (and presumably simplified) the presentation of the fundamental group using some external tool (such as GAP or Magma), and it replaces the current presentation with the new presentation <em>pres</em> that is passed.</p>
<p>Regina does <em>not</em> verify that the new presentation is isomorphic to the old, since this is an extremely hard problem.</p>
<p>If the fundamental group has not yet been calculated for this triangulation, then this routine will cache <em>pres</em> as the fundamental group, under the assumption that you have worked out the group through some other clever means without ever having needed to call <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a> at all.</p>
<p>Note that this routine will not fire a packet change event.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given presentation <em>pres</em> is indeed a presentation of the fundamental group of this triangulation, as described by <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pres</td><td>a new presentation of the fundamental group of this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa795373077b40844b3e960ab551f861" name="afa795373077b40844b3e960ab551f861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa795373077b40844b3e960ab551f861">&#9670;&#160;</a></span>shellBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::shellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangulation. </p>
<p>This involves popping off a top-dimensional simplex with one or more facets on the boundary.</p>
<p>This move is <em>only available in standard dimensions</em>, since Regina's notion of "valid faces" is weaker in higher dimensions (due to the need to solve undecidable problems). See <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face::isValid()</a> for further discussion.</p>
<p>This triangulation will be changed directly.</p>
<p>This move will only be performed if it will not change the topology of the manifold (as outlined below), <em>and</em> it will not violate any simplex and/or facet locks. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks.</p>
<p>In order to not change the topology, we require the conditions below. These are conditions are stricter than necessary, but the resulting "lost opportunities" only affect invalid triangulations.</p>
<p>In this list of conditions, we let <em>s</em> denote the given top-dimensional simplex, and we let <em>f</em> denote the face of <em>s</em> opposite the intersection of all its boundary facets. For example, for a 4-manifold triangulation where <em>s</em> has exactly two boundary facets meeting in a common boundary triangle, <em>f</em> would denote the edge of <em>s</em> opposite this common triangle. Put differently: <em>f</em> is the (unique) smallest face of <em>s</em> that <em>might</em> not be entirely contained in the triangulation boundary. Note that the dimension of <em>f</em> will be one less than the number of boundary facets of <em>s</em>.</p>
<p>Having said all of this, our conditions are:</p>
<ul>
<li>all faces of all dimensions of the simplex <em>s</em>, except possibly its vertices, are valid;</li>
<li>at least one but not all of the facets of <em>s</em> lie in the boundary of the triangulation;</li>
<li>the face <em>f</em> (defined above) is valid (even if it is a vertex), and does not lie entirely in the boundary of the triangulation;</li>
<li>for each facial dimension <em>k</em>, no two <em>k</em>-faces of <em>s</em> that both contain <em>f</em> are identified (testing this for <code>k = dim(f)+1</code> is enough to ensure it holds for all <em>k</em>).</li>
</ul>
<p>If this triangulation is currently oriented, then this operation will (trivially) preserve the orientation.</p>
<p>Note that after performing this move, all skeletal objects (faces, components, etc.) will be reconstructed, which means any pointers to old skeletal objects can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. </dd>
<dd>
The given simplex is a simplex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the top-dimensional simplex upon which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a4b03a55bb0527a9604604be099ed5f14" name="a4b03a55bb0527a9604604be099ed5f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b03a55bb0527a9604604be099ed5f14">&#9670;&#160;</a></span>shellBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::shellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a boundary shelling move on the given top-dimensional simplex. </p>
<p>For more detail on boundary shelling moves and when they can be performed, see the variant of <a class="el" href="#afa795373077b40844b3e960ab551f861" title="If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangu...">shellBoundary()</a> without the extra boolean arguments.</p>
<p>This routine will always <em>check</em> whether the requested move is legal and will not violate any simplex and/or facet locks (see <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks). If the move <em>is</em> allowed, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<p>This move is <em>only available in standard dimensions</em>, since Regina's notion of "valid faces" is weaker in higher dimensions (due to the need to solve undecidable problems). See <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face::isValid()</a> for further discussion.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000225">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a285440f69d71e964ec70c897298850ca" title="Determines whether it is possible to perform a boundary shelling move upon the given top-dimensional ...">hasShellBoundary()</a>. If you wish to both check and perform the move, call <a class="el" href="#afa795373077b40844b3e960ab551f861" title="If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangu...">shellBoundary()</a> without the two extra boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. </dd>
<dd>
The given simplex is a simplex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the top-dimensional simplex upon which to perform the move. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a220763a5656748e7d75e79485a5acbde" name="a220763a5656748e7d75e79485a5acbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220763a5656748e7d75e79485a5acbde">&#9670;&#160;</a></span>sig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="group__surface.html#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">Type</a> , class Encoding &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Encoding::Signature <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::sig </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>, which constructs the isomorphism signature of the given type for this triangulation. </p>
<p>This alias <a class="el" href="#a220763a5656748e7d75e79485a5acbde" title="Alias for isoSig(), which constructs the isomorphism signature of the given type for this triangulati...">sig()</a> is provided to assist with generic code that can work with both triangulations and links.</p>
<p>See <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> for further details.</p>
<dl class="section user"><dt>Python</dt><dd>This alias is only available for the default signature type and encoding (i.e., the default C++ template arguments). If you wish to use a different signature type and/or encoding, you can instead use the variants provided with <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a>; that is, you can call a function of the form isoSig_<em>Type</em>. See the <a class="el" href="#a3133ab83d943df1dd216dc2fbde58c6c" title="Constructs the isomorphism signature of the given type for this triangulation.">isoSig()</a> documentation for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a id="ae2e269a7332e80aeec3603881fd175d3" name="ae2e269a7332e80aeec3603881fd175d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e269a7332e80aeec3603881fd175d3">&#9670;&#160;</a></span>simplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="a7cdadce4ea703518064241597cf1514b" name="a7cdadce4ea703518064241597cf1514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdadce4ea703518064241597cf1514b">&#9670;&#160;</a></span>simplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="a7d7a7d5c459569dbf66147b62f695c2d" name="a7d7a7d5c459569dbf66147b62f695c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a7d5c459569dbf66147b62f695c2d">&#9670;&#160;</a></span>simplices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all top-dimensional simplices in this triangulation. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1Face_3_01dim_00_01dim_01_4.html">Simplex&lt;dim&gt;</a>* s : tri.<a class="code hl_function" href="#a7d7a7d5c459569dbf66147b62f695c2d">simplices</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Face_3_01dim_00_01dim_01_4_html"><div class="ttname"><a href="classregina_1_1Face_3_01dim_00_01dim_01_4.html">regina::Face&lt; dim, dim &gt;</a></div><div class="ttdoc">Represents a top-dimensional simplex in a dim-manifold triangulation.</div><div class="ttdef"><b>Definition</b> simplex.h:98</div></div>
<div class="ttc" id="aclassregina_1_1detail_1_1TriangulationBase_html_a7d7a7d5c459569dbf66147b62f695c2d"><div class="ttname"><a href="#a7d7a7d5c459569dbf66147b62f695c2d">regina::detail::TriangulationBase::simplices</a></div><div class="ttdeci">auto simplices() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all top-dimensional simplices in...</div><div class="ttdef"><b>Definition</b> triangulation.h:4631</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the triangulation exists: even as simplices are added and/or removed, it will always reflect the simplices that are currently in the triangulation. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="a7fa0e8cb1b4938a51deaedeea236dc56" name="a7fa0e8cb1b4938a51deaedeea236dc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa0e8cb1b4938a51deaedeea236dc56">&#9670;&#160;</a></span>simplifiedFundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplifiedFundamentalGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a></td>          <td class="paramname"><span class="paramname"><em>pres</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="#abcb2d416c0af527bf91b2b5f2128ed83" title="Allows the specific presentation of the fundamental group to be changed by some other (external) mean...">setGroupPresentation()</a>, which allows the specific presentation of the fundamental group to be changed by some other (external) means. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000222">Deprecated</a></b></dt><dd>This routine has been renamed to <a class="el" href="#abcb2d416c0af527bf91b2b5f2128ed83" title="Allows the specific presentation of the fundamental group to be changed by some other (external) mean...">setGroupPresentation()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given presentation <em>pres</em> is indeed a presentation of the fundamental group of this triangulation, as described by <a class="el" href="#a419c0f6e468ad24cfc450775c6a19b81" title="Returns the fundamental group of this triangulation.">group()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pres</td><td>a new presentation of the fundamental group of this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3871caa1f02ccda957f22ebd9a646ff5" name="a3871caa1f02ccda957f22ebd9a646ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871caa1f02ccda957f22ebd9a646ff5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of top-dimensional simplices in the triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="a969c32d5436daaee2e541628559c775b" name="a969c32d5436daaee2e541628559c775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969c32d5436daaee2e541628559c775b">&#9670;&#160;</a></span>source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#ga4042b3d9832af20a99be34899e313442">Language</a></td>          <td class="paramname"><span class="paramname"><em>language</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#gga4042b3d9832af20a99be34899e313442a222a267cc5778206b253be35ee3ddab5">Language::Current</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns C++ or Python source code that can be used to reconstruct this triangulation. </p>
<p>This code will call <a class="el" href="#ad91567ffbe224dcd1f1da3cb273efe49" title="Creates a triangulation from a hard-coded list of gluings.">Triangulation&lt;dim&gt;::fromGluings()</a>, passing a hard-coded C++ initialiser list or Python list (depending on the requested language).</p>
<p>The main purpose of this routine is to generate this hard-coded list, which can be tedious and error-prone to write by hand.</p>
<p>Note that the number of lines of code produced grows linearly with the number of simplices. If this triangulation is very large, the returned string will be very large as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">language</td><td>the language in which the source code should be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the source code that was generated. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a0e7139822eb449840c13dbcc304f8491" name="a0e7139822eb449840c13dbcc304f8491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7139822eb449840c13dbcc304f8491">&#9670;&#160;</a></span>subdivide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::subdivide </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a barycentric subdivision of the triangulation. </p>
<p>This is done in-place, i.e., the triangulation will be modified directly.</p>
<p>Each top-dimensional simplex <em>s</em> is divided into (<em>dim</em> + 1) factorial sub-simplices by placing an extra vertex at the centroid of every face of every dimension. Each of these sub-simplices <em>t</em> is described by a permutation <em>p</em> of (0, ..., <em>dim</em>). The vertices of such a sub-simplex <em>t</em> are:</p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em>;</li>
<li>...</li>
<li>the centroid of face (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2], <em>p</em>[<em>dim</em>]) of <em>s</em>, which is the entire simplex <em>s</em> itself.</li>
</ul>
<p>The sub-simplices have their vertices numbered in a way that mirrors the original simplex <em>s:</em> </p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em> will be labelled <em>p</em>[0] in <em>t</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em> will be labelled <em>p</em>[1] in <em>t</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em> will be labelled <em>p</em>[2] in <em>t</em>;</li>
<li>...</li>
<li>the centroid of <em>s</em> itself will be labelled <em>p</em>[<em>dim</em>] in <em>t</em>.</li>
</ul>
<p>In particular, if this triangulation is currently oriented, then this barycentric subdivision will preserve the orientation.</p>
<p>If simplex <em>s</em> has index <em>i</em> in the original triangulation, then its sub-simplex corresponding to permutation <em>p</em> will have index <code>((dim + 1)! * i + p.orderedSnIndex())</code> in the resulting triangulation. In other words: sub-simplices are ordered first according to the original simplex that contains them, and then according to the lexicographical ordering of the corresponding permutations <em>p</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions. This precondition is a safety net, since in higher dimensions the triangulation would explode too quickly in size (and for the highest dimensions, possibly beyond the limits of <code>size_t</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimensions 3 and 4, both the labelling and ordering of sub-simplices in the subdivided triangulation has changed as of Regina 5.1. (Earlier versions of Regina made no guarantee about the labelling and ordering; these guarantees are also new to Regina 5.1).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>This triangulation contains at least one locked top-dimensional simplex and/or facet. This exception will be thrown before any changes are made. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on how such locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the subdivision. However, only do this for <em>valid</em> triangulations (since we can have scenarios where invalid triangulations becoming valid and ideal after subdivision, which may change properties such as Triangulation&lt;4&gt;::knownSimpleLinks). </dd></dl>

</div>
</div>
<a id="a111c0d2dfaba45d86517ba04bb7aa019" name="a111c0d2dfaba45d86517ba04bb7aa019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111c0d2dfaba45d86517ba04bb7aa019">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Snapshottable.html">Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap operation. </p>
<p>This should <em>only</em> be called when the entire type <em>T</em> contents of this object and <em>other</em> are being swapped. If one object has a current snapshot, then the other object will move in as the new image for that <em>same</em> snapshot. This avoids a deep copies of this object and/or <em>other</em>, even though both objects are changing.</p>
<p>In particular, if the swap function for <em>T</em> calls this base class function (as it should), then there is no need to call <a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f">takeSnapshot()</a> from either this object or <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the snapshot image being swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b16509c98bc3e4b38f673aff15337f5" name="a8b16509c98bc3e4b38f673aff15337f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b16509c98bc3e4b38f673aff15337f5">&#9670;&#160;</a></span>swapBaseData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::swapBaseData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all data that is managed by this base class, including simplices, skeletal data, cached properties and the snapshotting data, with the given triangulation. </p>
<p>Note that <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this routine itself. Typically <a class="el" href="#a8b16509c98bc3e4b38f673aff15337f5" title="Swaps all data that is managed by this base class, including simplices, skeletal data,...">swapBaseData()</a> is only ever called by <a class="el" href="classregina_1_1Triangulation.html#a2bd6dce66f275321427010a5b11b0894" title="Swaps the contents of this and the given triangulation.">Triangulation&lt;dim&gt;::swap()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose data should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7e625e918d497e1a006bc13b64a1d4f" name="ac7e625e918d497e1a006bc13b64a1d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e625e918d497e1a006bc13b64a1d4f">&#9670;&#160;</a></span>takeSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::takeSnapshot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called before modification and/or destruction of the type <em>T</em> contents. </p>
<p>See the <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> class notes for a full explanation of how this requirement works.</p>
<p>There are a few exceptions where <a class="el" href="classregina_1_1Snapshottable.html#ac7e625e918d497e1a006bc13b64a1d4f">takeSnapshot()</a> does not need to be called: these are where type <em>T</em> move, copy and/or swap operations call the base class operations (as they should). See the <a class="el" href="classregina_1_1Snapshottable.html" title="A base class for images of type T that can be snapshotted at a particular moment in time.">Snapshottable</a> move, copy and swap functions for details.</p>
<p>If this object has a current snapshot, then this function will trigger a deep copy with the snapshot.</p>
<p>After this function returns, this object is guaranteed to be completely unenrolled from the snapshotting machinery. </p>

</div>
</div>
<a id="a93ff42c3c6b43c59759b08be17d7e269" name="a93ff42c3c6b43c59759b08be17d7e269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff42c3c6b43c59759b08be17d7e269">&#9670;&#160;</a></span>tetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedra </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;3&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 3. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p>See <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="ad2cfbc6303920dc017eaf102d272ba4e" name="ad2cfbc6303920dc017eaf102d272ba4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cfbc6303920dc017eaf102d272ba4e">&#9670;&#160;</a></span>tetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3. It returns a non-const tetrahedron pointer.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a2272099afa80eff2b1aed22237df0147" name="a2272099afa80eff2b1aed22237df0147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2272099afa80eff2b1aed22237df0147">&#9670;&#160;</a></span>tetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;3&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 3. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3. It returns a const tetrahedron pointer in dimension <em>dim</em> = 3, and a non-const tetrahedron pointer in all higher dimensions.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a93e807b7e562aeafd28ca506bd78f7b4" name="a93e807b7e562aeafd28ca506bd78f7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e807b7e562aeafd28ca506bd78f7b4">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a triangulation from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a <em>dim</em>-dimensional triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a <em>dim</em>-dimensional triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the triangulation represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a393121abbf7a159a21ffca9deb9fb824" name="a393121abbf7a159a21ffca9deb9fb824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393121abbf7a159a21ffca9deb9fb824">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this triangulation to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a5857fcc6d1187bc8d72b900fef3161d6" name="a5857fcc6d1187bc8d72b900fef3161d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5857fcc6d1187bc8d72b900fef3161d6">&#9670;&#160;</a></span>topologyLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TopologyLockable::topologyLocked </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not there are any topology locks currently held on this object. </p>
<p>Strictly speaking, this routine could return a false negative: the number of locks is stored as an 8-bit integer and so in reality this tests whether the number of locks is a multiple of 256. False negatives are mathematically harmless, since the worst that will happen is that topological properties will be cleared when they could have been preserved, and so unnecessary extra computation may be required to compute them again.</p>
<p>This routine will never return a false positive.</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if there are no topology locks currently held on this object, or if a false negative occurs (as described above); or <code>true</code> to indicate that there are currently topology locks held on this object. </dd></dl>

</div>
</div>
<a id="a2a9a1bdc2c2e643c8c424cd31f557207" name="a2a9a1bdc2c2e643c8c424cd31f557207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9a1bdc2c2e643c8c424cd31f557207">&#9670;&#160;</a></span>translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a face of some other triangulation into the corresponding face of this triangulation, using simplex numbers for the translation. </p>
<p>Typically this routine would be used when the given face comes from a triangulation that is combinatorially identical to this, and you wish to obtain the corresponding face of this triangulation.</p>
<p>Specifically:</p>
<ul>
<li>For faces of dimension <code>k &lt; dim</code>, if <em>other</em> refers to face <em>i</em> of top-dimensional simplex number <em>k</em> of some other triangulation, then this routine will return face <em>i</em> of top-dimensional simplex number <em>k</em> of this triangulation. Note that this routine does <em>not</em> use the face indices within each triangulation (which is outside the user's control), but rather the simplex numbering (which the user has full control over).</li>
<li>For top-dimensional simplices (i.e., faces of dimension <code>k = dim</code>), this routine will simply translate top-dimensional simplex number <em>k</em> of some other triangulation into top-dimensional simplex number <em>k</em> of this triangulation.</li>
</ul>
<p>This routine behaves correctly even if <em>other</em> is a null pointer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation contains at least as many top-dimensional simplices as the triangulation containing <em>other</em> (though, as noted above, in typical scenarios both triangulations would actually be combinatorially identical).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em> inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the face to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face of this triangulation. </dd></dl>

</div>
</div>
<a id="a52b0522d4a3195257f4d5409253b524a" name="a52b0522d4a3195257f4d5409253b524a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b0522d4a3195257f4d5409253b524a">&#9670;&#160;</a></span>translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, subdim &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, subdim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a face embedding from some other triangulation into the corresponding face embedding with respect to this triangulation, using simplex numbers for the translation. </p>
<p>Typically this routine would be used when the given embedding comes from a triangulation that is combinatorially identical to this, and you wish to obtain the corresponding face embedding within this triangulation.</p>
<p>Specifically: if the embedding <em>other</em> refers to face <em>i</em> of top-dimensional simplex number <em>k</em> of some other triangulation, then the embedding that is returned will refer to face <em>i</em> of top-dimensional simplex number <em>k</em> of this triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation contains at least as many top-dimensional simplices as the triangulation containing <em>other</em> (though, as noted above, in typical scenarios both triangulations would actually be combinatorially identical).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the face dimension; this must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the face embedding to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face embedding in this triangulation. </dd></dl>

</div>
</div>
<a id="a19d82c1572359a3075cfe47d2916e1f8" name="a19d82c1572359a3075cfe47d2916e1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d82c1572359a3075cfe47d2916e1f8">&#9670;&#160;</a></span>triangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2. </p>
<p>This alias is available for all dimensions <em>dim</em>. It returns a non-const triangle pointer.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="a5c7536b6eef07a72d344053560d06594" name="a5c7536b6eef07a72d344053560d06594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7536b6eef07a72d344053560d06594">&#9670;&#160;</a></span>triangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;2&gt;()</a>, or an alias for <a class="el" href="#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> in dimension <em>dim</em> = 2. </p>
<p>This alias is available for all dimensions <em>dim</em>. It returns a const triangle pointer in dimension <em>dim</em> = 2, and a non-const triangle pointer in all higher dimensions.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="acce900ea2eb29bfac1b9c93ca78f9ea3" name="acce900ea2eb29bfac1b9c93ca78f9ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce900ea2eb29bfac1b9c93ca78f9ea3">&#9670;&#160;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;2&gt;()</a>, or an alias for <a class="el" href="#a7d7a7d5c459569dbf66147b62f695c2d" title="Returns an object that allows iteration through and random access to all top-dimensional simplices in...">simplices()</a> in dimension <em>dim</em> = 2. </p>
<p>This alias is available for all dimensions.</p>
<p>See <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a8c9bc864e2b45447e3fcc92f99d3840e" name="a8c9bc864e2b45447e3fcc92f99d3840e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9bc864e2b45447e3fcc92f99d3840e">&#9670;&#160;</a></span>triangulateComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::triangulateComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the individual connected components of this triangulation. </p>
<p>This triangulation will not be modified.</p>
<p>This function is new to Regina 7.0, and it has two important changes of behaviour from the old splitIntoComponents() from Regina 6.0.1 and earlier:</p>
<ul>
<li>This function does not insert the resulting components into the packet tree.</li>
<li>This function does not assign labels to the new components.</li>
</ul>
<p>If this triangulation has locks on any top-dimensional simplices and/or their facets, these locks will also be copied over to the newly-triangulated components.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of individual component triangulations. </dd></dl>

</div>
</div>
<a id="afca59a5a9f5b041d2159cc995f643c0f" name="afca59a5a9f5b041d2159cc995f643c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca59a5a9f5b041d2159cc995f643c0f">&#9670;&#160;</a></span>twoZeroMove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a 2-0 move about the given <em>k</em>-face of this triangulation. </p>
<p>For more detail on 2-0 moves and when they can be performed, see <a class="el" href="#a1e874f14510689aa9db756ddc8611ca3" title="If possible, performs a 2-0 move about the given k-face of degree two.">move20()</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is legal and will not violate any simplex and/or facet locks (see <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for further details on locks). If the move <em>is</em> allowed, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000224">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a797ccce735aa5a4eab9433f64b848faa" title="Determines whether it is possible to perform a 2-0 move about the given k-face of this triangulation,...">has20()</a>. If you wish to both check and perform the move, call <a class="el" href="#a1e874f14510689aa9db756ddc8611ca3" title="If possible, performs a 2-0 move about the given k-face of degree two.">move20()</a>, which does not take the two extra boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be 0, 1 or 2, and must not exceed <code>dim - 2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="ac66330cee32127dad0c2ac14874acd71" name="ac66330cee32127dad0c2ac14874acd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66330cee32127dad0c2ac14874acd71">&#9670;&#160;</a></span>unlockAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::unlockAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks all top-dimensional simplices and their facets. </p>
<p>In short, locking a top-dimensional simplex and/or some of its facets means that that the simplex and/or facets must not be changed. See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">Simplex&lt;dim&gt;::lock()</a> and <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">Simplex&lt;dim&gt;::lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>After this is routine called, <a class="el" href="#ac40a47a823d15f016cd0efeb9d1b1644" title="Identifies whether any top-dimensional simplices and/or any of their facets are locked.">hasLocks()</a> will return <code>false</code>. </p>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a9b86e0d3a00fa5da038c6cce117b343f" name="a9b86e0d3a00fa5da038c6cce117b343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b86e0d3a00fa5da038c6cce117b343f">&#9670;&#160;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face&lt;0&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a802ea1cdd46af32418fb76c49712ccb8" title="Returns the requested subdim-face of this triangulation, in a way that is optimised for C++ programme...">face()</a> for further information. </p>

</div>
</div>
<a id="ad44ec5cdb434c3119eb68ce0deae76c8" name="ad44ec5cdb434c3119eb68ce0deae76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ec5cdb434c3119eb68ce0deae76c8">&#9670;&#160;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces&lt;0&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#ac4a59c70ef42fd731d7167df4973f389" title="Returns an object that allows iteration through and random access to all subdim-faces of this triangu...">faces()</a> for further information. </p>

</div>
</div>
<a id="a1820f61089b2dd96808420c7cbf383bc" name="a1820f61089b2dd96808420c7cbf383bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1820f61089b2dd96808420c7cbf383bc">&#9670;&#160;</a></span>with20()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::with20 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If possible, returns the triangulation obtained by performing a 2-0 move about the given <em>k</em>-face of this triangulation. </p>
<p>If such a move is not allowed, or if such a move would violate any simplex and/or facet locks, then this routine returns no value.</p>
<p>This triangulation will not be changed.</p>
<p>For more detail on 2-0 moves and when they can be performed, see <a class="el" href="#a1e874f14510689aa9db756ddc8611ca3" title="If possible, performs a 2-0 move about the given k-face of degree two.">move20()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be 0, 1 or 2, and must not exceed <code>dim - 2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new triangulation obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a4da934e97035b4b4d5eb27f0cb156c6e" name="a4da934e97035b4b4d5eb27f0cb156c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da934e97035b4b4d5eb27f0cb156c6e">&#9670;&#160;</a></span>withPachner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::withPachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If possible, returns the triangulation obtained by performing a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face of this triangulation. </p>
<p>If such a move is not allowed, or if such a move would violate any simplex and/or facet locks, then this routine returns no value.</p>
<p>This triangulation will not be changed.</p>
<p>For more detail on Pachner moves and when they can be performed, see <a class="el" href="#a9b1e72e8b2ac09786a36bc0c97aa16aa" title="If possible, performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face.">pachner()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new triangulation obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a75b3c1559b9efd6989b2f71f0fa48940" name="a75b3c1559b9efd6989b2f71f0fa48940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b3c1559b9efd6989b2f71f0fa48940">&#9670;&#160;</a></span>withShellBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::withShellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If possible, returns the triangulation obtained by performing a boundary shelling move on the given top-dimensional simplex of this triangulation. </p>
<p>If such a move is not allowed, or if such a move would violate any simplex and/or facet locks, then this routine returns no value.</p>
<p>This operation is <em>only available in standard dimensions</em>, since Regina's notion of "valid faces" is weaker in higher dimensions (due to the need to solve undecidable problems). See <a class="el" href="classregina_1_1detail_1_1FaceBase.html#ab1ee842a9ff01de928193d14c23ce4f7" title="Determines if this face is valid.">Face::isValid()</a> for further discussion.</p>
<p>This triangulation will not be changed.</p>
<p>For more detail on boundary shelling moves and when they can be performed, see <a class="el" href="#afa795373077b40844b3e960ab551f861" title="If possible, performs a boundary shelling move upon the given top-dimensional simplex of this triangu...">shellBoundary()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. </dd>
<dd>
The given simplex is a simplex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the top-dimensional simplex upon which to perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new triangulation obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a856a84ed29cd61f1b3bea9df595fb981" name="a856a84ed29cd61f1b3bea9df595fb981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856a84ed29cd61f1b3bea9df595fb981">&#9670;&#160;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the dual graph of this triangulation in the Graphviz DOT language. </p>
<p>See <a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">dot()</a> for further details on what this output contains.</p>
<p>This routine is equivalent to (but faster than) writing the string returned by <a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">dot()</a> to the given output stream.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#a085f589f5d63dbbac25978cf350ff459" title="Returns a Graphviz DOT representation of the dual graph of this triangulation.">dot()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices should be labelled with the corresponding top-dimensional simplex numbers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a60a36c856a443ff64609e1b7761bf875" name="a60a36c856a443ff64609e1b7761bf875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a36c856a443ff64609e1b7761bf875">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad4d1c374ad8abd557bd087251a0eb6" name="a9ad4d1c374ad8abd557bd087251a0eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad4d1c374ad8abd557bd087251a0eb6">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1d1a2ca27fd966c3c7403f0a1c6080d" name="ad1d1a2ca27fd966c3c7403f0a1c6080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d1a2ca27fd966c3c7403f0a1c6080d">&#9670;&#160;</a></span>writeXMLBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeXMLBaseProperties </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing properties of this triangulation. </p>
<p>This routine covers those properties that are managed by this base class <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> and that have already been computed for this triangulation.</p>
<p>This routine is typically called from within Triangulation&lt;dim&gt;::writeXMLPacketData(). The XML elements that it writes are child elements of the <code>tri</code> element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa6e46682d3ce5b05f7e693f863018f66" name="aa6e46682d3ce5b05f7e693f863018f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e46682d3ce5b05f7e693f863018f66">&#9670;&#160;</a></span>boundaryComponents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The components that form the boundary of the triangulation. </p>

</div>
</div>
<a id="a17cab33bd8fb5910570468b60fe4f18b" name="a17cab33bd8fb5910570468b60fe4f18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cab33bd8fb5910570468b60fe4f18b">&#9670;&#160;</a></span>components_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::components_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The connected components that form the triangulation. </p>
<p>This list is only filled if/when the skeleton of the triangulation is computed. </p>

</div>
</div>
<a id="aa177dda3276927267a3ae0130765a6f1" name="aa177dda3276927267a3ae0130765a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa177dda3276927267a3ae0130765a6f1">&#9670;&#160;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of the triangulation. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&#160;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p>As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="a1db8e55f59788fbb27cb5a15c44f127a" name="a1db8e55f59788fbb27cb5a15c44f127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db8e55f59788fbb27cb5a15c44f127a">&#9670;&#160;</a></span>nBoundaryFaces_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;size_t, dim&gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::nBoundaryFaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary faces of each dimension. </p>

</div>
</div>
<a id="a1739e33bdbb5c52cb77de81ec93c1ec8" name="a1739e33bdbb5c52cb77de81ec93c1ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1739e33bdbb5c52cb77de81ec93c1ec8">&#9670;&#160;</a></span>simplices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-dimensional simplices that form the triangulation. </p>

</div>
</div>
<a id="a11f83f8f5e9df2281cb7b65b1d46bd4c" name="a11f83f8f5e9df2281cb7b65b1d46bd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f83f8f5e9df2281cb7b65b1d46bd4c">&#9670;&#160;</a></span>topologyLock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t regina::TopologyLockable::topologyLock_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of topology locks currently held on this object. </p>
<p>Any non-zero number of locks implies that "hook routines" that clear computed properties (as described in the class notes) will preserve properties that are purely topological. </p>

</div>
</div>
<a id="a106dc9d8ffc9e2bd1dd35ad35d52773c" name="a106dc9d8ffc9e2bd1dd35ad35d52773c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106dc9d8ffc9e2bd1dd35ad35d52773c">&#9670;&#160;</a></span>valid_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this triangulation valid? See <a class="el" href="#ab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>triangulation/detail/<a class="el" href="detail_2boundarycomponent_8h.html">boundarycomponent.h</a></li>
<li>triangulation/detail/<a class="el" href="detail_2component_8h.html">component.h</a></li>
<li>triangulation/detail/<a class="el" href="detail_2face_8h.html">face.h</a></li>
<li>triangulation/detail/<a class="el" href="detail_2simplex_8h.html">simplex.h</a></li>
<li>triangulation/detail/<a class="el" href="detail_2triangulation_8h.html">triangulation.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
