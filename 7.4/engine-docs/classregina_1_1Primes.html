<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::Primes Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Primes.html">Primes</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1Primes-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Primes Class Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A helper class for finding primes and factorising integers.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;maths/primes.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a67943b6500c9dbfce1265bb3c709f0fb" id="r_a67943b6500c9dbfce1265bb3c709f0fb"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67943b6500c9dbfce1265bb3c709f0fb">size</a> ()</td></tr>
<tr class="memdesc:a67943b6500c9dbfce1265bb3c709f0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of primes (or suspected primes) currently stored.  <br /></td></tr>
<tr class="separator:a67943b6500c9dbfce1265bb3c709f0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e63b81b6f268d258c2dd33d30cab52c" id="r_a9e63b81b6f268d258c2dd33d30cab52c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e63b81b6f268d258c2dd33d30cab52c">prime</a> (size_t which, bool autoGrow=true)</td></tr>
<tr class="memdesc:a9e63b81b6f268d258c2dd33d30cab52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested prime (or suspected prime).  <br /></td></tr>
<tr class="separator:a9e63b81b6f268d258c2dd33d30cab52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e357e3d10095e07d841ad2251219446" id="r_a3e357e3d10095e07d841ad2251219446"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e357e3d10095e07d841ad2251219446">primeDecomp</a> (const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;n)</td></tr>
<tr class="memdesc:a3e357e3d10095e07d841ad2251219446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prime factorisation of the given integer as a list of individual primes (or suspected primes).  <br /></td></tr>
<tr class="separator:a3e357e3d10095e07d841ad2251219446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fc0db2a816d6c57b7c890c80f788d7" id="r_ad9fc0db2a816d6c57b7c890c80f788d7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>, unsigned long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9fc0db2a816d6c57b7c890c80f788d7">primePowerDecomp</a> (const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;n)</td></tr>
<tr class="memdesc:ad9fc0db2a816d6c57b7c890c80f788d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prime factorisation of the given integer as a list of prime powers (or suspected prime powers).  <br /></td></tr>
<tr class="separator:ad9fc0db2a816d6c57b7c890c80f788d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A helper class for finding primes and factorising integers. </p>
<p>This class has two functions: (i) to maintain a list of known primes, and (ii) to use this list to factorise integers into prime factors.</p>
<p>The primes stored by this class will always be the smallest <em>k</em> suspected primes, where <em>k</em> may grow dynamically as the program runs. Specifically:</p>
<ul>
<li>An initial hard-coded list of seed primes is loaded into the class on startup. This list contains precisely the smallest 10,000 primes (the size of this list is subject to change in future versions of Regina).</li>
<li>Whenever a prime beyond the known list is requested (e.g., when a number greater than the largest stored prime is to be factorised), the list is extended on the fly. The extension uses the probabilistic algorithm shipped with GMP (hence the phrase "suspected primes" above); regarding this algorithm, the GMP documentation states that "for
  practical purposes it's adequate, the chance of a composite passing
  will be extremely small."</li>
</ul>
<p>This list is used by the high-level factorisation routines in this class, such as <a class="el" href="#a3e357e3d10095e07d841ad2251219446" title="Returns the prime factorisation of the given integer as a list of individual primes (or suspected pri...">primeDecomp()</a> and <a class="el" href="#ad9fc0db2a816d6c57b7c890c80f788d7" title="Returns the prime factorisation of the given integer as a list of prime powers (or suspected prime po...">primePowerDecomp()</a>. For users only interested in these high-level routines, there is no need to worry about the size of the list; the high-level routines will extend it if necessary.</p>
<p>Although this class makes use of global data in its implementation, all of its methods are thread-safe.</p>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney, B.B. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9e63b81b6f268d258c2dd33d30cab52c" name="a9e63b81b6f268d258c2dd33d30cab52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e63b81b6f268d258c2dd33d30cab52c">&#9670;&#160;</a></span>prime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> regina::Primes::prime </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>which</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoGrow</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested prime (or suspected prime). </p>
<p>More specifically, this routine returns the (<em>which</em> + 1)th smallest prime. Thus prime(0) returns 2, prime(1) returns 3, prime(2) returns 5, and so on.</p>
<p>If <em>which</em> is smaller than the number of initial seed primes, the result is guaranteed to be the (<em>which</em> + 1)th smallest prime (see the <a class="el" href="classregina_1_1Primes.html" title="A helper class for finding primes and factorising integers.">Primes</a> class notes for the size of the initial seed list). If <em>which</em> is larger, a probabilistic algorithm is used and so there is a possibility that non-primes are included in the list.</p>
<p>If <em>which</em> &lt; <a class="el" href="#a67943b6500c9dbfce1265bb3c709f0fb" title="Returns the number of primes (or suspected primes) currently stored.">size()</a> then this routine is essentially instantaneous, since the (<em>which</em> + 1)th smallest (suspected) prime is already stored. Otherwise the behaviour depends on the argument <em>autoGrow</em>. If <em>autoGrow</em> is <code>true</code> (the default) then this routine calculates the requested prime, which might take some time. If <em>autoGrow</em> is <code>false</code> then this routine returns zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which prime is requested. </td></tr>
    <tr><td class="paramname">autoGrow</td><td>specifies what to do if the requested prime lies beyond the list currently stored (see above). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested prime (or suspected prime), or zero if <em>which</em> was too large and <em>autoGrow</em> was <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3e357e3d10095e07d841ad2251219446" name="a3e357e3d10095e07d841ad2251219446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e357e3d10095e07d841ad2251219446">&#9670;&#160;</a></span>primeDecomp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; regina::Primes::primeDecomp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prime factorisation of the given integer as a list of individual primes (or suspected primes). </p>
<p>Prime factors are returned in increasing order. Where a prime power appears in the factorisation, the relevant prime will appear several times in the list.</p>
<p>For very large integers, the factorisation becomes probabilistic: (i) this routine examines suspected primes instead of primes (see the class notes), and (ii) if the routine is having trouble finding factors then it will run a probabilistic prime test on whatever portion of <em>n</em> still remains (and will assume that portion to be prime if the test passes).</p>
<p>The given integer may be negative, in which case -1 will be listed as the first factor (even though -1 is not prime). If 0 is passed then a single factor of 0 will be returned; if 1 is passed then an empty list will be returned. In all cases, the given integer <em>n</em> will be the product of all elements of the final list (where an empty product is assumed to be 1).</p>
<p>As an example, the prime factors of 54 will be listed as (2, 3, 3, 3), and the prime factors of -90 will be listed as (-1, 2, 3, 3, 5).</p>
<p>Note that the internal list of known primes and suspected primes will be expanded as necessary; there is no need for the caller to manage this list manually.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo</a></b></dt><dd><em>Optimise:</em> Add a version that does not return the factors by value.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In addition to this routine, the routine primeDecompInt() is also available. The routine primeDecompInt() behaves identically to this routine except that the (i) return values are of ordinary integer type, not Integer; (ii) the input value <em>n</em> must lie within the C++ long integer range (otherwise the behaviour is undefined).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the integer to factorise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of prime factors as described above. </dd></dl>

</div>
</div>
<a id="ad9fc0db2a816d6c57b7c890c80f788d7" name="ad9fc0db2a816d6c57b7c890c80f788d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fc0db2a816d6c57b7c890c80f788d7">&#9670;&#160;</a></span>primePowerDecomp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::pair&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>, unsigned long &gt; &gt; regina::Primes::primePowerDecomp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prime factorisation of the given integer as a list of prime powers (or suspected prime powers). </p>
<p>Factors are returned as (prime, exponent) pairs. Different pairs describe different primes, and the pairs are sorted in order from smallest prime to largest. All exponents are strictly positive.</p>
<p>For very large integers, the factorisation becomes probabilistic: (i) this routine examines suspected primes instead of primes (see the class notes), and (ii) if the routine is having trouble finding factors then it will run a probabilistic prime test on whatever portion of <em>n</em> still remains (and will assume that portion to be prime if the test passes).</p>
<p>The given integer may be negative, in which case (-1,1) will be listed as the first prime power (even though -1 is not prime). If 0 is passed then a single pair (0,1) will be returned; if 1 is passed then an empty list will be returned. In all cases, the given integer <em>n</em> will be the product of all powers described by the final list (where an empty product is assumed to be 1).</p>
<p>As an example, the factorisation of 54 will be reported as [(2,1) (3,3)], and the factorisation of -90 will be reported as [(-1,1) (2,1) (3,2) (5,1)].</p>
<p>Note that the internal list of known primes and suspected primes will be expanded as necessary; there is no need for the caller to manage this list manually.</p>
<p>The current implementation of this routine merely calls <a class="el" href="#a3e357e3d10095e07d841ad2251219446" title="Returns the prime factorisation of the given integer as a list of individual primes (or suspected pri...">primeDecomp()</a> and rewrites the list of factors by grouping primes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo</a></b></dt><dd><em>Optimise:</em> Implement this routine natively to avoid the overhead of the temporary <a class="el" href="#a3e357e3d10095e07d841ad2251219446" title="Returns the prime factorisation of the given integer as a list of individual primes (or suspected pri...">primeDecomp()</a> vector.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo</a></b></dt><dd><em>Optimise:</em> Add a version that does not return the factors by value.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In addition to this routine, the routine primePowerDecompInt() is also available. The routine primePowerDecompInt() behaves identically to this routine except that the (i) return values are of ordinary integer type, not Integer; (ii) the input value <em>n</em> must lie within the C++ long integer range (otherwise the behaviour is undefined).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the integer to factorise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of prime power factors as described above. </dd></dl>

</div>
</div>
<a id="a67943b6500c9dbfce1265bb3c709f0fb" name="a67943b6500c9dbfce1265bb3c709f0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67943b6500c9dbfce1265bb3c709f0fb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Primes::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of primes (or suspected primes) currently stored. </p>
<p><a class="el" href="classregina_1_1Primes.html" title="A helper class for finding primes and factorising integers.">Primes</a> that are already stored can be accessed instantly; primes larger than those currently stored must be generated on the fly (which takes time).</p>
<p>This number may increase as the program runs (according to whether larger primes are requested), but it will never decrease.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of primes or suspected primes currently stored. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>maths/<a class="el" href="primes_8h.html">primes.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
