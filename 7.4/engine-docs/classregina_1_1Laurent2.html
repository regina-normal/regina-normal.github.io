<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::Laurent2&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Laurent2-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Laurent2&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;maths/laurent2.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Laurent2&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Laurent2.png" usemap="#regina::Laurent2_3C_20T_20_3E_map" alt=""/>
  <map id="regina::Laurent2_3C_20T_20_3E_map" name="regina::Laurent2_3C_20T_20_3E_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Laurent2&lt; T &gt;, true &gt;" shape="rect" coords="0,56,257,80"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Laurent2&lt; T &gt; &gt;" shape="rect" coords="267,56,524,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; T, supportsUtf8 &gt;" shape="rect" coords="0,0,257,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab6f6ee7dcc072a40c5efd0047534ed8a" id="r_ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6f6ee7dcc072a40c5efd0047534ed8a">Coefficient</a> = T</td></tr>
<tr class="memdesc:ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each coefficient of the polynomial.  <br /></td></tr>
<tr class="separator:ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9616417b71fba47f8169ef0ed71f0f95" id="r_a9616417b71fba47f8169ef0ed71f0f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9616417b71fba47f8169ef0ed71f0f95">Laurent2</a> ()=default</td></tr>
<tr class="memdesc:a9616417b71fba47f8169ef0ed71f0f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the zero polynomial.  <br /></td></tr>
<tr class="separator:a9616417b71fba47f8169ef0ed71f0f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc2af7274f123e473f108bc1259d5c" id="r_a66bc2af7274f123e473f108bc1259d5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66bc2af7274f123e473f108bc1259d5c">Laurent2</a> (long xExp, long yExp)</td></tr>
<tr class="memdesc:a66bc2af7274f123e473f108bc1259d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated constructor that creates the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>.  <br /></td></tr>
<tr class="separator:a66bc2af7274f123e473f108bc1259d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807c716cf55df302a2ce75d0eb596aa" id="r_ae807c716cf55df302a2ce75d0eb596aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae807c716cf55df302a2ce75d0eb596aa">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ae807c716cf55df302a2ce75d0eb596aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <br /></td></tr>
<tr class="separator:ae807c716cf55df302a2ce75d0eb596aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340676c9f944ce88693e69bbea56023" id="r_aa340676c9f944ce88693e69bbea56023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa340676c9f944ce88693e69bbea56023">Laurent2</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;value) noexcept=default</td></tr>
<tr class="memdesc:aa340676c9f944ce88693e69bbea56023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this new polynomial.  <br /></td></tr>
<tr class="separator:aa340676c9f944ce88693e69bbea56023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1c31a611b8708d14bdf6e809d016f" id="r_a25c1c31a611b8708d14bdf6e809d016f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c1c31a611b8708d14bdf6e809d016f">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;toShift, long xShift, long yShift)</td></tr>
<tr class="memdesc:a25c1c31a611b8708d14bdf6e809d016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given polynomial with all terms multiplied by <code>x^d y^e</code> for some integers <em>d</em> and <em>e</em>.  <br /></td></tr>
<tr class="separator:a25c1c31a611b8708d14bdf6e809d016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd07a8882921df669daf862ebd624a73" id="r_acd07a8882921df669daf862ebd624a73"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acd07a8882921df669daf862ebd624a73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd07a8882921df669daf862ebd624a73">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:acd07a8882921df669daf862ebd624a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <br /></td></tr>
<tr class="separator:acd07a8882921df669daf862ebd624a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f3c265d8997bdfa3b8b494673d25e" id="r_ab97f3c265d8997bdfa3b8b494673d25e"><td class="memTemplParams" colspan="2">template&lt;typename iterator , typename deref  = decltype(*iterator())&gt; </td></tr>
<tr class="memitem:ab97f3c265d8997bdfa3b8b494673d25e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab97f3c265d8997bdfa3b8b494673d25e">Laurent2</a> (iterator begin, iterator end)</td></tr>
<tr class="memdesc:ab97f3c265d8997bdfa3b8b494673d25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from the given collection of coefficients.  <br /></td></tr>
<tr class="separator:ab97f3c265d8997bdfa3b8b494673d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c3979b7f375496277c6d81a0fc7e87" id="r_aa6c3979b7f375496277c6d81a0fc7e87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6c3979b7f375496277c6d81a0fc7e87">Laurent2</a> (std::initializer_list&lt; std::tuple&lt; long, long, T &gt; &gt; coefficients)</td></tr>
<tr class="memdesc:aa6c3979b7f375496277c6d81a0fc7e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from a hard-coded collection of non-zero coefficients.  <br /></td></tr>
<tr class="separator:aa6c3979b7f375496277c6d81a0fc7e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9ab37ac09da1d2c1af9597f6e333dd" id="r_a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9ab37ac09da1d2c1af9597f6e333dd">init</a> ()</td></tr>
<tr class="memdesc:a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the zero polynomial.  <br /></td></tr>
<tr class="separator:a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157870b097f4ca71a3840c6d5d86a496" id="r_a157870b097f4ca71a3840c6d5d86a496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a157870b097f4ca71a3840c6d5d86a496">initExp</a> (long xExp, long yExp)</td></tr>
<tr class="memdesc:a157870b097f4ca71a3840c6d5d86a496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>.  <br /></td></tr>
<tr class="separator:a157870b097f4ca71a3840c6d5d86a496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151f203694f59cfa524785828edf9e81" id="r_a151f203694f59cfa524785828edf9e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151f203694f59cfa524785828edf9e81">init</a> (long xExp, long yExp)</td></tr>
<tr class="memdesc:a151f203694f59cfa524785828edf9e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated function that sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>.  <br /></td></tr>
<tr class="separator:a151f203694f59cfa524785828edf9e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2127cd484f250361b34862f116a597" id="r_a0f2127cd484f250361b34862f116a597"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f2127cd484f250361b34862f116a597">isZero</a> () const</td></tr>
<tr class="memdesc:a0f2127cd484f250361b34862f116a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is the zero polynomial.  <br /></td></tr>
<tr class="separator:a0f2127cd484f250361b34862f116a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9123daa1ba8056b3afde06f9a3087d77" id="r_a9123daa1ba8056b3afde06f9a3087d77"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9123daa1ba8056b3afde06f9a3087d77">operator()</a> (long xExp, long yExp) const</td></tr>
<tr class="memdesc:a9123daa1ba8056b3afde06f9a3087d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given coefficient of this polynomial.  <br /></td></tr>
<tr class="separator:a9123daa1ba8056b3afde06f9a3087d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e21fd6436363e5555380f69aef2b5ba" id="r_a6e21fd6436363e5555380f69aef2b5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e21fd6436363e5555380f69aef2b5ba">set</a> (long xExp, long yExp, const T &amp;value)</td></tr>
<tr class="memdesc:a6e21fd6436363e5555380f69aef2b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the given coefficient of this polynomial.  <br /></td></tr>
<tr class="separator:a6e21fd6436363e5555380f69aef2b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0" id="r_a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0">operator==</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given polynomial are equal.  <br /></td></tr>
<tr class="separator:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bd6b6b6068fa5f976bee847c210cc3" id="r_af9bd6b6b6068fa5f976bee847c210cc3"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9bd6b6b6068fa5f976bee847c210cc3">operator&lt;=&gt;</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:af9bd6b6b6068fa5f976bee847c210cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <br /></td></tr>
<tr class="separator:af9bd6b6b6068fa5f976bee847c210cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c335642e5da5084f38d5b3c166e36b" id="r_a48c335642e5da5084f38d5b3c166e36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c335642e5da5084f38d5b3c166e36b">operator=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a48c335642e5da5084f38d5b3c166e36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <br /></td></tr>
<tr class="separator:a48c335642e5da5084f38d5b3c166e36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538528845f776b8908e3a08f24af37b1" id="r_a538528845f776b8908e3a08f24af37b1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a538528845f776b8908e3a08f24af37b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a538528845f776b8908e3a08f24af37b1">operator=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:a538528845f776b8908e3a08f24af37b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <br /></td></tr>
<tr class="separator:a538528845f776b8908e3a08f24af37b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032ed022582395968183345ee988f77b" id="r_a032ed022582395968183345ee988f77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032ed022582395968183345ee988f77b">operator=</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;value) noexcept=default</td></tr>
<tr class="memdesc:a032ed022582395968183345ee988f77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this polynomial.  <br /></td></tr>
<tr class="separator:a032ed022582395968183345ee988f77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5382c0231814155a040fd05d908d1f73" id="r_a5382c0231814155a040fd05d908d1f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5382c0231814155a040fd05d908d1f73">swap</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a5382c0231814155a040fd05d908d1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given polynomial.  <br /></td></tr>
<tr class="separator:a5382c0231814155a040fd05d908d1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fed3d5d702211cfd7b90cad87f43205" id="r_a8fed3d5d702211cfd7b90cad87f43205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fed3d5d702211cfd7b90cad87f43205">negate</a> ()</td></tr>
<tr class="memdesc:a8fed3d5d702211cfd7b90cad87f43205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates this polynomial.  <br /></td></tr>
<tr class="separator:a8fed3d5d702211cfd7b90cad87f43205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f26c1e006e72e788e2c997ba414d5" id="r_a928f26c1e006e72e788e2c997ba414d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928f26c1e006e72e788e2c997ba414d5">invertX</a> ()</td></tr>
<tr class="memdesc:a928f26c1e006e72e788e2c997ba414d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>x</code> with <code>x^-1</code> in this polynomial.  <br /></td></tr>
<tr class="separator:a928f26c1e006e72e788e2c997ba414d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edd6a788a049890345d6e73942259f2" id="r_a6edd6a788a049890345d6e73942259f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6edd6a788a049890345d6e73942259f2">invertY</a> ()</td></tr>
<tr class="memdesc:a6edd6a788a049890345d6e73942259f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>y</code> with <code>y^-1</code> in this polynomial.  <br /></td></tr>
<tr class="separator:a6edd6a788a049890345d6e73942259f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b4233936c5293e81447dc71daaf157" id="r_a62b4233936c5293e81447dc71daaf157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b4233936c5293e81447dc71daaf157">operator*=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:a62b4233936c5293e81447dc71daaf157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this polynomial by the given constant.  <br /></td></tr>
<tr class="separator:a62b4233936c5293e81447dc71daaf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a5d7d2ee2b527e1bf6f24564f6175a" id="r_ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2a5d7d2ee2b527e1bf6f24564f6175a">operator/=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this polynomial by the given constant.  <br /></td></tr>
<tr class="separator:ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f7e7ab24cc91845a017b34b887cb3c" id="r_a88f7e7ab24cc91845a017b34b887cb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f7e7ab24cc91845a017b34b887cb3c">operator+=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a88f7e7ab24cc91845a017b34b887cb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given polynomial to this.  <br /></td></tr>
<tr class="separator:a88f7e7ab24cc91845a017b34b887cb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4cdcdcf36e3c2323d6add8eb5f802f" id="r_a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c4cdcdcf36e3c2323d6add8eb5f802f">operator-=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given polynomial from this.  <br /></td></tr>
<tr class="separator:a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91abd504dba2918cfc8e1589eac7c147" id="r_a91abd504dba2918cfc8e1589eac7c147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91abd504dba2918cfc8e1589eac7c147">operator*=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a91abd504dba2918cfc8e1589eac7c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by the given polynomial.  <br /></td></tr>
<tr class="separator:a91abd504dba2918cfc8e1589eac7c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be6449b77d1e89b70195d5467bddff" id="r_a92be6449b77d1e89b70195d5467bddff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92be6449b77d1e89b70195d5467bddff">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="#ade0a2543536786e006e31898f01140bb">utf8</a>=false, const char *varX=nullptr, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:a92be6449b77d1e89b70195d5467bddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this polynomial to the given output stream, using the given variable names instead of <code>x</code> and <code>y</code>.  <br /></td></tr>
<tr class="separator:a92be6449b77d1e89b70195d5467bddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f12b76398e549fa66a3a0e7ef3b79" id="r_a760f12b76398e549fa66a3a0e7ef3b79"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79">str</a> (const char *varX, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:a760f12b76398e549fa66a3a0e7ef3b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string, using the given variable names instead of <code>x</code> and <code>y</code>.  <br /></td></tr>
<tr class="separator:a760f12b76398e549fa66a3a0e7ef3b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a2543536786e006e31898f01140bb" id="r_ade0a2543536786e006e31898f01140bb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade0a2543536786e006e31898f01140bb">utf8</a> (const char *varX, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:ade0a2543536786e006e31898f01140bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string using unicode characters, using the given variable names instead of <code>x</code> and <code>y</code>.  <br /></td></tr>
<tr class="separator:ade0a2543536786e006e31898f01140bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73caa4080f9139ff3c5fe4b3954af005" id="r_a73caa4080f9139ff3c5fe4b3954af005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73caa4080f9139ff3c5fe4b3954af005">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a73caa4080f9139ff3c5fe4b3954af005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this polynomial to the given output stream.  <br /></td></tr>
<tr class="separator:a73caa4080f9139ff3c5fe4b3954af005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51197dbd112bb60b7893cc51a09003" id="r_a2c51197dbd112bb60b7893cc51a09003"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a2c51197dbd112bb60b7893cc51a09003">hash</a> () const</td></tr>
<tr class="memdesc:a2c51197dbd112bb60b7893cc51a09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:a2c51197dbd112bb60b7893cc51a09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a336e0de0717577470b920e1bfca88d8b" id="r_a336e0de0717577470b920e1bfca88d8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a336e0de0717577470b920e1bfca88d8b">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a336e0de0717577470b920e1bfca88d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a polynomial from its given tight encoding.  <br /></td></tr>
<tr class="separator:a336e0de0717577470b920e1bfca88d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1e9ca4d39ca75620494c1f03ae5b00e8" id="r_a1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memItemLeft" align="right" valign="top"><a id="a1e9ca4d39ca75620494c1f03ae5b00e8" name="a1e9ca4d39ca75620494c1f03ae5b00e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Link</b></td></tr>
<tr class="separator:a1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e7f5f2f40f9bc758612463732f203" id="r_a2e6e7f5f2f40f9bc758612463732f203"><td class="memTemplParams" colspan="2"><a id="a2e6e7f5f2f40f9bc758612463732f203" name="a2e6e7f5f2f40f9bc758612463732f203"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2e6e7f5f2f40f9bc758612463732f203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a2e6e7f5f2f40f9bc758612463732f203"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class regina::Laurent2&lt; T &gt;</div><p>Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>. </p>
<p>A <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial differs from an ordinary polynomial in that it allows negative exponents (so, for example, you can represent a polynomial such as <code>2 + 3x² + y/x - 1/y³</code>).</p>
<p>The type <em>T</em> must represent a ring with no zero divisors. In particular, it must:</p>
<ul>
<li>support basic arithmetic operations;</li>
<li>support assignments of the form <code>x = int</code> and tests of the form <code>x == int</code> and <code>x &lt; int</code>;</li>
<li>have a default constructor that assigns an explicit value of zero.</li>
</ul>
<p>This means that Regina's numerical types such as Integer and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a> are supported, but native data types such as int and long are not (since they have no zero-initialising default constructor).</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<p>The underlying storage method for this class is sparse: only the non-zero coefficients are stored.</p>
<p>See also the class <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a>, which describes <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials in just one variable.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a> refers to the specific template class Laurent2&lt;Integer&gt;. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab6f6ee7dcc072a40c5efd0047534ed8a" name="ab6f6ee7dcc072a40c5efd0047534ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f6ee7dcc072a40c5efd0047534ed8a">&#9670;&#160;</a></span>Coefficient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Coefficient = T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of each coefficient of the polynomial. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9616417b71fba47f8169ef0ed71f0f95" name="a9616417b71fba47f8169ef0ed71f0f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616417b71fba47f8169ef0ed71f0f95">&#9670;&#160;</a></span>Laurent2() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the zero polynomial. </p>

</div>
</div>
<a id="a66bc2af7274f123e473f108bc1259d5c" name="a66bc2af7274f123e473f108bc1259d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bc2af7274f123e473f108bc1259d5c">&#9670;&#160;</a></span>Laurent2() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yExp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated constructor that creates the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated</a></b></dt><dd>This will be removed in a future version of Regina for consistency with the single-variable polynomial classes <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> and <a class="el" href="classregina_1_1Polynomial.html" title="Represents a single-variable polynomial with coefficients of type T.">Polynomial</a>, since for those classes it is too easy for a casual reader to misread what such an "exponent-based constructor" actually does. You can still create <code>x^d y^e</code> by calling <code>initExp(d, e)</code> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent <em>d</em>, which is attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent <em>e</em>, which is attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae807c716cf55df302a2ce75d0eb596aa" name="ae807c716cf55df302a2ce75d0eb596aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae807c716cf55df302a2ce75d0eb596aa">&#9670;&#160;</a></span>Laurent2() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p>This constructor induces a deep copy of <em>value</em>.</p>
<p>A note for developers: even though this routine is identical to the templated copy constructor, it must be declared and implemented separately. Otherwise the compiler might create its own (incorrect) copy constructor automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa340676c9f944ce88693e69bbea56023" name="aa340676c9f944ce88693e69bbea56023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340676c9f944ce88693e69bbea56023">&#9670;&#160;</a></span>Laurent2() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this new polynomial. </p>
<p>This is a fast (constant time) operation.</p>
<p>The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c1c31a611b8708d14bdf6e809d016f" name="a25c1c31a611b8708d14bdf6e809d016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c1c31a611b8708d14bdf6e809d016f">&#9670;&#160;</a></span>Laurent2() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>toShift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xShift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yShift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of the given polynomial with all terms multiplied by <code>x^d y^e</code> for some integers <em>d</em> and <em>e</em>. </p>
<p>This constructor induces a deep (and modified) copy of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toShift</td><td>the polynomial to clone and shift. </td></tr>
    <tr><td class="paramname">xShift</td><td>the integer <em>d</em>, which will be added to all exponents for <em>x</em>. </td></tr>
    <tr><td class="paramname">yShift</td><td>the integer <em>e</em>, which will be added to all exponents for <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd07a8882921df669daf862ebd624a73" name="acd07a8882921df669daf862ebd624a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd07a8882921df669daf862ebd624a73">&#9670;&#160;</a></span>Laurent2() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p>This constructor induces a deep copy of <em>value</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values of type <em>U</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Python only supports <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials with one type of coefficient (the case where <em>T</em> is Integer). Therefore Python users can use the non-templated copy constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab97f3c265d8997bdfa3b8b494673d25e" name="ab97f3c265d8997bdfa3b8b494673d25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f3c265d8997bdfa3b8b494673d25e">&#9670;&#160;</a></span>Laurent2() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename iterator , typename deref &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from the given collection of coefficients. </p>
<p>The coefficients should be presented as a collection of tuples of the form (<em>d</em>, <em>e</em>, <em>v</em>), each representing a term of the form <code>v x^d y^e</code>.</p>
<p>The tuples may be given in any order. An empty sequence will be treated as the zero polynomial.</p>
<p>Unlike the std::initializer_list constructor, zero coefficients are allowed (these will be silently ignored), and multiple coefficients with the same exponents are also allowed (these will be aggregated using the += operator).</p>
<dl class="section user"><dt>Python</dt><dd>Instead of the iterators <em>begin</em> and <em>end</em>, this routine takes a python list of tuples.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>an iterator type which, when dereferenced, gives a std::tuple of the form (<em>d</em>, <em>e</em>, <em>v</em>), where <em>d</em> and <em>e</em> can be assigned to long integers, and where <em>v</em> can be assigned to type <em>T</em>.</td></tr>
    <tr><td class="paramname">deref</td><td>a dummy argument that should be ignored. This is present to ensure that <em>iterator</em> can be dereferenced, so that a call such as Laurent2(int, int) falls through to the (long, long) constructor, and not this iterator-based constructor instead. Once we support a greater subset of C++20, this will be enforced through concepts instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the beginning of the set of coefficients, as outlined above. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the set of coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6c3979b7f375496277c6d81a0fc7e87" name="aa6c3979b7f375496277c6d81a0fc7e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c3979b7f375496277c6d81a0fc7e87">&#9670;&#160;</a></span>Laurent2() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::Laurent2 </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::tuple&lt; long, long, T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from a hard-coded collection of non-zero coefficients. </p>
<p>The coefficients should be presented as a collection of tuples of the form (<em>d</em>, <em>e</em>, <em>v</em>) each representing a term of the form <code>v x^d y^e</code>.</p>
<p>The tuples may be given in any order. An empty sequence will be treated as the zero polynomial.</p>
<p>In practice, this means you can create a hard-coded polynomial using syntax such as:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classregina_1_1Laurent2.html">Laurent2&lt;Integer&gt;</a> p = { { 0, 0, 3 }, { 1, -1, 2 } };</div>
<div class="ttc" id="aclassregina_1_1Laurent2_html"><div class="ttname"><a href="classregina_1_1Laurent2.html">regina::Laurent2</a></div><div class="ttdoc">Represents a Laurent polynomial in the two variables x, y with coefficients of type T.</div><div class="ttdef"><b>Definition</b> laurent2.h:84</div></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>Each tuple has a non-zero value <em>v</em>, and no two tuples share the same pair of exponents (<em>d</em>, <em>e</em>).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the Python constructor that takes a list of coefficients (which need not be constant).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Two of the given tuples share the same pair of exponents (<em>d</em>, <em>e</em>), and/or one of the given tuples has its value <em>v</em> equal to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coefficients</td><td>the set of all non-zero coefficients, as outlined above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a2c51197dbd112bb60b7893cc51a09003" name="a2c51197dbd112bb60b7893cc51a09003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51197dbd112bb60b7893cc51a09003">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; T &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>This hash function makes use of Regina's tight encodings. In particular, any two objects with the same tight encoding will have equal hashes. This implementation (and therefore the specific hash value for each object) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows objects of this type to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this object. </dd></dl>

</div>
</div>
<a id="a3b9ab37ac09da1d2c1af9597f6e333dd" name="a3b9ab37ac09da1d2c1af9597f6e333dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9ab37ac09da1d2c1af9597f6e333dd">&#9670;&#160;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the zero polynomial. </p>

</div>
</div>
<a id="a151f203694f59cfa524785828edf9e81" name="a151f203694f59cfa524785828edf9e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151f203694f59cfa524785828edf9e81">&#9670;&#160;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yExp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated function that sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated</a></b></dt><dd>This has been renamed to <a class="el" href="#a157870b097f4ca71a3840c6d5d86a496" title="Sets this to become the polynomial x^d y^e for the given exponents d and e.">initExp()</a> for consistency with the single-variable polynomial classes <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> and <a class="el" href="classregina_1_1Polynomial.html" title="Represents a single-variable polynomial with coefficients of type T.">Polynomial</a>, since for those classes it is too easy for a casual reader to misread what such an "exponent-based initialisation" actually does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the new exponent <em>d</em>, which is attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the new exponent <em>e</em>, which is attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a157870b097f4ca71a3840c6d5d86a496" name="a157870b097f4ca71a3840c6d5d86a496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157870b097f4ca71a3840c6d5d86a496">&#9670;&#160;</a></span>initExp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::initExp </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yExp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the new exponent <em>d</em>, which is attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the new exponent <em>e</em>, which is attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a928f26c1e006e72e788e2c997ba414d5" name="a928f26c1e006e72e788e2c997ba414d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928f26c1e006e72e788e2c997ba414d5">&#9670;&#160;</a></span>invertX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::invertX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces <code>x</code> with <code>x^-1</code> in this polynomial. </p>
<p>This polynomial is changed directly. </p>

</div>
</div>
<a id="a6edd6a788a049890345d6e73942259f2" name="a6edd6a788a049890345d6e73942259f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edd6a788a049890345d6e73942259f2">&#9670;&#160;</a></span>invertY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::invertY </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces <code>y</code> with <code>y^-1</code> in this polynomial. </p>
<p>This polynomial is changed directly. </p>

</div>
</div>
<a id="a0f2127cd484f250361b34862f116a597" name="a0f2127cd484f250361b34862f116a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2127cd484f250361b34862f116a597">&#9670;&#160;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::isZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this is the zero polynomial. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the zero polynomial. </dd></dl>

</div>
</div>
<a id="a8fed3d5d702211cfd7b90cad87f43205" name="a8fed3d5d702211cfd7b90cad87f43205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fed3d5d702211cfd7b90cad87f43205">&#9670;&#160;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::negate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates this polynomial. </p>
<p>This polynomial is changed directly. </p>

</div>
</div>
<a id="a9123daa1ba8056b3afde06f9a3087d77" name="a9123daa1ba8056b3afde06f9a3087d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9123daa1ba8056b3afde06f9a3087d77">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yExp</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given coefficient of this polynomial. </p>
<p>There are no restrictions on the exponents <em>xExp</em> and <em>yExp</em>.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this is the square bracket operator, not the round bracket operator; that is, Python users can access coefficients through the syntax <code>poly[xExp, yExp]</code>. Moreover, this operator can also <em>set</em> cofficients; that is, you can write <code>poly[xExp, yExp] = value</code>. However, when <em>getting</em> a coefficient this operator will return by value (to enforce constness), which means for example you cannot write something like <code>poly[xExp, yExp].<a class="el" href="#a8fed3d5d702211cfd7b90cad87f43205" title="Negates this polynomial.">negate()</a></code>.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>For C++ users, this operator is read-only. To <em>set</em> coefficients, you must use the separate routine <a class="el" href="#a6e21fd6436363e5555380f69aef2b5ba" title="Changes the given coefficient of this polynomial.">set()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coefficient of the term with the given exponents. </dd></dl>

</div>
</div>
<a id="a91abd504dba2918cfc8e1589eac7c147" name="a91abd504dba2918cfc8e1589eac7c147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91abd504dba2918cfc8e1589eac7c147">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this by the given polynomial. </p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to multiply this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a62b4233936c5293e81447dc71daaf157" name="a62b4233936c5293e81447dc71daaf157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b4233936c5293e81447dc71daaf157">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this polynomial by the given constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a88f7e7ab24cc91845a017b34b887cb3c" name="a88f7e7ab24cc91845a017b34b887cb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f7e7ab24cc91845a017b34b887cb3c">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given polynomial to this. </p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a5c4cdcdcf36e3c2323d6add8eb5f802f" name="a5c4cdcdcf36e3c2323d6add8eb5f802f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4cdcdcf36e3c2323d6add8eb5f802f">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the given polynomial from this. </p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="ad2a5d7d2ee2b527e1bf6f24564f6175a" name="ad2a5d7d2ee2b527e1bf6f24564f6175a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a5d7d2ee2b527e1bf6f24564f6175a">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this polynomial by the given constant. </p>
<p>This uses the division operator /= for the coefficient type <em>T</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="af9bd6b6b6068fa5f976bee847c210cc3" name="af9bd6b6b6068fa5f976bee847c210cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bd6b6b6068fa5f976bee847c210cc3">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p>The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<p>This routine generates all of the usual comparison operators, including <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This spaceship operator <code>x &lt;=&gt; y</code> is not available, but the other comparison operators that it generates <em>are</em> available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison between this and the given polynomial. </dd></dl>

</div>
</div>
<a id="a48c335642e5da5084f38d5b3c166e36b" name="a48c335642e5da5084f38d5b3c166e36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c335642e5da5084f38d5b3c166e36b">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p>This operator induces a deep copy of <em>value</em>.</p>
<p>A note to developers: although this is identical to the templated assignment operator, it must be declared and implemented separately. See the copy constructor for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a538528845f776b8908e3a08f24af37b1" name="a538528845f776b8908e3a08f24af37b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538528845f776b8908e3a08f24af37b1">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p>This operator induces a deep copy of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a032ed022582395968183345ee988f77b" name="a032ed022582395968183345ee988f77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032ed022582395968183345ee988f77b">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this polynomial. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p>The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0" name="a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given polynomial are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given polynomial are equal. </dd></dl>

</div>
</div>
<a id="a6e21fd6436363e5555380f69aef2b5ba" name="a6e21fd6436363e5555380f69aef2b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e21fd6436363e5555380f69aef2b5ba">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>xExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>yExp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the given coefficient of this polynomial. </p>
<p>There are no restrictions on the exponents <em>xExp</em> and <em>yExp</em>, and the new coefficient <em>value</em> may be zero.</p>
<p>Moreover, the underlying data structures ensure that this operation is cheap regardless of the exponents involved.</p>
<dl class="section user"><dt>Python</dt><dd>This <a class="el" href="#a6e21fd6436363e5555380f69aef2b5ba" title="Changes the given coefficient of this polynomial.">set()</a> routine is available, but you can also set coefficients directly using syntax of the form <code>p[xExp, yExp] = value</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent attached to <em>y</em>. </td></tr>
    <tr><td class="paramname">value</td><td>the new value of the corresponding coefficient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a760f12b76398e549fa66a3a0e7ef3b79" name="a760f12b76398e549fa66a3a0e7ef3b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760f12b76398e549fa66a3a0e7ef3b79">&#9670;&#160;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::str </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>x</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>y</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a human-readable string. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a5382c0231814155a040fd05d908d1f73" name="a5382c0231814155a040fd05d908d1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382c0231814155a040fd05d908d1f73">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given polynomial. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a336e0de0717577470b920e1bfca88d8b" name="a336e0de0717577470b920e1bfca88d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336e0de0717577470b920e1bfca88d8b">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a polynomial from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding static <a class="el" href="#a336e0de0717577470b920e1bfca88d8b" title="Reconstructs a polynomial from its given tight encoding.">tightDecode()</a> function. This is true for Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polynomial represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; T &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a73caa4080f9139ff3c5fe4b3954af005" name="a73caa4080f9139ff3c5fe4b3954af005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73caa4080f9139ff3c5fe4b3954af005">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this polynomial to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding <a class="el" href="#a73caa4080f9139ff3c5fe4b3954af005" title="Writes the tight encoding of this polynomial to the given output stream.">tightEncode()</a> function. This is true for Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; T &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ade0a2543536786e006e31898f01140bb" name="ade0a2543536786e006e31898f01140bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a2543536786e006e31898f01140bb">&#9670;&#160;</a></span>utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string using unicode characters, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<p>This is similar to the output from <a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, except that it uses unicode characters to make the output more pleasant to read. In particular, it makes use of superscript digits for exponents and a wider minus sign.</p>
<p>The string is encoded in UTF-8.</p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="#ade0a2543536786e006e31898f01140bb" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>x</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>y</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a unicode-enabled human-readable string. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; T, supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92be6449b77d1e89b70195d5467bddff" name="a92be6449b77d1e89b70195d5467bddff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be6449b77d1e89b70195d5467bddff">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>utf8</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>varY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this polynomial to the given output stream, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<p>If <em>utf8</em> is passed as <code>true</code> then unicode superscript characters will be used for exponents and the minus sign; these will be encoded using UTF-8. This will make the output nicer, but will require more complex fonts to be available on the user's machine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a> or <a class="el" href="#ade0a2543536786e006e31898f01140bb" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if unicode characters may be used. </td></tr>
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>x</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>y</code> will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
<li>maths/<a class="el" href="laurent2_8h.html">laurent2.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
