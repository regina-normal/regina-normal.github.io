<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::EulerSearcher::TetVertexState Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1EulerSearcher.html">EulerSearcher</a></li><li class="navelem"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structregina_1_1EulerSearcher_1_1TetVertexState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::EulerSearcher::TetVertexState Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;census/gluingpermsearcher3.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a03fbc7349339abeb42fb3658e5cb8de3" id="r_a03fbc7349339abeb42fb3658e5cb8de3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03fbc7349339abeb42fb3658e5cb8de3">TetVertexState</a> ()</td></tr>
<tr class="memdesc:a03fbc7349339abeb42fb3658e5cb8de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone tetrahedron vertex in an equivalence class all of its own.  <br /></td></tr>
<tr class="separator:a03fbc7349339abeb42fb3658e5cb8de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82404c59a59f47997ef0d00f1fc3199" id="r_ad82404c59a59f47997ef0d00f1fc3199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82404c59a59f47997ef0d00f1fc3199">dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad82404c59a59f47997ef0d00f1fc3199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <br /></td></tr>
<tr class="separator:ad82404c59a59f47997ef0d00f1fc3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500c01ec0a679f33340b80e1a77f91e6" id="r_a500c01ec0a679f33340b80e1a77f91e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a500c01ec0a679f33340b80e1a77f91e6">readData</a> (std::istream &amp;in, size_t nStates)</td></tr>
<tr class="memdesc:a500c01ec0a679f33340b80e1a77f91e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <br /></td></tr>
<tr class="separator:a500c01ec0a679f33340b80e1a77f91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9084d80d633592e2ea75a8780dc65c8f" id="r_a9084d80d633592e2ea75a8780dc65c8f"><td class="memItemLeft" align="right" valign="top"><a id="a9084d80d633592e2ea75a8780dc65c8f" name="a9084d80d633592e2ea75a8780dc65c8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TetVertexState</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:a9084d80d633592e2ea75a8780dc65c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77d6053d21e13a8015aea8f9cfd5cfc" id="r_ae77d6053d21e13a8015aea8f9cfd5cfc"><td class="memItemLeft" align="right" valign="top"><a id="ae77d6053d21e13a8015aea8f9cfd5cfc" name="ae77d6053d21e13a8015aea8f9cfd5cfc"></a>
<a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:ae77d6053d21e13a8015aea8f9cfd5cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a48e84899d220e08d1d5bdffbe0c04759" id="r_a48e84899d220e08d1d5bdffbe0c04759"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48e84899d220e08d1d5bdffbe0c04759">parent</a></td></tr>
<tr class="memdesc:a48e84899d220e08d1d5bdffbe0c04759"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <br /></td></tr>
<tr class="separator:a48e84899d220e08d1d5bdffbe0c04759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0719fd1aab088e82beb27648e311bc0" id="r_ac0719fd1aab088e82beb27648e311bc0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0719fd1aab088e82beb27648e311bc0">rank</a></td></tr>
<tr class="memdesc:ac0719fd1aab088e82beb27648e311bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <br /></td></tr>
<tr class="separator:ac0719fd1aab088e82beb27648e311bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee2844a397bc3f974a1bbef11e424ed" id="r_a3ee2844a397bc3f974a1bbef11e424ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee2844a397bc3f974a1bbef11e424ed">bdry</a></td></tr>
<tr class="memdesc:a3ee2844a397bc3f974a1bbef11e424ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary edges in the vertex link for this equivalence class of vertices.  <br /></td></tr>
<tr class="separator:a3ee2844a397bc3f974a1bbef11e424ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4115df4efb2da5dbc1fd3e31df210f" id="r_adf4115df4efb2da5dbc1fd3e31df210f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4115df4efb2da5dbc1fd3e31df210f">euler</a></td></tr>
<tr class="memdesc:adf4115df4efb2da5dbc1fd3e31df210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic that the vertex link would have if its punctures were all filled.  <br /></td></tr>
<tr class="separator:adf4115df4efb2da5dbc1fd3e31df210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b374687123ab8241e1cf84aff30a73" id="r_a18b374687123ab8241e1cf84aff30a73"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b374687123ab8241e1cf84aff30a73">twistUp</a></td></tr>
<tr class="memdesc:a18b374687123ab8241e1cf84aff30a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link.  <br /></td></tr>
<tr class="separator:a18b374687123ab8241e1cf84aff30a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e9f6f128b8fb6a5c6f92d66e37422c" id="r_a61e9f6f128b8fb6a5c6f92d66e37422c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e9f6f128b8fb6a5c6f92d66e37422c">hadEqualRank</a></td></tr>
<tr class="memdesc:a61e9f6f128b8fb6a5c6f92d66e37422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <br /></td></tr>
<tr class="separator:a61e9f6f128b8fb6a5c6f92d66e37422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f35e848e877b5739402ebb0824f7984" id="r_a8f35e848e877b5739402ebb0824f7984"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f35e848e877b5739402ebb0824f7984">bdryEdges</a></td></tr>
<tr class="memdesc:a8f35e848e877b5739402ebb0824f7984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link.  <br /></td></tr>
<tr class="separator:a8f35e848e877b5739402ebb0824f7984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aa8a803ffacbdc1d91f0060114479c" id="r_a08aa8a803ffacbdc1d91f0060114479c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08aa8a803ffacbdc1d91f0060114479c">bdryNext</a> [2]</td></tr>
<tr class="memdesc:a08aa8a803ffacbdc1d91f0060114479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment.  <br /></td></tr>
<tr class="separator:a08aa8a803ffacbdc1d91f0060114479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf573efd973f2236d51ba379187d05f" id="r_a5cf573efd973f2236d51ba379187d05f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cf573efd973f2236d51ba379187d05f">bdryTwist</a> [2]</td></tr>
<tr class="memdesc:a5cf573efd973f2236d51ba379187d05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side.  <br /></td></tr>
<tr class="separator:a5cf573efd973f2236d51ba379187d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b05840efae83aec94368c13fab75b3" id="r_ab3b05840efae83aec94368c13fab75b3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b05840efae83aec94368c13fab75b3">bdryNextOld</a> [2]</td></tr>
<tr class="memdesc:ab3b05840efae83aec94368c13fab75b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <br /></td></tr>
<tr class="separator:ab3b05840efae83aec94368c13fab75b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa654cd4ef912a6762cd4351254d32fc4" id="r_aa654cd4ef912a6762cd4351254d32fc4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa654cd4ef912a6762cd4351254d32fc4">bdryTwistOld</a> [2]</td></tr>
<tr class="memdesc:aa654cd4ef912a6762cd4351254d32fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <br /></td></tr>
<tr class="separator:aa654cd4ef912a6762cd4351254d32fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed. </p>
<p>Two vertices are considered equivalent if they are identified within the triangulation.</p>
<p>Tetrahedron vertices are indexed linearly by tetrahedron and then vertex number. Specifically, vertex v (0..3) of tetrahedron t (0..nTets-1) has index 4t+v.</p>
<p>Each equivalence class of vertices corresponds to a tree of <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> objects, arranged to form a modified union-find structure.</p>
<p>Note that a single tetrahedron vertex (as described by this structure) provides a single triangular piece of the overall vertex link. This triangle piece is referred to in several of the data members below. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a03fbc7349339abeb42fb3658e5cb8de3" name="a03fbc7349339abeb42fb3658e5cb8de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fbc7349339abeb42fb3658e5cb8de3">&#9670;&#160;</a></span>TetVertexState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::TetVertexState::TetVertexState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone tetrahedron vertex in an equivalence class all of its own. </p>
<p>Note that the vertex link will be a single triangle with three boundary edges. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad82404c59a59f47997ef0d00f1fc3199" name="ad82404c59a59f47997ef0d00f1fc3199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82404c59a59f47997ef0d00f1fc3199">&#9670;&#160;</a></span>dumpData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::TetVertexState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="#a500c01ec0a679f33340b80e1a77f91e6" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a500c01ec0a679f33340b80e1a77f91e6" name="a500c01ec0a679f33340b80e1a77f91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500c01ec0a679f33340b80e1a77f91e6">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetVertexState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nStates</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="#ad82404c59a59f47997ef0d00f1fc3199" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nStates</td><td>the total number of vertex states under consideration (this must be four times the number of tetrahedra). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3ee2844a397bc3f974a1bbef11e424ed" name="a3ee2844a397bc3f974a1bbef11e424ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee2844a397bc3f974a1bbef11e424ed">&#9670;&#160;</a></span>bdry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::TetVertexState::bdry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of boundary edges in the vertex link for this equivalence class of vertices. </p>
<p>Any face whose gluing permutation has not yet been decided is treated as a boundary face. This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="a8f35e848e877b5739402ebb0824f7984" name="a8f35e848e877b5739402ebb0824f7984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f35e848e877b5739402ebb0824f7984">&#9670;&#160;</a></span>bdryEdges</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t regina::EulerSearcher::TetVertexState::bdryEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link. </p>
<p>Equivalently, this measures the number of faces of this tetrahedron meeting this vertex that are not yet joined to their partner faces. This always takes the value 0, 1, 2 or 3. </p>

</div>
</div>
<a id="a08aa8a803ffacbdc1d91f0060114479c" name="a08aa8a803ffacbdc1d91f0060114479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aa8a803ffacbdc1d91f0060114479c">&#9670;&#160;</a></span>bdryNext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::TetVertexState::bdryNext[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment. </p>
<p>Note that in most cases (see below) this is not the present vertex. For instance, if this vertex provides two boundary edges, then this array describes the boundary before the first edge and after the second.</p>
<p>The boundary segment described by <em>bdryNext</em>[1] follows on from this segment in the direction described by the <em>vertexLinkNextFace</em> array. The boundary segment in the other direction is described by <em>bdryNext</em>[0].</p>
<p>If the vertex link is just this one triangle (i.e., all three faces of this tetrahedron surrounding this vertex are boundary faces, or one is a boundary and the other two are joined together), then both elements of <em>bdryNext</em> refer to this vertex itself. These are the only situations in which <em>bdryNext</em> refers back to this vertex.</p>
<p>If the triangle is internal to the vertex link (i.e., <em>bdryEdges</em> is zero), then this array maintains the last values it had when there was at least one boundary edge earlier in the search.</p>
<p>Each element of this array lies between 0 and 4t-1 inclusive, where <em>t</em> is the total number of tetrahedra. </p>

</div>
</div>
<a id="ab3b05840efae83aec94368c13fab75b3" name="ab3b05840efae83aec94368c13fab75b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b05840efae83aec94368c13fab75b3">&#9670;&#160;</a></span>bdryNextOld</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t regina::EulerSearcher::TetVertexState::bdryNextOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="a5cf573efd973f2236d51ba379187d05f" name="a5cf573efd973f2236d51ba379187d05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf573efd973f2236d51ba379187d05f">&#9670;&#160;</a></span>bdryTwist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::bdryTwist[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side. </p>
<p>See <em>bdryNext</em> for further discussion of boundary segments. The <em>bdryNext</em> array defines an orientation for this section of vertex link, pointing from the end described by <em>bdryNext</em>[0] to the end described by <em>bdryNext</em>[1].</p>
<p>For each <em>i</em>, the value <em>bdryTwist</em>[i] is 0 if the orientation of the adjacent segment described by <em>bdryNext</em>[i] is the same as this segment (as defined by the <em>bdryNext</em> values stored with the adjacent vertex), or 1 if the orientations differ.</p>
<p>If the triangle supplied by this vertex is internal to the vertex link, this array maintains the last values it had when there was at least one boundary edge earlier in the search (just like the <em>bdryNext</em> array). </p>

</div>
</div>
<a id="aa654cd4ef912a6762cd4351254d32fc4" name="aa654cd4ef912a6762cd4351254d32fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa654cd4ef912a6762cd4351254d32fc4">&#9670;&#160;</a></span>bdryTwistOld</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::bdryTwistOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="adf4115df4efb2da5dbc1fd3e31df210f" name="adf4115df4efb2da5dbc1fd3e31df210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4115df4efb2da5dbc1fd3e31df210f">&#9670;&#160;</a></span>euler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetVertexState::euler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Euler characteristic that the vertex link would have if its punctures were all filled. </p>
<p>As above, this value is only maintained correctly for the root of the corresponding object tree.</p>
<p>This is of type <code>int</code>, since the search algorithm ensures it will never drop more than a small constant below <a class="el" href="classregina_1_1EulerSearcher.html#a642c9886af812c5fb4b30273f60e89d8" title="The Euler characteristic that vertex links must have.">EulerSearcher::euler_</a>. </p>

</div>
</div>
<a id="a61e9f6f128b8fb6a5c6f92d66e37422c" name="a61e9f6f128b8fb6a5c6f92d66e37422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e9f6f128b8fb6a5c6f92d66e37422c">&#9670;&#160;</a></span>hadEqualRank</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetVertexState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="a48e84899d220e08d1d5bdffbe0c04759" name="a48e84899d220e08d1d5bdffbe0c04759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e84899d220e08d1d5bdffbe0c04759">&#9670;&#160;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t regina::EulerSearcher::TetVertexState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="ac0719fd1aab088e82beb27648e311bc0" name="ac0719fd1aab088e82beb27648e311bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0719fd1aab088e82beb27648e311bc0">&#9670;&#160;</a></span>rank</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::TetVertexState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="a18b374687123ab8241e1cf84aff30a73" name="a18b374687123ab8241e1cf84aff30a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b374687123ab8241e1cf84aff30a73">&#9670;&#160;</a></span>twistUp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link. </p>
<p>Each of these triangles in the vertex link can be labelled with its own vertices 0, 1 and 2 and thereby be assigned a clockwise or anticlockwise orientation.</p>
<p>The parameter <em>twistUp</em> is 0 if these two triangles in the vertex link are joined in a way that preserves orientation, or 1 if the gluing does not preserve orientation.</p>
<p>If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>census/<a class="el" href="gluingpermsearcher3_8h.html">gluingpermsearcher3.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
