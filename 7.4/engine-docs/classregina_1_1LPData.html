<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::LPData&lt; LPConstraint, IntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LPData.html">LPData</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1LPData-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::LPData&lt; LPConstraint, IntType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery for using the dual simplex method.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;enumerate/treelp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::LPData&lt; LPConstraint, IntType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1LPData.png" usemap="#regina::LPData_3C_20LPConstraint_2C_20IntType_20_3E_map" alt=""/>
  <map id="regina::LPData_3C_20LPConstraint_2C_20IntType_20_3E_map" name="regina::LPData_3C_20LPConstraint_2C_20IntType_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; LPData&lt; LPConstraint, IntType &gt; &gt;" shape="rect" coords="0,0,302,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac45a4647f5f984621209b6b0b3f68c4b" id="r_ac45a4647f5f984621209b6b0b3f68c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac45a4647f5f984621209b6b0b3f68c4b">LPData</a> ()</td></tr>
<tr class="memdesc:ac45a4647f5f984621209b6b0b3f68c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new tableaux.  <br /></td></tr>
<tr class="separator:ac45a4647f5f984621209b6b0b3f68c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e6d32e6b831f21b8ebb0aab6619c41" id="r_ae9e6d32e6b831f21b8ebb0aab6619c41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e6d32e6b831f21b8ebb0aab6619c41">LPData</a> (<a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ae9e6d32e6b831f21b8ebb0aab6619c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given tableaux into this new tableaux.  <br /></td></tr>
<tr class="separator:ae9e6d32e6b831f21b8ebb0aab6619c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294602a33df9186b5ccf57afdeb6c879" id="r_a294602a33df9186b5ccf57afdeb6c879"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a294602a33df9186b5ccf57afdeb6c879">~LPData</a> ()</td></tr>
<tr class="memdesc:a294602a33df9186b5ccf57afdeb6c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tableaux.  <br /></td></tr>
<tr class="separator:a294602a33df9186b5ccf57afdeb6c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440407e4d41f54d2184c9c4a0693d446" id="r_a440407e4d41f54d2184c9c4a0693d446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a440407e4d41f54d2184c9c4a0693d446">operator=</a> (<a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a440407e4d41f54d2184c9c4a0693d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given tableaux into this tableaux.  <br /></td></tr>
<tr class="separator:a440407e4d41f54d2184c9c4a0693d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ee5cab10eb9f413d2cfb0193359eb4" id="r_ae3ee5cab10eb9f413d2cfb0193359eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ee5cab10eb9f413d2cfb0193359eb4">swap</a> (<a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ae3ee5cab10eb9f413d2cfb0193359eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given tableaux.  <br /></td></tr>
<tr class="separator:ae3ee5cab10eb9f413d2cfb0193359eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023ac09bed669b64dd604c630af77037" id="r_a023ac09bed669b64dd604c630af77037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a023ac09bed669b64dd604c630af77037">reserve</a> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;origTableaux)</td></tr>
<tr class="memdesc:a023ac09bed669b64dd604c630af77037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough memory for this tableaux to work with.  <br /></td></tr>
<tr class="separator:a023ac09bed669b64dd604c630af77037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48f34d3d8d79b3823f95bc2f64cf7a3" id="r_ac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac48f34d3d8d79b3823f95bc2f64cf7a3">initStart</a> ()</td></tr>
<tr class="memdesc:ac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this tableaux by beginning at the original starting tableaux and working our way to any feasible basis.  <br /></td></tr>
<tr class="separator:ac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb498c421ccd15a2853821057078ff2" id="r_adfb498c421ccd15a2853821057078ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb498c421ccd15a2853821057078ff2">initClone</a> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;parent)</td></tr>
<tr class="memdesc:adfb498c421ccd15a2853821057078ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this tableaux to be a clone of the given tableaux.  <br /></td></tr>
<tr class="separator:adfb498c421ccd15a2853821057078ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a7934c8922f0d79fdc255d56eeb7e" id="r_a463a7934c8922f0d79fdc255d56eeb7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463a7934c8922f0d79fdc255d56eeb7e">columns</a> () const</td></tr>
<tr class="memdesc:a463a7934c8922f0d79fdc255d56eeb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in this tableaux.  <br /></td></tr>
<tr class="separator:a463a7934c8922f0d79fdc255d56eeb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6928bbd64d2ab42699c4c9420290e2" id="r_a9e6928bbd64d2ab42699c4c9420290e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e6928bbd64d2ab42699c4c9420290e2">coordinateColumns</a> () const</td></tr>
<tr class="memdesc:a9e6928bbd64d2ab42699c4c9420290e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in this tableaux that correspond to normal coordinates or angle structure coordinates.  <br /></td></tr>
<tr class="separator:a9e6928bbd64d2ab42699c4c9420290e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cafcaf61506e02ff12c7699424bedd" id="r_a89cafcaf61506e02ff12c7699424bedd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89cafcaf61506e02ff12c7699424bedd">isFeasible</a> () const</td></tr>
<tr class="memdesc:a89cafcaf61506e02ff12c7699424bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this system is feasible.  <br /></td></tr>
<tr class="separator:a89cafcaf61506e02ff12c7699424bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add208d6c008be7871ae8f1c8616febf4" id="r_add208d6c008be7871ae8f1c8616febf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add208d6c008be7871ae8f1c8616febf4">isActive</a> (size_t pos) const</td></tr>
<tr class="memdesc:add208d6c008be7871ae8f1c8616febf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given variable is currently active.  <br /></td></tr>
<tr class="separator:add208d6c008be7871ae8f1c8616febf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e0ad8d04a86ed816a5cdf6deb01a09" id="r_a86e0ad8d04a86ed816a5cdf6deb01a09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86e0ad8d04a86ed816a5cdf6deb01a09">sign</a> (size_t pos) const</td></tr>
<tr class="memdesc:a86e0ad8d04a86ed816a5cdf6deb01a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of the given variable under the current basis.  <br /></td></tr>
<tr class="separator:a86e0ad8d04a86ed816a5cdf6deb01a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1edaef1809e78ae76143ee115ef8c5" id="r_aec1edaef1809e78ae76143ee115ef8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec1edaef1809e78ae76143ee115ef8c5">constrainZero</a> (size_t pos)</td></tr>
<tr class="memdesc:aec1edaef1809e78ae76143ee115ef8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains this system further by setting the given variable to zero and deactivating it.  <br /></td></tr>
<tr class="separator:aec1edaef1809e78ae76143ee115ef8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae72fe4a5077f398e36a61f44794f13" id="r_acae72fe4a5077f398e36a61f44794f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acae72fe4a5077f398e36a61f44794f13">constrainPositive</a> (size_t pos)</td></tr>
<tr class="memdesc:acae72fe4a5077f398e36a61f44794f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains this system further by constraining the given variable to be strictly positive.  <br /></td></tr>
<tr class="separator:acae72fe4a5077f398e36a61f44794f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346904f9cfc84ad23f8db2c99bb3851" id="r_a9346904f9cfc84ad23f8db2c99bb3851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851">constrainOct</a> (size_t quad1, size_t quad2)</td></tr>
<tr class="memdesc:a9346904f9cfc84ad23f8db2c99bb3851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single octagon coordinate, for use with almost normal surfaces, and constrains the system accordingly.  <br /></td></tr>
<tr class="separator:a9346904f9cfc84ad23f8db2c99bb3851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b11f71be84c664d25c0e074c3d66a08" id="r_a5b11f71be84c664d25c0e074c3d66a08"><td class="memTemplParams" colspan="2">template&lt;class RayClass &gt; </td></tr>
<tr class="memitem:a5b11f71be84c664d25c0e074c3d66a08"><td class="memTemplItemLeft" align="right" valign="top">RayClass&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b11f71be84c664d25c0e074c3d66a08">extractSolution</a> (const char *type) const</td></tr>
<tr class="memdesc:a5b11f71be84c664d25c0e074c3d66a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the values of the individual variables from the current basis, with some modifications (as described below).  <br /></td></tr>
<tr class="separator:a5b11f71be84c664d25c0e074c3d66a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e148dd6e3ce6c0279e25151da47d50" id="r_ac8e148dd6e3ce6c0279e25151da47d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e148dd6e3ce6c0279e25151da47d50">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac8e148dd6e3ce6c0279e25151da47d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:ac8e148dd6e3ce6c0279e25151da47d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6d61c7d9fe70bce09c95c9e5a80f71" id="r_a2d6d61c7d9fe70bce09c95c9e5a80f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d6d61c7d9fe70bce09c95c9e5a80f71">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2d6d61c7d9fe70bce09c95c9e5a80f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a2d6d61c7d9fe70bce09c95c9e5a80f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11328811a59f0f1d2ddd8f2b909f371" id="r_ad11328811a59f0f1d2ddd8f2b909f371"><td class="memItemLeft" align="right" valign="top"><a id="ad11328811a59f0f1d2ddd8f2b909f371" name="ad11328811a59f0f1d2ddd8f2b909f371"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LPData</b> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;)=delete</td></tr>
<tr class="separator:ad11328811a59f0f1d2ddd8f2b909f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a082e4ee276b2a8a5e8fcad04d2f175" id="r_a9a082e4ee276b2a8a5e8fcad04d2f175"><td class="memItemLeft" align="right" valign="top"><a id="a9a082e4ee276b2a8a5e8fcad04d2f175" name="a9a082e4ee276b2a8a5e8fcad04d2f175"></a>
<a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;)=delete</td></tr>
<tr class="separator:a9a082e4ee276b2a8a5e8fcad04d2f175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class LPConstraint, typename IntType&gt;<br />
class regina::LPData&lt; LPConstraint, IntType &gt;</div><p>Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery for using the dual simplex method. </p>
<p>This class forms part of the tree traversal algorithms for enumerating and locating normal surfaces, as described in "A tree traversal algorithm
for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079. It is also used for locating a single strict angle structure, and for enumerating all taut angle structures.</p>
<p>This class is designed to represent a state partway through the tree traversal algorithm, where the tableaux has been altered to constrain some variables:</p>
<ul>
<li>Some variables have been "deactivated". This means we fix them to zero permanently, and pretend that the corresponding columns do not exist in the matrix. As a result, the rank of the matrix may smaller than it was when we began the tree traversal.</li>
<li>Some variables have been constrained to be positive; as described in Burton and Ozlen, it is safe to do this using the non-strict inequality x_i ≥ 1 (instead of the strict inequality x_i &gt; 0, which is more difficult to enforce). We enforce this constraing using a change of variable: we replace the variable x_i with (x_i - 1), which is then constrained to be non-negative as usual. The new variable (x_i - 1) uses the same column in the tableaux (we perform the actual change of variable by editing the tableaux itself using column operations). Be warned: as a result, when we arrive at a final solution and collect the values of the variables, we must remember to <em>increment</em> the values of any such variables by one.</li>
</ul>
<p>We do not store the full tableaux (which is dense and slow to work with). Instead we store the matrix of row operations that were applied to the original starting tableaux (in the notation of Burton and Ozlen, we store the matrix M_β^{-1}, where M is the original matrix stored in the class <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a>, and β is the current basis).</p>
<p>If the system is infeasible (because the constraints on variables as described above are too severe), then the contents of the internal data members are undefined (other than the data member <em>feasible_</em>, which is guaranteed to be <code>false</code>). This is because the code is optimised to abort any operation as soon as infeasibility is detected, which may leave the data members in a broken state. If you are not sure, you should always call <a class="el" href="#a89cafcaf61506e02ff12c7699424bedd" title="Returns whether or not this system is feasible.">isFeasible()</a> before performing any other query or operation on this tableaux.</p>
<p>This class is designed to be used in a backtracking search, which means the API is cumbersome but we can quickly rewrite and copy data. The rules are as follows:</p>
<ul>
<li>Before using an <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> object, you must reserve the necessary memory by calling <a class="el" href="#a023ac09bed669b64dd604c630af77037" title="Reserves enough memory for this tableaux to work with.">reserve()</a> and passing the original starting tableaux.</li>
<li>After this, you can reset the data by calling one of the initialisation routines <a class="el" href="#ac48f34d3d8d79b3823f95bc2f64cf7a3" title="Initialises this tableaux by beginning at the original starting tableaux and working our way to any f...">initStart()</a> or <a class="el" href="#adfb498c421ccd15a2853821057078ff2" title="Initialises this tableaux to be a clone of the given tableaux.">initClone()</a>, and you can call these initialisation routines as often as you like.</li>
</ul>
<p>Like <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a>, this class can enforce additional linear constraints (such as positive Euler characteristic) through the template parameter LPConstraint. If there are no such constraints, simply use the template parameter <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>.</p>
<p>In the context of normal surfaces (not angle structures): Although the underlying coordinate system is based on quadrilaterals and (optionally) triangles, this class has elementary support for octagons also, as seen in <em>almost</em> normal surface theory. For the purposes of this class, an octagon is represented as a pair of quadrilaterals of different types in the same tetrahedron: these meet the boundary of the tetrahedron in the same arcs as a single octagon, and therefore interact with the matching equations in the same way.</p>
<p>To declare that you will be using octagons in some tetrahedron, you must call constrainOct(quad1, quad2), where <em>quad1</em> and <em>quad2</em> are the two corresponding quadrilateral columns. This will have the following effects, all of which may alter the tableaux:</p>
<ul>
<li>There will be some changes of variable. One of the two variables x_i will be replaced with (x_i - 1), forcing the number of octagons to be positive. The other variable x_j will be replaced with (x_j - x_i), which will be set to zero and deactivated. There is no guarantee as to which of the two variables <em>quad1</em> and <em>quad2</em> will be kept and which will be deactivated: this will depend on the layout of the tableaux when <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> is called.</li>
<li>If you are imposing additional constraints through the <em>LPConstraint</em> template parameter, the corresponding linear constraint functions may change their values (since the coefficients they use for octagon types need not be related to the coefficients for the two corresponding quadrilateral columns). Any such changes, if necessary, are encoded by the constant LPConstraint::octAdjustment.</li>
</ul>
<p>This class has been optimised to ensure that you only have one octagon type declared at any given time (which is consistent with the constraints of almost normal surface theory).</p>
<p>All tableaux elements are of the integer class <em>IntType</em>, which is supplied as a template argument. This same integer class will be used as a template argument for <em>LPConstraint</em>.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. However, due to the unusual create-reserve-initialise procedure, it does not support copying (either by copy construction or copy assignment). Because of the move semantics, this class avoids deep copies, even when passing or returning objects by value.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template parameter LPConstraint must be one of the subclasses of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a>. See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> class notes for further details.</dd>
<dd>
The default constructor for the template class IntType must intialise each new integer to zero. The classes Integer and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>, for instance, have this property.</dd></dl>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (treelp-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This is a heavily templated class; nevertheless, many variants are now made available to Python users. Each class name is of the form LPData_<em>LPConstraint</em>, where the suffix <em>LPConstraint</em> is an abbreviated version of the <em>LPConstraint</em> template parameter; this suffix is omitted entirely for the common case <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>. An example of such a Python class name is <code>LPData_EulerPositive</code>. You are encouraged to look through the Regina namespace to see which constraint classes are supported under Python. In all cases, the IntType parameter is taken to be <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac45a4647f5f984621209b6b0b3f68c4b" name="ac45a4647f5f984621209b6b0b3f68c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45a4647f5f984621209b6b0b3f68c4b">&#9670;&#160;</a></span>LPData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::LPData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new tableaux. </p>
<p>You <em>must</em> call <a class="el" href="#a023ac09bed669b64dd604c630af77037" title="Reserves enough memory for this tableaux to work with.">reserve()</a> before doing anything else with this tableaux. </p>

</div>
</div>
<a id="ae9e6d32e6b831f21b8ebb0aab6619c41" name="ae9e6d32e6b831f21b8ebb0aab6619c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e6d32e6b831f21b8ebb0aab6619c41">&#9670;&#160;</a></span>LPData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::LPData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given tableaux into this new tableaux. </p>
<p>This is a fast (constant time) operation.</p>
<p>If the given tableaux is uninitialised, then this new tableaux will be uninitialised also.</p>
<p>The tableaux that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tableaux to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a294602a33df9186b5ccf57afdeb6c879" name="a294602a33df9186b5ccf57afdeb6c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294602a33df9186b5ccf57afdeb6c879">&#9670;&#160;</a></span>~LPData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::~<a class="el" href="classregina_1_1LPData.html">LPData</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tableaux. </p>
<p>This is safe even if <a class="el" href="#a023ac09bed669b64dd604c630af77037" title="Reserves enough memory for this tableaux to work with.">reserve()</a> was never called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a463a7934c8922f0d79fdc255d56eeb7e" name="a463a7934c8922f0d79fdc255d56eeb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a7934c8922f0d79fdc255d56eeb7e">&#9670;&#160;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::columns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in this tableaux. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the number of columns will be larger than in the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="a9346904f9cfc84ad23f8db2c99bb3851" name="a9346904f9cfc84ad23f8db2c99bb3851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9346904f9cfc84ad23f8db2c99bb3851">&#9670;&#160;</a></span>constrainOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainOct </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>quad1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>quad2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single octagon coordinate, for use with almost normal surfaces, and constrains the system accordingly. </p>
<p>This constrains the system in several ways, as discussed in detail in the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes. In theory, we set the two quadrilateral coordinates to be equal, and also insist that the number of octagons be strictly positive. In practice, we do this through several changes of variable; see the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for a detailed discussion of precisely how the variables and tableaux will change.</p>
<p>This routine will work even if one of the given quadrilateral variables has already been deactivated, but in this case the routine will immediately set the system to infeasible and return.</p>
<p>This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is the first time <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> has been called on this tableaux. This is because this class can only handle one octagon type in the entire system.</dd>
<dd>
Variables <em>quad1</em> and <em>quad2</em> represent different quadrilateral coordinates in the same tetrahedron of the underlying triangulation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on one of the given variables, then these prior routines will have performed a change of variable. Any new call to <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> involving this same variable will constrain the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad1</td><td>one of the two quadrilateral types that we combine to form the new octagon type. This should be a column index with respect to this tableaux (i.e., it must take into account any permutation of columns from the original matching equations). </td></tr>
    <tr><td class="paramname">quad2</td><td>the other of the two quadrilateral types that we combine to form the new octagon type. Again this should be a column index with respect to this tableaux. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acae72fe4a5077f398e36a61f44794f13" name="acae72fe4a5077f398e36a61f44794f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae72fe4a5077f398e36a61f44794f13">&#9670;&#160;</a></span>constrainPositive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainPositive </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains this system further by constraining the given variable to be strictly positive. </p>
<p>We do this using a change of variable that effectively replaces x_pos with the new variable x'_pos = x_pos - 1 (which we simply constrain to be non-negative as usual). See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<p>This routine will work even if the given variable has already been deactivated, but in this case the routine will immediately set the system to infeasible and return.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on this variable, then these prior routines will have performed a change of variable. Any new call to <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> on this same variable will constrain the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable that is to be constrained as positive. This must be between 0 and origTableaux_-&gt;<a class="el" href="#a463a7934c8922f0d79fdc255d56eeb7e" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. The index should be with respect to this tableaux (i.e., it must take into account any permutation of columns from the original matching equations). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec1edaef1809e78ae76143ee115ef8c5" name="aec1edaef1809e78ae76143ee115ef8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1edaef1809e78ae76143ee115ef8c5">&#9670;&#160;</a></span>constrainZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainZero </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains this system further by setting the given variable to zero and deactivating it. </p>
<p>See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<p>This routine will work even if the given variable has already been deactivated (and it will do nothing in this case).</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on this variable, then these prior routines will have performed a change of variable. Any new call to constraintZero() on this same variable will constraint the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable that is to be set to zero. This must be between 0 and origTableaux_-&gt;<a class="el" href="#a463a7934c8922f0d79fdc255d56eeb7e" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. The index should be with respect to this tableaux (i.e., it must take into account any permutation of columns from the original matching equations). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e6928bbd64d2ab42699c4c9420290e2" name="a9e6928bbd64d2ab42699c4c9420290e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6928bbd64d2ab42699c4c9420290e2">&#9670;&#160;</a></span>coordinateColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::coordinateColumns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in this tableaux that correspond to normal coordinates or angle structure coordinates. </p>
<p>This is precisely the number of columns in the original matrix of matching equations.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of normal or angle structure coordinate columns. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt;, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a5b11f71be84c664d25c0e074c3d66a08" name="a5b11f71be84c664d25c0e074c3d66a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b11f71be84c664d25c0e074c3d66a08">&#9670;&#160;</a></span>extractSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<div class="memtemplate">
template&lt;class RayClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RayClass <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::extractSolution </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the values of the individual variables from the current basis, with some modifications (as described below). </p>
<p>The values of the variables will be returned in vector form.</p>
<p>The modifications are as follows:</p>
<ul>
<li>We extract variables that correspond to the original matching equations obtained from the underlying triangulation, <em>not</em> the current tableaux and <em>not</em> even the original starting tableaux stored in origTableaux_. In other words, when we fill the resulting vector, we undo the column permutation described by <a class="el" href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">LPInitialTableaux::columnPerm()</a>, and we undo any changes of variable that were caused by calls to <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> and/or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a>.</li>
<li>To ensure that the variables are all integers, we scale the resulting vector by the smallest positive rational multiple for which all elements of the vector are integers.</li>
</ul>
<p>This routine is not used as an internal part of the tree traversal algorithm; instead it is offered as a helper routine for reconstructing the normal surfaces or angle structures that result.</p>
<dl class="section pre"><dt>Precondition</dt><dd>No individual coordinate column has had more than one call to either of <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> (otherwise the coordinate will not be correctly reconstructed). Any additional columns arising from LPConstraint are exempt from this requirement.</dd>
<dd>
The precision of integers in <em>RayClass</em> is at least as large as the precision of <em>IntType</em> (as used by <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RayClass</td><td>the class used to hold the output vector. This should be Vector&lt;T&gt; where <em>T</em> is one of Regina's own integer types (Integer, LargeInteger or <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>). In particular, this ensures that all elements of a newly-created output vector will be automatically initialised to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The type vector should be passed as a Python list of integers (for example, in the enumeration of normal surfaces, there would be one integer per tetrahedron, each equal to 0, 1, 2 or 3). The <em>RayClass</em> argument is taken to be Vector&lt;Integer&gt;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type vector corresponding to the current state of this tableaux, indicating which variables were previously fixed as positive via calls to <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a>. This is necessary because <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> does not keep such historical data on its own. The order of these types should be with respect to the permuted columns (i.e., it should reflect the columns as they are stored in this tableaux, not the original matching equations). As a special case, when extracting a strict angle structure one may pass <em>type</em> = <code>null</code>, in which case this routine will assume that <em>every</em> coordinate was constrained as positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the values of all the variables. This vector will have length origTableaux_-&gt;<a class="el" href="#a9e6928bbd64d2ab42699c4c9420290e2" title="Returns the number of columns in this tableaux that correspond to normal coordinates or angle structu...">coordinateColumns()</a>. </dd></dl>

</div>
</div>
<a id="adfb498c421ccd15a2853821057078ff2" name="adfb498c421ccd15a2853821057078ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb498c421ccd15a2853821057078ff2">&#9670;&#160;</a></span>initClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::initClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises this tableaux to be a clone of the given tableaux. </p>
<p>This is used in the tree traversal algorithm as we work our way down the search tree, and child nodes "inherit" tableaux from their parent nodes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a023ac09bed669b64dd604c630af77037" title="Reserves enough memory for this tableaux to work with.">reserve()</a> has already been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the tableaux to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac48f34d3d8d79b3823f95bc2f64cf7a3" name="ac48f34d3d8d79b3823f95bc2f64cf7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48f34d3d8d79b3823f95bc2f64cf7a3">&#9670;&#160;</a></span>initStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::initStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises this tableaux by beginning at the original starting tableaux and working our way to any feasible basis. </p>
<p>This routine also explicitly enforces the additional constraints from the template parameter LPConstraint (i.e., this routine is responsible for forcing the corresponding linear function(s) to be zero or strictly positive as appropriate).</p>
<p>It is possible that a feasible basis cannot be found; you should test <a class="el" href="#a89cafcaf61506e02ff12c7699424bedd" title="Returns whether or not this system is feasible.">isFeasible()</a> after running this routine to see whether this is the case.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a023ac09bed669b64dd604c630af77037" title="Reserves enough memory for this tableaux to work with.">reserve()</a> has already been called. </dd></dl>

</div>
</div>
<a id="add208d6c008be7871ae8f1c8616febf4" name="add208d6c008be7871ae8f1c8616febf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add208d6c008be7871ae8f1c8616febf4">&#9670;&#160;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::isActive </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given variable is currently active. </p>
<p>See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable to query. This must be between 0 and origTableaux_-&gt;<a class="el" href="#a463a7934c8922f0d79fdc255d56eeb7e" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. The index should be with respect to this tableaux (i.e., it must take into account any permutation of columns from the original matching equations). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89cafcaf61506e02ff12c7699424bedd" name="a89cafcaf61506e02ff12c7699424bedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cafcaf61506e02ff12c7699424bedd">&#9670;&#160;</a></span>isFeasible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::isFeasible </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this system is feasible. </p>
<p>A system may become infeasible when we add too many extra constraints on the variables (such as forcing them to be positive, or setting them to zero); see the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on these constraints.</p>
<dl class="section warning"><dt>Warning</dt><dd>As explained in the class notes, if this system is infeasible then any queries or operations (other than calling <a class="el" href="#a89cafcaf61506e02ff12c7699424bedd" title="Returns whether or not this system is feasible.">isFeasible()</a> itself) are undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this system is feasible, or <code>false</code> if it is infeasible. </dd></dl>

</div>
</div>
<a id="a440407e4d41f54d2184c9c4a0693d446" name="a440407e4d41f54d2184c9c4a0693d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440407e4d41f54d2184c9c4a0693d446">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp; <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given tableaux into this tableaux. </p>
<p>This is a fast (constant time) operation.</p>
<p>If the given tableaux is uninitialised, then this tableaux will become uninitialised also.</p>
<p>The tableaux that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tableaux to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tableaux. </dd></dl>

</div>
</div>
<a id="a023ac09bed669b64dd604c630af77037" name="a023ac09bed669b64dd604c630af77037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023ac09bed669b64dd604c630af77037">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>origTableaux</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough memory for this tableaux to work with. </p>
<p>You <em>must</em> call this routine before doing anything else with this tableaux.</p>
<p>The data in this tableaux will not be initialised, and the contents and behaviour of this tableaux will remain undefined until you call one of the initialisation routines <a class="el" href="#ac48f34d3d8d79b3823f95bc2f64cf7a3" title="Initialises this tableaux by beginning at the original starting tableaux and working our way to any f...">initStart()</a> or <a class="el" href="#adfb498c421ccd15a2853821057078ff2" title="Initialises this tableaux to be a clone of the given tableaux.">initClone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origTableaux</td><td>the original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm began. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86e0ad8d04a86ed816a5cdf6deb01a09" name="a86e0ad8d04a86ed816a5cdf6deb01a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e0ad8d04a86ed816a5cdf6deb01a09">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::sign </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of the given variable under the current basis. </p>
<p>This does <em>not</em> attempt to "undo" any changes of variable caused by prior calls to <a class="el" href="#acae72fe4a5077f398e36a61f44794f13" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="#a9346904f9cfc84ad23f8db2c99bb3851" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a>; it simply tests the sign of the variable in the given column of the tableaux in its current form.</p>
<p>Specifically: if the given variable is inactive or non-basic, this routine returns zero. If the given variable is in the basis, this routine returns the sign of the corresponding integer on the right-hand side of the tableaux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable to query. This must be between 0 and origTableaux_-&gt;<a class="el" href="#a463a7934c8922f0d79fdc255d56eeb7e" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. The index should be with respect to this tableaux (i.e., it must take into account any permutation of columns from the original matching equations). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the variable as described above; this will be either 1, 0 or -1. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt;, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae3ee5cab10eb9f413d2cfb0193359eb4" name="ae3ee5cab10eb9f413d2cfb0193359eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ee5cab10eb9f413d2cfb0193359eb4">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given tableaux. </p>
<p>It does not matter if the two tableaux have different sizes, or if one or both is unintialised; if so then these properties will be swapped also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tableaux whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt;, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a2d6d61c7d9fe70bce09c95c9e5a80f71" name="a2d6d61c7d9fe70bce09c95c9e5a80f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6d61c7d9fe70bce09c95c9e5a80f71">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e148dd6e3ce6c0279e25151da47d50" name="ac8e148dd6e3ce6c0279e25151da47d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e148dd6e3ce6c0279e25151da47d50">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>enumerate/<a class="el" href="treeconstraint_8h.html">treeconstraint.h</a></li>
<li>enumerate/<a class="el" href="treelp_8h.html">treelp.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
