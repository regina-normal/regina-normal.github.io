<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::EulerSearcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1EulerSearcher.html">EulerSearcher</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classregina_1_1EulerSearcher-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::EulerSearcher Class Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A gluing permutation search class that offers a specialised search algorithm for when all vertex links must all have a given fixed Euler characteristic.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;census/gluingpermsearcher3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::EulerSearcher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1EulerSearcher.png" usemap="#regina::EulerSearcher_map" alt=""/>
  <map id="regina::EulerSearcher_map" name="regina::EulerSearcher_map">
<area href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given..." alt="regina::GluingPermSearcher&lt; 3 &gt;" shape="rect" coords="0,112,300,136"/>
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; GluingPermSearcher&lt; 3 &gt; &gt;" shape="rect" coords="0,56,300,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GluingPermSearcher&lt; 3 &gt;, false &gt;" shape="rect" coords="0,0,300,24"/>
<area href="classregina_1_1HyperbolicMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only minimal id..." alt="regina::HyperbolicMinSearcher" shape="rect" coords="0,224,300,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is constructed.  <a href="structregina_1_1EulerSearcher_1_1TetEdgeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed.  <a href="structregina_1_1EulerSearcher_1_1TetVertexState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af05400bd3d386b58e12971dc9dfa6c2b" id="r_af05400bd3d386b58e12971dc9dfa6c2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af05400bd3d386b58e12971dc9dfa6c2b">EulerSearcher</a> (int useEuler, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge)</td></tr>
<tr class="memdesc:af05400bd3d386b58e12971dc9dfa6c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager that restricts Euler characteristic on the vertex links, as described in the class overview.  <br /></td></tr>
<tr class="separator:af05400bd3d386b58e12971dc9dfa6c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be09ff8730ae38e6729094cf0b8b0a" id="r_a24be09ff8730ae38e6729094cf0b8b0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24be09ff8730ae38e6729094cf0b8b0a">EulerSearcher</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a24be09ff8730ae38e6729094cf0b8b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <br /></td></tr>
<tr class="separator:a24be09ff8730ae38e6729094cf0b8b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a14a9b16a7035ef90fa803e22a1d818" id="r_a0a14a9b16a7035ef90fa803e22a1d818"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a14a9b16a7035ef90fa803e22a1d818">~EulerSearcher</a> () override</td></tr>
<tr class="memdesc:a0a14a9b16a7035ef90fa803e22a1d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <br /></td></tr>
<tr class="separator:a0a14a9b16a7035ef90fa803e22a1d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5531da4b1c649408364359cafb5d862d" id="r_a5531da4b1c649408364359cafb5d862d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5531da4b1c649408364359cafb5d862d">dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a5531da4b1c649408364359cafb5d862d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <br /></td></tr>
<tr class="separator:a5531da4b1c649408364359cafb5d862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a30b20a6f0b9051de8dcddb562cb572" id="r_a8a30b20a6f0b9051de8dcddb562cb572"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a8a30b20a6f0b9051de8dcddb562cb572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572">runSearch</a> (Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8a30b20a6f0b9051de8dcddb562cb572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <br /></td></tr>
<tr class="separator:a8a30b20a6f0b9051de8dcddb562cb572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2298c5145ff75ef61405b8413244b" id="r_a1fa2298c5145ff75ef61405b8413244b"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a1fa2298c5145ff75ef61405b8413244b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b">partialSearch</a> (long maxDepth, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1fa2298c5145ff75ef61405b8413244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a partial search for all possible gluing permutations that satisfy the search criteria, branching only to the given depth and no further.  <br /></td></tr>
<tr class="separator:a1fa2298c5145ff75ef61405b8413244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700bd99a9f6255a07df0ace0a9a442a" id="r_ad700bd99a9f6255a07df0ace0a9a442a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ad700bd99a9f6255a07df0ace0a9a442a">isComplete</a> () const</td></tr>
<tr class="memdesc:ad700bd99a9f6255a07df0ace0a9a442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <br /></td></tr>
<tr class="separator:ad700bd99a9f6255a07df0ace0a9a442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aae09c481982555e0a9f744264e8dc" id="r_a68aae09c481982555e0a9f744264e8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc">dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a68aae09c481982555e0a9f744264e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <br /></td></tr>
<tr class="separator:a68aae09c481982555e0a9f744264e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb81ca0d2dc30c293cecd37c45802d0" id="r_a1eb81ca0d2dc30c293cecd37c45802d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0">taggedData</a> () const</td></tr>
<tr class="memdesc:a1eb81ca0d2dc30c293cecd37c45802d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <br /></td></tr>
<tr class="separator:a1eb81ca0d2dc30c293cecd37c45802d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fda6e57f48ae36ee4cf9a55aa20c9" id="r_a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9">data</a> () const</td></tr>
<tr class="memdesc:a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all internal data in a plain text format.  <br /></td></tr>
<tr class="separator:a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab59c19d79ad769be986408bfff7e9a" id="r_acab59c19d79ad769be986408bfff7e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#acab59c19d79ad769be986408bfff7e9a">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:acab59c19d79ad769be986408bfff7e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:acab59c19d79ad769be986408bfff7e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3c0db014ab83e17f618477c7412bcf57" id="r_a3c0db014ab83e17f618477c7412bcf57"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a3c0db014ab83e17f618477c7412bcf57"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a3c0db014ab83e17f618477c7412bcf57">findAllPerms</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c0db014ab83e17f618477c7412bcf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <br /></td></tr>
<tr class="separator:a3c0db014ab83e17f618477c7412bcf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054b62a34fcc7bd6f86c32fb45ccc955" id="r_a054b62a34fcc7bd6f86c32fb45ccc955"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a054b62a34fcc7bd6f86c32fb45ccc955">bestSearcher</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge)</td></tr>
<tr class="memdesc:a054b62a34fcc7bd6f86c32fb45ccc955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <br /></td></tr>
<tr class="separator:a054b62a34fcc7bd6f86c32fb45ccc955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809bd79cc004ea30eb752dfd4f018574" id="r_a809bd79cc004ea30eb752dfd4f018574"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574">fromTaggedData</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a809bd79cc004ea30eb752dfd4f018574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <br /></td></tr>
<tr class="separator:a809bd79cc004ea30eb752dfd4f018574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d5c83555812ec5537ee85dfa12a71b" id="r_a87d5c83555812ec5537ee85dfa12a71b"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a87d5c83555812ec5537ee85dfa12a71b">fromTaggedData</a> (std::string <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9">data</a>)</td></tr>
<tr class="memdesc:a87d5c83555812ec5537ee85dfa12a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data stored in the given string.  <br /></td></tr>
<tr class="separator:a87d5c83555812ec5537ee85dfa12a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8b8f38fc679c0ed421f8740e480450ec" id="r_a8b8f38fc679c0ed421f8740e480450ec"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8f38fc679c0ed421f8740e480450ec">dataTag</a> = 'e'</td></tr>
<tr class="memdesc:a8b8f38fc679c0ed421f8740e480450ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <br /></td></tr>
<tr class="separator:a8b8f38fc679c0ed421f8740e480450ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a78092e891f6f355e6e65876301fcaf6f" id="r_a78092e891f6f355e6e65876301fcaf6f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#a78092e891f6f355e6e65876301fcaf6fa48683e64b202e5e03d093d52837c899b">VLINK_JOIN_INIT</a> = -1
, <a class="el" href="#a78092e891f6f355e6e65876301fcaf6fa6c8e29d0377dd6124780ea5fd0169052">VLINK_JOIN_HANDLE</a> = -2
, <a class="el" href="#a78092e891f6f355e6e65876301fcaf6fab6592b7a8fc5491a8a482f5051e3bda5">VLINK_JOIN_BRIDGE</a> = -3
, <a class="el" href="#a78092e891f6f355e6e65876301fcaf6fa4c0a3cec3e4456fda85a4d785c9772ee">VLINK_JOIN_TWIST</a> = -4
 }</td></tr>
<tr class="memdesc:a78092e891f6f355e6e65876301fcaf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants used in the <em>vertexStateChanged</em> array to indicate how a partial vertex link becomes glued to itself along two of its boundary edges.  <a href="#a78092e891f6f355e6e65876301fcaf6f">More...</a><br /></td></tr>
<tr class="separator:a78092e891f6f355e6e65876301fcaf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a4aee3a8183e5f79b7a171872462a2" id="r_ab4a4aee3a8183e5f79b7a171872462a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> = std::function&lt;void(const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt;&amp;)&gt;</td></tr>
<tr class="memdesc:ab4a4aee3a8183e5f79b7a171872462a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to hold the user's action function and arguments when enumerating gluing permutations.  <br /></td></tr>
<tr class="separator:ab4a4aee3a8183e5f79b7a171872462a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed8be67de5d3c79fa8a90d84d2953871" id="r_aed8be67de5d3c79fa8a90d84d2953871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8be67de5d3c79fa8a90d84d2953871">searchImpl</a> (long maxDepth, <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> &amp;&amp;action) override</td></tr>
<tr class="memdesc:aed8be67de5d3c79fa8a90d84d2953871"><td class="mdescLeft">&#160;</td><td class="mdescRight">A de-templatised implementation of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>.  <br /></td></tr>
<tr class="separator:aed8be67de5d3c79fa8a90d84d2953871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfc6d817749b340a6d2290bb31436a3" id="r_accfc6d817749b340a6d2290bb31436a3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accfc6d817749b340a6d2290bb31436a3">dataTagInternal</a> () const override</td></tr>
<tr class="memdesc:accfc6d817749b340a6d2290bb31436a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character used to identify this class when storing tagged data in text format.  <br /></td></tr>
<tr class="separator:accfc6d817749b340a6d2290bb31436a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6680949d642a2d468d5331cc015aea0a" id="r_a6680949d642a2d468d5331cc015aea0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6680949d642a2d468d5331cc015aea0a">findEdgeClass</a> (size_t edgeID) const</td></tr>
<tr class="memdesc:a6680949d642a2d468d5331cc015aea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the representative of the equivalence class containing the given tetrahedron edge.  <br /></td></tr>
<tr class="separator:a6680949d642a2d468d5331cc015aea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec584882551d1739ed30927c9cdcd37c" id="r_aec584882551d1739ed30927c9cdcd37c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec584882551d1739ed30927c9cdcd37c">findEdgeClass</a> (size_t edgeID, char &amp;twisted) const</td></tr>
<tr class="memdesc:aec584882551d1739ed30927c9cdcd37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the representative of the equivalence class containing the given tetrahedron edge.  <br /></td></tr>
<tr class="separator:aec584882551d1739ed30927c9cdcd37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f12fdba99f7dd5736b17e8acf2f3f9d" id="r_a5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f12fdba99f7dd5736b17e8acf2f3f9d">mergeVertexClasses</a> ()</td></tr>
<tr class="memdesc:a5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search.  <br /></td></tr>
<tr class="separator:a5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b3e60a84f49fdacdc12967dc88e50c" id="r_a11b3e60a84f49fdacdc12967dc88e50c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b3e60a84f49fdacdc12967dc88e50c">mergeEdgeClasses</a> ()</td></tr>
<tr class="memdesc:a11b3e60a84f49fdacdc12967dc88e50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search.  <br /></td></tr>
<tr class="separator:a11b3e60a84f49fdacdc12967dc88e50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7223404529a44de2fc26778be8780264" id="r_a7223404529a44de2fc26778be8780264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7223404529a44de2fc26778be8780264">splitVertexClasses</a> ()</td></tr>
<tr class="memdesc:a7223404529a44de2fc26778be8780264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <br /></td></tr>
<tr class="separator:a7223404529a44de2fc26778be8780264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39fef0d44352e48acbc72179b45d2f3" id="r_ae39fef0d44352e48acbc72179b45d2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae39fef0d44352e48acbc72179b45d2f3">splitEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ae39fef0d44352e48acbc72179b45d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <br /></td></tr>
<tr class="separator:ae39fef0d44352e48acbc72179b45d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710dad8f8061954153c2e39e61c046c2" id="r_a710dad8f8061954153c2e39e61c046c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710dad8f8061954153c2e39e61c046c2">vtxBdryJoin</a> (size_t vertexID, char end, size_t adjVertexID, char twist)</td></tr>
<tr class="memdesc:a710dad8f8061954153c2e39e61c046c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent.  <br /></td></tr>
<tr class="separator:a710dad8f8061954153c2e39e61c046c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f818f061eb2029d238ef9be269f4dec" id="r_a1f818f061eb2029d238ef9be269f4dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f818f061eb2029d238ef9be269f4dec">vtxBdryFixAdj</a> (size_t vertexID)</td></tr>
<tr class="memdesc:a1f818f061eb2029d238ef9be269f4dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex.  <br /></td></tr>
<tr class="separator:a1f818f061eb2029d238ef9be269f4dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea40073cb4fa7a7fd590e90b0d28e05" id="r_adea40073cb4fa7a7fd590e90b0d28e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adea40073cb4fa7a7fd590e90b0d28e05">vtxBdryBackup</a> (size_t vertexID)</td></tr>
<tr class="memdesc:adea40073cb4fa7a7fd590e90b0d28e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex.  <br /></td></tr>
<tr class="separator:adea40073cb4fa7a7fd590e90b0d28e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cd4a8fdb3306d8954168f07936cb52" id="r_a24cd4a8fdb3306d8954168f07936cb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24cd4a8fdb3306d8954168f07936cb52">vtxBdryRestore</a> (size_t vertexID)</td></tr>
<tr class="memdesc:a24cd4a8fdb3306d8954168f07936cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex.  <br /></td></tr>
<tr class="separator:a24cd4a8fdb3306d8954168f07936cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef01849800f375bb077ed4e9ff91640" id="r_a3ef01849800f375bb077ed4e9ff91640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ef01849800f375bb077ed4e9ff91640">vtxBdryNext</a> (size_t vertexID, size_t tet, int vertex, int bdryFace, size_t next[2], char twist[2])</td></tr>
<tr class="memdesc:a3ef01849800f375bb077ed4e9ff91640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction.  <br /></td></tr>
<tr class="separator:a3ef01849800f375bb077ed4e9ff91640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f3e2795f1f1851b4a6751ddec5b5fa" id="r_aa2f3e2795f1f1851b4a6751ddec5b5fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f3e2795f1f1851b4a6751ddec5b5fa">vtxBdryLength1</a> (size_t vertexID)</td></tr>
<tr class="memdesc:aa2f3e2795f1f1851b4a6751ddec5b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link.  <br /></td></tr>
<tr class="separator:aa2f3e2795f1f1851b4a6751ddec5b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59c5f5100b936d4534fc82259e9583" id="r_aed59c5f5100b936d4534fc82259e9583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed59c5f5100b936d4534fc82259e9583">vtxBdryLength2</a> (size_t vertexID1, size_t vertexID2)</td></tr>
<tr class="memdesc:aed59c5f5100b936d4534fc82259e9583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle.  <br /></td></tr>
<tr class="separator:aed59c5f5100b936d4534fc82259e9583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c895ecdbfb0ac85b999c8fda4d0618e" id="r_a5c895ecdbfb0ac85b999c8fda4d0618e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c895ecdbfb0ac85b999c8fda4d0618e">vtxBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:a5c895ecdbfb0ac85b999c8fda4d0618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class.  <br /></td></tr>
<tr class="separator:a5c895ecdbfb0ac85b999c8fda4d0618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff088f3e12d5e1a0875a33ee7afa1e" id="r_a63ff088f3e12d5e1a0875a33ee7afa1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ff088f3e12d5e1a0875a33ee7afa1e">vtxBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:a63ff088f3e12d5e1a0875a33ee7afa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream.  <br /></td></tr>
<tr class="separator:a63ff088f3e12d5e1a0875a33ee7afa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e6c6d0cce1efb0335a09ae6bdcd1f" id="r_a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8c7e6c6d0cce1efb0335a09ae6bdcd1f">isCanonical</a> () const</td></tr>
<tr class="memdesc:a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <br /></td></tr>
<tr class="separator:a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941c419f7a3a7d86e850a8d32a6bdd86" id="r_a941c419f7a3a7d86e850a8d32a6bdd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a941c419f7a3a7d86e850a8d32a6bdd86">badEdgeLink</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face) const</td></tr>
<tr class="memdesc:a941c419f7a3a7d86e850a8d32a6bdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <br /></td></tr>
<tr class="separator:a941c419f7a3a7d86e850a8d32a6bdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4089dd2a85f436724655825f082b81" id="r_a9f4089dd2a85f436724655825f082b81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a9f4089dd2a85f436724655825f082b81">lowDegreeEdge</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face, bool testDegree12, bool testDegree3) const</td></tr>
<tr class="memdesc:a9f4089dd2a85f436724655825f082b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <br /></td></tr>
<tr class="separator:a9f4089dd2a85f436724655825f082b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a642c9886af812c5fb4b30273f60e89d8" id="r_a642c9886af812c5fb4b30273f60e89d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642c9886af812c5fb4b30273f60e89d8">euler_</a></td></tr>
<tr class="memdesc:a642c9886af812c5fb4b30273f60e89d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic that vertex links must have.  <br /></td></tr>
<tr class="separator:a642c9886af812c5fb4b30273f60e89d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e9895e4a1f8c507e2785bb9f7b6fd" id="r_adb0e9895e4a1f8c507e2785bb9f7b6fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0e9895e4a1f8c507e2785bb9f7b6fd">nVertexClasses</a></td></tr>
<tr class="memdesc:adb0e9895e4a1f8c507e2785bb9f7b6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron vertices.  <br /></td></tr>
<tr class="separator:adb0e9895e4a1f8c507e2785bb9f7b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82d5ea45a6d1ca689bc81c55599970d" id="r_ad82d5ea45a6d1ca689bc81c55599970d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82d5ea45a6d1ca689bc81c55599970d">vertexState</a></td></tr>
<tr class="memdesc:ad82d5ea45a6d1ca689bc81c55599970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron vertices.  <br /></td></tr>
<tr class="separator:ad82d5ea45a6d1ca689bc81c55599970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d7108c8e376f1282634ccee141e0f" id="r_a161d7108c8e376f1282634ccee141e0f"><td class="memItemLeft" align="right" valign="top">std::make_signed_t&lt; size_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a161d7108c8e376f1282634ccee141e0f">vertexStateChanged</a></td></tr>
<tr class="memdesc:a161d7108c8e376f1282634ccee141e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the vertexState[] array has been updated over time.  <br /></td></tr>
<tr class="separator:a161d7108c8e376f1282634ccee141e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f694214e1f4e6b1b1862141e3d17856" id="r_a3f694214e1f4e6b1b1862141e3d17856"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f694214e1f4e6b1b1862141e3d17856">nEdgeClasses</a></td></tr>
<tr class="memdesc:a3f694214e1f4e6b1b1862141e3d17856"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron edges.  <br /></td></tr>
<tr class="separator:a3f694214e1f4e6b1b1862141e3d17856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae928a1464153e1e3a4d438cee59d5" id="r_a7cae928a1464153e1e3a4d438cee59d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cae928a1464153e1e3a4d438cee59d5">edgeState</a></td></tr>
<tr class="memdesc:a7cae928a1464153e1e3a4d438cee59d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron edges.  <br /></td></tr>
<tr class="separator:a7cae928a1464153e1e3a4d438cee59d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f39d04c568f4a8e495814fbb1531a" id="r_a4e6f39d04c568f4a8e495814fbb1531a"><td class="memItemLeft" align="right" valign="top">ssize_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6f39d04c568f4a8e495814fbb1531a">edgeStateChanged</a></td></tr>
<tr class="memdesc:a4e6f39d04c568f4a8e495814fbb1531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState[] array has been updated over time.  <br /></td></tr>
<tr class="separator:a4e6f39d04c568f4a8e495814fbb1531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526564cd5833ff23c26c6f5bd7895add" id="r_a526564cd5833ff23c26c6f5bd7895add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a526564cd5833ff23c26c6f5bd7895add">perms_</a></td></tr>
<tr class="memdesc:a526564cd5833ff23c26c6f5bd7895add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of gluing permutations under construction.  <br /></td></tr>
<tr class="separator:a526564cd5833ff23c26c6f5bd7895add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b55f535b4cc3677b6176b766ba9fec8" id="r_a0b55f535b4cc3677b6176b766ba9fec8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a0b55f535b4cc3677b6176b766ba9fec8">autos_</a></td></tr>
<tr class="memdesc:a0b55f535b4cc3677b6176b766ba9fec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <br /></td></tr>
<tr class="separator:a0b55f535b4cc3677b6176b766ba9fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7086cef35b30a1e10385ec3f12bce31" id="r_ae7086cef35b30a1e10385ec3f12bce31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ae7086cef35b30a1e10385ec3f12bce31">orientableOnly_</a></td></tr>
<tr class="memdesc:ae7086cef35b30a1e10385ec3f12bce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <br /></td></tr>
<tr class="separator:ae7086cef35b30a1e10385ec3f12bce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107d4ea96e2006fce01b49508221e604" id="r_a107d4ea96e2006fce01b49508221e604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a107d4ea96e2006fce01b49508221e604">finiteOnly_</a></td></tr>
<tr class="memdesc:a107d4ea96e2006fce01b49508221e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <br /></td></tr>
<tr class="separator:a107d4ea96e2006fce01b49508221e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223af4f18c75892d5eccea336e49151" id="r_a1223af4f18c75892d5eccea336e49151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1223af4f18c75892d5eccea336e49151">purge_</a></td></tr>
<tr class="memdesc:a1223af4f18c75892d5eccea336e49151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? See the constructor documentation for further details on this search parameter.  <br /></td></tr>
<tr class="separator:a1223af4f18c75892d5eccea336e49151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ef778b520739058cf77d70963d7ab6" id="r_a46ef778b520739058cf77d70963d7ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a46ef778b520739058cf77d70963d7ab6">started</a></td></tr>
<tr class="memdesc:a46ef778b520739058cf77d70963d7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <br /></td></tr>
<tr class="separator:a46ef778b520739058cf77d70963d7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07986d0a577e24601d762c07c43226eb" id="r_a07986d0a577e24601d762c07c43226eb"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a07986d0a577e24601d762c07c43226eb">orientation</a></td></tr>
<tr class="memdesc:a07986d0a577e24601d762c07c43226eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <br /></td></tr>
<tr class="separator:a07986d0a577e24601d762c07c43226eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8738eee160530cfdcf10a05f626212da" id="r_a8738eee160530cfdcf10a05f626212da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8738eee160530cfdcf10a05f626212da">order</a></td></tr>
<tr class="memdesc:a8738eee160530cfdcf10a05f626212da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <br /></td></tr>
<tr class="separator:a8738eee160530cfdcf10a05f626212da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1716e934d96c4657abb5e6d0118f18a1" id="r_a1716e934d96c4657abb5e6d0118f18a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1716e934d96c4657abb5e6d0118f18a1">orderSize</a></td></tr>
<tr class="memdesc:a1716e934d96c4657abb5e6d0118f18a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <br /></td></tr>
<tr class="separator:a1716e934d96c4657abb5e6d0118f18a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c8899d3f4b3b789905c0b24d670715" id="r_ad1c8899d3f4b3b789905c0b24d670715"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ad1c8899d3f4b3b789905c0b24d670715">orderElt</a></td></tr>
<tr class="memdesc:ad1c8899d3f4b3b789905c0b24d670715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <br /></td></tr>
<tr class="separator:ad1c8899d3f4b3b789905c0b24d670715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa6e5ac84a096612d71e4ddc2cea763a3" id="r_aa6e5ac84a096612d71e4ddc2cea763a3"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e5ac84a096612d71e4ddc2cea763a3">VLINK_CLOSED</a> = 1</td></tr>
<tr class="memdesc:aa6e5ac84a096612d71e4ddc2cea763a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges).  <br /></td></tr>
<tr class="separator:aa6e5ac84a096612d71e4ddc2cea763a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17d2f1e9eed6d6c7796d44417880db2" id="r_ab17d2f1e9eed6d6c7796d44417880db2"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab17d2f1e9eed6d6c7796d44417880db2">VLINK_BAD_EULER</a> = 2</td></tr>
<tr class="memdesc:ab17d2f1e9eed6d6c7796d44417880db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has either (i) accumulated too high a genus (so when its punctures are filled the Euler characteristic will be too low), or has (ii) been closed off with too low a genus (so its final Euler characteristic is too high).  <br /></td></tr>
<tr class="separator:ab17d2f1e9eed6d6c7796d44417880db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc83da54a0646f841ea40bb0c40ab7" id="r_a53dc83da54a0646f841ea40bb0c40ab7"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53dc83da54a0646f841ea40bb0c40ab7">vertexLinkNextFace</a> [4][4]</td></tr>
<tr class="memdesc:a53dc83da54a0646f841ea40bb0c40ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron.  <br /></td></tr>
<tr class="separator:a53dc83da54a0646f841ea40bb0c40ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4609aecf1e7fae96f3ccfa6b56fc66d5" id="r_a4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4609aecf1e7fae96f3ccfa6b56fc66d5">vertexLinkPrevFace</a> [4][4]</td></tr>
<tr class="memdesc:a4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>.  <br /></td></tr>
<tr class="separator:a4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A gluing permutation search class that offers a specialised search algorithm for when all vertex links must all have a given fixed Euler characteristic. </p>
<p>Examples might be Euler characteristic 2 (for closed manifolds), or Euler characteristic 0 (for manifolds with torus and/or Klein bottle cusps). In addition, we require that every edge must be valid (i.e., not identified with itself in reverse).</p>
<p>Vertices on boundary triangles are treated a little differently. If the underlying face pairing includes boundary triangles and the given Euler characteristic is <em>E</em>, then boundary vertex links must have Euler characteristic <em>E-1</em>, and must have exactly one puncture. For instance, if <em>E</em> is 2 and the face pairing includes boundary faces, then all vertex links must be either spheres (for internal vertices) or discs (for boundary vertices).</p>
<p>The search algorithm uses modified union-find structures on both edge and vertex equivalence classes to prune searches that are guaranteed to lead to bad edge or vertex links. For details see "Enumeration of non-orientable 3-manifolds using face-pairing graphs and
union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571; and "Detecting genus in vertex links for the fast enumeration
of 3-manifold triangulations", Benjamin A. Burton, in "ISSAC 2011:
Proceedings of the 36th International Symposium on Symbolic and
Algebraic Computation", ACM, 2011, pp. 59-66.</p>
<p>No additional unwanted triangulations will be produced by this search (in contrast to other search classes, such as <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a>). That is, <em>only</em> 3-manifolds with the required vertex links will be produced.</p>
<p>This class is designed to manage the construction of a large census of triangulations, and so it does not support copying, moving or swapping. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab4a4aee3a8183e5f79b7a171872462a2" name="ab4a4aee3a8183e5f79b7a171872462a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a4aee3a8183e5f79b7a171872462a2">&#9670;&#160;</a></span>ActionWrapper</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::ActionWrapper = std::function&lt;void(const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt;&amp;)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type used to hold the user's action function and arguments when enumerating gluing permutations. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a78092e891f6f355e6e65876301fcaf6f" name="a78092e891f6f355e6e65876301fcaf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78092e891f6f355e6e65876301fcaf6f">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants used in the <em>vertexStateChanged</em> array to indicate how a partial vertex link becomes glued to itself along two of its boundary edges. </p>
<p>See <em>vertexStateChanged</em> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a78092e891f6f355e6e65876301fcaf6fa48683e64b202e5e03d093d52837c899b" name="a78092e891f6f355e6e65876301fcaf6fa48683e64b202e5e03d093d52837c899b"></a>VLINK_JOIN_INIT&#160;</td><td class="fielddoc"><p>A placeholder value for a join that has not yet been made. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78092e891f6f355e6e65876301fcaf6fa6c8e29d0377dd6124780ea5fd0169052" name="a78092e891f6f355e6e65876301fcaf6fa6c8e29d0377dd6124780ea5fd0169052"></a>VLINK_JOIN_HANDLE&#160;</td><td class="fielddoc"><p>Signifies that two distinct boundary components of a vertex link have been connected, forming a handle (either orientable or non-orientable). </p>
</td></tr>
<tr><td class="fieldname"><a id="a78092e891f6f355e6e65876301fcaf6fab6592b7a8fc5491a8a482f5051e3bda5" name="a78092e891f6f355e6e65876301fcaf6fab6592b7a8fc5491a8a482f5051e3bda5"></a>VLINK_JOIN_BRIDGE&#160;</td><td class="fielddoc"><p>Signifies that a single boundary component of the vertex link has had two edges joined together in an orientation-preserving fashion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78092e891f6f355e6e65876301fcaf6fa4c0a3cec3e4456fda85a4d785c9772ee" name="a78092e891f6f355e6e65876301fcaf6fa4c0a3cec3e4456fda85a4d785c9772ee"></a>VLINK_JOIN_TWIST&#160;</td><td class="fielddoc"><p>Signifies that a single boundary component of the vertex link has had two edges joined together in an orientation-reversing fashion. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af05400bd3d386b58e12971dc9dfa6c2b" name="af05400bd3d386b58e12971dc9dfa6c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05400bd3d386b58e12971dc9dfa6c2b">&#9670;&#160;</a></span>EulerSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::EulerSearcher </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>useEuler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager that restricts Euler characteristic on the vertex links, as described in the class overview. </p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> documentation. Note in particular that this class will be automatically used by GluingPermSearcher&lt;3&gt;::findAllPerms() if possible, so there is often no need for an end user to instantiate this class directly.</p>
<p>All constructor arguments except for <em>euler</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor, though some arguments (such as <em>finiteOnly</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Euler characteristic is at most 2. </dd>
<dd>
The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useEuler</td><td>the Euler characteristic that vertex links must have. For boundary vertices, this is the Euler characteristic of the closed surface that would be obtained if the puncture in the vertex link were filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24be09ff8730ae38e6729094cf0b8b0a" name="a24be09ff8730ae38e6729094cf0b8b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be09ff8730ae38e6729094cf0b8b0a">&#9670;&#160;</a></span>EulerSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::EulerSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The data found in the input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. This constructor is fundamentally designed around working through a single input stream as we make our way from base class constructors down to subclass constructors. Python users should use <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead, which incorporate this same text data as part of their richer text format.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a14a9b16a7035ef90fa803e22a1d818" name="a0a14a9b16a7035ef90fa803e22a1d818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a14a9b16a7035ef90fa803e22a1d818">&#9670;&#160;</a></span>~EulerSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::~EulerSearcher </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a941c419f7a3a7d86e850a8d32a6bdd86" name="a941c419f7a3a7d86e850a8d32a6bdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941c419f7a3a7d86e850a8d32a6bdd86">&#9670;&#160;</a></span>badEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::badEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse. </p>
<p>Note that such edges can only occur in non-orientable triangulations.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<p>If <em>finiteOnly_</em> is <code>true</code> in the search criteria, additional tests will be run that can eliminate triangulations with non-orientable vertex links. Although these tests are not searching for bad edge links per se, they can be performed within this routine with very little additional work needing to be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to an edge identified with itself in reverse, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="a054b62a34fcc7bd6f86c32fb45ccc955" name="a054b62a34fcc7bd6f86c32fb45ccc955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054b62a34fcc7bd6f86c32fb45ccc955">&#9670;&#160;</a></span>bestSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finiteOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> instead.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager. </dd></dl>

</div>
</div>
<a id="a1e9fda6e57f48ae36ee4cf9a55aa20c9" name="a1e9fda6e57f48ae36ee4cf9a55aa20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all internal data in a plain text format. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for the appropriate class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>If subclasses override this function, they should write subclass data after superclass data. This means it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will be lost).</p>
<p>This routine returns the same information that <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> writes.</p>
<p>The key difference between <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> is that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available, but the matching input stream constructor is not. Python users should use <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all of this object's internal data in plain text format. </dd></dl>

</div>
</div>
<a id="accfc6d817749b340a6d2290bb31436a3" name="accfc6d817749b340a6d2290bb31436a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfc6d817749b340a6d2290bb31436a3">&#9670;&#160;</a></span>dataTagInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::dataTagInternal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a25a8d7405efc6728d46be43c6ead90cd">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#aafb35fb4974fe505202111b50745e6ca">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a5531da4b1c649408364359cafb5d862d" name="a5531da4b1c649408364359cafb5d862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5531da4b1c649408364359cafb5d862d">&#9670;&#160;</a></span>dumpData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for the appropriate class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>If subclasses override this function, they should write subclass data after superclass data. This means it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will be lost).</p>
<p>This routine outputs the same information that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> returns.</p>
<p>The key difference between <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> is that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. You can instead use <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a>, which returns this same information as a string. However, the matching input stream constructor is not available in Python either, so it is recommended that Python users use <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a57f65e0d9e84e884c5205aa327ba52c6">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#a6f67121d4c28ba2f28b73d42d5ed93bd">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="a68aae09c481982555e0a9f744264e8dc" name="a68aae09c481982555e0a9f744264e8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68aae09c481982555e0a9f744264e8dc">&#9670;&#160;</a></span>dumpTaggedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<p>This routine outputs the same information that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> returns.</p>
<p>The key difference between <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> is that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a>, which returns this same information as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0db014ab83e17f618477c7412bcf57" name="a3c0db014ab83e17f618477c7412bcf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0db014ab83e17f618477c7412bcf57">&#9670;&#160;</a></span>findAllPerms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finiteOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given face pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> and then calls <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results via <em>action</em> and <em>args</em>..</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here). </dd></dl>

</div>
</div>
<a id="a6680949d642a2d468d5331cc015aea0a" name="a6680949d642a2d468d5331cc015aea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6680949d642a2d468d5331cc015aea0a">&#9670;&#160;</a></span>findEdgeClass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>edgeID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="#a6680949d642a2d468d5331cc015aea0a" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly slower but which also tracks edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="aec584882551d1739ed30927c9cdcd37c" name="aec584882551d1739ed30927c9cdcd37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec584882551d1739ed30927c9cdcd37c">&#9670;&#160;</a></span>findEdgeClass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>edgeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;</td>          <td class="paramname"><span class="paramname"><em>twisted</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>The argument <em>twisted</em> is also modified to indicate whether or not the identification of the given edge with the class representative preserves orientation. Note that this arugment is <em>not</em> initialised. Instead, if the identification is orientation-preserving then <em>twisted</em> will be left unmodified, and if it is orientation-reversing then <em>twisted</em> will be changed from 0 to 1 or vice-versa.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="#a6680949d642a2d468d5331cc015aea0a" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly faster but which does not track edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
    <tr><td class="paramname">twisted</td><td>used to track edge orientation, as described above. This must be either 0 or 1 as it is passed into the function, and it will also be either 0 or 1 upon returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="a809bd79cc004ea30eb752dfd4f018574" name="a809bd79cc004ea30eb752dfd4f018574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809bd79cc004ea30eb752dfd4f018574">&#9670;&#160;</a></span>fromTaggedData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::fromTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The data found in the given input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> that takes its input as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager, or <code>null</code> if the data in the input stream was invalid or incorrectly formatted. </dd></dl>

</div>
</div>
<a id="a87d5c83555812ec5537ee85dfa12a71b" name="a87d5c83555812ec5537ee85dfa12a71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d5c83555812ec5537ee85dfa12a71b">&#9670;&#160;</a></span>fromTaggedData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::fromTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data stored in the given string. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format returned by <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="#a5531da4b1c649408364359cafb5d862d" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The data found in the given string is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the tagged data from which to reconstruct a search manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager, or <code>null</code> if the data in the given string was invalid or incorrectly formatted. </dd></dl>

</div>
</div>
<a id="a8c7e6c6d0cce1efb0335a09ae6bdcd1f" name="a8c7e6c6d0cce1efb0335a09ae6bdcd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7e6c6d0cce1efb0335a09ae6bdcd1f">&#9670;&#160;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad700bd99a9f6255a07df0ace0a9a442a" name="ad700bd99a9f6255a07df0ace0a9a442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700bd99a9f6255a07df0ace0a9a442a">&#9670;&#160;</a></span>isComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::isComplete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>action</em> routine when running partial depth-based searches. See <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9f4089dd2a85f436724655825f082b81" name="a9f4089dd2a85f436724655825f082b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4089dd2a85f436724655825f082b81">&#9670;&#160;</a></span>lowDegreeEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::lowDegreeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>face</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>testDegree12</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>testDegree3</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with a low degree edge. </p>
<p>Precisely which types of low degree edges are identified must be specified through parameters <em>testDegree12</em> and <em>testDegree3</em>.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
    <tr><td class="paramname">testDegree12</td><td><code>true</code> if we should test for non-boundary edges of degree 1 or 2. </td></tr>
    <tr><td class="paramname">testDegree3</td><td><code>true</code> if we should test for non-boundary edges of degree 3 involving three distinct tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a low-degree edge as specified by parameters <em>testDegree12</em> and <em>testDegree3</em>, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="a11b3e60a84f49fdacdc12967dc88e50c" name="a11b3e60a84f49fdacdc12967dc88e50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b3e60a84f49fdacdc12967dc88e50c">&#9670;&#160;</a></span>mergeEdgeClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::mergeEdgeClasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details.</p>
<p>This routine returns a boolean that indicates whether this merge creates an invalid edge (i.e., an edge identified with itself in reverse).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this merge creates an invalid edge, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a5f12fdba99f7dd5736b17e8acf2f3f9d" name="a5f12fdba99f7dd5736b17e8acf2f3f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f12fdba99f7dd5736b17e8acf2f3f9d">&#9670;&#160;</a></span>mergeVertexClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::mergeVertexClasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<p>This routine returns a bitwise (OR) combination of the VLINK_... flags defined earlier in this class. These flags describe what happened to the vertex links during this particular merge. In particular, they note when a vertex link is closed off, or enters a state where it will be forced to have the wrong Euler characteristic.</p>
<dl class="section return"><dt>Returns</dt><dd>a combination of VLINK_... flags describing how the vertex links were changed, or 0 if none of the changes described by these flags were observed. </dd></dl>

</div>
</div>
<a id="a1fa2298c5145ff75ef61405b8413244b" name="a1fa2298c5145ff75ef61405b8413244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa2298c5145ff75ef61405b8413244b">&#9670;&#160;</a></span>partialSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::partialSearch </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>maxDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a partial search for all possible gluing permutations that satisfy the search criteria, branching only to the given depth and no further. </p>
<p>This routine essentially does some but not all of the work of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> documentation for a detailed overview of what the full search aims to achieve.</p>
<p>If <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> enumerates an entire search tree, then you can think of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> as only enumerating the first <em>maxDepth</em> levels of this search tree. Rather than producing complete gluing permutation sets, this search will produce a series of partially-constructed permutation sets. A partial search can be continued by calling <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> again on the underlying <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> (perhaps after being frozen, or passed on to a different processor via <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a>). If necessary, the <em>action</em> routine may call <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ad700bd99a9f6255a07df0ace0a9a442a" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">isComplete()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<p>If the search tree is shallow enough (or if <em>maxDepth</em> is large enough), it is possible that this routine will produce complete gluing permutation sets.</p>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run. A negative number indicates that a full search should be run. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each permutation set (partial or complete) that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial permutation set argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a30b20a6f0b9051de8dcddb562cb572" name="a8a30b20a6f0b9051de8dcddb562cb572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a30b20a6f0b9051de8dcddb562cb572">&#9670;&#160;</a></span>runSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a const reference to a <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;3&gt;</a>. This will be the permutation set that was found. If <em>action</em> wishes to keep the permutation set, it should take a deep copy (not a reference), since the permutation set may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<p>It is possible to run only a partial search, branching to a given depth but no further; for this you should use the separate routine <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>, not <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each permutation set that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial permutation set argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed8be67de5d3c79fa8a90d84d2953871" name="aed8be67de5d3c79fa8a90d84d2953871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8be67de5d3c79fa8a90d84d2953871">&#9670;&#160;</a></span>searchImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::searchImpl </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>maxDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A de-templatised implementation of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>. </p>
<p>Here the templated action plus arguments are bundled together in a wrapper whose full type is known in advance.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>See <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> for further details. </p>

<p>Reimplemented from <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#aa838ef5adde96dd8681e70413a59bb54">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#a0a38bbe30a8533db040c1f2b48fd3553">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="ae39fef0d44352e48acbc72179b45d2f3" name="ae39fef0d44352e48acbc72179b45d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39fef0d44352e48acbc72179b45d2f3">&#9670;&#160;</a></span>splitEdgeClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::splitEdgeClasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details. </p>

</div>
</div>
<a id="a7223404529a44de2fc26778be8780264" name="a7223404529a44de2fc26778be8780264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7223404529a44de2fc26778be8780264">&#9670;&#160;</a></span>splitVertexClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::splitVertexClasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details. </p>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a1eb81ca0d2dc30c293cecd37c45802d0" name="a1eb81ca0d2dc30c293cecd37c45802d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb81ca0d2dc30c293cecd37c45802d0">&#9670;&#160;</a></span>taggedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::taggedData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<p>This routine returns the same information that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> writes.</p>
<p>The key difference between <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> is that <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all of this object's internal data in plain text format. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="adea40073cb4fa7a7fd590e90b0d28e05" name="adea40073cb4fa7a7fd590e90b0d28e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea40073cb4fa7a7fd590e90b0d28e05">&#9670;&#160;</a></span>vtxBdryBackup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryBackup </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c895ecdbfb0ac85b999c8fda4d0618e" name="a5c895ecdbfb0ac85b999c8fda4d0618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c895ecdbfb0ac85b999c8fda4d0618e">&#9670;&#160;</a></span>vtxBdryConsistencyCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryConsistencyCheck </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class. </p>
<p>Any errors that are identified will be written to standard error. Note that some errors might be harmless (for instance, when a call to <a class="el" href="#a5f12fdba99f7dd5736b17e8acf2f3f9d" title="Merge the classes of tetrahedron vertices as required by the new gluing made at stage orderElt of the...">mergeVertexClasses()</a> leaves processing incomplete because it has located a bad vertex link and expects the merge to be immediately undone). </p>

</div>
</div>
<a id="a63ff088f3e12d5e1a0875a33ee7afa1e" name="a63ff088f3e12d5e1a0875a33ee7afa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff088f3e12d5e1a0875a33ee7afa1e">&#9670;&#160;</a></span>vtxBdryDump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryDump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream. </p>
<p>The output format is relatively compact, and is subject to change in future versions of Regina. The output uses one line only, and a final newline is written.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f818f061eb2029d238ef9be269f4dec" name="a1f818f061eb2029d238ef9be269f4dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f818f061eb2029d238ef9be269f4dec">&#9670;&#160;</a></span>vtxBdryFixAdj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryFixAdj </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex. </p>
<p>It is assumed that the vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link. Recall from the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class notes that the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given vertex describe the boundary edges that follow on in either direction from the boundary edges supplied by this triangle.</p>
<p>This routine locates the tetrahedron vertices that provide the neighbouring boundary edges, and adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for these neighbouring vertices to point back to the given vertex.</p>
<p>This routine is intended to assist with backtracking. This routine is safe to use if the given tetrahedron vertex points to itself (i.e., it provides a complete boundary cycle of three edges in the vertex link).</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710dad8f8061954153c2e39e61c046c2" name="a710dad8f8061954153c2e39e61c046c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710dad8f8061954153c2e39e61c046c2">&#9670;&#160;</a></span>vtxBdryJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryJoin </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>adjVertexID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>twist</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent. </p>
<p>The <em>bdryNext</em> and <em>bdryTwist</em> arrays for each vertex will be adjusted to point to the other.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the first tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">end</td><td>specifies in which direction the adjacent boundary edges lie. This must be either 0 or 1, and its value should correspond to the relevant index in the <em>bdryNext</em> and <em>bdryTwist</em> arrays for vertex <em>vertexID</em>. </td></tr>
    <tr><td class="paramname">adjVertexID</td><td>the tetrahedron vertex whose boundary edges are adjacent to the boundary edges supplied by <em>vertexID</em>; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">twist</td><td>0 if the orientations of the two boundary segments of vertex link are oriented in the same direction, or 1 if they are oriented in opposite directions; see the <em>bdryTwist</em> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f3e2795f1f1851b4a6751ddec5b5fa" name="aa2f3e2795f1f1851b4a6751ddec5b5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f3e2795f1f1851b4a6751ddec5b5fa">&#9670;&#160;</a></span>vtxBdryLength1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::vtxBdryLength1 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a one-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aed59c5f5100b936d4534fc82259e9583" name="aed59c5f5100b936d4534fc82259e9583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed59c5f5100b936d4534fc82259e9583">&#9670;&#160;</a></span>vtxBdryLength2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::vtxBdryLength2 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID1</td><td>the first tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">vertexID2</td><td>the second tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a two-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3ef01849800f375bb077ed4e9ff91640" name="a3ef01849800f375bb077ed4e9ff91640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef01849800f375bb077ed4e9ff91640">&#9670;&#160;</a></span>vtxBdryNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryNext </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>tet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bdryFace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>next</em></span>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>twist</em></span>[2]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction. </p>
<p>The given edge of the vertex linking triangle must belong to one of the two tetrahedron faces currently being joined.</p>
<p>The tetrahedron vertex to examine is passed in <em>vertexID</em>, <em>tet</em> and <em>vertex</em>, and the particular edge of the vertex linking triangle to examine is specified by <em>bdryFace</em>. Details of the adjacent boundary edges are returned in the arrays <em>next</em> and <em>twist</em>.</p>
<p>Note that the values returned might or might not correspond to the <em>bdryNext</em> and <em>bdryTwist</em> arrays of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class, since the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> arrays skip over adjacent edges belonging to the same vertex linking triangle.</p>
<p>If the given edge of the vertex linking triangle is not a boundary edge of the vertex link, the behaviour of this routine is undefined.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tetrahedron face (<em>tet</em>, <em>bdryFace</em>) is one of the two faces that are currently being joined together. That is, this face is either order[orderElt] or its partner in the underlying face pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">tet</td><td>the tetrahedron described by <em>vertexID</em>; this must be (vertexID / 4). It is passed separately to avoid a slow division operation. </td></tr>
    <tr><td class="paramname">vertex</td><td>the tetrahedron vertex number described by <em>vertexID</em>; this must be (vertexID % 4). It is passed separately to avoid a slow modulus operation. </td></tr>
    <tr><td class="paramname">bdryFace</td><td>the face number of the given tetrahedron containing the edge of the vertex linking triangle that is under consideration. This must be between 0 and 3 inclusive, and it may not be equal to <em>vertex</em>. </td></tr>
    <tr><td class="paramname">next</td><td>returns the tetrahedron vertex supplying each adjacent boundary edge; see the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html#a08aa8a803ffacbdc1d91f0060114479c" title="If the corresponding triangular piece of vertex link has any boundary edges, bdryNext stores the indi...">TetVertexState::bdryNext</a> notes for details on which directions correspond to array indices 0 and 1. </td></tr>
    <tr><td class="paramname">twist</td><td>returns whether the orientations of the adjacent boundary edges are consistent with the orientation of this boundary edge; see the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html#a5cf573efd973f2236d51ba379187d05f" title="Describes whether the orientation of this boundary segment of the vertex link is consistent with the ...">TetVertexState::bdryTwist</a> notes for further information on orientations in the vertex link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24cd4a8fdb3306d8954168f07936cb52" name="a24cd4a8fdb3306d8954168f07936cb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cd4a8fdb3306d8954168f07936cb52">&#9670;&#160;</a></span>vtxBdryRestore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryRestore </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>vertexID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acab59c19d79ad769be986408bfff7e9a" name="acab59c19d79ad769be986408bfff7e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab59c19d79ad769be986408bfff7e9a">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0b55f535b4cc3677b6176b766ba9fec8" name="a0b55f535b4cc3677b6176b766ba9fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b55f535b4cc3677b6176b766ba9fec8">&#9670;&#160;</a></span>autos_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;3&gt;::IsoList <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying face pairing. </p>

</div>
</div>
<a id="a8b8f38fc679c0ed421f8740e480450ec" name="a8b8f38fc679c0ed421f8740e480450ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8f38fc679c0ed421f8740e480450ec">&#9670;&#160;</a></span>dataTag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::dataTag = 'e'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="a7cae928a1464153e1e3a4d438cee59d5" name="a7cae928a1464153e1e3a4d438cee59d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cae928a1464153e1e3a4d438cee59d5">&#9670;&#160;</a></span>edgeState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a>* regina::EulerSearcher::edgeState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron edges. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> description for details. This array has size 6n, where edge e of tetrahedron t has index 6t+e. </p>

</div>
</div>
<a id="a4e6f39d04c568f4a8e495814fbb1531a" name="a4e6f39d04c568f4a8e495814fbb1531a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f39d04c568f4a8e495814fbb1531a">&#9670;&#160;</a></span>edgeStateChanged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t* regina::EulerSearcher::edgeStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the edgeState[] array has been updated over time. </p>
<p>This array has size 8n. Suppose the gluing for order[i] affects face f of tetrahedron t. Then element 4i+v of this array describes how the gluing for order[i] affects the edge of tetrahedron t opposite vertices f and v (note that a quarter of this array will remain unused, since f and v are never equal).</p>
<p>If this identification of edges results in the tree with root edgeState[p] being grafted beneath the tree with root edgeState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="a642c9886af812c5fb4b30273f60e89d8" name="a642c9886af812c5fb4b30273f60e89d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642c9886af812c5fb4b30273f60e89d8">&#9670;&#160;</a></span>euler_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::euler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Euler characteristic that vertex links must have. </p>
<p>For boundary vertices, this is the Euler characteristic of the closed surface that would be obtained if the puncture in the vertex link were filled. </p>

</div>
</div>
<a id="a107d4ea96e2006fce01b49508221e604" name="a107d4ea96e2006fce01b49508221e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107d4ea96e2006fce01b49508221e604">&#9670;&#160;</a></span>finiteOnly_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite triangulations? </p>

</div>
</div>
<a id="a3f694214e1f4e6b1b1862141e3d17856" name="a3f694214e1f4e6b1b1862141e3d17856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f694214e1f4e6b1b1862141e3d17856">&#9670;&#160;</a></span>nEdgeClasses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::nEdgeClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron edges. </p>

</div>
</div>
<a id="adb0e9895e4a1f8c507e2785bb9f7b6fd" name="adb0e9895e4a1f8c507e2785bb9f7b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e9895e4a1f8c507e2785bb9f7b6fd">&#9670;&#160;</a></span>nVertexClasses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::EulerSearcher::nVertexClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron vertices. </p>

</div>
</div>
<a id="a8738eee160530cfdcf10a05f626212da" name="a8738eee160530cfdcf10a05f626212da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8738eee160530cfdcf10a05f626212da">&#9670;&#160;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;3&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to faces. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying face pairing graph, which in turn represents a tetrahedron face and its image under the given face pairing.</p>
<p>The specific tetrahedron face stored in this array for each edge of the underlying face pairing graph will be the smaller of the two identified tetrahedron faces (unless otherwise specified for a particular edge type; see <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> for examples). </p>

</div>
</div>
<a id="ad1c8899d3f4b3b789905c0b24d670715" name="ad1c8899d3f4b3b789905c0b24d670715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c8899d3f4b3b789905c0b24d670715">&#9670;&#160;</a></span>orderElt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a id="a1716e934d96c4657abb5e6d0118f18a1" name="a1716e934d96c4657abb5e6d0118f18a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1716e934d96c4657abb5e6d0118f18a1">&#9670;&#160;</a></span>orderSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a id="ae7086cef35b30a1e10385ec3f12bce31" name="ae7086cef35b30a1e10385ec3f12bce31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7086cef35b30a1e10385ec3f12bce31">&#9670;&#160;</a></span>orientableOnly_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a id="a07986d0a577e24601d762c07c43226eb" name="a07986d0a577e24601d762c07c43226eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07986d0a577e24601d762c07c43226eb">&#9670;&#160;</a></span>orientation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each tetrahedron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply ±1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a id="a526564cd5833ff23c26c6f5bd7895add" name="a526564cd5833ff23c26c6f5bd7895add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526564cd5833ff23c26c6f5bd7895add">&#9670;&#160;</a></span>perms_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::perms_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of gluing permutations under construction. </p>

</div>
</div>
<a id="a1223af4f18c75892d5eccea336e49151" name="a1223af4f18c75892d5eccea336e49151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223af4f18c75892d5eccea336e49151">&#9670;&#160;</a></span>purge_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;<a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a>&gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::purge_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there any types of triangulation that we may optionally avoid constructing? See the constructor documentation for further details on this search parameter. </p>

</div>
</div>
<a id="a46ef778b520739058cf77d70963d7ab6" name="a46ef778b520739058cf77d70963d7ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ef778b520739058cf77d70963d7ab6">&#9670;&#160;</a></span>started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a id="a53dc83da54a0646f841ea40bb0c40ab7" name="a53dc83da54a0646f841ea40bb0c40ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dc83da54a0646f841ea40bb0c40ab7">&#9670;&#160;</a></span>vertexLinkNextFace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::EulerSearcher::vertexLinkNextFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron. </p>
<p>This ordering is consistent with the orientations of triangles in the vertex link used by <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html#a18b374687123ab8241e1cf84aff30a73" title="The identification of this object and its parent in the tree corresponds to a gluing of two triangles...">TetVertexState::twistUp</a>.</p>
<p>For vertex v (0..3), the tetrahedron face that follows f (0..3) in this ordering is <em>vertexLinkNextFace</em>[v][f]. The remaining array elements <em>vertexLinkNextFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="a4609aecf1e7fae96f3ccfa6b56fc66d5" name="a4609aecf1e7fae96f3ccfa6b56fc66d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4609aecf1e7fae96f3ccfa6b56fc66d5">&#9670;&#160;</a></span>vertexLinkPrevFace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::EulerSearcher::vertexLinkPrevFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>. </p>
<p>For vertex v (0..3), the tetrahedron face that precedes f (0..3) in this ordering is <em>vertexLinkPrevFace</em>[v][f]. The remaining array elements <em>vertexLinkPrevFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="ad82d5ea45a6d1ca689bc81c55599970d" name="ad82d5ea45a6d1ca689bc81c55599970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82d5ea45a6d1ca689bc81c55599970d">&#9670;&#160;</a></span>vertexState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a>* regina::EulerSearcher::vertexState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron vertices. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> description for details. This array has size 4n, where vertex v of tetrahedron t has index 4t+v. </p>

</div>
</div>
<a id="a161d7108c8e376f1282634ccee141e0f" name="a161d7108c8e376f1282634ccee141e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161d7108c8e376f1282634ccee141e0f">&#9670;&#160;</a></span>vertexStateChanged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::make_signed_t&lt;size_t&gt;* regina::EulerSearcher::vertexStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the vertexState[] array has been updated over time. </p>
<p>This array has size 8n, where element 4i+v describes how the gluing for order[i] affects vertex v of the corresponding tetrahedron (thus a quarter of this array will remain unused, since only three vertices are affected for each gluing).</p>
<p>If this identification of vertices results in the tree with root vertexState[p] being grafted beneath the tree with root vertexState[q] (so two distinct vertex links become joined together), this array will store the value p. Otherwise it will store one of the values <em>VLINK_JOIN_HANDLE</em>, <em>VLINK_JOIN_BRIDGE</em> or <em>VLINK_JOIN_TWIST</em>, indicating how the corresponding partial link is glued to itself.</p>
<p>The value <em>VLINK_JOIN_INIT</em> will be stored for positions in the array that correspond to gluings that have not yet been made.</p>
<p>This uses a signed variant of <code>size_t</code>, since it can take on several possible negative values (whereas <code>ssize_t</code> only strictly supports -1). </p>

</div>
</div>
<a id="ab17d2f1e9eed6d6c7796d44417880db2" name="ab17d2f1e9eed6d6c7796d44417880db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17d2f1e9eed6d6c7796d44417880db2">&#9670;&#160;</a></span>VLINK_BAD_EULER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::VLINK_BAD_EULER = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has either (i) accumulated too high a genus (so when its punctures are filled the Euler characteristic will be too low), or has (ii) been closed off with too low a genus (so its final Euler characteristic is too high). </p>

</div>
</div>
<a id="aa6e5ac84a096612d71e4ddc2cea763a3" name="aa6e5ac84a096612d71e4ddc2cea763a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5ac84a096612d71e4ddc2cea763a3">&#9670;&#160;</a></span>VLINK_CLOSED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::VLINK_CLOSED = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingpermsearcher3_8h.html">gluingpermsearcher3.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
