<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::NormalHypersurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalHypersurface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::NormalHypersurface Class Reference<div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a single normal hypersurface in a 4-manifold triangulation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;hypersurface/normalhypersurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalHypersurface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalHypersurface.png" usemap="#regina::NormalHypersurface_map" alt=""/>
  <map id="regina::NormalHypersurface_map" name="regina::NormalHypersurface_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; NormalHypersurface &gt;" shape="rect" coords="0,56,269,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalHypersurface, false &gt;" shape="rect" coords="0,0,269,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e9526737af0cb5a5359a4b2ff4c42fb" id="r_a9e9526737af0cb5a5359a4b2ff4c42fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e9526737af0cb5a5359a4b2ff4c42fb">NormalHypersurface</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;)=default</td></tr>
<tr class="memdesc:a9e9526737af0cb5a5359a4b2ff4c42fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal hypersurface.  <br /></td></tr>
<tr class="separator:a9e9526737af0cb5a5359a4b2ff4c42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3d68c7234546f77c2bde2ba88ebcd" id="r_ac1b3d68c7234546f77c2bde2ba88ebcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b3d68c7234546f77c2bde2ba88ebcd">NormalHypersurface</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;src, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;<a class="el" href="#ac6559f6224c63ac9ab10a682be8f0c20">triangulation</a>)</td></tr>
<tr class="memdesc:ac1b3d68c7234546f77c2bde2ba88ebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal hypersurface, but relocated to the given triangulation.  <br /></td></tr>
<tr class="separator:ac1b3d68c7234546f77c2bde2ba88ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78248d10707c26c430a607db8e51769" id="r_af78248d10707c26c430a607db8e51769"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af78248d10707c26c430a607db8e51769">NormalHypersurface</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;src, const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;<a class="el" href="#ac6559f6224c63ac9ab10a682be8f0c20">triangulation</a>)</td></tr>
<tr class="memdesc:af78248d10707c26c430a607db8e51769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal hypersurface, but relocated to the given triangulation.  <br /></td></tr>
<tr class="separator:af78248d10707c26c430a607db8e51769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ade394077a8fd53ac1408c001039d" id="r_ab56ade394077a8fd53ac1408c001039d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab56ade394077a8fd53ac1408c001039d">NormalHypersurface</a> (<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ab56ade394077a8fd53ac1408c001039d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given hypersurface into this new normal hypersurface.  <br /></td></tr>
<tr class="separator:ab56ade394077a8fd53ac1408c001039d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea32e694f88c8c18332813d7b080634c" id="r_aea32e694f88c8c18332813d7b080634c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea32e694f88c8c18332813d7b080634c">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;triang)</td></tr>
<tr class="memdesc:aea32e694f88c8c18332813d7b080634c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the empty hypersurface within the given triangulation.  <br /></td></tr>
<tr class="separator:aea32e694f88c8c18332813d7b080634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ab2d5d5f7749fc3c7d9d5ce7890a6b" id="r_a59ab2d5d5f7749fc3c7d9d5ce7890a6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59ab2d5d5f7749fc3c7d9d5ce7890a6b">NormalHypersurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;triang)</td></tr>
<tr class="memdesc:a59ab2d5d5f7749fc3c7d9d5ce7890a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the empty hypersurface within the given triangulation.  <br /></td></tr>
<tr class="separator:a59ab2d5d5f7749fc3c7d9d5ce7890a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b653cfb6e5d61dfa63d9cbf6dc71b" id="r_a719b653cfb6e5d61dfa63d9cbf6dc71b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a719b653cfb6e5d61dfa63d9cbf6dc71b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a719b653cfb6e5d61dfa63d9cbf6dc71b">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;triang, <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> enc, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:a719b653cfb6e5d61dfa63d9cbf6dc71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:a719b653cfb6e5d61dfa63d9cbf6dc71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed2ca497adf1def023b827ff70a4ec" id="r_ae9ed2ca497adf1def023b827ff70a4ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ed2ca497adf1def023b827ff70a4ec">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;triang, <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> enc, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:ae9ed2ca497adf1def023b827ff70a4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:ae9ed2ca497adf1def023b827ff70a4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57bf5cdf15a134b76bb03b3050c14d" id="r_aed57bf5cdf15a134b76bb03b3050c14d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aed57bf5cdf15a134b76bb03b3050c14d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed57bf5cdf15a134b76bb03b3050c14d">NormalHypersurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;triang, <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> enc, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:aed57bf5cdf15a134b76bb03b3050c14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:aed57bf5cdf15a134b76bb03b3050c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248dc15241dc0e04e5253c92044d8147" id="r_a248dc15241dc0e04e5253c92044d8147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248dc15241dc0e04e5253c92044d8147">NormalHypersurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;triang, <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> enc, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:a248dc15241dc0e04e5253c92044d8147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:a248dc15241dc0e04e5253c92044d8147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6630148f48e91724a8ab5fa4901a3ec" id="r_af6630148f48e91724a8ab5fa4901a3ec"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af6630148f48e91724a8ab5fa4901a3ec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6630148f48e91724a8ab5fa4901a3ec">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:af6630148f48e91724a8ab5fa4901a3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:af6630148f48e91724a8ab5fa4901a3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692346272e3f4829e45f20b84f6b6e9a" id="r_a692346272e3f4829e45f20b84f6b6e9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692346272e3f4829e45f20b84f6b6e9a">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:a692346272e3f4829e45f20b84f6b6e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:a692346272e3f4829e45f20b84f6b6e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36b0caa56725128a009f5f009dc3c41" id="r_ae36b0caa56725128a009f5f009dc3c41"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae36b0caa56725128a009f5f009dc3c41"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae36b0caa56725128a009f5f009dc3c41">NormalHypersurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:ae36b0caa56725128a009f5f009dc3c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:ae36b0caa56725128a009f5f009dc3c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab492b84845125970836918e28e6071ed" id="r_ab492b84845125970836918e28e6071ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab492b84845125970836918e28e6071ed">NormalHypersurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>)</td></tr>
<tr class="memdesc:ab492b84845125970836918e28e6071ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:ab492b84845125970836918e28e6071ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fda319e4d0872763b0690ee6b901a60" id="r_a9fda319e4d0872763b0690ee6b901a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fda319e4d0872763b0690ee6b901a60">operator=</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;)=default</td></tr>
<tr class="memdesc:a9fda319e4d0872763b0690ee6b901a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given normal hypersurface.  <br /></td></tr>
<tr class="separator:a9fda319e4d0872763b0690ee6b901a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59896902fd80ebacf1fd7288e9983a30" id="r_a59896902fd80ebacf1fd7288e9983a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59896902fd80ebacf1fd7288e9983a30">operator=</a> (<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a59896902fd80ebacf1fd7288e9983a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given normal hypersurface to this hypersurface.  <br /></td></tr>
<tr class="separator:a59896902fd80ebacf1fd7288e9983a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac6a49d6ebb8426d9129b48817c82e" id="r_a96ac6a49d6ebb8426d9129b48817c82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96ac6a49d6ebb8426d9129b48817c82e">swap</a> (<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a96ac6a49d6ebb8426d9129b48817c82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given normal hypersurface.  <br /></td></tr>
<tr class="separator:a96ac6a49d6ebb8426d9129b48817c82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b4836a74ad23132cce3417c098c3a" id="r_a047b4836a74ad23132cce3417c098c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047b4836a74ad23132cce3417c098c3a">doubleHypersurface</a> () const</td></tr>
<tr class="memdesc:a047b4836a74ad23132cce3417c098c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the double of this hypersurface.  <br /></td></tr>
<tr class="separator:a047b4836a74ad23132cce3417c098c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fbd77dc01ae05f976aa8cda39b9eb" id="r_af57fbd77dc01ae05f976aa8cda39b9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af57fbd77dc01ae05f976aa8cda39b9eb">operator+</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;rhs) const</td></tr>
<tr class="memdesc:af57fbd77dc01ae05f976aa8cda39b9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of this and the given hypersurface.  <br /></td></tr>
<tr class="separator:af57fbd77dc01ae05f976aa8cda39b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb00a44731aa8f7a9e4749aa3c61e28" id="r_a2eb00a44731aa8f7a9e4749aa3c61e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb00a44731aa8f7a9e4749aa3c61e28">operator*</a> (const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;coeff) const</td></tr>
<tr class="memdesc:a2eb00a44731aa8f7a9e4749aa3c61e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given integer multiple of this hypersurface.  <br /></td></tr>
<tr class="separator:a2eb00a44731aa8f7a9e4749aa3c61e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da4318554a609a1a79b0c252cd61d98" id="r_a3da4318554a609a1a79b0c252cd61d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3da4318554a609a1a79b0c252cd61d98">operator*=</a> (const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;coeff)</td></tr>
<tr class="memdesc:a3da4318554a609a1a79b0c252cd61d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this hypersurface into the given integer multiple of itself.  <br /></td></tr>
<tr class="separator:a3da4318554a609a1a79b0c252cd61d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df9586927e777b3964eead71110c198" id="r_a3df9586927e777b3964eead71110c198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df9586927e777b3964eead71110c198">scaleDown</a> ()</td></tr>
<tr class="memdesc:a3df9586927e777b3964eead71110c198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this hypersurface into its smallest positive rational multiple with integer coordinates.  <br /></td></tr>
<tr class="separator:a3df9586927e777b3964eead71110c198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e571077474b0899732e60f6c3c393df" id="r_a5e571077474b0899732e60f6c3c393df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e571077474b0899732e60f6c3c393df">tetrahedra</a> (size_t pentIndex, int vertex) const</td></tr>
<tr class="memdesc:a5e571077474b0899732e60f6c3c393df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tetrahedron pieces of the given type in this normal hypersurface.  <br /></td></tr>
<tr class="separator:a5e571077474b0899732e60f6c3c393df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34268af846d03f4016a3a6134e6f65d5" id="r_a34268af846d03f4016a3a6134e6f65d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34268af846d03f4016a3a6134e6f65d5">prisms</a> (size_t pentIndex, int prismType) const</td></tr>
<tr class="memdesc:a34268af846d03f4016a3a6134e6f65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of prism pieces of the given type in this normal hypersurface.  <br /></td></tr>
<tr class="separator:a34268af846d03f4016a3a6134e6f65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0661d930754b6c681e6a23595a36476" id="r_ae0661d930754b6c681e6a23595a36476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0661d930754b6c681e6a23595a36476">edgeWeight</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:ae0661d930754b6c681e6a23595a36476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times this normal hypersurface crosses the given edge.  <br /></td></tr>
<tr class="separator:ae0661d930754b6c681e6a23595a36476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6559f6224c63ac9ab10a682be8f0c20" id="r_ac6559f6224c63ac9ab10a682be8f0c20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6559f6224c63ac9ab10a682be8f0c20">triangulation</a> () const</td></tr>
<tr class="memdesc:ac6559f6224c63ac9ab10a682be8f0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation in which this normal hypersurface resides.  <br /></td></tr>
<tr class="separator:ac6559f6224c63ac9ab10a682be8f0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aca89d84f22f361520c25277521b9d9" id="r_a6aca89d84f22f361520c25277521b9d9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aca89d84f22f361520c25277521b9d9">name</a> () const</td></tr>
<tr class="memdesc:a6aca89d84f22f361520c25277521b9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name associated with this normal hypersurface.  <br /></td></tr>
<tr class="separator:a6aca89d84f22f361520c25277521b9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdf3ef9c9407d10c5eabc69671207f5" id="r_a1cdf3ef9c9407d10c5eabc69671207f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cdf3ef9c9407d10c5eabc69671207f5">setName</a> (const std::string &amp;<a class="el" href="#a6aca89d84f22f361520c25277521b9d9">name</a>)</td></tr>
<tr class="memdesc:a1cdf3ef9c9407d10c5eabc69671207f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal hypersurface.  <br /></td></tr>
<tr class="separator:a1cdf3ef9c9407d10c5eabc69671207f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac169d0bb98e129d7437ca45b97054b47" id="r_ac169d0bb98e129d7437ca45b97054b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac169d0bb98e129d7437ca45b97054b47">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac169d0bb98e129d7437ca45b97054b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates.  <br /></td></tr>
<tr class="separator:ac169d0bb98e129d7437ca45b97054b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531f769dd9c1e82d75f9d5c3be8036d7" id="r_a531f769dd9c1e82d75f9d5c3be8036d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531f769dd9c1e82d75f9d5c3be8036d7">writeXMLData</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *list) const</td></tr>
<tr class="memdesc:a531f769dd9c1e82d75f9d5c3be8036d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal hypersurface and all of its properties.  <br /></td></tr>
<tr class="separator:a531f769dd9c1e82d75f9d5c3be8036d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac5d0891674f9dd46395d7099dcf6a" id="r_ae6ac5d0891674f9dd46395d7099dcf6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6ac5d0891674f9dd46395d7099dcf6a">isEmpty</a> () const</td></tr>
<tr class="memdesc:ae6ac5d0891674f9dd46395d7099dcf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is empty (has no pieces whatsoever).  <br /></td></tr>
<tr class="separator:ae6ac5d0891674f9dd46395d7099dcf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bc4b36bd5443133c33aed2b02177e1" id="r_a49bc4b36bd5443133c33aed2b02177e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49bc4b36bd5443133c33aed2b02177e1">isCompact</a> () const</td></tr>
<tr class="memdesc:a49bc4b36bd5443133c33aed2b02177e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is compact (has finitely many pieces).  <br /></td></tr>
<tr class="separator:a49bc4b36bd5443133c33aed2b02177e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99506625435eadb56c06968221623935" id="r_a99506625435eadb56c06968221623935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99506625435eadb56c06968221623935">isOrientable</a> () const</td></tr>
<tr class="memdesc:a99506625435eadb56c06968221623935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this hypersurface is orientable.  <br /></td></tr>
<tr class="separator:a99506625435eadb56c06968221623935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad578abb2b7507a4bdac7cf8427389e0" id="r_aad578abb2b7507a4bdac7cf8427389e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad578abb2b7507a4bdac7cf8427389e0">isTwoSided</a> () const</td></tr>
<tr class="memdesc:aad578abb2b7507a4bdac7cf8427389e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this hypersurface is two-sided.  <br /></td></tr>
<tr class="separator:aad578abb2b7507a4bdac7cf8427389e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770ee1870e1ceb28a2b577356a4be33d" id="r_a770ee1870e1ceb28a2b577356a4be33d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a770ee1870e1ceb28a2b577356a4be33d">isConnected</a> () const</td></tr>
<tr class="memdesc:a770ee1870e1ceb28a2b577356a4be33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this hypersurface is connected.  <br /></td></tr>
<tr class="separator:a770ee1870e1ceb28a2b577356a4be33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd89e9ad52cd1934f435ea1ecfae1ed" id="r_a8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fd89e9ad52cd1934f435ea1ecfae1ed">hasRealBoundary</a> () const</td></tr>
<tr class="memdesc:a8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation.  <br /></td></tr>
<tr class="separator:a8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ced3478b08bde5ad883ef77724420" id="r_a842ced3478b08bde5ad883ef77724420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842ced3478b08bde5ad883ef77724420">isVertexLinking</a> () const</td></tr>
<tr class="memdesc:a842ced3478b08bde5ad883ef77724420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this hypersurface is vertex linking.  <br /></td></tr>
<tr class="separator:a842ced3478b08bde5ad883ef77724420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8a721415302c5101e5064db14b153" id="r_a54e8a721415302c5101e5064db14b153"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gaa2d0c69ce4cea268f94f93dbbcfbc21d">Vertex</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54e8a721415302c5101e5064db14b153">isVertexLink</a> () const</td></tr>
<tr class="memdesc:a54e8a721415302c5101e5064db14b153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the link of a single vertex.  <br /></td></tr>
<tr class="separator:a54e8a721415302c5101e5064db14b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8126f6c44dc69ca6e66fd6045313bd7b" id="r_a8126f6c44dc69ca6e66fd6045313bd7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8126f6c44dc69ca6e66fd6045313bd7b">isThinEdgeLink</a> () const</td></tr>
<tr class="memdesc:a8126f6c44dc69ca6e66fd6045313bd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single edge.  <br /></td></tr>
<tr class="separator:a8126f6c44dc69ca6e66fd6045313bd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf80e36cdf49f440fe2edc51629a0d2f" id="r_abf80e36cdf49f440fe2edc51629a0d2f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 4 &gt; * &gt;, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf80e36cdf49f440fe2edc51629a0d2f">isNormalEdgeLink</a> () const</td></tr>
<tr class="memdesc:abf80e36cdf49f440fe2edc51629a0d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single edge.  <br /></td></tr>
<tr class="separator:abf80e36cdf49f440fe2edc51629a0d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a84a39ecb0f34417d71150c8685daac" id="r_a4a84a39ecb0f34417d71150c8685daac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; *, const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a84a39ecb0f34417d71150c8685daac">isThinTriangleLink</a> () const</td></tr>
<tr class="memdesc:a4a84a39ecb0f34417d71150c8685daac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single triangle.  <br /></td></tr>
<tr class="separator:a4a84a39ecb0f34417d71150c8685daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf94a5fa6b52b19ae4cba13388bc1568" id="r_acf94a5fa6b52b19ae4cba13388bc1568"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; * &gt;, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf94a5fa6b52b19ae4cba13388bc1568">isNormalTriangleLink</a> () const</td></tr>
<tr class="memdesc:acf94a5fa6b52b19ae4cba13388bc1568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single triangle.  <br /></td></tr>
<tr class="separator:acf94a5fa6b52b19ae4cba13388bc1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c37c760e13e7ad570de4fdf2709494" id="r_ae0c37c760e13e7ad570de4fdf2709494"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; *, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c37c760e13e7ad570de4fdf2709494">isThinTetrahedronLink</a> () const</td></tr>
<tr class="memdesc:ae0c37c760e13e7ad570de4fdf2709494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single tetrahedron.  <br /></td></tr>
<tr class="separator:ae0c37c760e13e7ad570de4fdf2709494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245e3c55ac9506efb2fc2289940b54b" id="r_ac245e3c55ac9506efb2fc2289940b54b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; * &gt;, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac245e3c55ac9506efb2fc2289940b54b">isNormalTetrahedronLink</a> () const</td></tr>
<tr class="memdesc:ac245e3c55ac9506efb2fc2289940b54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single tetrahedron.  <br /></td></tr>
<tr class="separator:ac245e3c55ac9506efb2fc2289940b54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cfddf3340d89bc8e5c8414e3b2d17a" id="r_af5cfddf3340d89bc8e5c8414e3b2d17a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cfddf3340d89bc8e5c8414e3b2d17a">homology</a> () const</td></tr>
<tr class="memdesc:af5cfddf3340d89bc8e5c8414e3b2d17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group of this hypersurface.  <br /></td></tr>
<tr class="separator:af5cfddf3340d89bc8e5c8414e3b2d17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49d406024a72fda5fc843e087668f2" id="r_a1a49d406024a72fda5fc843e087668f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a49d406024a72fda5fc843e087668f2">triangulate</a> () const</td></tr>
<tr class="memdesc:a1a49d406024a72fda5fc843e087668f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-manifold triangulation describing this normal hypersurface.  <br /></td></tr>
<tr class="separator:a1a49d406024a72fda5fc843e087668f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5655fa15fa8e40dd2170a9b805d3bea0" id="r_a5655fa15fa8e40dd2170a9b805d3bea0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5655fa15fa8e40dd2170a9b805d3bea0">operator==</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const</td></tr>
<tr class="memdesc:a5655fa15fa8e40dd2170a9b805d3bea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface in fact represent the same normal hypersurface.  <br /></td></tr>
<tr class="separator:a5655fa15fa8e40dd2170a9b805d3bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cedb6b664a561fd2acfac42fc7f50d" id="r_a51cedb6b664a561fd2acfac42fc7f50d"><td class="memItemLeft" align="right" valign="top">std::weak_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51cedb6b664a561fd2acfac42fc7f50d">operator&lt;=&gt;</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a51cedb6b664a561fd2acfac42fc7f50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given surface under a total ordering of all normal hypersurfaces.  <br /></td></tr>
<tr class="separator:a51cedb6b664a561fd2acfac42fc7f50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4f6c59a84e0cd88f91802d0524497b" id="r_afe4f6c59a84e0cd88f91802d0524497b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4f6c59a84e0cd88f91802d0524497b">embedded</a> () const</td></tr>
<tr class="memdesc:afe4f6c59a84e0cd88f91802d0524497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this hypersurface is embedded.  <br /></td></tr>
<tr class="separator:afe4f6c59a84e0cd88f91802d0524497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a7a0a235aec8da73213bbf1934aa41" id="r_aa4a7a0a235aec8da73213bbf1934aa41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a7a0a235aec8da73213bbf1934aa41">locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const</td></tr>
<tr class="memdesc:aa4a7a0a235aec8da73213bbf1934aa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface are locally compatible.  <br /></td></tr>
<tr class="separator:aa4a7a0a235aec8da73213bbf1934aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1de0b691babc0f5e57cada22fdfb8e" id="r_add1de0b691babc0f5e57cada22fdfb8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a> () const</td></tr>
<tr class="memdesc:add1de0b691babc0f5e57cada22fdfb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the integer vector that Regina uses internally to represent this hypersurface.  <br /></td></tr>
<tr class="separator:add1de0b691babc0f5e57cada22fdfb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b5a8ff7934b6b0c4f7db6338fa29fd" id="r_af7b5a8ff7934b6b0c4f7db6338fa29fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b5a8ff7934b6b0c4f7db6338fa29fd">encoding</a> () const</td></tr>
<tr class="memdesc:af7b5a8ff7934b6b0c4f7db6338fa29fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific integer vector encoding that this hypersurface uses internally.  <br /></td></tr>
<tr class="separator:af7b5a8ff7934b6b0c4f7db6338fa29fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac04478970c45ff019913788cb0da9202" id="r_ac04478970c45ff019913788cb0da9202"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04478970c45ff019913788cb0da9202">reconstructTetrahedra</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;tri, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;<a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e">vector</a>, <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> enc)</td></tr>
<tr class="memdesc:ac04478970c45ff019913788cb0da9202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the tetrahedron coordinates in the given integer vector.  <br /></td></tr>
<tr class="separator:ac04478970c45ff019913788cb0da9202"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad4c022a3694a8d086bc43ad3c0cfa746" id="r_ad4c022a3694a8d086bc43ad3c0cfa746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4c022a3694a8d086bc43ad3c0cfa746">enc_</a></td></tr>
<tr class="memdesc:ad4c022a3694a8d086bc43ad3c0cfa746"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specific encoding of a normal hypersurface used by the coordinate vector.  <br /></td></tr>
<tr class="separator:ad4c022a3694a8d086bc43ad3c0cfa746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d605360542560b5f5c7ff09e68d15a" id="r_a74d605360542560b5f5c7ff09e68d15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d605360542560b5f5c7ff09e68d15a">vector_</a></td></tr>
<tr class="memdesc:a74d605360542560b5f5c7ff09e68d15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal hypersurface.  <br /></td></tr>
<tr class="separator:a74d605360542560b5f5c7ff09e68d15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc47eb2a88a13593faf7b83596126ea" id="r_a6dc47eb2a88a13593faf7b83596126ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dc47eb2a88a13593faf7b83596126ea">triangulation_</a></td></tr>
<tr class="memdesc:a6dc47eb2a88a13593faf7b83596126ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal hypersurface resides.  <br /></td></tr>
<tr class="separator:a6dc47eb2a88a13593faf7b83596126ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b0370203eda2d9b07e3c751d81e76" id="r_a935b0370203eda2d9b07e3c751d81e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935b0370203eda2d9b07e3c751d81e76">name_</a></td></tr>
<tr class="memdesc:a935b0370203eda2d9b07e3c751d81e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this hypersurface.  <br /></td></tr>
<tr class="separator:a935b0370203eda2d9b07e3c751d81e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327f6f657e624dacdcfd3274f5b4e392" id="r_a327f6f657e624dacdcfd3274f5b4e392"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327f6f657e624dacdcfd3274f5b4e392">orientable_</a></td></tr>
<tr class="memdesc:a327f6f657e624dacdcfd3274f5b4e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface orientable? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:a327f6f657e624dacdcfd3274f5b4e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e21b4061791f5e685080aea2be20d" id="r_a8e2e21b4061791f5e685080aea2be20d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e2e21b4061791f5e685080aea2be20d">twoSided_</a></td></tr>
<tr class="memdesc:a8e2e21b4061791f5e685080aea2be20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface two-sided? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:a8e2e21b4061791f5e685080aea2be20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52667613c30ab62834f69a01cb683cb2" id="r_a52667613c30ab62834f69a01cb683cb2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52667613c30ab62834f69a01cb683cb2">connected_</a></td></tr>
<tr class="memdesc:a52667613c30ab62834f69a01cb683cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface connected? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:a52667613c30ab62834f69a01cb683cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a2a4777c8e85e04d8310f8ea317264" id="r_af5a2a4777c8e85e04d8310f8ea317264"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a2a4777c8e85e04d8310f8ea317264">realBoundary_</a></td></tr>
<tr class="memdesc:af5a2a4777c8e85e04d8310f8ea317264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this hypersurface have real boundary (i.e.  <br /></td></tr>
<tr class="separator:af5a2a4777c8e85e04d8310f8ea317264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f78b7b54fe91a29227df79cf7c5467" id="r_a52f78b7b54fe91a29227df79cf7c5467"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f78b7b54fe91a29227df79cf7c5467">compact_</a></td></tr>
<tr class="memdesc:a52f78b7b54fe91a29227df79cf7c5467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface compact (i.e., does it only contain finitely many pieces)? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:a52f78b7b54fe91a29227df79cf7c5467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead6ad353e200887cf8b247293fe08d7" id="r_aead6ad353e200887cf8b247293fe08d7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead6ad353e200887cf8b247293fe08d7">H1_</a></td></tr>
<tr class="memdesc:aead6ad353e200887cf8b247293fe08d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">First homology group of the hypersurface.  <br /></td></tr>
<tr class="separator:aead6ad353e200887cf8b247293fe08d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960bb89eb398ccc700fc93be94e6613" id="r_a7960bb89eb398ccc700fc93be94e6613"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7960bb89eb398ccc700fc93be94e6613">linkOf_</a> { 0 }</td></tr>
<tr class="memdesc:a7960bb89eb398ccc700fc93be94e6613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which dimensions of face a positive rational multiple of this hypersurface is a thin or normalised link of.  <br /></td></tr>
<tr class="separator:a7960bb89eb398ccc700fc93be94e6613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad51ed54e8b4d8d41dfdfa82496be1ee" id="r_aad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memItemLeft" align="right" valign="top"><a id="aad51ed54e8b4d8d41dfdfa82496be1ee" name="aad51ed54e8b4d8d41dfdfa82496be1ee"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalHypersurfaceReader</b></td></tr>
<tr class="separator:aad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a single normal hypersurface in a 4-manifold triangulation. </p>
<p>The normal hypersurface is described internally by an integer vector (discussed in more detail below). Since different hypersurfaces may use different vector encodings, you should not rely on the raw vector entries unless absolutely necessary. Instead, the query routines such as <a class="el" href="#a5e571077474b0899732e60f6c3c393df" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">tetrahedra()</a>, <a class="el" href="#a34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">prisms()</a>, <a class="el" href="#ae0661d930754b6c681e6a23595a36476" title="Returns the number of times this normal hypersurface crosses the given edge.">edgeWeight()</a> and so on are independent of the underlying vector encoding being used.</p>
<p>Note that non-compact hypersurfaces (surfaces with infinitely many pieces) are allowed; in these cases, the corresponding coordinate lookup routines will return <a class="el" href="classregina_1_1IntegerBase.html#a127260b6be26c7f4600b12268e86f73c" title="Globally available infinity.">LargeInteger::infinity</a> where appropriate.</p>
<p>Since Regina 7.0, you can modify or even destroy the original triangulation that was used to create this normal hypersurface. If you do, then this normal hypersurface will automatically make a private copy of the original triangulation as an ongoing reference. Different normal hypersurfaces can all share the same private copy, so this is not an expensive process.</p>
<p>Internally, a normal hypersurface is represented by a Vector&lt;LargeInteger&gt; (possibly using a different coordinate system from the one in which the hypersurfaces were originally enumerated). This contains a block of coordinates for each pentachoron, in order from the first pentachoron to the last. Each block begins with five tetrahedron coordinates (always), followed by ten prisms coordinates (always) - unlike the 3-dimensional world, there are currently no optional coordinates that might or might not be stored (though this could change in future versions of Regina). Therefore the vector that is stored will always have length 15<em>n</em>, where <em>n</em> is the number of pentachora in the underlying triangulation.</p>
<p>When adding support for a new coordinate system:</p>
<ul>
<li>The file <a class="el" href="hypercoords_8h.html" title="Defines constants for normal hypersurface coordinate systems.">hypercoords.h</a> must be updated. This includes a new enum value for HyperCoords, a new case for the <a class="el" href="classregina_1_1HyperEncoding.html" title="Indicates precisely how a normal hypersurface within a 4-manifold triangulation is encoded by an inte...">HyperEncoding</a> constructor, and new cases for the functions in <a class="el" href="classregina_1_1HyperInfo.html" title="A class used to query general information about different normal hypersurface coordinate systems.">HyperInfo</a>. Do not forget to update the python bindings for HyperCoords also.</li>
<li>The global routines <a class="el" href="group__hypersurface.html#ga0736934b2b18b263665b5e6ef0f4eb9f" title="Generates the validity constraints representing the condition that normal hypersurfaces be embedded.">makeEmbeddedConstraints()</a> and <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> should be updated to incorporate the new coordinate system.</li>
</ul>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e9526737af0cb5a5359a4b2ff4c42fb" name="a9e9526737af0cb5a5359a4b2ff4c42fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9526737af0cb5a5359a4b2ff4c42fb">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal hypersurface. </p>

</div>
</div>
<a id="ac1b3d68c7234546f77c2bde2ba88ebcd" name="ac1b3d68c7234546f77c2bde2ba88ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b3d68c7234546f77c2bde2ba88ebcd">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal hypersurface, but relocated to the given triangulation. </p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal hypersurface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is either the same as, or is combinatorially identical to, the triangulation in which <em>src</em> resides.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal hypersurface to copy. </td></tr>
    <tr><td class="paramname">triangulation</td><td>the triangulation in which this new hypersurface will reside. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af78248d10707c26c430a607db8e51769" name="af78248d10707c26c430a607db8e51769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78248d10707c26c430a607db8e51769">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal hypersurface, but relocated to the given triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is either the same as, or is combinatorially identical to, the triangulation in which <em>src</em> resides.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal hypersurface to copy. </td></tr>
    <tr><td class="paramname">triangulation</td><td>a snapshot, frozen in time, of the triangulation in which this new hypersurface will reside. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab56ade394077a8fd53ac1408c001039d" name="ab56ade394077a8fd53ac1408c001039d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ade394077a8fd53ac1408c001039d">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given hypersurface into this new normal hypersurface. </p>
<p>This is a fast (constant time) operation.</p>
<p>The hypersurface that is passed will no longer be usable. </p>

</div>
</div>
<a id="aea32e694f88c8c18332813d7b080634c" name="aea32e694f88c8c18332813d7b080634c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea32e694f88c8c18332813d7b080634c">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the empty hypersurface within the given triangulation. </p>
<p>All normal coordinates will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59ab2d5d5f7749fc3c7d9d5ce7890a6b" name="a59ab2d5d5f7749fc3c7d9d5ce7890a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ab2d5d5f7749fc3c7d9d5ce7890a6b">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the empty hypersurface within the given triangulation. </p>
<p>All normal coordinates will be zero.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal hypersurface resides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a719b653cfb6e5d61dfa63d9cbf6dc71b" name="a719b653cfb6e5d61dfa63d9cbf6dc71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b653cfb6e5d61dfa63d9cbf6dc71b">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this hypersurface will keep the given encoding: <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal hypersurface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The supported types for the template parameter <em>U</em> are <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> and <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>. You may also, if you prefer, pass <em>vector</em> as a Python list of integers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal hypersurface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ed2ca497adf1def023b827ff70a4ec" name="ae9ed2ca497adf1def023b827ff70a4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed2ca497adf1def023b827ff70a4ec">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this hypersurface will keep the given encoding: <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal hypersurface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal hypersurface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed57bf5cdf15a134b76bb03b3050c14d" name="aed57bf5cdf15a134b76bb03b3050c14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed57bf5cdf15a134b76bb03b3050c14d">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this hypersurface will keep the given encoding: <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal hypersurface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a248dc15241dc0e04e5253c92044d8147" name="a248dc15241dc0e04e5253c92044d8147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248dc15241dc0e04e5253c92044d8147">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this hypersurface will keep the given encoding: <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation and copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal hypersurface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6630148f48e91724a8ab5fa4901a3ec" name="af6630148f48e91724a8ab5fa4901a3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6630148f48e91724a8ab5fa4901a3ec">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this hypersurface uses the vector encoding described by <code>HyperEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal hypersurface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this hypersurface will use <code>HyperEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal hypersurface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the encoding <code>HyperEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The supported types for the template parameter <em>U</em> are <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> and <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>. You may also, if you prefer, pass <em>vector</em> as a Python list of integers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692346272e3f4829e45f20b84f6b6e9a" name="a692346272e3f4829e45f20b84f6b6e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692346272e3f4829e45f20b84f6b6e9a">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this hypersurface uses the vector encoding described by <code>HyperEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal hypersurface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this hypersurface will use <code>HyperEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal hypersurface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the encoding <code>HyperEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae36b0caa56725128a009f5f009dc3c41" name="ae36b0caa56725128a009f5f009dc3c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36b0caa56725128a009f5f009dc3c41">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this hypersurface uses the vector encoding described by <code>HyperEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal hypersurface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this hypersurface will use <code>HyperEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the encoding <code>HyperEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab492b84845125970836918e28e6071ed" name="ab492b84845125970836918e28e6071ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab492b84845125970836918e28e6071ed">&#9670;&#160;</a></span>NormalHypersurface() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this hypersurface uses the vector encoding described by <code>HyperEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal hypersurface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this hypersurface will use <code>HyperEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include tetrahedron coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal hypersurface inside the given triangulation, using the encoding <code>HyperEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation and copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a047b4836a74ad23132cce3417c098c3a" name="a047b4836a74ad23132cce3417c098c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b4836a74ad23132cce3417c098c3a">&#9670;&#160;</a></span>doubleHypersurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> regina::NormalHypersurface::doubleHypersurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the double of this hypersurface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated</a></b></dt><dd>Normal hypersurfaces can now be multiplied by integer constants. In particular, this routine has exactly the same effect as multiplying the hypersurface by 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal hypersurface. </dd></dl>

</div>
</div>
<a id="ae0661d930754b6c681e6a23595a36476" name="ae0661d930754b6c681e6a23595a36476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0661d930754b6c681e6a23595a36476">&#9670;&#160;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalHypersurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>edgeIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times this normal hypersurface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f" title="A dimension-specific alias for countFaces&lt;1&gt;().">Triangulation&lt;4&gt;::countEdges()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

</div>
</div>
<a id="afe4f6c59a84e0cd88f91802d0524497b" name="afe4f6c59a84e0cd88f91802d0524497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4f6c59a84e0cd88f91802d0524497b">&#9670;&#160;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::embedded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this hypersurface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting prism types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is embedded. </dd></dl>

</div>
</div>
<a id="af7b5a8ff7934b6b0c4f7db6338fa29fd" name="af7b5a8ff7934b6b0c4f7db6338fa29fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b5a8ff7934b6b0c4f7db6338fa29fd">&#9670;&#160;</a></span>encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> regina::NormalHypersurface::encoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific integer vector encoding that this hypersurface uses internally. </p>
<p>This is the encoding that should be used to interpret <a class="el" href="#add1de0b691babc0f5e57cada22fdfb8e" title="Gives read-only access to the integer vector that Regina uses internally to represent this hypersurfa...">vector()</a>.</p>
<p>Note that this might differ from the encoding originally passed to the class constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>the internal vector encoding. </dd></dl>

</div>
</div>
<a id="a8fd89e9ad52cd1934f435ea1ecfae1ed" name="a8fd89e9ad52cd1934f435ea1ecfae1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd89e9ad52cd1934f435ea1ecfae1ed">&#9670;&#160;</a></span>hasRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface has real boundary. </dd></dl>

</div>
</div>
<a id="af5cfddf3340d89bc8e5c8414e3b2d17a" name="af5cfddf3340d89bc8e5c8414e3b2d17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cfddf3340d89bc8e5c8414e3b2d17a">&#9670;&#160;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::NormalHypersurface::homology </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first homology group of this hypersurface. </p>
<p>There is an important caveat regarding invalid 4-manifold triangulations. If the underlying triangulation has edge links that are not spheres, then it is possible that this normal hypersurface is not a compact 3-manifold. In such a case, this routine will compute homology in the same way as <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">Triangulation&lt;3&gt;::homology()</a> - that is, by effectively truncating ideal points of the hypersurface (which may arise where the hypersurface meets an invalid edge).</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a id="a49bc4b36bd5443133c33aed2b02177e1" name="a49bc4b36bd5443133c33aed2b02177e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bc4b36bd5443133c33aed2b02177e1">&#9670;&#160;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isCompact </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is compact (has finitely many pieces). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal hypersurface is compact. </dd></dl>

</div>
</div>
<a id="a770ee1870e1ceb28a2b577356a4be33d" name="a770ee1870e1ceb28a2b577356a4be33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770ee1870e1ceb28a2b577356a4be33d">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this hypersurface is connected. </p>
<p>For our purposes, the empty hypersurface is considered to be connected.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is connected, or <code>false</code> if this hypersurface is disconnected. </dd></dl>

</div>
</div>
<a id="ae6ac5d0891674f9dd46395d7099dcf6a" name="ae6ac5d0891674f9dd46395d7099dcf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ac5d0891674f9dd46395d7099dcf6a">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is empty (has no pieces whatsoever). </p>

</div>
</div>
<a id="abf80e36cdf49f440fe2edc51629a0d2f" name="abf80e36cdf49f440fe2edc51629a0d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf80e36cdf49f440fe2edc51629a0d2f">&#9670;&#160;</a></span>isNormalEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 4 &gt; * &gt;, unsigned &gt; regina::NormalHypersurface::isNormalEdgeLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single edge. </p>
<p>Here the phrase <em>normalised</em> link of an edge <em>e</em> means the frontier of a regular neighbourhood of <em>e</em>, converted into a normal hypersurface by expanding away from the edge using some basic normalisation moves. It could be that there is no normalisation required at all (in which case it is also a <em>thin</em> edge link). However, it could be that the normalisation process expands the hypersurface far away from the edge itself, or changes its topology, or disconnects the hypersurface, or even normalises it away to an empty hypersurface.</p>
<p>In particular, this test behaves differently from <a class="el" href="#a8126f6c44dc69ca6e66fd6045313bd7b" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinEdgeLink()</a>, which tests for thin edge links only (where no additional normalisation is required). If you are only interested in thin edge links, then you should call <a class="el" href="#a8126f6c44dc69ca6e66fd6045313bd7b" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinEdgeLink()</a>, which has much less overhead.</p>
<p>A hypersurface (or its positive rational multiple) could be the normalised link of many edges. The return value will be a pair (<em>v</em>, <em>thin</em>), where:</p>
<ul>
<li><em>v</em> is a vector containing all such edges. This will begin with the edges for which this hypersurface is a thin link, followed by the edges where normalisation was required; within each category the edges will be ordered by their index within the triangulation.</li>
<li><em>thin</em> is either 0 or 1, indicating how many edges this hypersurface is a thin link for. This uses an unsigned type, since it will often be compared to <code>v.size()</code>.</li>
</ul>
<p>If no positive rational multiple of this hypersurface is the normalised link of any edge, then <em>link</em> will be 0 and <em>v</em> will be the empty vector.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the edge(s) linked by a positive rational multiple of this hypersurface and an integer indicating how many of these links are thin, as described above. </dd></dl>

</div>
</div>
<a id="ac245e3c55ac9506efb2fc2289940b54b" name="ac245e3c55ac9506efb2fc2289940b54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac245e3c55ac9506efb2fc2289940b54b">&#9670;&#160;</a></span>isNormalTetrahedronLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; * &gt;, unsigned &gt; regina::NormalHypersurface::isNormalTetrahedronLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single tetrahedron. </p>
<p>Here the phrase <em>normalised</em> link of a tetrahedron <em>t</em> means the frontier of a regular neighbourhood of <em>t</em>, converted into a normal hypersurface by expanding away from the tetrahedron using some basic normalisation moves. It could be that there is no normalisation required at all (in which case it is also a <em>thin</em> tetrahedron link). However, it could be that the normalisation process expands the hypersurface far away from the tetrahedron itself, or changes its topology, or disconnects the hypersurface, or even normalises it away to an empty hypersurface.</p>
<p>In particular, this test behaves differently from <a class="el" href="#ae0c37c760e13e7ad570de4fdf2709494" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTetrahedronLink()</a>, which tests for thin tetrahedron links only (where no additional normalisation is required). Unlike the tests for edge links, the routines <a class="el" href="#ae0c37c760e13e7ad570de4fdf2709494" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTetrahedronLink()</a> and <a class="el" href="#ac245e3c55ac9506efb2fc2289940b54b" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTetrahedronLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A hypersurface (or its positive rational multiple) could be the normalised link of many tetrahedra. The return value will be a pair (<em>v</em>, <em>thin</em>), where:</p>
<ul>
<li><em>v</em> is a vector containing all such tetrahedra. This will begin with the tetrahedra for which this hypersurface is a thin link, followed by the tetrahedra where normalisation was required; within each category the tetrahedra will be ordered by their index within the triangulation.</li>
<li><em>thin</em> is either 0, 1 or 2, indicating how many tetrahedra this hypersurface is a thin link for. This uses an unsigned type, since it will often be compared to <code>v.size()</code>.</li>
</ul>
<p>If no positive rational multiple of this hypersurface is the normalised link of any tetrahedron, then <em>link</em> will be 0 and <em>v</em> will be the empty vector.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the tetrahedra linked by a positive rational multiple of this hypersurface and an integer indicating how many of these links are thin, as described above. </dd></dl>

</div>
</div>
<a id="acf94a5fa6b52b19ae4cba13388bc1568" name="acf94a5fa6b52b19ae4cba13388bc1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf94a5fa6b52b19ae4cba13388bc1568">&#9670;&#160;</a></span>isNormalTriangleLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; * &gt;, unsigned &gt; regina::NormalHypersurface::isNormalTriangleLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the normalised link of a single triangle. </p>
<p>Here the phrase <em>normalised</em> link of a triangle <em>t</em> means the frontier of a regular neighbourhood of <em>t</em>, converted into a normal hypersurface by expanding away from the triangle using some basic normalisation moves. It could be that there is no normalisation required at all (in which case it is also a <em>thin</em> triangle link). However, it could be that the normalisation process expands the hypersurface far away from the triangle itself, or changes its topology, or disconnects the hypersurface, or even normalises it away to an empty hypersurface.</p>
<p>In particular, this test behaves differently from <a class="el" href="#a4a84a39ecb0f34417d71150c8685daac" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTriangleLink()</a>, which tests for thin triangle links only (where no additional normalisation is required). Unlike the tests for edge links, the routines <a class="el" href="#a4a84a39ecb0f34417d71150c8685daac" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTriangleLink()</a> and <a class="el" href="#acf94a5fa6b52b19ae4cba13388bc1568" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTriangleLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A hypersurface (or its positive rational multiple) could be the normalised link of many triangles. The return value will be a pair (<em>v</em>, <em>thin</em>), where:</p>
<ul>
<li><em>v</em> is a vector containing all such triangles. This will begin with the triangles for which this hypersurface is a thin link, followed by the triangles where normalisation was required; within each category the triangles will be ordered by their index within the triangulation.</li>
<li><em>thin</em> is either 0, 1 or 2, indicating how many triangles this hypersurface is a thin link for. This uses an unsigned type, since it will often be compared to <code>v.size()</code>.</li>
</ul>
<p>If no positive rational multiple of this hypersurface is the normalised link of any triangle, then <em>link</em> will be 0 and <em>v</em> will be the empty vector.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the triangle(s) linked by a positive rational multiple of this hypersurface and an integer indicating how many of these links are thin, as described above. </dd></dl>

</div>
</div>
<a id="a99506625435eadb56c06968221623935" name="a99506625435eadb56c06968221623935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99506625435eadb56c06968221623935">&#9670;&#160;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this hypersurface is orientable. </p>
<p>For our purposes, the empty hypersurface is considered to be orientable.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is orientable, or <code>false</code> if this hypersurface is non-orientable. </dd></dl>

</div>
</div>
<a id="a8126f6c44dc69ca6e66fd6045313bd7b" name="a8126f6c44dc69ca6e66fd6045313bd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8126f6c44dc69ca6e66fd6045313bd7b">&#9670;&#160;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 4 &gt; * regina::NormalHypersurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single edge. </p>
<p>Here a <em>thin</em> edge link is a normal hypersurface which appears naturally as the frontier of a regular neighbourhood of an edge, with no need for any further normalisation.</p>
<p>This behaves differently from <a class="el" href="#abf80e36cdf49f440fe2edc51629a0d2f" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalEdgeLink()</a>, which tests for a <em>normalised</em> edge link (which could end up far away from the edge, or could be normalised into a hypersurface with different topology, or could even be normalised away to nothing). Although <a class="el" href="#abf80e36cdf49f440fe2edc51629a0d2f" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalEdgeLink()</a> will also indicate thin edge links, this test has significantly less overhead (and so should be faster).</p>
<p>A hypersurface (or its positive rational multiple) can be the thin edge link of at most one edge.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by a positive rational multiple of this hypersurface, or <code>null</code> if this hypersurface is not a multiple of a single thin edge link. </dd></dl>

</div>
</div>
<a id="ae0c37c760e13e7ad570de4fdf2709494" name="ae0c37c760e13e7ad570de4fdf2709494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c37c760e13e7ad570de4fdf2709494">&#9670;&#160;</a></span>isThinTetrahedronLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; *, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 4 &gt; * &gt; regina::NormalHypersurface::isThinTetrahedronLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single tetrahedron. </p>
<p>Here a <em>thin</em> tetrahedron link is a normal hypersurface which appears naturally as the frontier of a regular neighbourhood of a tetrahedron, with no need for any further normalisation.</p>
<p>This behaves differently from <a class="el" href="#ac245e3c55ac9506efb2fc2289940b54b" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTetrahedronLink()</a>, which tests for a <em>normalised</em> tetrahedron link (which could end up far away from the tetrahedron, or could be normalised into a hypersurface with different topology, or could even be normalised away to nothing). Unlike the tests for edge links, the routines <a class="el" href="#ae0c37c760e13e7ad570de4fdf2709494" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTetrahedronLink()</a> and <a class="el" href="#ac245e3c55ac9506efb2fc2289940b54b" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTetrahedronLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A hypersurface (or its positive rational multiple) can be the thin link of at most two tetrahedra. If there are indeed two different tetrahedra <em>t1</em> and <em>t2</em> for which a multiple of this hypersurface can be expressed as the thin tetrahedron link, then the pair (<em>t1</em>, <em>t2</em>) will be returned. If there is only one such tetrahedron <em>t</em>, then the pair (<em>t</em>, <code>null</code>) will be returned. If no positive rational multiple of this hypersurface is the thin link of any tetrahedron, then the pair (<code>null</code>, <code>null</code>) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the tetrahedra linked by a positive rational multiple of this hypersurface, as described above. </dd></dl>

</div>
</div>
<a id="a4a84a39ecb0f34417d71150c8685daac" name="a4a84a39ecb0f34417d71150c8685daac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a84a39ecb0f34417d71150c8685daac">&#9670;&#160;</a></span>isThinTriangleLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; *, const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 4 &gt; * &gt; regina::NormalHypersurface::isThinTriangleLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the thin link of a single triangle. </p>
<p>Here a <em>thin</em> triangle link is a normal hypersurface which appears naturally as the frontier of a regular neighbourhood of a triangle, with no need for any further normalisation.</p>
<p>This behaves differently from <a class="el" href="#acf94a5fa6b52b19ae4cba13388bc1568" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTriangleLink()</a>, which tests for a <em>normalised</em> triangle link (which could end up far away from the triangle, or could be normalised into a hypersurface with different topology, or could even be normalised away to nothing). Unlike the tests for edge links, the routines <a class="el" href="#a4a84a39ecb0f34417d71150c8685daac" title="Determines whether or not a positive rational multiple of this hypersurface is the thin link of a sin...">isThinTriangleLink()</a> and <a class="el" href="#acf94a5fa6b52b19ae4cba13388bc1568" title="Determines whether or not a positive rational multiple of this hypersurface is the normalised link of...">isNormalTriangleLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A hypersurface (or its positive rational multiple) can be the thin triangle link of at most two triangles. If there are indeed two different triangles <em>t1</em> and <em>t2</em> for which a multiple of this hypersurface can be expressed as the thin triangle link, then the pair (<em>t1</em>, <em>t2</em>) will be returned. If there is only one such triangle <em>t</em>, then the pair (<em>t</em>, <code>null</code>) will be returned. If no positive rational multiple of this hypersurface is the thin link of any triangle, then the pair (<code>null</code>, <code>null</code>) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the triangle(s) linked by a positive rational multiple of this hypersurface, as described above. </dd></dl>

</div>
</div>
<a id="aad578abb2b7507a4bdac7cf8427389e0" name="aad578abb2b7507a4bdac7cf8427389e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad578abb2b7507a4bdac7cf8427389e0">&#9670;&#160;</a></span>isTwoSided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this hypersurface is two-sided. </p>
<p>For our purposes, the empty hypersurface is considered to be two-sided.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is two-sided, or <code>false</code> if this hypersurface is one-sided. </dd></dl>

</div>
</div>
<a id="a54e8a721415302c5101e5064db14b153" name="a54e8a721415302c5101e5064db14b153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8a721415302c5101e5064db14b153">&#9670;&#160;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gaa2d0c69ce4cea268f94f93dbbcfbc21d">Vertex</a>&lt; 4 &gt; * regina::NormalHypersurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this hypersurface is the link of a single vertex. </p>
<p>This behaves differently from <a class="el" href="#a842ced3478b08bde5ad883ef77724420" title="Determines whether or not this hypersurface is vertex linking.">isVertexLinking()</a>, which will also detect a union of several different vertex links. In contrast, this routine will only identify the link of a <em>single</em> vertex (or a multiple of such a link).</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by a positive rational multiple of this hypersurface, or <code>null</code> if this hypersurface is not a multiple of a single vertex link. </dd></dl>

</div>
</div>
<a id="a842ced3478b08bde5ad883ef77724420" name="a842ced3478b08bde5ad883ef77724420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842ced3478b08bde5ad883ef77724420">&#9670;&#160;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this hypersurface is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>This behaves differently from <a class="el" href="#a54e8a721415302c5101e5064db14b153" title="Determines whether or not a positive rational multiple of this hypersurface is the link of a single v...">isVertexLink()</a>, which only detects the link of a single vertex (or a multiple of such a link). In contrast, this routine will also detect the union of several <em>different</em> vertex links.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is vertex linking. </dd></dl>

</div>
</div>
<a id="aa4a7a0a235aec8da73213bbf1934aa41" name="aa4a7a0a235aec8da73213bbf1934aa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a7a0a235aec8da73213bbf1934aa41">&#9670;&#160;</a></span>locallyCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface are locally compatible. </p>
<p>Local compatibility means that, within each individual pentachoron of the triangulation, it is possible to arrange the normal discs of both hypersurfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all pentachora <em>simultaneously</em>.</p>
<p>Local compatibility can be formulated in terms of normal piece types. Two normal hypersurfaces are locally compatible if and only if they together use at most two prism piece types per pentachoron; moreover, if there <em>are</em> two prism piece types within a single pentachoron then these prism types are non-intersecting.</p>
<p>If one of the two hypersurfaces breaks the local compatibility constraints on its own (for instance, it contains two conflicting prism types within the same pentachoron), then this routine will return <code>false</code> regardless of what the other hypersurface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface live within the same 4-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other hypersurface to test for local compatibility with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two hypersurfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="a6aca89d84f22f361520c25277521b9d9" name="a6aca89d84f22f361520c25277521b9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aca89d84f22f361520c25277521b9d9">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalHypersurface::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this hypersurface. </dd></dl>

</div>
</div>
<a id="a2eb00a44731aa8f7a9e4749aa3c61e28" name="a2eb00a44731aa8f7a9e4749aa3c61e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00a44731aa8f7a9e4749aa3c61e28">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> regina::NormalHypersurface::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given integer multiple of this hypersurface. </p>
<p>The resulting hypersurface will use the same internal vector encoding as this hypersurface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>the coefficient to multiply this hypersurface by; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting multiple of this hypersurface. </dd></dl>

</div>
</div>
<a id="a3da4318554a609a1a79b0c252cd61d98" name="a3da4318554a609a1a79b0c252cd61d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da4318554a609a1a79b0c252cd61d98">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp; regina::NormalHypersurface::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this hypersurface into the given integer multiple of itself. </p>
<p>The internal vector encoding used by this hypersurface will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>the coefficient to multiply this hypersurface by; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this hypersurface. </dd></dl>

</div>
</div>
<a id="af57fbd77dc01ae05f976aa8cda39b9eb" name="af57fbd77dc01ae05f976aa8cda39b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57fbd77dc01ae05f976aa8cda39b9eb">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> regina::NormalHypersurface::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of this and the given hypersurface. </p>
<p>This will combine all tetrahedra and/or prisms from both surfaces.</p>
<p>The two hypersurfaces do not need to use the same coordinate system and/or internal vector encodings. Moreover, the resulting hypersurface might well use an encoding different from both of these, or even a hybrid encoding that does not come from one of Regina's ready-made coordinate systems.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface use the same underlying triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the hypersurface to sum with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both normal hypersurfaces. </dd></dl>

</div>
</div>
<a id="a51cedb6b664a561fd2acfac42fc7f50d" name="a51cedb6b664a561fd2acfac42fc7f50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cedb6b664a561fd2acfac42fc7f50d">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ordering regina::NormalHypersurface::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this against the given surface under a total ordering of all normal hypersurfaces. </p>
<p>This ordering is not mathematically meaningful; it is merely provided for scenarios where you need to be able to sort hypersurfaces (e.g., when using them as keys in a map).</p>
<p>The order <em>is</em> well-defined, and will be preserved across copy/move operations, different program executions, and different platforms (since it is defined purely in terms of the normal coordinates, and does not use transient properties such as locations in memory).</p>
<p>This operation is consistent with the equality test. In particular, it does not matter whether the two hypersurfaces belong to different triangulations, or use different encodings, or if one but not the other supports non-compact hypersurfaces. See the equality test <a class="el" href="#a5655fa15fa8e40dd2170a9b805d3bea0" title="Determines whether this and the given hypersurface in fact represent the same normal hypersurface.">operator==()</a> for further details.</p>
<p>This routine generates all of the usual comparison operators, including <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This spaceship operator <code>x &lt;=&gt; y</code> is not available, but the other comparison operators that it generates <em>are</em> available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the hypersurface to compare this hypersurface with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison between this and the given hypersurface. This is marked as a weak ordering (not a strong ordering) to reflect the fact that (for example) hypersurfaces in different triangulations or using different encodings could be considered equal under this comparison. </dd></dl>

</div>
</div>
<a id="a9fda319e4d0872763b0690ee6b901a60" name="a9fda319e4d0872763b0690ee6b901a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fda319e4d0872763b0690ee6b901a60">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp; regina::NormalHypersurface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given normal hypersurface. </p>
<p>This and the given normal hypersurface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then this hypersurface will be adjusted accordingly.</p>
<p>This operator induces a deep copy of the given normal hypersurface.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this normal hypersurface. </dd></dl>

</div>
</div>
<a id="a59896902fd80ebacf1fd7288e9983a30" name="a59896902fd80ebacf1fd7288e9983a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59896902fd80ebacf1fd7288e9983a30">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp; regina::NormalHypersurface::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given normal hypersurface to this hypersurface. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given normal hypersurface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then this hypersurface will be adjusted accordingly.</p>
<p>The hypersurface that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this normal hypersurface. </dd></dl>

</div>
</div>
<a id="a5655fa15fa8e40dd2170a9b805d3bea0" name="a5655fa15fa8e40dd2170a9b805d3bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5655fa15fa8e40dd2170a9b805d3bea0">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface in fact represent the same normal hypersurface. </p>
<p>Specifically, this routine examines (or computes) the number of normal pieces of each type, and returns <code>true</code> if and only if these counts are the same for both hypersurfaces.</p>
<p>It does not matter what vector encodings the two hypersurfaces use. In particular, it does not matter if this and the given hypersurface use different encodings, or if one but not the other supports non-compact hypersurfaces.</p>
<p>This routine is safe to call even if this and the given hypersurface do not belong to the same triangulation:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will test whether this hypersurface, if transplanted into the other triangulation using the same pentachoron numbering and the same normal piece types, would be the same as <em>other</em>.</li>
<li>If the two triangulations have different sizes, then this routine will return <code>false</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the hypersurface to be compared with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both hypersurfaces represent the same normal hypersurface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a34268af846d03f4016a3a6134e6f65d5" name="a34268af846d03f4016a3a6134e6f65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34268af846d03f4016a3a6134e6f65d5">&#9670;&#160;</a></span>prisms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalHypersurface::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pentIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>prismType</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of prism pieces of the given type in this normal hypersurface. </p>
<p>A prism piece type is identified by specifying a pentachoron and an edge of that pentachoron; prisms of this type will then separate edge <em>i</em> of the pentachoron from triangle <em>i</em> of the pentachoron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prisms reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

</div>
</div>
<a id="ac04478970c45ff019913788cb0da9202" name="ac04478970c45ff019913788cb0da9202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04478970c45ff019913788cb0da9202">&#9670;&#160;</a></span>reconstructTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> regina::NormalHypersurface::reconstructTetrahedra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs the tetrahedron coordinates in the given integer vector. </p>
<p>The given vector must represent a normal hypersurface within the given triangulation, using the given vector encoding.</p>
<ul>
<li>If the given encoding does not already store tetrahedron coordinates, then the vector will be modified directly to use a new encoding that does, and this new encoding will be returned.</li>
<li>If the given encoding does already store tetrahedra, then this routine will do nothing and immediately return <em>enc</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which the normal hypersurface lives. </td></tr>
    <tr><td class="paramname">vector</td><td>an integer vector that encodes a normal hypersurface within <em>tri</em>; this will be modified directly. </td></tr>
    <tr><td class="paramname">enc</td><td>the encoding used by the given integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new encoding used by the modified <em>vector</em>. </dd></dl>

</div>
</div>
<a id="a3df9586927e777b3964eead71110c198" name="a3df9586927e777b3964eead71110c198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df9586927e777b3964eead71110c198">&#9670;&#160;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalHypersurface::scaleDown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this hypersurface into its smallest positive rational multiple with integer coordinates. </p>
<p>Note that the scaling factor will be independent of which internal vector encoding is used. This is essentially because integer prism coordinates (which are stored in every encoding) are enough to guarantee integer tetrahedron coordinates (which might or might not be stored).</p>
<dl class="section return"><dt>Returns</dt><dd>the integer by which the original hypersurface was divided (i.e., the gcd of all normal coordinates in the original hypersurface). This will always be strictly positive. </dd></dl>

</div>
</div>
<a id="a1cdf3ef9c9407d10c5eabc69671207f5" name="a1cdf3ef9c9407d10c5eabc69671207f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdf3ef9c9407d10c5eabc69671207f5">&#9670;&#160;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name to associate with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a96ac6a49d6ebb8426d9129b48817c82e" name="a96ac6a49d6ebb8426d9129b48817c82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ac6a49d6ebb8426d9129b48817c82e">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given normal hypersurface. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given normal hypersurface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then the two hypersurfaces will be adjusted accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the normal hypersurface whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e571077474b0899732e60f6c3c393df" name="a5e571077474b0899732e60f6c3c393df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e571077474b0899732e60f6c3c393df">&#9670;&#160;</a></span>tetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalHypersurface::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pentIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>A tetrahedron piece type is identified by specifying a pentachoron and a vertex of that pentachoron that the tetrahedron surrounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested pieces lie; this should be between 0 and 4 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

</div>
</div>
<a id="a1a49d406024a72fda5fc843e087668f2" name="a1a49d406024a72fda5fc843e087668f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a49d406024a72fda5fc843e087668f2">&#9670;&#160;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::NormalHypersurface::triangulate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 3-manifold triangulation describing this normal hypersurface. </p>
<p>The triangulation will be simplified via Triangulation&lt;3&gt;::simplify(), which means that the tetrahedra of the final triangulation are not likely to correspond to any particular tetrahedron/prism pieces of this normal hypersurface.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo</a></b></dt><dd><em>Bug:</em> Check for absurdly large numbers of pieces and return <code>null</code> accordingly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this normal hypersurface. </dd></dl>

</div>
</div>
<a id="ac6559f6224c63ac9ab10a682be8f0c20" name="ac6559f6224c63ac9ab10a682be8f0c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6559f6224c63ac9ab10a682be8f0c20">&#9670;&#160;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp; regina::NormalHypersurface::triangulation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation in which this normal hypersurface resides. </p>
<p>This will be a snapshot frozen in time of the triangulation that was originally passed to the <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> constructor.</p>
<p>This will return a correct result even if the original triangulation has since been modified or destroyed. However, in order to ensure this behaviour, it is possible that at different points in time this function may return references to different C++ objects.</p>
<p>The rules for using the <a class="el" href="#ac6559f6224c63ac9ab10a682be8f0c20" title="Returns the triangulation in which this normal hypersurface resides.">triangulation()</a> reference are:</p>
<ul>
<li>Do not keep the resulting reference as a long-term reference or pointer of your own, since in time you may find yourself referring to the wrong object (see above). Just call this function again.</li>
<li>You must respect the read-only nature of the result (i.e., you must not cast the constness away). The snapshotting process detects modifications, and modifying the frozen snapshot may result in an exception being thrown.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="add1de0b691babc0f5e57cada22fdfb8e" name="add1de0b691babc0f5e57cada22fdfb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1de0b691babc0f5e57cada22fdfb8e">&#9670;&#160;</a></span>vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp; regina::NormalHypersurface::vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the integer vector that Regina uses internally to represent this hypersurface. </p>
<p>Note that this vector might not use the same coordinate system in which the hypersurfaces were originally enumerated. (For example, this vector will always include tetrahedron coordinates, even if the surfaces were originally enumerated in prism coordinates.) You can call <a class="el" href="#af7b5a8ff7934b6b0c4f7db6338fa29fd" title="Returns the specific integer vector encoding that this hypersurface uses internally.">encoding()</a> to find out precisley how the coordinates of this vector should be interpreted.</p>
<p>See the <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> class notes for information on how this vector is structured.</p>
<dl class="section note"><dt>Note</dt><dd>If you wish to access the numbers of tetrahedra, prisms and so on, you should use the functions <a class="el" href="#a5e571077474b0899732e60f6c3c393df" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">tetrahedra()</a>, <a class="el" href="#a34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">prisms()</a>, etc., which do not require any knowledge of the internal vector encoding that this hypersurface uses.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying integer vector. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac169d0bb98e129d7437ca45b97054b47" name="ac169d0bb98e129d7437ca45b97054b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac169d0bb98e129d7437ca45b97054b47">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531f769dd9c1e82d75f9d5c3be8036d7" name="a531f769dd9c1e82d75f9d5c3be8036d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531f769dd9c1e82d75f9d5c3be8036d7">&#9670;&#160;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal hypersurface and all of its properties. </p>
<p>This routine will be called from within NormalHypersurfaces::writeXMLPacketData().</p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">list</td><td>the enclosing normal hypersurface list. Currently this is only relevant when writing to the older <a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68a8ebe490ca48cc932225a7c441864abd1" title="Indicates the second-generation file format used from Regina 3.0 through to Regina 6....">FileFormat::XmlGen2</a> format; it will be ignored (and may be <code>null</code>) for newer file formats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a52f78b7b54fe91a29227df79cf7c5467" name="a52f78b7b54fe91a29227df79cf7c5467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f78b7b54fe91a29227df79cf7c5467">&#9670;&#160;</a></span>compact_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalHypersurface::compact_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface compact (i.e., does it only contain finitely many pieces)? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a52667613c30ab62834f69a01cb683cb2" name="a52667613c30ab62834f69a01cb683cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52667613c30ab62834f69a01cb683cb2">&#9670;&#160;</a></span>connected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalHypersurface::connected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface connected? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="ad4c022a3694a8d086bc43ad3c0cfa746" name="ad4c022a3694a8d086bc43ad3c0cfa746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c022a3694a8d086bc43ad3c0cfa746">&#9670;&#160;</a></span>enc_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HyperEncoding.html">HyperEncoding</a> regina::NormalHypersurface::enc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The specific encoding of a normal hypersurface used by the coordinate vector. </p>

</div>
</div>
<a id="aead6ad353e200887cf8b247293fe08d7" name="aead6ad353e200887cf8b247293fe08d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead6ad353e200887cf8b247293fe08d7">&#9670;&#160;</a></span>H1_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&gt; regina::NormalHypersurface::H1_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First homology group of the hypersurface. </p>
<p>This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a7960bb89eb398ccc700fc93be94e6613" name="a7960bb89eb398ccc700fc93be94e6613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7960bb89eb398ccc700fc93be94e6613">&#9670;&#160;</a></span>linkOf_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t regina::NormalHypersurface::linkOf_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which dimensions of face a positive rational multiple of this hypersurface is a thin or normalised link of. </p>
<p>This is treated as a bitmask: for each i=0,1,2,3, the (2i+1)th bit indicates whether this hypersurface scales to the link of an i-face, and the (2i)th bit indicates whether this information has actually been computed yet; if it has not been computed, then the (2i+1)th bit will be zero. </p>

</div>
</div>
<a id="a935b0370203eda2d9b07e3c751d81e76" name="a935b0370203eda2d9b07e3c751d81e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935b0370203eda2d9b07e3c751d81e76">&#9670;&#160;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalHypersurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this hypersurface. </p>

</div>
</div>
<a id="a327f6f657e624dacdcfd3274f5b4e392" name="a327f6f657e624dacdcfd3274f5b4e392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327f6f657e624dacdcfd3274f5b4e392">&#9670;&#160;</a></span>orientable_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalHypersurface::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface orientable? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="af5a2a4777c8e85e04d8310f8ea317264" name="af5a2a4777c8e85e04d8310f8ea317264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a2a4777c8e85e04d8310f8ea317264">&#9670;&#160;</a></span>realBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalHypersurface::realBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this hypersurface have real boundary (i.e. </p>
<p>does it meet any boundary facets)? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a6dc47eb2a88a13593faf7b83596126ea" name="a6dc47eb2a88a13593faf7b83596126ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc47eb2a88a13593faf7b83596126ea">&#9670;&#160;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt;<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt; &gt; regina::NormalHypersurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal hypersurface resides. </p>

</div>
</div>
<a id="a8e2e21b4061791f5e685080aea2be20d" name="a8e2e21b4061791f5e685080aea2be20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2e21b4061791f5e685080aea2be20d">&#9670;&#160;</a></span>twoSided_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalHypersurface::twoSided_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface two-sided? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a74d605360542560b5f5c7ff09e68d15a" name="a74d605360542560b5f5c7ff09e68d15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d605360542560b5f5c7ff09e68d15a">&#9670;&#160;</a></span>vector_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&gt; regina::NormalHypersurface::vector_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal hypersurface. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hypersurface/<a class="el" href="normalhypersurface_8h.html">normalhypersurface.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
