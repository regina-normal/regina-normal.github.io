<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: Mathematical Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Mathematical Support</div></div>
</div><!--header-->
<div class="contents">

<p>Underlying mathematical gruntwork.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Vector3D.html">regina::Vector3D&lt; Real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector in real three-dimensional space.  <a href="structregina_1_1Vector3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Segment3D.html">regina::Segment3D&lt; Real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a line segment in 3-dimensional space, defined by its two endpoints <em>u</em> and <em>v</em>.  <a href="structregina_1_1Segment3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix3D.html">regina::Matrix3D&lt; Real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a linear transformation in three-dimensional space, as represented by a real 3-by-3 matrix.  <a href="classregina_1_1Matrix3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Rotation3D.html">regina::Rotation3D&lt; Real &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rotation about the origin in real three-dimensional space.  <a href="classregina_1_1Rotation3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Arrow.html">regina::Arrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a multivariate polynomial of the type used by arrow polynomials of links.  <a href="classregina_1_1Arrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Cyclotomic.html">regina::Cyclotomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an element of a cyclotomic field.  <a href="classregina_1_1Cyclotomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1InfinityBase.html">regina::InfinityBase&lt; withInfinity &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal base classes for use with <a class="el" href="classregina_1_1IntegerBase.html" title="Represents an arbitrary precision integer.">IntegerBase</a>, templated on whether we should support infinity as an allowed value.  <a href="structregina_1_1InfinityBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1IntegerBase.html">regina::IntegerBase&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arbitrary precision integer.  <a href="classregina_1_1IntegerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NativeInteger.html">regina::NativeInteger&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for a native, fixed-precision integer type of the given size.  <a href="classregina_1_1NativeInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial with coefficients of type <em>T</em>.  <a href="classregina_1_1Laurent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>.  <a href="classregina_1_1Laurent2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix&lt; typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements of the given type <em>T</em>.  <a href="classregina_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix2.html">regina::Matrix2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-by-2 integer matrix.  <a href="classregina_1_1Matrix2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm.html">regina::Perm&lt; n &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,...,<em>n</em>-1}.  <a href="classregina_1_1Perm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermClass.html">regina::PermClass&lt; n &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a conjugacy class of permutations on <em>n</em> elements.  <a href="classregina_1_1PermClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup&lt; n, cached &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a group of permutations on <em>n</em> elements.  <a href="classregina_1_1PermGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PermSn.html">regina::PermSn&lt; n, order, codeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight array-like object that supports fast lookup and iteration for permutations on <em>n</em> objects.  <a href="structregina_1_1PermSn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1PermSubSn.html">regina::detail::PermSubSn&lt; n, m, order &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight array-like object that indexes smaller permutations within larger permutation groups; that is, it embeds the group <em>S_m</em> inside <em>S_n</em> for some <code>n &gt; m</code>.  <a href="structregina_1_1detail_1_1PermSubSn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Polynomial.html">regina::Polynomial&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single-variable polynomial with coefficients of type <em>T</em>.  <a href="classregina_1_1Polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Primes.html">regina::Primes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for finding primes and factorising integers.  <a href="classregina_1_1Primes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Rational.html">regina::Rational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arbitrary precision rational number.  <a href="classregina_1_1Rational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1RingTraits.html">regina::RingTraits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that instructs Regina how to do mathematical operations with objects from any ring type <em>T</em>.  <a href="structregina_1_1RingTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_012_01_4.html">regina::Perm&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1}.  <a href="classregina_1_1Perm_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_013_01_4.html">regina::Perm&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2}.  <a href="classregina_1_1Perm_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_014_01_4.html">regina::Perm&lt; 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3}.  <a href="classregina_1_1Perm_3_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_015_01_4.html">regina::Perm&lt; 5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3,4}.  <a href="classregina_1_1Perm_3_015_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_016_01_4.html">regina::Perm&lt; 6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3,4,5}.  <a href="classregina_1_1Perm_3_016_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Perm_3_017_01_4.html">regina::Perm&lt; 7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3,4,5,6}.  <a href="classregina_1_1Perm_3_017_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html">regina::Vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised vector class of elements from a given ring T.  <a href="classregina_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6ecbbcb8b1e292eb5bf7dccca4be31bf" id="r_ga6ecbbcb8b1e292eb5bf7dccca4be31bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ecbbcb8b1e292eb5bf7dccca4be31bf">mpz_cmp_si_cpp</a>(z,  si)</td></tr>
<tr class="memdesc:ga6ecbbcb8b1e292eb5bf7dccca4be31bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal copy of the GMP signed comparison optimisations.  <br /></td></tr>
<tr class="separator:ga6ecbbcb8b1e292eb5bf7dccca4be31bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga09ee46ba09e6de43ed86f26fe90b81f9" id="r_ga09ee46ba09e6de43ed86f26fe90b81f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga09ee46ba09e6de43ed86f26fe90b81f9">regina::LargeInteger</a> = <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt;true&gt;</td></tr>
<tr class="memdesc:ga09ee46ba09e6de43ed86f26fe90b81f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with support for infinity.  <br /></td></tr>
<tr class="separator:ga09ee46ba09e6de43ed86f26fe90b81f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea6ee3343b36485a2ffcc441e7e17ac" id="r_ga6ea6ee3343b36485a2ffcc441e7e17ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">regina::Integer</a> = <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt;false&gt;</td></tr>
<tr class="memdesc:ga6ea6ee3343b36485a2ffcc441e7e17ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer is a type alias for <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase&lt;false&gt;</a>, which offers arbitrary precision integers without support for infinity.  <br /></td></tr>
<tr class="separator:ga6ea6ee3343b36485a2ffcc441e7e17ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d7b6494ae06bfac341b2c0722c1943" id="r_ga00d7b6494ae06bfac341b2c0722c1943"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00d7b6494ae06bfac341b2c0722c1943">regina::NativeLong</a> = <a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt;sizeof(long)&gt;</td></tr>
<tr class="memdesc:ga00d7b6494ae06bfac341b2c0722c1943"><td class="mdescLeft">&#160;</td><td class="mdescRight">NativeLong is a type alias for the <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a> template class whose underlying integer type is a native long.  <br /></td></tr>
<tr class="separator:ga00d7b6494ae06bfac341b2c0722c1943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a9df11c8b8434e6ba30d1dc1fc50f6" id="r_ga03a9df11c8b8434e6ba30d1dc1fc50f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">regina::MatrixInt</a> = <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt;<a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&gt;</td></tr>
<tr class="memdesc:ga03a9df11c8b8434e6ba30d1dc1fc50f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of arbitrary-precision integers.  <br /></td></tr>
<tr class="separator:ga03a9df11c8b8434e6ba30d1dc1fc50f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f885c624db0ced0d10ab3057ac6e4c0" id="r_ga5f885c624db0ced0d10ab3057ac6e4c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f885c624db0ced0d10ab3057ac6e4c0">regina::MatrixBool</a> = <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt;bool&gt;</td></tr>
<tr class="memdesc:ga5f885c624db0ced0d10ab3057ac6e4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of booleans.  <br /></td></tr>
<tr class="separator:ga5f885c624db0ced0d10ab3057ac6e4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fad760ce1aacdbfef978d52f620e2c" id="r_gae3fad760ce1aacdbfef978d52f620e2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3fad760ce1aacdbfef978d52f620e2c">regina::VectorInt</a> = <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&gt;</td></tr>
<tr class="memdesc:gae3fad760ce1aacdbfef978d52f620e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of arbitrary-precision integers.  <br /></td></tr>
<tr class="separator:gae3fad760ce1aacdbfef978d52f620e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2c36ac76c2c080374f654bbada2506" id="r_ga2c2c36ac76c2c080374f654bbada2506"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c2c36ac76c2c080374f654bbada2506">regina::VectorLarge</a> = <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&gt;</td></tr>
<tr class="memdesc:ga2c2c36ac76c2c080374f654bbada2506"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of arbitrary-precision integers that allows infinite elements.  <br /></td></tr>
<tr class="separator:ga2c2c36ac76c2c080374f654bbada2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae8090c7366267fc9deefd4927be21476" id="r_gae8090c7366267fc9deefd4927be21476"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8090c7366267fc9deefd4927be21476">regina::PermCodeType</a> { <a class="el" href="#ggae8090c7366267fc9deefd4927be21476afff0d600f8a0b5e19e88bfb821dd1157">regina::PermCodeType::Images</a> = 1
, <a class="el" href="#ggae8090c7366267fc9deefd4927be21476a88fa71f0a6e0dfedbb46d91cc0b37a50">regina::PermCodeType::Index</a> = 2
 }</td></tr>
<tr class="memdesc:gae8090c7366267fc9deefd4927be21476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the different kinds of internal permutation codes that are used in Regina's various Perm&lt;n&gt; template classes.  <a href="#gae8090c7366267fc9deefd4927be21476">More...</a><br /></td></tr>
<tr class="separator:gae8090c7366267fc9deefd4927be21476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9587dc3912b0044f72b146c5cd95b2bc" id="r_ga9587dc3912b0044f72b146c5cd95b2bc"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ga9587dc3912b0044f72b146c5cd95b2bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9587dc3912b0044f72b146c5cd95b2bc">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt; Real &gt; &amp;v)</td></tr>
<tr class="memdesc:ga9587dc3912b0044f72b146c5cd95b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given vector to the given output stream.  <br /></td></tr>
<tr class="separator:ga9587dc3912b0044f72b146c5cd95b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272974190dcd881f3fee1856c915071a" id="r_ga272974190dcd881f3fee1856c915071a"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ga272974190dcd881f3fee1856c915071a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga272974190dcd881f3fee1856c915071a">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1Segment3D.html">Segment3D</a>&lt; Real &gt; &amp;s)</td></tr>
<tr class="memdesc:ga272974190dcd881f3fee1856c915071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given line segment to the given output stream.  <br /></td></tr>
<tr class="separator:ga272974190dcd881f3fee1856c915071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88df7f1c82c5adeed23445eb0725dd7" id="r_gac88df7f1c82c5adeed23445eb0725dd7"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:gac88df7f1c82c5adeed23445eb0725dd7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac88df7f1c82c5adeed23445eb0725dd7">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Matrix3D.html">Matrix3D</a>&lt; Real &gt; &amp;m)</td></tr>
<tr class="memdesc:gac88df7f1c82c5adeed23445eb0725dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given matrix to the given output stream.  <br /></td></tr>
<tr class="separator:gac88df7f1c82c5adeed23445eb0725dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5369fbb998574ec461588c3fc15980f1" id="r_ga5369fbb998574ec461588c3fc15980f1"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ga5369fbb998574ec461588c3fc15980f1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5369fbb998574ec461588c3fc15980f1">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Rotation3D.html">Rotation3D</a>&lt; Real &gt; &amp;rot)</td></tr>
<tr class="memdesc:ga5369fbb998574ec461588c3fc15980f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given rotation to the given output stream.  <br /></td></tr>
<tr class="separator:ga5369fbb998574ec461588c3fc15980f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5669e91dc80942eab14d2b465ec19f88" id="r_ga5669e91dc80942eab14d2b465ec19f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5669e91dc80942eab14d2b465ec19f88">regina::swap</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;a, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga5669e91dc80942eab14d2b465ec19f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given polynomials.  <br /></td></tr>
<tr class="separator:ga5669e91dc80942eab14d2b465ec19f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da2e19e0953ef1bee21156c1260e061" id="r_ga3da2e19e0953ef1bee21156c1260e061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3da2e19e0953ef1bee21156c1260e061">regina::operator*</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> poly, const <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;scalar)</td></tr>
<tr class="memdesc:ga3da2e19e0953ef1bee21156c1260e061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given integer constant.  <br /></td></tr>
<tr class="separator:ga3da2e19e0953ef1bee21156c1260e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9f677a4160356445e139f7b8b62161" id="r_gacc9f677a4160356445e139f7b8b62161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc9f677a4160356445e139f7b8b62161">regina::operator*</a> (const <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;scalar, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> poly)</td></tr>
<tr class="memdesc:gacc9f677a4160356445e139f7b8b62161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given integer constant.  <br /></td></tr>
<tr class="separator:gacc9f677a4160356445e139f7b8b62161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e04cdf43e104204ac55917aba1f3ea4" id="r_ga8e04cdf43e104204ac55917aba1f3ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e04cdf43e104204ac55917aba1f3ea4">regina::operator*</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> arrow, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;laurent)</td></tr>
<tr class="memdesc:ga8e04cdf43e104204ac55917aba1f3ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given arrow polynomial by the given <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <code>A</code>.  <br /></td></tr>
<tr class="separator:ga8e04cdf43e104204ac55917aba1f3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4547463696a545700c7516c337e995" id="r_gacb4547463696a545700c7516c337e995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb4547463696a545700c7516c337e995">regina::operator*</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;laurent, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> arrow)</td></tr>
<tr class="memdesc:gacb4547463696a545700c7516c337e995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given arrow polynomial by the given <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <code>A</code>.  <br /></td></tr>
<tr class="separator:gacb4547463696a545700c7516c337e995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abc98d9c5bc347db11af397f573bdb7" id="r_ga5abc98d9c5bc347db11af397f573bdb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5abc98d9c5bc347db11af397f573bdb7">regina::operator+</a> (const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;lhs, const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga5abc98d9c5bc347db11af397f573bdb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga5abc98d9c5bc347db11af397f573bdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d2de6168cbe0d361388ceaf254b85e" id="r_ga13d2de6168cbe0d361388ceaf254b85e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga13d2de6168cbe0d361388ceaf254b85e">regina::operator+</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;lhs, const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga13d2de6168cbe0d361388ceaf254b85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga13d2de6168cbe0d361388ceaf254b85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d708584d8796cf3ccb3005f67a7edf2" id="r_ga3d708584d8796cf3ccb3005f67a7edf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d708584d8796cf3ccb3005f67a7edf2">regina::operator+</a> (const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;lhs, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga3d708584d8796cf3ccb3005f67a7edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga3d708584d8796cf3ccb3005f67a7edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac963beb7dc09011f4f8dd0811dda4334" id="r_gac963beb7dc09011f4f8dd0811dda4334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac963beb7dc09011f4f8dd0811dda4334">regina::operator+</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;lhs, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gac963beb7dc09011f4f8dd0811dda4334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:gac963beb7dc09011f4f8dd0811dda4334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccc1b6882dbafc03823730366522c0a" id="r_ga9ccc1b6882dbafc03823730366522c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ccc1b6882dbafc03823730366522c0a">regina::operator-</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> arg)</td></tr>
<tr class="memdesc:ga9ccc1b6882dbafc03823730366522c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative of the given polynomial.  <br /></td></tr>
<tr class="separator:ga9ccc1b6882dbafc03823730366522c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4cee5ce390dd03631d86118a18490d3" id="r_gaa4cee5ce390dd03631d86118a18490d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4cee5ce390dd03631d86118a18490d3">regina::operator-</a> (const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;lhs, const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaa4cee5ce390dd03631d86118a18490d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:gaa4cee5ce390dd03631d86118a18490d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c52ccdb43e4a4f8b6155cd94f69184" id="r_ga08c52ccdb43e4a4f8b6155cd94f69184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga08c52ccdb43e4a4f8b6155cd94f69184">regina::operator-</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;lhs, const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga08c52ccdb43e4a4f8b6155cd94f69184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga08c52ccdb43e4a4f8b6155cd94f69184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6816f63242efa377c9d647c5749f17" id="r_ga5a6816f63242efa377c9d647c5749f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a6816f63242efa377c9d647c5749f17">regina::operator-</a> (const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;lhs, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga5a6816f63242efa377c9d647c5749f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga5a6816f63242efa377c9d647c5749f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c105b8713be3a63453f347ea136aa5" id="r_ga53c105b8713be3a63453f347ea136aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga53c105b8713be3a63453f347ea136aa5">regina::operator-</a> (<a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;lhs, <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga53c105b8713be3a63453f347ea136aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga53c105b8713be3a63453f347ea136aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19924a442a9a5a8b8cd7bcc471d7e443" id="r_ga19924a442a9a5a8b8cd7bcc471d7e443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Arrow.html">Arrow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19924a442a9a5a8b8cd7bcc471d7e443">regina::operator*</a> (const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;lhs, const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga19924a442a9a5a8b8cd7bcc471d7e443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two given polynomials.  <br /></td></tr>
<tr class="separator:ga19924a442a9a5a8b8cd7bcc471d7e443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6dccba582fc983e1ea9d27fdd634ab" id="r_ga3b6dccba582fc983e1ea9d27fdd634ab"><td class="memItemLeft" align="right" valign="top">consteval int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b6dccba582fc983e1ea9d27fdd634ab">regina::binomSmall</a> (int n, int k)</td></tr>
<tr class="memdesc:ga3b6dccba582fc983e1ea9d27fdd634ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binomial coefficient <em>n</em> choose <em>k</em> in constant time for small arguments (<em>n</em> ≤ 16).  <br /></td></tr>
<tr class="separator:ga3b6dccba582fc983e1ea9d27fdd634ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bdb34817179ccd0ad99fd7d2033dce" id="r_ga12bdb34817179ccd0ad99fd7d2033dce"><td class="memItemLeft" align="right" valign="top">constexpr int_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12bdb34817179ccd0ad99fd7d2033dce">regina::binomMedium</a> (int n, int k)</td></tr>
<tr class="memdesc:ga12bdb34817179ccd0ad99fd7d2033dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binomial coefficient <em>n</em> choose <em>k</em> in linear time for medium-sized arguments (<em>n</em> ≤ 61).  <br /></td></tr>
<tr class="separator:ga12bdb34817179ccd0ad99fd7d2033dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70d0209d90d5babcc252f4da212b7b9" id="r_gaf70d0209d90d5babcc252f4da212b7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf70d0209d90d5babcc252f4da212b7b9">regina::swap</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;a, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:gaf70d0209d90d5babcc252f4da212b7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given field elements.  <br /></td></tr>
<tr class="separator:gaf70d0209d90d5babcc252f4da212b7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66807f120ff00334a07f910b7aa3bd7" id="r_gae66807f120ff00334a07f910b7aa3bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae66807f120ff00334a07f910b7aa3bd7">regina::operator*</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> elt, const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;scalar)</td></tr>
<tr class="memdesc:gae66807f120ff00334a07f910b7aa3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given field element by the given rational.  <br /></td></tr>
<tr class="separator:gae66807f120ff00334a07f910b7aa3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c949c5925ab83b3de51cf7f22e9547" id="r_ga06c949c5925ab83b3de51cf7f22e9547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga06c949c5925ab83b3de51cf7f22e9547">regina::operator*</a> (const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;scalar, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> elt)</td></tr>
<tr class="memdesc:ga06c949c5925ab83b3de51cf7f22e9547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given field element by the given rational.  <br /></td></tr>
<tr class="separator:ga06c949c5925ab83b3de51cf7f22e9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d490bdb5c5fa0521faadf36c20d2598" id="r_ga0d490bdb5c5fa0521faadf36c20d2598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0d490bdb5c5fa0521faadf36c20d2598">regina::operator/</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> elt, const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;scalar)</td></tr>
<tr class="memdesc:ga0d490bdb5c5fa0521faadf36c20d2598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the given field element by the given rational.  <br /></td></tr>
<tr class="separator:ga0d490bdb5c5fa0521faadf36c20d2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef69b52b11337a042216f3e57562e1f" id="r_ga2ef69b52b11337a042216f3e57562e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2ef69b52b11337a042216f3e57562e1f">regina::operator+</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga2ef69b52b11337a042216f3e57562e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:ga2ef69b52b11337a042216f3e57562e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0a0325a636a2cda313b9ee76c6700c" id="r_gaee0a0325a636a2cda313b9ee76c6700c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee0a0325a636a2cda313b9ee76c6700c">regina::operator+</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaee0a0325a636a2cda313b9ee76c6700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gaee0a0325a636a2cda313b9ee76c6700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe173d208150767d2489e23aa2112db4" id="r_gafe173d208150767d2489e23aa2112db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe173d208150767d2489e23aa2112db4">regina::operator+</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gafe173d208150767d2489e23aa2112db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gafe173d208150767d2489e23aa2112db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d7185bac78d1d9e8d7e3df261b06c" id="r_gaf02d7185bac78d1d9e8d7e3df261b06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf02d7185bac78d1d9e8d7e3df261b06c">regina::operator+</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;lhs, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaf02d7185bac78d1d9e8d7e3df261b06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gaf02d7185bac78d1d9e8d7e3df261b06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c30a807b58e5a71b561eebe14560fc" id="r_gae0c30a807b58e5a71b561eebe14560fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0c30a807b58e5a71b561eebe14560fc">regina::operator-</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> arg)</td></tr>
<tr class="memdesc:gae0c30a807b58e5a71b561eebe14560fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative of the given field element.  <br /></td></tr>
<tr class="separator:gae0c30a807b58e5a71b561eebe14560fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce5ceb3b7e84865d0b06a55acc3e224" id="r_gabce5ceb3b7e84865d0b06a55acc3e224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabce5ceb3b7e84865d0b06a55acc3e224">regina::operator-</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:gabce5ceb3b7e84865d0b06a55acc3e224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gabce5ceb3b7e84865d0b06a55acc3e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37c0a90f313b78098fa966201663751" id="r_gaf37c0a90f313b78098fa966201663751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf37c0a90f313b78098fa966201663751">regina::operator-</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaf37c0a90f313b78098fa966201663751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gaf37c0a90f313b78098fa966201663751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1fbbc601e603d15718c091bd379c25d" id="r_gae1fbbc601e603d15718c091bd379c25d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae1fbbc601e603d15718c091bd379c25d">regina::operator-</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gae1fbbc601e603d15718c091bd379c25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gae1fbbc601e603d15718c091bd379c25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec93028be41ad43f3566bb0dc79572eb" id="r_gaec93028be41ad43f3566bb0dc79572eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec93028be41ad43f3566bb0dc79572eb">regina::operator-</a> (<a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;lhs, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gaec93028be41ad43f3566bb0dc79572eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:gaec93028be41ad43f3566bb0dc79572eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511574e229c46b89a4bae0cb203b6e94" id="r_ga511574e229c46b89a4bae0cb203b6e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga511574e229c46b89a4bae0cb203b6e94">regina::operator*</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga511574e229c46b89a4bae0cb203b6e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:ga511574e229c46b89a4bae0cb203b6e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d728ca6501de2610f8c4392c1664ac4" id="r_ga5d728ca6501de2610f8c4392c1664ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d728ca6501de2610f8c4392c1664ac4">regina::operator/</a> (const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;lhs, const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga5d728ca6501de2610f8c4392c1664ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the two given cyclotomic field elements.  <br /></td></tr>
<tr class="separator:ga5d728ca6501de2610f8c4392c1664ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4539ca41a1bea970672d3f18d3f68882" id="r_ga4539ca41a1bea970672d3f18d3f68882"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:ga4539ca41a1bea970672d3f18d3f68882"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4539ca41a1bea970672d3f18d3f68882">regina::swap</a> (<a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;a, <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga4539ca41a1bea970672d3f18d3f68882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given integers.  <br /></td></tr>
<tr class="separator:ga4539ca41a1bea970672d3f18d3f68882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5c9244276eb19180344afd5cb716b6" id="r_gacc5c9244276eb19180344afd5cb716b6"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:gacc5c9244276eb19180344afd5cb716b6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacc5c9244276eb19180344afd5cb716b6">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;i)</td></tr>
<tr class="memdesc:gacc5c9244276eb19180344afd5cb716b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given integer to the given output stream.  <br /></td></tr>
<tr class="separator:gacc5c9244276eb19180344afd5cb716b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4abce8443e3a8b2901da90fc4ebcf55" id="r_gad4abce8443e3a8b2901da90fc4ebcf55"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:gad4abce8443e3a8b2901da90fc4ebcf55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad4abce8443e3a8b2901da90fc4ebcf55">regina::operator+</a> (long lhs, const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad4abce8443e3a8b2901da90fc4ebcf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given native integer to the given large integer.  <br /></td></tr>
<tr class="separator:gad4abce8443e3a8b2901da90fc4ebcf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d732b736f8cd9f48fbfb7b29ea021d" id="r_gaa4d732b736f8cd9f48fbfb7b29ea021d"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:gaa4d732b736f8cd9f48fbfb7b29ea021d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa4d732b736f8cd9f48fbfb7b29ea021d">regina::operator*</a> (long lhs, const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa4d732b736f8cd9f48fbfb7b29ea021d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given native integer with the given large integer.  <br /></td></tr>
<tr class="separator:gaa4d732b736f8cd9f48fbfb7b29ea021d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f617ed59595ca8e0a6109b423d2831b" id="r_ga5f617ed59595ca8e0a6109b423d2831b"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:ga5f617ed59595ca8e0a6109b423d2831b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5f617ed59595ca8e0a6109b423d2831b">regina::tightEncode</a> (std::ostream &amp;out, <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; value)</td></tr>
<tr class="memdesc:ga5f617ed59595ca8e0a6109b423d2831b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given arbitrary precision integer to the given output stream.  <br /></td></tr>
<tr class="separator:ga5f617ed59595ca8e0a6109b423d2831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0118b9ecfaa863e512e118df0ed5b883" id="r_ga0118b9ecfaa863e512e118df0ed5b883"><td class="memTemplParams" colspan="2">template&lt;bool withInfinity&gt; </td></tr>
<tr class="memitem:ga0118b9ecfaa863e512e118df0ed5b883"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0118b9ecfaa863e512e118df0ed5b883">regina::tightEncoding</a> (<a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; value)</td></tr>
<tr class="memdesc:ga0118b9ecfaa863e512e118df0ed5b883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given arbitrary precision integer.  <br /></td></tr>
<tr class="separator:ga0118b9ecfaa863e512e118df0ed5b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab584fd1a7852e425bff4cf82dac63798" id="r_gab584fd1a7852e425bff4cf82dac63798"><td class="memTemplParams" colspan="2">template&lt;int bytes&gt; </td></tr>
<tr class="memitem:gab584fd1a7852e425bff4cf82dac63798"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab584fd1a7852e425bff4cf82dac63798">regina::swap</a> (<a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;a, <a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gab584fd1a7852e425bff4cf82dac63798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given integers.  <br /></td></tr>
<tr class="separator:gab584fd1a7852e425bff4cf82dac63798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752c440af02effb2ea39193ed9fb720a" id="r_ga752c440af02effb2ea39193ed9fb720a"><td class="memTemplParams" colspan="2">template&lt;int bytes&gt; </td></tr>
<tr class="memitem:ga752c440af02effb2ea39193ed9fb720a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga752c440af02effb2ea39193ed9fb720a">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;i)</td></tr>
<tr class="memdesc:ga752c440af02effb2ea39193ed9fb720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given integer to the given output stream.  <br /></td></tr>
<tr class="separator:ga752c440af02effb2ea39193ed9fb720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629640cdbecc2dbfd1b13cca9e968b1a" id="r_ga629640cdbecc2dbfd1b13cca9e968b1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga629640cdbecc2dbfd1b13cca9e968b1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga629640cdbecc2dbfd1b13cca9e968b1a">regina::swap</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga629640cdbecc2dbfd1b13cca9e968b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given polynomials.  <br /></td></tr>
<tr class="separator:ga629640cdbecc2dbfd1b13cca9e968b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadb9e18385a09e05adb6197c32b1188" id="r_gadadb9e18385a09e05adb6197c32b1188"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadadb9e18385a09e05adb6197c32b1188"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadadb9e18385a09e05adb6197c32b1188">regina::operator*</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:gadadb9e18385a09e05adb6197c32b1188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:gadadb9e18385a09e05adb6197c32b1188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1464fd6fc66da7181d5d9e9413df091d" id="r_ga1464fd6fc66da7181d5d9e9413df091d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1464fd6fc66da7181d5d9e9413df091d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1464fd6fc66da7181d5d9e9413df091d">regina::operator*</a> (const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;scalar, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; poly)</td></tr>
<tr class="memdesc:ga1464fd6fc66da7181d5d9e9413df091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:ga1464fd6fc66da7181d5d9e9413df091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab384f01e0a3ead90d17cb8b5627ce9f9" id="r_gab384f01e0a3ead90d17cb8b5627ce9f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab384f01e0a3ead90d17cb8b5627ce9f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab384f01e0a3ead90d17cb8b5627ce9f9">regina::operator/</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:gab384f01e0a3ead90d17cb8b5627ce9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:gab384f01e0a3ead90d17cb8b5627ce9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bc2d020478e794808557a56819db10" id="r_ga05bc2d020478e794808557a56819db10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga05bc2d020478e794808557a56819db10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga05bc2d020478e794808557a56819db10">regina::operator+</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga05bc2d020478e794808557a56819db10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga05bc2d020478e794808557a56819db10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1739b0949f80233bb811a0d7c22bcd63" id="r_ga1739b0949f80233bb811a0d7c22bcd63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1739b0949f80233bb811a0d7c22bcd63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1739b0949f80233bb811a0d7c22bcd63">regina::operator+</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1739b0949f80233bb811a0d7c22bcd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga1739b0949f80233bb811a0d7c22bcd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227446e24c68af8fd7f7b1f2fd94d8ec" id="r_ga227446e24c68af8fd7f7b1f2fd94d8ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga227446e24c68af8fd7f7b1f2fd94d8ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga227446e24c68af8fd7f7b1f2fd94d8ec">regina::operator+</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga227446e24c68af8fd7f7b1f2fd94d8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga227446e24c68af8fd7f7b1f2fd94d8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f7badfb3b93c80ea0bef4016322526" id="r_ga15f7badfb3b93c80ea0bef4016322526"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga15f7badfb3b93c80ea0bef4016322526"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga15f7badfb3b93c80ea0bef4016322526">regina::operator+</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga15f7badfb3b93c80ea0bef4016322526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga15f7badfb3b93c80ea0bef4016322526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b9a142c3b3386975ed8e4eaa535863" id="r_ga86b9a142c3b3386975ed8e4eaa535863"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga86b9a142c3b3386975ed8e4eaa535863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga86b9a142c3b3386975ed8e4eaa535863">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; arg)</td></tr>
<tr class="memdesc:ga86b9a142c3b3386975ed8e4eaa535863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative of the given polynomial.  <br /></td></tr>
<tr class="separator:ga86b9a142c3b3386975ed8e4eaa535863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db067bde73132ecc7300bfbf76ffeb4" id="r_ga5db067bde73132ecc7300bfbf76ffeb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5db067bde73132ecc7300bfbf76ffeb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5db067bde73132ecc7300bfbf76ffeb4">regina::operator-</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5db067bde73132ecc7300bfbf76ffeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga5db067bde73132ecc7300bfbf76ffeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23cebf0f325b89655b2f3bf5aa04d78b" id="r_ga23cebf0f325b89655b2f3bf5aa04d78b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga23cebf0f325b89655b2f3bf5aa04d78b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga23cebf0f325b89655b2f3bf5aa04d78b">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga23cebf0f325b89655b2f3bf5aa04d78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga23cebf0f325b89655b2f3bf5aa04d78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2986994dfe16c9e43f092aaa9b3f5" id="r_ga2ff2986994dfe16c9e43f092aaa9b3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2ff2986994dfe16c9e43f092aaa9b3f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2ff2986994dfe16c9e43f092aaa9b3f5">regina::operator-</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga2ff2986994dfe16c9e43f092aaa9b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga2ff2986994dfe16c9e43f092aaa9b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff5aebd44e21a82a1cb3b6163c271f2" id="r_gadff5aebd44e21a82a1cb3b6163c271f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadff5aebd44e21a82a1cb3b6163c271f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadff5aebd44e21a82a1cb3b6163c271f2">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gadff5aebd44e21a82a1cb3b6163c271f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:gadff5aebd44e21a82a1cb3b6163c271f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97959d063caf380a41e1cd8998fe8c3" id="r_gab97959d063caf380a41e1cd8998fe8c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab97959d063caf380a41e1cd8998fe8c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab97959d063caf380a41e1cd8998fe8c3">regina::operator*</a> (const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab97959d063caf380a41e1cd8998fe8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two given polynomials.  <br /></td></tr>
<tr class="separator:gab97959d063caf380a41e1cd8998fe8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae922db629f2c26ecbeefdbddff69a1c7" id="r_gae922db629f2c26ecbeefdbddff69a1c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae922db629f2c26ecbeefdbddff69a1c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae922db629f2c26ecbeefdbddff69a1c7">regina::swap</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae922db629f2c26ecbeefdbddff69a1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given polynomials.  <br /></td></tr>
<tr class="separator:gae922db629f2c26ecbeefdbddff69a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8f9efcce3be09a0ab85458058a5c9d" id="r_ga8b8f9efcce3be09a0ab85458058a5c9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8b8f9efcce3be09a0ab85458058a5c9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b8f9efcce3be09a0ab85458058a5c9d">regina::operator*</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:ga8b8f9efcce3be09a0ab85458058a5c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:ga8b8f9efcce3be09a0ab85458058a5c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3bc28c6d3e9d9c0c1a1949407d97ef" id="r_ga0a3bc28c6d3e9d9c0c1a1949407d97ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a3bc28c6d3e9d9c0c1a1949407d97ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0a3bc28c6d3e9d9c0c1a1949407d97ef">regina::operator*</a> (const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;scalar, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; poly)</td></tr>
<tr class="memdesc:ga0a3bc28c6d3e9d9c0c1a1949407d97ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:ga0a3bc28c6d3e9d9c0c1a1949407d97ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb07cb1a5784d68da25c71d0ebdeb125" id="r_gacb07cb1a5784d68da25c71d0ebdeb125"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacb07cb1a5784d68da25c71d0ebdeb125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacb07cb1a5784d68da25c71d0ebdeb125">regina::operator/</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:gacb07cb1a5784d68da25c71d0ebdeb125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:gacb07cb1a5784d68da25c71d0ebdeb125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc20446f3eaa1e6e69a00ddaa0899f2e" id="r_gabc20446f3eaa1e6e69a00ddaa0899f2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabc20446f3eaa1e6e69a00ddaa0899f2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabc20446f3eaa1e6e69a00ddaa0899f2e">regina::operator+</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabc20446f3eaa1e6e69a00ddaa0899f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:gabc20446f3eaa1e6e69a00ddaa0899f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b830131a72788b1a55887e9de678df3" id="r_ga8b830131a72788b1a55887e9de678df3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8b830131a72788b1a55887e9de678df3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b830131a72788b1a55887e9de678df3">regina::operator+</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8b830131a72788b1a55887e9de678df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga8b830131a72788b1a55887e9de678df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da1f2d7cc3ccf5868beb18f272f80d5" id="r_ga1da1f2d7cc3ccf5868beb18f272f80d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1da1f2d7cc3ccf5868beb18f272f80d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1da1f2d7cc3ccf5868beb18f272f80d5">regina::operator+</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga1da1f2d7cc3ccf5868beb18f272f80d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga1da1f2d7cc3ccf5868beb18f272f80d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426632ac5fb0a8c43c8b8029477c60a2" id="r_ga426632ac5fb0a8c43c8b8029477c60a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga426632ac5fb0a8c43c8b8029477c60a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga426632ac5fb0a8c43c8b8029477c60a2">regina::operator+</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga426632ac5fb0a8c43c8b8029477c60a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga426632ac5fb0a8c43c8b8029477c60a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ccb2e6cab2b44268cddb0f28053fd0" id="r_ga53ccb2e6cab2b44268cddb0f28053fd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53ccb2e6cab2b44268cddb0f28053fd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga53ccb2e6cab2b44268cddb0f28053fd0">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; arg)</td></tr>
<tr class="memdesc:ga53ccb2e6cab2b44268cddb0f28053fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative of the given polynomial.  <br /></td></tr>
<tr class="separator:ga53ccb2e6cab2b44268cddb0f28053fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbf14f7449cd036f49200e7c5d524ba" id="r_ga6fbf14f7449cd036f49200e7c5d524ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fbf14f7449cd036f49200e7c5d524ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6fbf14f7449cd036f49200e7c5d524ba">regina::operator-</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6fbf14f7449cd036f49200e7c5d524ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga6fbf14f7449cd036f49200e7c5d524ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede6f5acb23d837f0930a19a263251a9" id="r_gaede6f5acb23d837f0930a19a263251a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaede6f5acb23d837f0930a19a263251a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaede6f5acb23d837f0930a19a263251a9">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaede6f5acb23d837f0930a19a263251a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:gaede6f5acb23d837f0930a19a263251a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b52f7eda98219e068e935776e08e7" id="r_ga447b52f7eda98219e068e935776e08e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga447b52f7eda98219e068e935776e08e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga447b52f7eda98219e068e935776e08e7">regina::operator-</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga447b52f7eda98219e068e935776e08e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga447b52f7eda98219e068e935776e08e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801ec085beabc96fea83bdc3205d340d" id="r_ga801ec085beabc96fea83bdc3205d340d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga801ec085beabc96fea83bdc3205d340d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga801ec085beabc96fea83bdc3205d340d">regina::operator-</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga801ec085beabc96fea83bdc3205d340d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga801ec085beabc96fea83bdc3205d340d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fad4e753022f32d41927d65398e2ee" id="r_gad5fad4e753022f32d41927d65398e2ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad5fad4e753022f32d41927d65398e2ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad5fad4e753022f32d41927d65398e2ee">regina::operator*</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad5fad4e753022f32d41927d65398e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two given polynomials.  <br /></td></tr>
<tr class="separator:gad5fad4e753022f32d41927d65398e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade671546c9ba9ca4198e43ab57d6b626" id="r_gade671546c9ba9ca4198e43ab57d6b626"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gade671546c9ba9ca4198e43ab57d6b626"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gade671546c9ba9ca4198e43ab57d6b626">regina::swap</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gade671546c9ba9ca4198e43ab57d6b626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given matrices.  <br /></td></tr>
<tr class="separator:gade671546c9ba9ca4198e43ab57d6b626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cfa8150c425808f106f6f51c54dee7" id="r_ga09cfa8150c425808f106f6f51c54dee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga09cfa8150c425808f106f6f51c54dee7">regina::swap</a> (<a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;a, <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga09cfa8150c425808f106f6f51c54dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given matrices.  <br /></td></tr>
<tr class="separator:ga09cfa8150c425808f106f6f51c54dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dfa0040b213b62780fcb530ac8974dd" id="r_ga2dfa0040b213b62780fcb530ac8974dd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2dfa0040b213b62780fcb530ac8974dd">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;mat)</td></tr>
<tr class="memdesc:ga2dfa0040b213b62780fcb530ac8974dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given matrix to the given output stream.  <br /></td></tr>
<tr class="separator:ga2dfa0040b213b62780fcb530ac8974dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8596862fc390e91ab3f15e7d828c0f7c" id="r_ga8596862fc390e91ab3f15e7d828c0f7c"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8596862fc390e91ab3f15e7d828c0f7c">regina::simplerThreeWay</a> (const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;m1, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;m2)</td></tr>
<tr class="memdesc:ga8596862fc390e91ab3f15e7d828c0f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two matrices to determine which is more aesthetically pleasing.  <br /></td></tr>
<tr class="separator:ga8596862fc390e91ab3f15e7d828c0f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1446f5ce6902b72889d354b003fd098e" id="r_ga1446f5ce6902b72889d354b003fd098e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1446f5ce6902b72889d354b003fd098e">regina::simpler</a> (const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;m1, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;m2)</td></tr>
<tr class="memdesc:ga1446f5ce6902b72889d354b003fd098e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines whether the first given matrix is more aesthetically pleasing than the second.  <br /></td></tr>
<tr class="separator:ga1446f5ce6902b72889d354b003fd098e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b2fc2064b7c97b3cca3bcbe27f9e0d" id="r_ga89b2fc2064b7c97b3cca3bcbe27f9e0d"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89b2fc2064b7c97b3cca3bcbe27f9e0d">regina::simplerThreeWay</a> (const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair1first, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair1second, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair2first, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair2second)</td></tr>
<tr class="memdesc:ga89b2fc2064b7c97b3cca3bcbe27f9e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ordered pairs of matrices to determine which pair is more aesthetically pleasing.  <br /></td></tr>
<tr class="separator:ga89b2fc2064b7c97b3cca3bcbe27f9e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cca6045c934d6f78c51f9ac4acebf3f" id="r_ga6cca6045c934d6f78c51f9ac4acebf3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cca6045c934d6f78c51f9ac4acebf3f">regina::simpler</a> (const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair1first, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair1second, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair2first, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;pair2second)</td></tr>
<tr class="memdesc:ga6cca6045c934d6f78c51f9ac4acebf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines whether the first given pair of matrices is more aesthetically pleasing than the second pair.  <br /></td></tr>
<tr class="separator:ga6cca6045c934d6f78c51f9ac4acebf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa593986d5cdcda5806cbd88625ab77e" id="r_gafa593986d5cdcda5806cbd88625ab77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa593986d5cdcda5806cbd88625ab77e">regina::smithNormalForm</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;matrix)</td></tr>
<tr class="memdesc:gafa593986d5cdcda5806cbd88625ab77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given integer matrix into Smith normal form.  <br /></td></tr>
<tr class="separator:gafa593986d5cdcda5806cbd88625ab77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7569d6d12d6910c859101d90a1ecd340" id="r_ga7569d6d12d6910c859101d90a1ecd340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7569d6d12d6910c859101d90a1ecd340">regina::smithNormalForm</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;matrix, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;rowSpaceBasis, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;rowSpaceBasisInv, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;colSpaceBasis, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;colSpaceBasisInv)</td></tr>
<tr class="memdesc:ga7569d6d12d6910c859101d90a1ecd340"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Smith normal form algorithm that also returns change of basis matrices.  <br /></td></tr>
<tr class="separator:ga7569d6d12d6910c859101d90a1ecd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9499002f32f341b62773264749a194db" id="r_ga9499002f32f341b62773264749a194db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9499002f32f341b62773264749a194db">regina::metricalSmithNormalForm</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;matrix, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;rowSpaceBasis, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;rowSpaceBasisInv, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;colSpaceBasis, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;colSpaceBasisInv)</td></tr>
<tr class="memdesc:ga9499002f32f341b62773264749a194db"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative Smith normal form algorithm that also returns change of basis matrices.  <br /></td></tr>
<tr class="separator:ga9499002f32f341b62773264749a194db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a009583b8be1b537c39716e85f8cc5b" id="r_ga0a009583b8be1b537c39716e85f8cc5b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0a009583b8be1b537c39716e85f8cc5b">regina::rowBasis</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;matrix)</td></tr>
<tr class="memdesc:ga0a009583b8be1b537c39716e85f8cc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a basis for the row space of the given matrix.  <br /></td></tr>
<tr class="separator:ga0a009583b8be1b537c39716e85f8cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618d7dcd03fe042475212cef13c8d158" id="r_ga618d7dcd03fe042475212cef13c8d158"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga618d7dcd03fe042475212cef13c8d158">regina::rowBasisAndOrthComp</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;input, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;complement)</td></tr>
<tr class="memdesc:ga618d7dcd03fe042475212cef13c8d158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a basis for the row space of the given matrix, as well as an "incremental" basis for its orthogonal complement.  <br /></td></tr>
<tr class="separator:ga618d7dcd03fe042475212cef13c8d158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f2049e1c9f66f9de3bcaeb386890ce" id="r_gac0f2049e1c9f66f9de3bcaeb386890ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0f2049e1c9f66f9de3bcaeb386890ce">regina::columnEchelonForm</a> (<a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;M, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;R, <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;Ri, const std::vector&lt; size_t &gt; &amp;rowList)</td></tr>
<tr class="memdesc:gac0f2049e1c9f66f9de3bcaeb386890ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given matrix into column echelon form with respect to a collection of rows.  <br /></td></tr>
<tr class="separator:gac0f2049e1c9f66f9de3bcaeb386890ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be8656317f0c42b449b68d503432131" id="r_ga0be8656317f0c42b449b68d503432131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0be8656317f0c42b449b68d503432131">regina::preImageOfLattice</a> (const <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;hom, const std::vector&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;sublattice)</td></tr>
<tr class="memdesc:ga0be8656317f0c42b449b68d503432131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a homomorphism from Z^n to Z^k and a sublattice of Z^k, compute the preimage of this sublattice under this homomorphism.  <br /></td></tr>
<tr class="separator:ga0be8656317f0c42b449b68d503432131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50aca1651103070774d22bb4cf4df140" id="r_ga50aca1651103070774d22bb4cf4df140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50aca1651103070774d22bb4cf4df140">regina::torsionAutInverse</a> (const <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;input, const std::vector&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;invF)</td></tr>
<tr class="memdesc:ga50aca1651103070774d22bb4cf4df140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an automorphism of an abelian group, this procedure computes the inverse automorphism.  <br /></td></tr>
<tr class="separator:ga50aca1651103070774d22bb4cf4df140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c1e8d24ec41764e74eec9afc308fd3" id="r_gad5c1e8d24ec41764e74eec9afc308fd3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5c1e8d24ec41764e74eec9afc308fd3">regina::reducedMod</a> (long k, long modBase)</td></tr>
<tr class="memdesc:gad5c1e8d24ec41764e74eec9afc308fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces <em>k</em> modulo <em>modBase</em> to give the smallest possible absolute value.  <br /></td></tr>
<tr class="separator:gad5c1e8d24ec41764e74eec9afc308fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb7e9d7bb70ac83a223d9e4ee907e9f" id="r_ga0bb7e9d7bb70ac83a223d9e4ee907e9f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0bb7e9d7bb70ac83a223d9e4ee907e9f">regina::gcd</a> (long a, long b)</td></tr>
<tr class="memdesc:ga0bb7e9d7bb70ac83a223d9e4ee907e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that calculates the greatest common divisor of two signed integers.  <br /></td></tr>
<tr class="separator:ga0bb7e9d7bb70ac83a223d9e4ee907e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cc7e1857dc83bb8102c1bd81f14d65" id="r_gac1cc7e1857dc83bb8102c1bd81f14d65"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; long, long, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1cc7e1857dc83bb8102c1bd81f14d65">regina::gcdWithCoeffs</a> (long a, long b)</td></tr>
<tr class="memdesc:gac1cc7e1857dc83bb8102c1bd81f14d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the greatest common divisor of two given integers and finds the smallest coefficients with which these integers combine to give their gcd.  <br /></td></tr>
<tr class="separator:gac1cc7e1857dc83bb8102c1bd81f14d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b8bfb17cf71bb3005b1838d30a1fb6" id="r_ga93b8bfb17cf71bb3005b1838d30a1fb6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93b8bfb17cf71bb3005b1838d30a1fb6">regina::lcm</a> (long a, long b)</td></tr>
<tr class="memdesc:ga93b8bfb17cf71bb3005b1838d30a1fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that calculates the lowest common multiple of two signed integers.  <br /></td></tr>
<tr class="separator:ga93b8bfb17cf71bb3005b1838d30a1fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f577a17e0394759896a67e85b20b070" id="r_ga0f577a17e0394759896a67e85b20b070"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f577a17e0394759896a67e85b20b070">regina::modularInverse</a> (long n, long k)</td></tr>
<tr class="memdesc:ga0f577a17e0394759896a67e85b20b070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the multiplicative inverse of one integer modulo another.  <br /></td></tr>
<tr class="separator:ga0f577a17e0394759896a67e85b20b070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79522cfe9691b3825e27a3d0d913e209" id="r_ga79522cfe9691b3825e27a3d0d913e209"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79522cfe9691b3825e27a3d0d913e209">regina::digit</a> (int i)</td></tr>
<tr class="memdesc:ga79522cfe9691b3825e27a3d0d913e209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character used to express the integer <em>i</em> in a permutation.  <br /></td></tr>
<tr class="separator:ga79522cfe9691b3825e27a3d0d913e209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6de79415ac9f777d8015d05df88d0af" id="r_gae6de79415ac9f777d8015d05df88d0af"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6de79415ac9f777d8015d05df88d0af">regina::factorial</a> (int n)</td></tr>
<tr class="memdesc:gae6de79415ac9f777d8015d05df88d0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factorial of <em>n</em>.  <br /></td></tr>
<tr class="separator:gae6de79415ac9f777d8015d05df88d0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958289d50917d6190aef488a6eb31387" id="r_ga958289d50917d6190aef488a6eb31387"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga958289d50917d6190aef488a6eb31387"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga958289d50917d6190aef488a6eb31387">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;p)</td></tr>
<tr class="memdesc:ga958289d50917d6190aef488a6eb31387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string representation of the given permutation to the given output stream.  <br /></td></tr>
<tr class="separator:ga958289d50917d6190aef488a6eb31387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5cab5f1db430c8b084c4416b024d09" id="r_ga5e5cab5f1db430c8b084c4416b024d09"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga5e5cab5f1db430c8b084c4416b024d09"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5e5cab5f1db430c8b084c4416b024d09">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1PermClass.html">PermClass</a>&lt; n &gt; &amp;c)</td></tr>
<tr class="memdesc:ga5e5cab5f1db430c8b084c4416b024d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string representation of the given conjugacy class of permutations to the given output stream.  <br /></td></tr>
<tr class="separator:ga5e5cab5f1db430c8b084c4416b024d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9271cc4e03621b78abd6e6dbb2d53d95" id="r_ga9271cc4e03621b78abd6e6dbb2d53d95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9271cc4e03621b78abd6e6dbb2d53d95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9271cc4e03621b78abd6e6dbb2d53d95">regina::swap</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga9271cc4e03621b78abd6e6dbb2d53d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given polynomials.  <br /></td></tr>
<tr class="separator:ga9271cc4e03621b78abd6e6dbb2d53d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb53c6e937f6c78c948666e615917ac" id="r_gacfb53c6e937f6c78c948666e615917ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacfb53c6e937f6c78c948666e615917ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacfb53c6e937f6c78c948666e615917ac">regina::operator*</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:gacfb53c6e937f6c78c948666e615917ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:gacfb53c6e937f6c78c948666e615917ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b67c6bef3bbc9277100816a38b5c781" id="r_ga5b67c6bef3bbc9277100816a38b5c781"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5b67c6bef3bbc9277100816a38b5c781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5b67c6bef3bbc9277100816a38b5c781">regina::operator*</a> (const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;scalar, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; poly)</td></tr>
<tr class="memdesc:ga5b67c6bef3bbc9277100816a38b5c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:ga5b67c6bef3bbc9277100816a38b5c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac95c8af9aa11a8f8df4ca60b8112dbfc" id="r_gac95c8af9aa11a8f8df4ca60b8112dbfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac95c8af9aa11a8f8df4ca60b8112dbfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac95c8af9aa11a8f8df4ca60b8112dbfc">regina::operator/</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; poly, const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;scalar)</td></tr>
<tr class="memdesc:gac95c8af9aa11a8f8df4ca60b8112dbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the given polynomial by the given scalar constant.  <br /></td></tr>
<tr class="separator:gac95c8af9aa11a8f8df4ca60b8112dbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09599e57ad76e65136191aeadd49a931" id="r_ga09599e57ad76e65136191aeadd49a931"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga09599e57ad76e65136191aeadd49a931"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga09599e57ad76e65136191aeadd49a931">regina::operator+</a> (const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga09599e57ad76e65136191aeadd49a931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga09599e57ad76e65136191aeadd49a931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf6517b2b69e1dea9e3fb27f58887ec" id="r_ga2bf6517b2b69e1dea9e3fb27f58887ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2bf6517b2b69e1dea9e3fb27f58887ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2bf6517b2b69e1dea9e3fb27f58887ec">regina::operator+</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2bf6517b2b69e1dea9e3fb27f58887ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga2bf6517b2b69e1dea9e3fb27f58887ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada00c51958f2df681898f986201f51ee" id="r_gada00c51958f2df681898f986201f51ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada00c51958f2df681898f986201f51ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gada00c51958f2df681898f986201f51ee">regina::operator+</a> (const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:gada00c51958f2df681898f986201f51ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:gada00c51958f2df681898f986201f51ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8fd586f1d41efeafb4d7bf97c50f8d" id="r_ga7a8fd586f1d41efeafb4d7bf97c50f8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a8fd586f1d41efeafb4d7bf97c50f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7a8fd586f1d41efeafb4d7bf97c50f8d">regina::operator+</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga7a8fd586f1d41efeafb4d7bf97c50f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two given polynomials.  <br /></td></tr>
<tr class="separator:ga7a8fd586f1d41efeafb4d7bf97c50f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7bdb9bc63dfce539d6faa38d842d892" id="r_gad7bdb9bc63dfce539d6faa38d842d892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad7bdb9bc63dfce539d6faa38d842d892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad7bdb9bc63dfce539d6faa38d842d892">regina::operator-</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; arg)</td></tr>
<tr class="memdesc:gad7bdb9bc63dfce539d6faa38d842d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative of the given polynomial.  <br /></td></tr>
<tr class="separator:gad7bdb9bc63dfce539d6faa38d842d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0364fc9032544d5eabe5989ebe1b82cd" id="r_ga0364fc9032544d5eabe5989ebe1b82cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0364fc9032544d5eabe5989ebe1b82cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0364fc9032544d5eabe5989ebe1b82cd">regina::operator-</a> (const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0364fc9032544d5eabe5989ebe1b82cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga0364fc9032544d5eabe5989ebe1b82cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02291b373a229837611436724e1e7142" id="r_ga02291b373a229837611436724e1e7142"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02291b373a229837611436724e1e7142"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga02291b373a229837611436724e1e7142">regina::operator-</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga02291b373a229837611436724e1e7142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga02291b373a229837611436724e1e7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8886658656e73de83ae29d8b8a4cfe21" id="r_ga8886658656e73de83ae29d8b8a4cfe21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8886658656e73de83ae29d8b8a4cfe21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8886658656e73de83ae29d8b8a4cfe21">regina::operator-</a> (const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;lhs, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga8886658656e73de83ae29d8b8a4cfe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga8886658656e73de83ae29d8b8a4cfe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445605c38ed64b079c0146d569c76234" id="r_ga445605c38ed64b079c0146d569c76234"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga445605c38ed64b079c0146d569c76234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga445605c38ed64b079c0146d569c76234">regina::operator-</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;lhs, <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ga445605c38ed64b079c0146d569c76234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the two given polynomials.  <br /></td></tr>
<tr class="separator:ga445605c38ed64b079c0146d569c76234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10d7097adba9d9aa495f542f9217667" id="r_gaf10d7097adba9d9aa495f542f9217667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf10d7097adba9d9aa495f542f9217667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf10d7097adba9d9aa495f542f9217667">regina::operator*</a> (const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf10d7097adba9d9aa495f542f9217667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two given polynomials.  <br /></td></tr>
<tr class="separator:gaf10d7097adba9d9aa495f542f9217667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9554051e4f6f185e9d3d97a3836902" id="r_gaeb9554051e4f6f185e9d3d97a3836902"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaeb9554051e4f6f185e9d3d97a3836902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeb9554051e4f6f185e9d3d97a3836902">regina::operator/</a> (<a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; lhs, const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaeb9554051e4f6f185e9d3d97a3836902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the two given polynomials.  <br /></td></tr>
<tr class="separator:gaeb9554051e4f6f185e9d3d97a3836902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8be8e91b1742b3882e85377d23109a3" id="r_gae8be8e91b1742b3882e85377d23109a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8be8e91b1742b3882e85377d23109a3">regina::swap</a> (<a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;a, <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:gae8be8e91b1742b3882e85377d23109a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given rationals.  <br /></td></tr>
<tr class="separator:gae8be8e91b1742b3882e85377d23109a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345f8b2bd10ead2b33f45693685f4fa8" id="r_ga345f8b2bd10ead2b33f45693685f4fa8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga345f8b2bd10ead2b33f45693685f4fa8">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;rat)</td></tr>
<tr class="memdesc:ga345f8b2bd10ead2b33f45693685f4fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given rational to the given output stream.  <br /></td></tr>
<tr class="separator:ga345f8b2bd10ead2b33f45693685f4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42ddfa6fb96263d510b53ba5f9a4bf6" id="r_gae42ddfa6fb96263d510b53ba5f9a4bf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae42ddfa6fb96263d510b53ba5f9a4bf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae42ddfa6fb96263d510b53ba5f9a4bf6">regina::swap</a> (<a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae42ddfa6fb96263d510b53ba5f9a4bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given vectors.  <br /></td></tr>
<tr class="separator:gae42ddfa6fb96263d510b53ba5f9a4bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed931495078c1c59d7016a099eb38d1" id="r_gabed931495078c1c59d7016a099eb38d1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabed931495078c1c59d7016a099eb38d1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabed931495078c1c59d7016a099eb38d1">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gabed931495078c1c59d7016a099eb38d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given vector to the given output stream.  <br /></td></tr>
<tr class="separator:gabed931495078c1c59d7016a099eb38d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7db2a4173e00dd5232fa395caa80ca3a" id="r_ga7db2a4173e00dd5232fa395caa80ca3a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7db2a4173e00dd5232fa395caa80ca3a">regina::detail::binomSmall_</a> [17][17]</td></tr>
<tr class="memdesc:ga7db2a4173e00dd5232fa395caa80ca3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lookup table that stores (<em>n</em> choose <em>k</em>) for all <em>n</em> ≤ <em>16</em>.  <br /></td></tr>
<tr class="separator:ga7db2a4173e00dd5232fa395caa80ca3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Underlying mathematical gruntwork. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6ecbbcb8b1e292eb5bf7dccca4be31bf" name="ga6ecbbcb8b1e292eb5bf7dccca4be31bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecbbcb8b1e292eb5bf7dccca4be31bf">&#9670;&#160;</a></span>mpz_cmp_si_cpp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpz_cmp_si_cpp</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>si</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An internal copy of the GMP signed comparison optimisations. </p>
<p>This macro should not be used outside this class.</p>
<p>By making our own copy of such optimisation macros we can use C++-style casts instead of C-style casts and avoid noisy compiler warnings. I'd love a better way of doing this. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6ea6ee3343b36485a2ffcc441e7e17ac" name="ga6ea6ee3343b36485a2ffcc441e7e17ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">&#9670;&#160;</a></span>Integer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">regina::Integer</a> = <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer is a type alias for <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase&lt;false&gt;</a>, which offers arbitrary precision integers without support for infinity. </p>

</div>
</div>
<a id="ga09ee46ba09e6de43ed86f26fe90b81f9" name="ga09ee46ba09e6de43ed86f26fe90b81f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ee46ba09e6de43ed86f26fe90b81f9">&#9670;&#160;</a></span>LargeInteger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga09ee46ba09e6de43ed86f26fe90b81f9">regina::LargeInteger</a> = <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with support for infinity. </p>

</div>
</div>
<a id="ga5f885c624db0ced0d10ab3057ac6e4c0" name="ga5f885c624db0ced0d10ab3057ac6e4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f885c624db0ced0d10ab3057ac6e4c0">&#9670;&#160;</a></span>MatrixBool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga5f885c624db0ced0d10ab3057ac6e4c0">regina::MatrixBool</a> = <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt;bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of booleans. </p>
<p>This is used in a handful of places in Regina to represent incidence or adjacency matrices.</p>
<dl class="section user"><dt>Python</dt><dd>This instance of the <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> template class is made available to Python. </dd></dl>

</div>
</div>
<a id="ga03a9df11c8b8434e6ba30d1dc1fc50f6" name="ga03a9df11c8b8434e6ba30d1dc1fc50f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">&#9670;&#160;</a></span>MatrixInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">regina::MatrixInt</a> = <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt;<a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of arbitrary-precision integers. </p>
<p>This is the most common class used by Regina when running algebraic algorithms over integer matrices. Since the underlying type is Regina's Integer class, calculations will be exact regardless of how large the integers become.</p>
<dl class="section user"><dt>Python</dt><dd>This instance of the <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> template class is made available to Python. </dd></dl>

</div>
</div>
<a id="ga00d7b6494ae06bfac341b2c0722c1943" name="ga00d7b6494ae06bfac341b2c0722c1943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d7b6494ae06bfac341b2c0722c1943">&#9670;&#160;</a></span>NativeLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga00d7b6494ae06bfac341b2c0722c1943">regina::NativeLong</a> = <a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt;sizeof(long)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NativeLong is a type alias for the <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a> template class whose underlying integer type is a native long. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a> classes are not available to Python users. </dd></dl>

</div>
</div>
<a id="gae3fad760ce1aacdbfef978d52f620e2c" name="gae3fad760ce1aacdbfef978d52f620e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fad760ce1aacdbfef978d52f620e2c">&#9670;&#160;</a></span>VectorInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gae3fad760ce1aacdbfef978d52f620e2c">regina::VectorInt</a> = <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of arbitrary-precision integers. </p>
<p>This is the underlying vector class that Regina uses to store angle structures.</p>
<dl class="section user"><dt>Python</dt><dd>This instance of the <a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> template class is made available to Python. </dd></dl>

</div>
</div>
<a id="ga2c2c36ac76c2c080374f654bbada2506" name="ga2c2c36ac76c2c080374f654bbada2506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2c36ac76c2c080374f654bbada2506">&#9670;&#160;</a></span>VectorLarge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2c2c36ac76c2c080374f654bbada2506">regina::VectorLarge</a> = <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of arbitrary-precision integers that allows infinite elements. </p>
<p>This is the underlying vector class that Regina uses to store normal surfaces and hypersurfaces.</p>
<dl class="section user"><dt>Python</dt><dd>This instance of the <a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> template class is made available to Python. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae8090c7366267fc9deefd4927be21476" name="gae8090c7366267fc9deefd4927be21476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8090c7366267fc9deefd4927be21476">&#9670;&#160;</a></span>PermCodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gae8090c7366267fc9deefd4927be21476">regina::PermCodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the different kinds of internal permutation codes that are used in Regina's various Perm&lt;n&gt; template classes. </p>
<p>See the Perm&lt;n&gt; class notes for more information on exactly how these codes are constructed. The class constant <a class="el" href="classregina_1_1Perm.html#a8f6fa6a6e2c773ecaff1229fee7c9dd1" title="Indicates what type of internal permutation code is used by this instance of the Perm class template.">Perm&lt;n&gt;::codeType</a> indicates which type of code is used for which <em>n</em>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae8090c7366267fc9deefd4927be21476afff0d600f8a0b5e19e88bfb821dd1157" name="ggae8090c7366267fc9deefd4927be21476afff0d600f8a0b5e19e88bfb821dd1157"></a>Images&#160;</td><td class="fielddoc"><p>This is a permutation code that packs the images of 0,...,<em>n</em>-1 into a single native integer using a handful of bits per image. </p>
<p>Such codes are easier to manipulate on an element-by-element basis.</p>
<p>Codes of this type can always be queried using <a class="el" href="classregina_1_1Perm.html#a2441b248d28aed6a7775c6515d3ee91d" title="Returns the internal code representing this permutation.">Perm&lt;n&gt;::permCode()</a>, and permutations can be recreated from them using <a class="el" href="classregina_1_1Perm.html#a5ed9840350bcd33b5793c83dc1081c7b" title="Creates a permutation from the given internal code.">Perm&lt;n&gt;::fromPermCode()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae8090c7366267fc9deefd4927be21476a88fa71f0a6e0dfedbb46d91cc0b37a50" name="ggae8090c7366267fc9deefd4927be21476a88fa71f0a6e0dfedbb46d91cc0b37a50"></a>Index&#160;</td><td class="fielddoc"><p>This is a permutation code that stores the index into the full permutation group <em>S_n</em>. </p>
<p>Such codes typically require fewer bytes and are packed together, making them ideal for working with lookup tables.</p>
<p>Codes of this type can be queried using <a class="el" href="classregina_1_1Perm.html#a9735dd0921cdf0214d31c2397798a1ae" title="Returns the index of this permutation in the Perm&lt;n&gt;::Sn array.">Perm&lt;n&gt;::SnIndex()</a>, and permutations can be recreated from them by indexing into <a class="el" href="classregina_1_1Perm.html#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The routines <a class="el" href="classregina_1_1Perm.html#a2441b248d28aed6a7775c6515d3ee91d" title="Returns the internal code representing this permutation.">Perm&lt;n&gt;::permCode()</a> and <a class="el" href="classregina_1_1Perm.html#a5ed9840350bcd33b5793c83dc1081c7b" title="Creates a permutation from the given internal code.">Perm&lt;n&gt;::fromPermCode()</a> will still be present, but in some classes (e.g., <a class="el" href="classregina_1_1Perm_3_014_01_4.html" title="Represents a permutation of {0,1,2,3}.">Perm&lt;4&gt;</a> and <a class="el" href="classregina_1_1Perm_3_015_01_4.html" title="Represents a permutation of {0,1,2,3,4}.">Perm&lt;5&gt;</a>), these are legacy routines that refer to different types of codes. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga12bdb34817179ccd0ad99fd7d2033dce" name="ga12bdb34817179ccd0ad99fd7d2033dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bdb34817179ccd0ad99fd7d2033dce">&#9670;&#160;</a></span>binomMedium()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int_fast64_t regina::binomMedium </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the binomial coefficient <em>n</em> choose <em>k</em> in linear time for medium-sized arguments (<em>n</em> ≤ 61). </p>
<p>This routine computes the binomial coefficient using the standard formula. It works entirely with native integers of a large enough size; the constraint <em>n</em> ≤ 61 is designed to avoid overflow (since all intermediate results are guaranteed to stay below 2^63).</p>
<p>If <em>n</em> ≤ 16 then this routine will use the same constant-time lookup as <a class="el" href="#ga3b6dccba582fc983e1ea9d27fdd634ab" title="Returns the binomial coefficient n choose k in constant time for small arguments (n ≤ 16).">binomSmall()</a> (i.e., there is no penalty for calling this routine with very small arguments).</p>
<p>If <em>k</em> is outside the usual range (i.e., <em>k</em> is negative or greater than <em>n</em>), then this routine will return 0.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>n</em> is negative or greater than 61.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the parameter <em>n</em> in (<em>n</em> choose <em>k</em>); this must be between 0 and 61 inclusive. </td></tr>
    <tr><td class="paramname">k</td><td>the parameter <em>k</em> in (<em>n</em> choose <em>k</em>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the binomial coefficient <em>n</em> choose <em>k</em>. </dd></dl>

</div>
</div>
<a id="ga3b6dccba582fc983e1ea9d27fdd634ab" name="ga3b6dccba582fc983e1ea9d27fdd634ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6dccba582fc983e1ea9d27fdd634ab">&#9670;&#160;</a></span>binomSmall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::binomSmall </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the binomial coefficient <em>n</em> choose <em>k</em> in constant time for small arguments (<em>n</em> ≤ 16). </p>
<p>This routine is very fast, since it uses a constant-time lookup. The trade-off is that it can only be used for <em>n</em> ≤ 16.</p>
<dl class="section note"><dt>Note</dt><dd>The constraint <em>n</em> ≤ 16 is large enough for working with triangulations in Regina, since Regina restricts its triangulations to dimension ≤ 15 (where each simplex has 16 vertices).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. As of Regina 7.4, this function is <code>consteval</code> which means it cannot be used at runtime, and therefore cannot be used in Python at all. Python users should call <a class="el" href="#ga12bdb34817179ccd0ad99fd7d2033dce" title="Returns the binomial coefficient n choose k in linear time for medium-sized arguments (n ≤ 61).">binomMedium()</a> instead, which will be just as fast for arguments n ≤ 16.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the parameter <em>n</em> in (<em>n</em> choose <em>k</em>); this must be between 0 and 16 inclusive. </td></tr>
    <tr><td class="paramname">k</td><td>the parameter <em>k</em> in (<em>n</em> choose <em>k</em>); this must be between 0 and <em>n</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the binomial coefficient <em>n</em> choose <em>k</em>. </dd></dl>

</div>
</div>
<a id="gac0f2049e1c9f66f9de3bcaeb386890ce" name="gac0f2049e1c9f66f9de3bcaeb386890ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f2049e1c9f66f9de3bcaeb386890ce">&#9670;&#160;</a></span>columnEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::columnEchelonForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Ri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rowList</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a given matrix into column echelon form with respect to a collection of rows. </p>
<p>The transformation will perform only column operations.</p>
<p>Given the matrix <em>M</em> and the list <em>rowList</em> of rows from <em>M</em>, this algorithm puts <em>M</em> in column echelon form with respect to the rows in <em>rowList</em>. The only purpose of <em>rowList</em> is to clarify and/or weaken precisely what is meant by "column echelon form"; all rows of <em>M</em> are affected by the resulting column operations that take place.</p>
<p>This routine also returns the corresponding change of coordinate matrices <em>R</em> and <em>Ri:</em> </p>
<ul>
<li>The matrix <em>R</em> will have precisely the same column operations applied to it as the matrix <em>M</em>. The matrix <em>Ri</em> will have the inverse <em>row</em> operations applied to it, thereby maintaining a constant value of the product <code>R * Ri</code> as the algorithm runs.</li>
<li>In particular, if <em>R</em> and <em>Ri</em> are passed into this routine as square identity matrices, then after the reduction is complete we will have <code>original_M * R = final_M</code> and <code>final_M * Ri = original_M</code>.</li>
</ul>
<p>Our convention is that a matrix is in column echelon form if:</p>
<ul>
<li>each column is either zero or there is a first non-zero entry which is positive (but see the note regarding <em>rowList</em> below);</li>
<li>moving from the leftmost column to the rightmost column, the rows containing the first non-zero entries for these columns have strictly increasing indices in <em>rowList</em>;</li>
<li>given a first non-zero column entry, in that row all the elements to the left are smaller and non-negative (all elements to the right are already zero by the previous condition);</li>
<li>all the zero columns are on the right hand side of the matrix.</li>
</ul>
<p>By a "zero column" here we simply mean "zero for every row in \a
rowList". Likewise, by "first non-zero entry" we mean "first row in
\a rowList with a non-zero entry".</p>
<p>In a pinch, you can also use this routine to compute the inverse of an invertible square matrix.</p>
<p>If you just wish to reduce the matrix, you do not care about the order of rows, and you do not want the change-of-basis matrices, then you should call <a class="el" href="classregina_1_1Matrix.html#aca9b085afd6017ff5cec350664de3fa0">MatrixInt::columnEchelonForm()</a> instead, which is simpler but also more streamlined.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>n</em> is the number of <em>columns</em> in <em>M</em>, then <em>R</em> has precisely <em>n</em> columns also, and <em>Ri</em> has precisely <em>n</em> rows.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Either `R.columns() ≠ M.columns()`, and/or <code>Ri.rows() ≠ M.columns()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the matrix to reduce. </td></tr>
    <tr><td class="paramname">R</td><td>used to return the row-reduction matrix, as described above. </td></tr>
    <tr><td class="paramname">Ri</td><td>used to return the inverse of <em>R</em>. </td></tr>
    <tr><td class="paramname">rowList</td><td>the rows to pay attention to. This list must contain distinct integers, all between 0 and M.rows()-1 inclusive (though it need not contain <em>all</em> of these integers). The integers may appear in any order (though changing the order will change the resulting column echelon form). For a "classical" column echelon form, this would be the list of all rows: <code>0,...,(M.rows()-1)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="ga79522cfe9691b3825e27a3d0d913e209" name="ga79522cfe9691b3825e27a3d0d913e209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79522cfe9691b3825e27a3d0d913e209">&#9670;&#160;</a></span>digit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::digit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character used to express the integer <em>i</em> in a permutation. </p>
<ul>
<li>For <em>i</em> = 0,...,9, this will be the usual digit representing <em>i</em>.</li>
<li>For <em>i</em> ≥ 10, this will be a lower-case letter. In particular, for <em>i</em> = 10,...,15, this will be the usual hexadecimal digit representing <em>i</em>.</li>
<li>At present, this routine only supports integers <em>i</em> &lt; 36.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the integer to represent; this must be between 0 and 35 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single character used to represent <em>i</em>. </dd></dl>

</div>
</div>
<a id="gae6de79415ac9f777d8015d05df88d0af" name="gae6de79415ac9f777d8015d05df88d0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6de79415ac9f777d8015d05df88d0af">&#9670;&#160;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t regina::factorial </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the factorial of <em>n</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any non-negative integer; this must be at most 20 (since otherwise the factorial will overflow). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the factorial of <em>n</em>.. </dd></dl>

</div>
</div>
<a id="ga0bb7e9d7bb70ac83a223d9e4ee907e9f" name="ga0bb7e9d7bb70ac83a223d9e4ee907e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb7e9d7bb70ac83a223d9e4ee907e9f">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::gcd </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that calculates the greatest common divisor of two signed integers. </p>
<p>This routine is not recursive.</p>
<p>Although the arguments may be negative, the result is guaranteed to be non-negative. As a special case, gcd(0,0) is considered to be zero.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated</a></b></dt><dd>Simply use std::gcd(), which was introduced with C++17.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one of the two integers to work with. </td></tr>
    <tr><td class="paramname">b</td><td>the other integer with which to work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a id="gac1cc7e1857dc83bb8102c1bd81f14d65" name="gac1cc7e1857dc83bb8102c1bd81f14d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cc7e1857dc83bb8102c1bd81f14d65">&#9670;&#160;</a></span>gcdWithCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; long, long, long &gt; regina::gcdWithCoeffs </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the greatest common divisor of two given integers and finds the smallest coefficients with which these integers combine to give their gcd. </p>
<p>This routine is not recursive.</p>
<p>Note that the given integers need not be non-negative. However, the gcd returned is guaranteed to be non-negative. As a special case, gcd(0,0) is considered to be zero.</p>
<p>If <em>d</em> is the gcd of <em>a</em> and <em>b</em>, then this routine returns the tuple (<em>d</em>, <em>u</em>, <em>v</em>), where <em>u</em> and <em>v</em> are coefficients for which:</p>
<ul>
<li><code>u⋅a + v⋅b = d</code>;</li>
<li><code>-|a|/d &lt; v⋅sign(b) ≤ 0 &lt; u⋅sign(a) ≤ |b|/d</code>.</li>
</ul>
<p>In the special case where one of the given integers is zero, the corresponding coefficient will also be zero and the other coefficient will be 1 or -1 so that <code>u⋅a + v⋅b = d</code> still holds. If both given integers are zero, both of the coefficients will be set to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine might give incorrect answers if a or b is precisely LONG_MIN, since this value cannot be correctly negated as a <code>long</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer to compute the gcd of. </td></tr>
    <tr><td class="paramname">b</td><td>the second integer to compute the gcd of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple containing: the greatest common divisor of <em>a</em> and <em>b</em>; the final coefficient of <em>a</em>; and the final coefficient of <em>b</em>. </dd></dl>

</div>
</div>
<a id="ga93b8bfb17cf71bb3005b1838d30a1fb6" name="ga93b8bfb17cf71bb3005b1838d30a1fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b8bfb17cf71bb3005b1838d30a1fb6">&#9670;&#160;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::lcm </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that calculates the lowest common multiple of two signed integers. </p>
<p>Although the arguments may be negative, the result is guaranteed to be non-negative.</p>
<p>If either of the arguments is zero, the return value will also be zero.</p>
<p>Regarding possible overflow: This routine does not create any temporary integers that are larger in magnitude than the final LCM.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated</a></b></dt><dd>Simply use std::lcm(), which was introduced with C++17.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one of the two integers to work with. </td></tr>
    <tr><td class="paramname">b</td><td>the other integer with which to work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lowest common multiple of <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a id="ga9499002f32f341b62773264749a194db" name="ga9499002f32f341b62773264749a194db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9499002f32f341b62773264749a194db">&#9670;&#160;</a></span>metricalSmithNormalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::metricalSmithNormalForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rowSpaceBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rowSpaceBasisInv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>colSpaceBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>colSpaceBasisInv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alternative Smith normal form algorithm that also returns change of basis matrices. </p>
<p>This routine may be preferable for extremely large matrices. This is a variant of Hafner-McCurley and Havas-Holt-Rees's description of pivoting methods.</p>
<p>The only input argument is <em>matrix</em>. The four remaining arguments (the change of basis matrices) will be refilled. All five arguments are used to return information as follows.</p>
<p>Let <em>M</em> be the initial value of <em>matrix</em>, and let <em>S</em> be the Smith normal form of <em>M</em>. After this routine exits:</p>
<ul>
<li>The argument <em>matrix</em> will contain the Smith normal form <em>S</em>;</li>
<li><code>colSpaceBasis * M * rowSpaceBasis = S</code>;</li>
<li><code>colSpaceBasisInv * S * rowSpaceBasisInv = M</code>;</li>
<li><code>colSpaceBasis * colSpaceBasisInv</code> and <code>rowSpaceBasis * rowSpaceBasisInv</code> are both identity matrices.</li>
</ul>
<p>Thus, one obtains the Smith normal form the original matrix by multiplying on the left by ColSpaceBasis and on the right by RowSpaceBasis.</p>
<p>The matrices <em>rowSpaceBasis</em> and <em>rowSpaceBasisInv</em> that are passed may be of any size, or they may even be uninitialised; upon return they will both be square with side length matrix.columns(). Likewise, the matrices <em>colSpaceBasis</em> and <em>colSpaceBasisInv</em> that are passed may be of any size or may be uninitialised; upon return they will both be square with side length matrix.rows().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the original matrix to put into Smith Normal Form (this need not be square). When the algorithm terminates, this matrix <em>is</em> in its Smith Normal Form. </td></tr>
    <tr><td class="paramname">rowSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">rowSpaceBasisInv</td><td>used to return the inverse of <em>rowSpaceBasis</em>. </td></tr>
    <tr><td class="paramname">colSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">colSpaceBasisInv</td><td>used to return the inverse of <em>colSpaceBasis</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="ga0f577a17e0394759896a67e85b20b070" name="ga0f577a17e0394759896a67e85b20b070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f577a17e0394759896a67e85b20b070">&#9670;&#160;</a></span>modularInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::modularInverse </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the multiplicative inverse of one integer modulo another. </p>
<p>Specifically, this computes the inverse of <em>k</em> modulo <em>n</em>, and returns a result between 0 and <code>n - 1</code> inclusive.</p>
<p>Note that <code>n == 1</code> <em>is</em> allowed, and will return 0 for any <em>k</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>n</em> is strictly positive; </dd>
<dd>
<em>n</em> and <em>k</em> are coprime.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Either <em>n</em> is zero or negative, or the given arguments are not coprime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the modular base in which to work. </td></tr>
    <tr><td class="paramname">k</td><td>the number whose multiplicative inverse should be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse <em>v</em> for which <code>k * v == 1 (mod n)</code>. </dd></dl>

</div>
</div>
<a id="ga8e04cdf43e104204ac55917aba1f3ea4" name="ga8e04cdf43e104204ac55917aba1f3ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e04cdf43e104204ac55917aba1f3ea4">&#9670;&#160;</a></span>operator*() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a></td>          <td class="paramname"><span class="paramname"><em>arrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>laurent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given arrow polynomial by the given <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <code>A</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrow</td><td>the arrow polynomial to multiply by. </td></tr>
    <tr><td class="paramname">laurent</td><td>the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial to multiply by; this will be treated as a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the ordinary variable <code>A</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given arrow and <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </dd></dl>

</div>
</div>
<a id="ga3da2e19e0953ef1bee21156c1260e061" name="ga3da2e19e0953ef1bee21156c1260e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da2e19e0953ef1bee21156c1260e061">&#9670;&#160;</a></span>operator*() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a></td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given integer constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar factor to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="ga19924a442a9a5a8b8cd7bcc471d7e443" name="ga19924a442a9a5a8b8cd7bcc471d7e443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19924a442a9a5a8b8cd7bcc471d7e443">&#9670;&#160;</a></span>operator*() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga511574e229c46b89a4bae0cb203b6e94" name="ga511574e229c46b89a4bae0cb203b6e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511574e229c46b89a4bae0cb203b6e94">&#9670;&#160;</a></span>operator*() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first field element to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second field element to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of both field elements. </dd></dl>

</div>
</div>
<a id="gacc9f677a4160356445e139f7b8b62161" name="gacc9f677a4160356445e139f7b8b62161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9f677a4160356445e139f7b8b62161">&#9670;&#160;</a></span>operator*() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a></td>          <td class="paramname"><span class="paramname"><em>poly</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given integer constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to multiply by. </td></tr>
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="gad5fad4e753022f32d41927d65398e2ee" name="gad5fad4e753022f32d41927d65398e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5fad4e753022f32d41927d65398e2ee">&#9670;&#160;</a></span>operator*() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of both polynomials. </dd></dl>

</div>
</div>
<a id="gacb4547463696a545700c7516c337e995" name="gacb4547463696a545700c7516c337e995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4547463696a545700c7516c337e995">&#9670;&#160;</a></span>operator*() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>laurent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a></td>          <td class="paramname"><span class="paramname"><em>arrow</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given arrow polynomial by the given <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <code>A</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">laurent</td><td>the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial to multiply by; this will be treated as a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the ordinary variable <code>A</code>. </td></tr>
    <tr><td class="paramname">arrow</td><td>the arrow polynomial to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given arrow and <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </dd></dl>

</div>
</div>
<a id="gab97959d063caf380a41e1cd8998fe8c3" name="gab97959d063caf380a41e1cd8998fe8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97959d063caf380a41e1cd8998fe8c3">&#9670;&#160;</a></span>operator*() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of both polynomials. </dd></dl>

</div>
</div>
<a id="gaf10d7097adba9d9aa495f542f9217667" name="gaf10d7097adba9d9aa495f542f9217667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10d7097adba9d9aa495f542f9217667">&#9670;&#160;</a></span>operator*() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of both polynomials. </dd></dl>

</div>
</div>
<a id="ga06c949c5925ab83b3de51cf7f22e9547" name="ga06c949c5925ab83b3de51cf7f22e9547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c949c5925ab83b3de51cf7f22e9547">&#9670;&#160;</a></span>operator*() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a></td>          <td class="paramname"><span class="paramname"><em>elt</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given field element by the given rational. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the rational to multiply by. </td></tr>
    <tr><td class="paramname">elt</td><td>the field element to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given field element and rational. </dd></dl>

</div>
</div>
<a id="ga0a3bc28c6d3e9d9c0c1a1949407d97ef" name="ga0a3bc28c6d3e9d9c0c1a1949407d97ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3bc28c6d3e9d9c0c1a1949407d97ef">&#9670;&#160;</a></span>operator*() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a" title="The type of each coefficient of the polynomial.">Laurent2&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="ga1464fd6fc66da7181d5d9e9413df091d" name="ga1464fd6fc66da7181d5d9e9413df091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1464fd6fc66da7181d5d9e9413df091d">&#9670;&#160;</a></span>operator*() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent.html#ac5415cf78943d61487a2e7b3992dc2d0" title="The type of each coefficient of the polynomial.">Laurent&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="ga5b67c6bef3bbc9277100816a38b5c781" name="ga5b67c6bef3bbc9277100816a38b5c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b67c6bef3bbc9277100816a38b5c781">&#9670;&#160;</a></span>operator*() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Polynomial.html#a339223de6de9828ebbb7ccb8ee8b75ea" title="The type of each coefficient of the polynomial.">Polynomial&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="gae66807f120ff00334a07f910b7aa3bd7" name="gae66807f120ff00334a07f910b7aa3bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae66807f120ff00334a07f910b7aa3bd7">&#9670;&#160;</a></span>operator*() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a></td>          <td class="paramname"><span class="paramname"><em>elt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given field element by the given rational. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>the field element to multiply by. </td></tr>
    <tr><td class="paramname">scalar</td><td>the rational to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given field element and rational. </dd></dl>

</div>
</div>
<a id="ga8b8f9efcce3be09a0ab85458058a5c9d" name="ga8b8f9efcce3be09a0ab85458058a5c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8f9efcce3be09a0ab85458058a5c9d">&#9670;&#160;</a></span>operator*() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a" title="The type of each coefficient of the polynomial.">Laurent2&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="gadadb9e18385a09e05adb6197c32b1188" name="gadadb9e18385a09e05adb6197c32b1188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadadb9e18385a09e05adb6197c32b1188">&#9670;&#160;</a></span>operator*() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent.html#ac5415cf78943d61487a2e7b3992dc2d0" title="The type of each coefficient of the polynomial.">Laurent&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="gaa4d732b736f8cd9f48fbfb7b29ea021d" name="gaa4d732b736f8cd9f48fbfb7b29ea021d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d732b736f8cd9f48fbfb7b29ea021d">&#9670;&#160;</a></span>operator*() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given native integer with the given large integer. </p>
<p>If the large integer is infinite, the result will also be infinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the native integer to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the large integer to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product <em>lhs</em> times <em>rhs</em>. </dd></dl>

</div>
</div>
<a id="gacfb53c6e937f6c78c948666e615917ac" name="gacfb53c6e937f6c78c948666e615917ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb53c6e937f6c78c948666e615917ac">&#9670;&#160;</a></span>operator*() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given polynomial by the given scalar constant. </p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Polynomial.html#a339223de6de9828ebbb7ccb8ee8b75ea" title="The type of each coefficient of the polynomial.">Polynomial&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to multiply by. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the given polynomial and scalar. </dd></dl>

</div>
</div>
<a id="gac963beb7dc09011f4f8dd0811dda4334" name="gac963beb7dc09011f4f8dd0811dda4334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac963beb7dc09011f4f8dd0811dda4334">&#9670;&#160;</a></span>operator+() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga13d2de6168cbe0d361388ceaf254b85e" name="ga13d2de6168cbe0d361388ceaf254b85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d2de6168cbe0d361388ceaf254b85e">&#9670;&#160;</a></span>operator+() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga3d708584d8796cf3ccb3005f67a7edf2" name="ga3d708584d8796cf3ccb3005f67a7edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d708584d8796cf3ccb3005f67a7edf2">&#9670;&#160;</a></span>operator+() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga5abc98d9c5bc347db11af397f573bdb7" name="ga5abc98d9c5bc347db11af397f573bdb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5abc98d9c5bc347db11af397f573bdb7">&#9670;&#160;</a></span>operator+() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga2ef69b52b11337a042216f3e57562e1f" name="ga2ef69b52b11337a042216f3e57562e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ef69b52b11337a042216f3e57562e1f">&#9670;&#160;</a></span>operator+() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first field element to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second field element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both field elements. </dd></dl>

</div>
</div>
<a id="gafe173d208150767d2489e23aa2112db4" name="gafe173d208150767d2489e23aa2112db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe173d208150767d2489e23aa2112db4">&#9670;&#160;</a></span>operator+() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first field element to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second field element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both field elements. </dd></dl>

</div>
</div>
<a id="gabc20446f3eaa1e6e69a00ddaa0899f2e" name="gabc20446f3eaa1e6e69a00ddaa0899f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc20446f3eaa1e6e69a00ddaa0899f2e">&#9670;&#160;</a></span>operator+() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga1da1f2d7cc3ccf5868beb18f272f80d5" name="ga1da1f2d7cc3ccf5868beb18f272f80d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da1f2d7cc3ccf5868beb18f272f80d5">&#9670;&#160;</a></span>operator+() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga05bc2d020478e794808557a56819db10" name="ga05bc2d020478e794808557a56819db10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bc2d020478e794808557a56819db10">&#9670;&#160;</a></span>operator+() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga227446e24c68af8fd7f7b1f2fd94d8ec" name="ga227446e24c68af8fd7f7b1f2fd94d8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga227446e24c68af8fd7f7b1f2fd94d8ec">&#9670;&#160;</a></span>operator+() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga09599e57ad76e65136191aeadd49a931" name="ga09599e57ad76e65136191aeadd49a931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09599e57ad76e65136191aeadd49a931">&#9670;&#160;</a></span>operator+() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="gada00c51958f2df681898f986201f51ee" name="gada00c51958f2df681898f986201f51ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada00c51958f2df681898f986201f51ee">&#9670;&#160;</a></span>operator+() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="gaee0a0325a636a2cda313b9ee76c6700c" name="gaee0a0325a636a2cda313b9ee76c6700c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0a0325a636a2cda313b9ee76c6700c">&#9670;&#160;</a></span>operator+() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first field element to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second field element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both field elements. </dd></dl>

</div>
</div>
<a id="gaf02d7185bac78d1d9e8d7e3df261b06c" name="gaf02d7185bac78d1d9e8d7e3df261b06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02d7185bac78d1d9e8d7e3df261b06c">&#9670;&#160;</a></span>operator+() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first field element to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second field element to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both field elements. </dd></dl>

</div>
</div>
<a id="ga8b830131a72788b1a55887e9de678df3" name="ga8b830131a72788b1a55887e9de678df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b830131a72788b1a55887e9de678df3">&#9670;&#160;</a></span>operator+() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga426632ac5fb0a8c43c8b8029477c60a2" name="ga426632ac5fb0a8c43c8b8029477c60a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426632ac5fb0a8c43c8b8029477c60a2">&#9670;&#160;</a></span>operator+() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga1739b0949f80233bb811a0d7c22bcd63" name="ga1739b0949f80233bb811a0d7c22bcd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1739b0949f80233bb811a0d7c22bcd63">&#9670;&#160;</a></span>operator+() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga15f7badfb3b93c80ea0bef4016322526" name="ga15f7badfb3b93c80ea0bef4016322526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f7badfb3b93c80ea0bef4016322526">&#9670;&#160;</a></span>operator+() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="gad4abce8443e3a8b2901da90fc4ebcf55" name="gad4abce8443e3a8b2901da90fc4ebcf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4abce8443e3a8b2901da90fc4ebcf55">&#9670;&#160;</a></span>operator+() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given native integer to the given large integer. </p>
<p>If the large integer is infinite, the result will also be infinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the native integer to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the large integer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum <em>lhs</em> plus <em>rhs</em>. </dd></dl>

</div>
</div>
<a id="ga2bf6517b2b69e1dea9e3fb27f58887ec" name="ga2bf6517b2b69e1dea9e3fb27f58887ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf6517b2b69e1dea9e3fb27f58887ec">&#9670;&#160;</a></span>operator+() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga7a8fd586f1d41efeafb4d7bf97c50f8d" name="ga7a8fd586f1d41efeafb4d7bf97c50f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8fd586f1d41efeafb4d7bf97c50f8d">&#9670;&#160;</a></span>operator+() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the two given polynomials. </p>
<p>This operator <code>+</code> is sometimes faster than using <code>+=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first polynomial to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second polynomial to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both polynomials. </dd></dl>

</div>
</div>
<a id="ga53c105b8713be3a63453f347ea136aa5" name="ga53c105b8713be3a63453f347ea136aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c105b8713be3a63453f347ea136aa5">&#9670;&#160;</a></span>operator-() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga08c52ccdb43e4a4f8b6155cd94f69184" name="ga08c52ccdb43e4a4f8b6155cd94f69184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c52ccdb43e4a4f8b6155cd94f69184">&#9670;&#160;</a></span>operator-() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga9ccc1b6882dbafc03823730366522c0a" name="ga9ccc1b6882dbafc03823730366522c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ccc1b6882dbafc03823730366522c0a">&#9670;&#160;</a></span>operator-() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative of the given polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the polynomial to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negative of <em>arg</em>. </dd></dl>

</div>
</div>
<a id="ga5a6816f63242efa377c9d647c5749f17" name="ga5a6816f63242efa377c9d647c5749f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6816f63242efa377c9d647c5749f17">&#9670;&#160;</a></span>operator-() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="gaa4cee5ce390dd03631d86118a18490d3" name="gaa4cee5ce390dd03631d86118a18490d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4cee5ce390dd03631d86118a18490d3">&#9670;&#160;</a></span>operator-() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="gabce5ceb3b7e84865d0b06a55acc3e224" name="gabce5ceb3b7e84865d0b06a55acc3e224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce5ceb3b7e84865d0b06a55acc3e224">&#9670;&#160;</a></span>operator-() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the field element to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the field element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first field element minus the second. </dd></dl>

</div>
</div>
<a id="gae1fbbc601e603d15718c091bd379c25d" name="gae1fbbc601e603d15718c091bd379c25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1fbbc601e603d15718c091bd379c25d">&#9670;&#160;</a></span>operator-() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the field element to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the field element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first field element minus the second. </dd></dl>

</div>
</div>
<a id="ga6fbf14f7449cd036f49200e7c5d524ba" name="ga6fbf14f7449cd036f49200e7c5d524ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbf14f7449cd036f49200e7c5d524ba">&#9670;&#160;</a></span>operator-() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first polynomial minus the second. </dd></dl>

</div>
</div>
<a id="ga447b52f7eda98219e068e935776e08e7" name="ga447b52f7eda98219e068e935776e08e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447b52f7eda98219e068e935776e08e7">&#9670;&#160;</a></span>operator-() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first polynomial minus the second. </dd></dl>

</div>
</div>
<a id="ga5db067bde73132ecc7300bfbf76ffeb4" name="ga5db067bde73132ecc7300bfbf76ffeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db067bde73132ecc7300bfbf76ffeb4">&#9670;&#160;</a></span>operator-() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga2ff2986994dfe16c9e43f092aaa9b3f5" name="ga2ff2986994dfe16c9e43f092aaa9b3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff2986994dfe16c9e43f092aaa9b3f5">&#9670;&#160;</a></span>operator-() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga0364fc9032544d5eabe5989ebe1b82cd" name="ga0364fc9032544d5eabe5989ebe1b82cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0364fc9032544d5eabe5989ebe1b82cd">&#9670;&#160;</a></span>operator-() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga8886658656e73de83ae29d8b8a4cfe21" name="ga8886658656e73de83ae29d8b8a4cfe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8886658656e73de83ae29d8b8a4cfe21">&#9670;&#160;</a></span>operator-() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="gaf37c0a90f313b78098fa966201663751" name="gaf37c0a90f313b78098fa966201663751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf37c0a90f313b78098fa966201663751">&#9670;&#160;</a></span>operator-() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the field element to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the field element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first field element minus the second. </dd></dl>

</div>
</div>
<a id="gaec93028be41ad43f3566bb0dc79572eb" name="gaec93028be41ad43f3566bb0dc79572eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec93028be41ad43f3566bb0dc79572eb">&#9670;&#160;</a></span>operator-() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the field element to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the field element to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first field element minus the second. </dd></dl>

</div>
</div>
<a id="gae0c30a807b58e5a71b561eebe14560fc" name="gae0c30a807b58e5a71b561eebe14560fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0c30a807b58e5a71b561eebe14560fc">&#9670;&#160;</a></span>operator-() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative of the given field element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the field element to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negative of <em>arg</em>. </dd></dl>

</div>
</div>
<a id="gaede6f5acb23d837f0930a19a263251a9" name="gaede6f5acb23d837f0930a19a263251a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede6f5acb23d837f0930a19a263251a9">&#9670;&#160;</a></span>operator-() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first polynomial minus the second. </dd></dl>

</div>
</div>
<a id="ga801ec085beabc96fea83bdc3205d340d" name="ga801ec085beabc96fea83bdc3205d340d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga801ec085beabc96fea83bdc3205d340d">&#9670;&#160;</a></span>operator-() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>The two polynomials need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to subtract from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first polynomial minus the second. </dd></dl>

</div>
</div>
<a id="ga53ccb2e6cab2b44268cddb0f28053fd0" name="ga53ccb2e6cab2b44268cddb0f28053fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ccb2e6cab2b44268cddb0f28053fd0">&#9670;&#160;</a></span>operator-() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative of the given polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the polynomial to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negative of <em>arg</em>. </dd></dl>

</div>
</div>
<a id="ga23cebf0f325b89655b2f3bf5aa04d78b" name="ga23cebf0f325b89655b2f3bf5aa04d78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23cebf0f325b89655b2f3bf5aa04d78b">&#9670;&#160;</a></span>operator-() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="gadff5aebd44e21a82a1cb3b6163c271f2" name="gadff5aebd44e21a82a1cb3b6163c271f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff5aebd44e21a82a1cb3b6163c271f2">&#9670;&#160;</a></span>operator-() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga86b9a142c3b3386975ed8e4eaa535863" name="ga86b9a142c3b3386975ed8e4eaa535863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86b9a142c3b3386975ed8e4eaa535863">&#9670;&#160;</a></span>operator-() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative of the given polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the polynomial to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negative of <em>arg</em>. </dd></dl>

</div>
</div>
<a id="ga02291b373a229837611436724e1e7142" name="ga02291b373a229837611436724e1e7142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02291b373a229837611436724e1e7142">&#9670;&#160;</a></span>operator-() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="ga445605c38ed64b079c0146d569c76234" name="ga445605c38ed64b079c0146d569c76234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga445605c38ed64b079c0146d569c76234">&#9670;&#160;</a></span>operator-() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the two given polynomials. </p>
<p>This operator <code>-</code> is sometimes faster than using <code>-=</code>, since it has more flexibility to avoid an internal deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to sutract <em>rhs</em> from. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial to subtract from <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two given polynomials. </dd></dl>

</div>
</div>
<a id="gad7bdb9bc63dfce539d6faa38d842d892" name="gad7bdb9bc63dfce539d6faa38d842d892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7bdb9bc63dfce539d6faa38d842d892">&#9670;&#160;</a></span>operator-() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative of the given polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>the polynomial to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negative of <em>arg</em>. </dd></dl>

</div>
</div>
<a id="ga5d728ca6501de2610f8c4392c1664ac4" name="ga5d728ca6501de2610f8c4392c1664ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d728ca6501de2610f8c4392c1664ac4">&#9670;&#160;</a></span>operator/() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the two given cyclotomic field elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The second argument <em>rhs</em> is non-zero. </dd>
<dd>
Both arguments belong to the same cyclotomic field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the field element to divide by <em>rhs</em>. </td></tr>
    <tr><td class="paramname">rhs</td><td>the field element to divide <em>lhs</em> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of dividing <em>lhs</em> by <em>rhs</em>. </dd></dl>

</div>
</div>
<a id="ga0d490bdb5c5fa0521faadf36c20d2598" name="ga0d490bdb5c5fa0521faadf36c20d2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d490bdb5c5fa0521faadf36c20d2598">&#9670;&#160;</a></span>operator/() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> regina::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a></td>          <td class="paramname"><span class="paramname"><em>elt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the given field element by the given rational. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>the field element to divide by the given rational. </td></tr>
    <tr><td class="paramname">scalar</td><td>the rational to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient of the given field element by the given rational. </dd></dl>

</div>
</div>
<a id="gacb07cb1a5784d68da25c71d0ebdeb125" name="gacb07cb1a5784d68da25c71d0ebdeb125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb07cb1a5784d68da25c71d0ebdeb125">&#9670;&#160;</a></span>operator/() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; regina::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the given polynomial by the given scalar constant. </p>
<p>This uses the division operator /= for the coefficient type <em>T</em>.</p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a" title="The type of each coefficient of the polynomial.">Laurent2&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to divide by the given scalar. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient of the given polynomial by the given scalar. </dd></dl>

</div>
</div>
<a id="gab384f01e0a3ead90d17cb8b5627ce9f9" name="gab384f01e0a3ead90d17cb8b5627ce9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab384f01e0a3ead90d17cb8b5627ce9f9">&#9670;&#160;</a></span>operator/() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; regina::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the given polynomial by the given scalar constant. </p>
<p>This uses the division operator /= for the coefficient type <em>T</em>.</p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Laurent.html#ac5415cf78943d61487a2e7b3992dc2d0" title="The type of each coefficient of the polynomial.">Laurent&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to divide by the given scalar. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient of the given polynomial by the given scalar. </dd></dl>

</div>
</div>
<a id="gaeb9554051e4f6f185e9d3d97a3836902" name="gaeb9554051e4f6f185e9d3d97a3836902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb9554051e4f6f185e9d3d97a3836902">&#9670;&#160;</a></span>operator/() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the two given polynomials. </p>
<p>More precisely: suppose there exist polynomials <em>q</em> and <em>r</em> with coefficients of type <em>T</em> for which <code>lhs = q.rhs + r</code>, and where <em>r</em> has smaller degree than <em>rhs</em>. Then we call <em>q</em> the <em>quotient</em>, and <em>r</em> the <em>remainder</em>.</p>
<p>This routine returns the quotient <em>q</em>, and discards the remainder. If you need to keep the remainder also, then call <a class="el" href="classregina_1_1Polynomial.html#af1e9458ec1fd303a38f949f9801189fa" title="Divides this by the given divisor, and returns both the quotient and the remainder.">Polynomial::divisionAlg()</a> instead.</p>
<p>Coefficients are divided using the operator /= on type <em>T</em>.</p>
<p>If your coefficient type <em>T</em> is not a field (e.g., if <em>T</em> is Integer), you must be sure to know in advance that the quotient exists (see the precondition below). Otherwise the behaviour of this routine is undefined.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The second polynomial <em>rhs</em> is non-zero.</dd>
<dd>
The quotient as defined above exists. If <em>T</em> is a field type (e.g., if <em>T</em> is <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a>) then this is true automatically. If not (e.g., if <em>T</em> is Integer) then this requires some prior knowledge about the arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the polynomial to divide by <em>rhs</em>. </td></tr>
    <tr><td class="paramname">rhs</td><td>the polynomial that we will divide <em>lhs</em> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient, as described above. </dd></dl>

</div>
</div>
<a id="gac95c8af9aa11a8f8df4ca60b8112dbfc" name="gac95c8af9aa11a8f8df4ca60b8112dbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac95c8af9aa11a8f8df4ca60b8112dbfc">&#9670;&#160;</a></span>operator/() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; regina::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt;::Coefficient &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the given polynomial by the given scalar constant. </p>
<p>This uses the division operator /= for the coefficient type <em>T</em>.</p>
<p>The scalar is simply of type <em>T</em>; we use the identical type <a class="el" href="classregina_1_1Polynomial.html#a339223de6de9828ebbb7ccb8ee8b75ea" title="The type of each coefficient of the polynomial.">Polynomial&lt;T&gt;::Coefficient</a> here to assist with C++ template type matching.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>the polynomial to divide by the given scalar. </td></tr>
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quotient of the given polynomial by the given scalar. </dd></dl>

</div>
</div>
<a id="gacc5c9244276eb19180344afd5cb716b6" name="gacc5c9244276eb19180344afd5cb716b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5c9244276eb19180344afd5cb716b6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given integer to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">i</td><td>the integer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga2dfa0040b213b62780fcb530ac8974dd" name="ga2dfa0040b213b62780fcb530ac8974dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dfa0040b213b62780fcb530ac8974dd">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given matrix to the given output stream. </p>
<p>The matrix will be written entirely on a single line, with the first row followed by the second row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gac88df7f1c82c5adeed23445eb0725dd7" name="gac88df7f1c82c5adeed23445eb0725dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88df7f1c82c5adeed23445eb0725dd7">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix3D.html">Matrix3D</a>&lt; Real &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given matrix to the given output stream. </p>
<p>The matrix will be written row by row, in the form <code>[[ m00 m01 m02 ] [ m10 m11 m12 ] [ m20 m21 m22 ]]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">m</td><td>the matrix to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga752c440af02effb2ea39193ed9fb720a" name="ga752c440af02effb2ea39193ed9fb720a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga752c440af02effb2ea39193ed9fb720a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given integer to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">i</td><td>the integer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga958289d50917d6190aef488a6eb31387" name="ga958289d50917d6190aef488a6eb31387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958289d50917d6190aef488a6eb31387">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a string representation of the given permutation to the given output stream. </p>
<p>The format will be the same as is used by <a class="el" href="classregina_1_1Perm.html#a4200afccebbd4ea0d74d02c7d5ab18d4" title="Returns a string representation of this permutation.">Perm::str()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">p</td><td>the permutation to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of objects being permuted. This must be between 2 and 16 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e5cab5f1db430c8b084c4416b024d09" name="ga5e5cab5f1db430c8b084c4416b024d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5cab5f1db430c8b084c4416b024d09">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermClass.html">PermClass</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a string representation of the given conjugacy class of permutations to the given output stream. </p>
<p>The format will be the same as is used by <a class="el" href="classregina_1_1PermClass.html#a0cbf2ab2df2963d6e33c424fd4bec3b8" title="Returns a string representation of this conjugacy class.">PermClass&lt;n&gt;::str()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">c</td><td>the conjugacy class to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of objects being permuted. This must be between 2 and 16 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga345f8b2bd10ead2b33f45693685f4fa8" name="ga345f8b2bd10ead2b33f45693685f4fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345f8b2bd10ead2b33f45693685f4fa8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rat</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given rational to the given output stream. </p>
<p>Infinity will be written as <code>Inf</code>. Undefined will be written as <code>Undef</code>. A rational with denominator one will be written as a single integer. All other rationals will be written in the form <code>r/s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">rat</td><td>the rational to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga5369fbb998574ec461588c3fc15980f1" name="ga5369fbb998574ec461588c3fc15980f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5369fbb998574ec461588c3fc15980f1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Rotation3D.html">Rotation3D</a>&lt; Real &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given rotation to the given output stream. </p>
<p>The rotation will be written using its quaternion coordinates, as a tuple <code>(a, b, c, d)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">rot</td><td>the rotation to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga272974190dcd881f3fee1856c915071a" name="ga272974190dcd881f3fee1856c915071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272974190dcd881f3fee1856c915071a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1Segment3D.html">Segment3D</a>&lt; Real &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given line segment to the given output stream. </p>
<p>The segment will be written in the form <code>[(...), (...)]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the line segment to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga9587dc3912b0044f72b146c5cd95b2bc" name="ga9587dc3912b0044f72b146c5cd95b2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9587dc3912b0044f72b146c5cd95b2bc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt; Real &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given vector to the given output stream. </p>
<p>The vector will be written as a triple <code>(x, y, z)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">v</td><td>the vector to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gabed931495078c1c59d7016a099eb38d1" name="gabed931495078c1c59d7016a099eb38d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed931495078c1c59d7016a099eb38d1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given vector to the given output stream. </p>
<p>The vector will be written on a single line with elements separated by a single space. No newline will be written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">vector</td><td>the vector to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga0be8656317f0c42b449b68d503432131" name="ga0be8656317f0c42b449b68d503432131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be8656317f0c42b449b68d503432131">&#9670;&#160;</a></span>preImageOfLattice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> regina::preImageOfLattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sublattice</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a homomorphism from Z^n to Z^k and a sublattice of Z^k, compute the preimage of this sublattice under this homomorphism. </p>
<p>The homomorphism from Z^n to Z^k is described by the given <em>k</em> by <em>n</em> matrix <em>hom</em>. The sublattice is of the form <code>(p1 Z) * (p2 Z) * ... * (pk Z)</code>, where the non-negative integers <em>p1</em>, ..., <em>pk</em> are passed in the given list <em>sublattice</em>.</p>
<p>An equivalent problem is to consider <em>hom</em> to be a homomorphism from Z^n to Z_p1 + ... + Z_pk; this routine then finds the kernel of this homomorphism.</p>
<p>The preimage of the sublattice (equivalently, the kernel described above) is some rank <em>n</em> lattice in Z^n. This algorithm finds and returns a basis for the lattice.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The length of <em>sublattice</em> is different from the number of rows of <em>hom</em>. Note that the <em>contents</em> of <em>sublattice</em> (specifically, the signs of the integers it contains) are not checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hom</td><td>the matrix representing the homomorphism from Z^n to Z^k; this must be a <em>k</em> by <em>n</em> matrix. </td></tr>
    <tr><td class="paramname">sublattice</td><td>a list of length <em>k</em> describing the sublattice of Z^k; the elements of this list must be the non-negative integers <em>p1</em>, ..., <em>pk</em> as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new matrix whose columns are a basis for the preimage lattice. This matrix will have precisely <em>n</em> rows.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="gad5c1e8d24ec41764e74eec9afc308fd3" name="gad5c1e8d24ec41764e74eec9afc308fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c1e8d24ec41764e74eec9afc308fd3">&#9670;&#160;</a></span>reducedMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::reducedMod </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>modBase</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces <em>k</em> modulo <em>modBase</em> to give the smallest possible absolute value. </p>
<p>For instance, <code>reducedMod(4,10) = 4</code> but <code>reducedMod(6,10) = -4</code>. In the case of a tie, the positive solution is taken.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>modBase</em> is strictly positive.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>modBase</em> is zero or negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number to reduce modulo <em>modBase</em>. </td></tr>
    <tr><td class="paramname">modBase</td><td>the modular base in which to work. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a009583b8be1b537c39716e85f8cc5b" name="ga0a009583b8be1b537c39716e85f8cc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a009583b8be1b537c39716e85f8cc5b">&#9670;&#160;</a></span>rowBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::rowBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a basis for the row space of the given matrix. </p>
<p>This routine will rearrange the rows of the given matrix so that the first <em>rank</em> rows form a basis for the row space (where <em>rank</em> is the rank of the matrix). The rank itself will be returned. No other changes will be made to the matrix aside from swapping rows.</p>
<p>Although this routine takes an integer matrix (and only uses integer operations), we consider the row space to be over the <em>rationals</em>. That is, although we never divide, we act as though we could if we wanted to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to examine and rearrange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the given matrix. </dd></dl>

</div>
</div>
<a id="ga618d7dcd03fe042475212cef13c8d158" name="ga618d7dcd03fe042475212cef13c8d158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618d7dcd03fe042475212cef13c8d158">&#9670;&#160;</a></span>rowBasisAndOrthComp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::rowBasisAndOrthComp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>complement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a basis for the row space of the given matrix, as well as an "incremental" basis for its orthogonal complement. </p>
<p>This routine takes an (<em>r</em> by <em>c</em>) matrix <em>input</em>, as well as a square (<em>c</em> by <em>c</em>) matrix <em>complement</em>, and does the following:</p>
<ul>
<li>The rows of <em>input</em> are rearranged so that the first <em>rank</em> rows form a basis for the row space (where <em>rank</em> is the rank of the matrix). No other changes are made to this matrix aside from swapping rows.</li>
<li>The matrix <em>complement</em> is re-filled (any previous contents are thrown away) so that, for any <em>i</em> between 0 and <em>rank-1</em> inclusive, the final (<em>c</em> - <em>i</em>) rows of <em>complement</em> form a basis for the orthogonal complement of the first <em>i</em> rows of the rearranged <em>input</em>.</li>
<li>The rank of the matrix <em>input</em> is returned from this routine.</li>
</ul>
<p>This routine can help with larger procedures that need to build up a row space and simultaneously cut down the complement one dimension at a time.</p>
<p>Although this routine takes integer matrices (and only uses integer operations), we consider all bases to be over the <em>rationals</em>. That is, although we never divide, we act as though we could if we wanted to.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrix <em>complement</em> is a square matrix, whose size is equal to the number of columns in <em>input</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The matrix <em>complement</em> is not square with side length equal to <code>input.columns()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input matrix whose row space we will describe; this matrix will be changed (though only by swapping rows). </td></tr>
    <tr><td class="paramname">complement</td><td>the square matrix that will be re-filled with the "incremental" basis for the orthogonal complement of <em>input</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the given matrix <em>input</em>. </dd></dl>

</div>
</div>
<a id="ga1446f5ce6902b72889d354b003fd098e" name="ga1446f5ce6902b72889d354b003fd098e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1446f5ce6902b72889d354b003fd098e">&#9670;&#160;</a></span>simpler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::simpler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines whether the first given matrix is more aesthetically pleasing than the second. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated</a></b></dt><dd>This routine is implemented using <a class="el" href="#ga8596862fc390e91ab3f15e7d828c0f7c" title="Compare two matrices to determine which is more aesthetically pleasing.">simplerThreeWay()</a>, and new code should use that routine instead. See <a class="el" href="#ga8596862fc390e91ab3f15e7d828c0f7c" title="Compare two matrices to determine which is more aesthetically pleasing.">simplerThreeWay()</a> for further discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the first matrix to examine. </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>m1</em> is deemed to be more pleasing than <em>m2</em>, or <code>false</code> if either the matrices are equal or <em>m2</em> is more pleasing than <em>m1</em>. </dd></dl>

</div>
</div>
<a id="ga6cca6045c934d6f78c51f9ac4acebf3f" name="ga6cca6045c934d6f78c51f9ac4acebf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cca6045c934d6f78c51f9ac4acebf3f">&#9670;&#160;</a></span>simpler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::simpler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair1first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair1second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair2first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair2second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines whether the first given pair of matrices is more aesthetically pleasing than the second pair. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated</a></b></dt><dd>This routine is implemented using <a class="el" href="#ga8596862fc390e91ab3f15e7d828c0f7c" title="Compare two matrices to determine which is more aesthetically pleasing.">simplerThreeWay()</a>, and new code should use that routine instead. See <a class="el" href="#ga8596862fc390e91ab3f15e7d828c0f7c" title="Compare two matrices to determine which is more aesthetically pleasing.">simplerThreeWay()</a> for further discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair1first</td><td>the first matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair1second</td><td>the second matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair2first</td><td>the first matrix of the second pair to examine. </td></tr>
    <tr><td class="paramname">pair2second</td><td>the second matrix of the second pair to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the first pair is deemed to be more pleasing than the second pair, or <code>false</code> if either the ordered pairs are equal or the second pair is more pleasing than the first. </dd></dl>

</div>
</div>
<a id="ga8596862fc390e91ab3f15e7d828c0f7c" name="ga8596862fc390e91ab3f15e7d828c0f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8596862fc390e91ab3f15e7d828c0f7c">&#9670;&#160;</a></span>simplerThreeWay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering regina::simplerThreeWay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two matrices to determine which is more aesthetically pleasing. </p>
<p>The way in which this judgement is made is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Instead of a <code>std::strong_ordering</code>, this routine returns an integer -1, 0 or 1 (representing <code>less</code>, <code>equal</code> or <code>greater</code> respectively).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the first matrix to examine. </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>less</code> if <em>m1</em> is deemed to be more pleasing than <em>m2</em>, <code>greater</code> if <em>m2</em> is more pleasing than <em>m1</em>, or <code>equal</code> if both matrices are equal. </dd></dl>

</div>
</div>
<a id="ga89b2fc2064b7c97b3cca3bcbe27f9e0d" name="ga89b2fc2064b7c97b3cca3bcbe27f9e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b2fc2064b7c97b3cca3bcbe27f9e0d">&#9670;&#160;</a></span>simplerThreeWay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering regina::simplerThreeWay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair1first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair1second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair2first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pair2second</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ordered pairs of matrices to determine which pair is more aesthetically pleasing. </p>
<p>The way in which this judgement is made is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<p>Note that pairs are ordered, so the pair (<em>M</em>, <em>N</em>) may be more (or perhaps less) pleasing than the pair (<em>N</em>, <em>M</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Instead of a <code>std::strong_ordering</code>, this routine returns an integer -1, 0 or 1 (representing <code>less</code>, <code>equal</code> or <code>greater</code> respectively).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair1first</td><td>the first matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair1second</td><td>the second matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair2first</td><td>the first matrix of the second pair to examine. </td></tr>
    <tr><td class="paramname">pair2second</td><td>the second matrix of the second pair to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>less</code> if the first pair is deemed to be more pleasing than the second pair, <code>greater</code> if the second pair is more pleasing than the first, or <code>equal</code> if both ordered pairs are equal. </dd></dl>

</div>
</div>
<a id="gafa593986d5cdcda5806cbd88625ab77e" name="gafa593986d5cdcda5806cbd88625ab77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa593986d5cdcda5806cbd88625ab77e">&#9670;&#160;</a></span>smithNormalForm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::smithNormalForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given integer matrix into Smith normal form. </p>
<p>Note that the given matrix need not be square and need not be of full rank.</p>
<p>Reading down the diagonal, the final Smith normal form will have a series of non-negative, non-decreasing invariant factors followed by zeroes. "Invariant factor" refers to the convention that the <em>i</em>th term divides the (<em>i</em>+1)th term, and so they are unique.</p>
<p>The algorithm used is due to Hafner and McCurley (1991). It does not use modular arithmetic to control the intermediate coefficient explosion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7569d6d12d6910c859101d90a1ecd340" name="ga7569d6d12d6910c859101d90a1ecd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7569d6d12d6910c859101d90a1ecd340">&#9670;&#160;</a></span>smithNormalForm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::smithNormalForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rowSpaceBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rowSpaceBasisInv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>colSpaceBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>colSpaceBasisInv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Smith normal form algorithm that also returns change of basis matrices. </p>
<p>This is a modification of the one-argument <a class="el" href="#gafa593986d5cdcda5806cbd88625ab77e" title="Transforms the given integer matrix into Smith normal form.">smithNormalForm(MatrixInt&amp;)</a>. As well as converting the given matrix <em>matrix</em> into Smith normal form, it also returns the appropriate change-of-basis matrices corresponding to all the row and column operations that were performed.</p>
<p>The only input argument is <em>matrix</em>. The four remaining arguments (the change of basis matrices) will be refilled. All five arguments are used to return information as follows.</p>
<p>Let <em>M</em> be the initial value of <em>matrix</em>, and let <em>S</em> be the Smith normal form of <em>M</em>. After this routine exits:</p>
<ul>
<li>The argument <em>matrix</em> will contain the Smith normal form <em>S</em>;</li>
<li><code>colSpaceBasis * M * rowSpaceBasis = S</code>;</li>
<li><code>colSpaceBasisInv * S * rowSpaceBasisInv = M</code>;</li>
<li><code>colSpaceBasis * colSpaceBasisInv</code> and <code>rowSpaceBasis * rowSpaceBasisInv</code> are both identity matrices.</li>
</ul>
<p>Thus, one obtains the Smith normal form of the original matrix by multiplying on the left by ColSpaceBasis and on the right by RowSpaceBasis.</p>
<p>The matrices <em>rowSpaceBasis</em> and <em>rowSpaceBasisInv</em> that are passed may be of any size, or they may even be uninitialised; upon return they will both be square with side length matrix.columns(). Likewise, the matrices <em>colSpaceBasis</em> and <em>colSpaceBasisInv</em> that are passed may be of any size or may be uninitialised; upon return they will both be square with side length matrix.rows().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the original matrix to put into Smith Normal Form (this need not be square). When the algorithm terminates, this matrix <em>is</em> in its Smith Normal Form. </td></tr>
    <tr><td class="paramname">rowSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">rowSpaceBasisInv</td><td>used to return the inverse of <em>rowSpaceBasis</em>. </td></tr>
    <tr><td class="paramname">colSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">colSpaceBasisInv</td><td>used to return the inverse of <em>colSpaceBasis</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5669e91dc80942eab14d2b465ec19f88" name="ga5669e91dc80942eab14d2b465ec19f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5669e91dc80942eab14d2b465ec19f88">&#9670;&#160;</a></span>swap() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given polynomials. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Arrow.html#acc69d38fcc90e9e5d27badaa6dd686e4" title="Swaps the contents of this and the given polynomial.">Arrow::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Arrow.html" title="Represents a multivariate polynomial of the type used by arrow polynomials of links.">Arrow</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first polynomial whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second polynomial whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf70d0209d90d5babcc252f4da212b7b9" name="gaf70d0209d90d5babcc252f4da212b7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70d0209d90d5babcc252f4da212b7b9">&#9670;&#160;</a></span>swap() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given field elements. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Cyclotomic.html#aabbd80c2e473a962e368794e9fc90cd5" title="Swaps the contents of this and the given field element.">Cyclotomic::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Cyclotomic.html" title="Represents an element of a cyclotomic field.">Cyclotomic</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first field element whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second field element whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4539ca41a1bea970672d3f18d3f68882" name="ga4539ca41a1bea970672d3f18d3f68882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4539ca41a1bea970672d3f18d3f68882">&#9670;&#160;</a></span>swap() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given integers. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1IntegerBase.html#aedf5a40f3457d7235532935bdab9c2fa" title="Swaps the values of this and the given integer.">IntegerBase&lt;withInfinity&gt;::swap()</a>; it is provided so that <a class="el" href="classregina_1_1IntegerBase.html" title="Represents an arbitrary precision integer.">IntegerBase</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second integer whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae922db629f2c26ecbeefdbddff69a1c7" name="gae922db629f2c26ecbeefdbddff69a1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae922db629f2c26ecbeefdbddff69a1c7">&#9670;&#160;</a></span>swap() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given polynomials. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Laurent2.html#a5382c0231814155a040fd05d908d1f73" title="Swaps the contents of this and the given polynomial.">Laurent2&lt;T&gt;::swap()</a>; it is provided so that Laurent2&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first polynomial whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second polynomial whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga629640cdbecc2dbfd1b13cca9e968b1a" name="ga629640cdbecc2dbfd1b13cca9e968b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629640cdbecc2dbfd1b13cca9e968b1a">&#9670;&#160;</a></span>swap() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given polynomials. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Laurent.html#ae4fd032076d422a88aca0c10284a69e5" title="Swaps the contents of this and the given polynomial.">Laurent&lt;T&gt;::swap()</a>; it is provided so that Laurent&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first polynomial whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second polynomial whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09cfa8150c425808f106f6f51c54dee7" name="ga09cfa8150c425808f106f6f51c54dee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cfa8150c425808f106f6f51c54dee7">&#9670;&#160;</a></span>swap() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given matrices. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Matrix2.html#a8a757f0f40a36af059caf9df64993cb9" title="Swaps the contents of this and the given matrix.">Matrix2::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Matrix2.html" title="Represents a 2-by-2 integer matrix.">Matrix2</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first matrix whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second matrix whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade671546c9ba9ca4198e43ab57d6b626" name="gade671546c9ba9ca4198e43ab57d6b626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade671546c9ba9ca4198e43ab57d6b626">&#9670;&#160;</a></span>swap() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given matrices. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Matrix.html#a4709bbb2e91745dce4035a8efe4dfeb3" title="Swaps the contents of this and the given matrix.">Matrix&lt;T&gt;::swap()</a>; it is provided so that Matrix&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first matrix whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second matrix whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab584fd1a7852e425bff4cf82dac63798" name="gab584fd1a7852e425bff4cf82dac63798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab584fd1a7852e425bff4cf82dac63798">&#9670;&#160;</a></span>swap() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NativeInteger.html">NativeInteger</a>&lt; bytes &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given integers. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1NativeInteger.html#aab362bfb356c1c9c23e25e01765a36e7" title="Swaps the values of this and the given integer.">NativeInteger&lt;bytes&gt;::swap()</a>; it is provided so that NativeInteger&lt;bytes&gt; meets the C++ Swappable requirements.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. The <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a> classes are not available to Python users.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second integer whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9271cc4e03621b78abd6e6dbb2d53d95" name="ga9271cc4e03621b78abd6e6dbb2d53d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9271cc4e03621b78abd6e6dbb2d53d95">&#9670;&#160;</a></span>swap() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given polynomials. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Polynomial.html#a3a194b8d221865ac8e53a8884af3f3ca" title="Swaps the contents of this and the given polynomial.">Polynomial&lt;T&gt;::swap()</a>; it is provided so that Polynomial&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first polynomial whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second polynomial whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8be8e91b1742b3882e85377d23109a3" name="gae8be8e91b1742b3882e85377d23109a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8be8e91b1742b3882e85377d23109a3">&#9670;&#160;</a></span>swap() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Rational.html">Rational</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given rationals. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Rational.html#aa30e1dc6899fca2ecb1c3793e1aa6b3b" title="Swaps the values of this and the given rational.">Rational::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first rational whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second rational whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae42ddfa6fb96263d510b53ba5f9a4bf6" name="gae42ddfa6fb96263d510b53ba5f9a4bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42ddfa6fb96263d510b53ba5f9a4bf6">&#9670;&#160;</a></span>swap() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given vectors. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1Vector.html#a8b9cc662372fa3a48e91fe15665ae7ed" title="Swaps the contents of this and the given vector.">Vector&lt;T&gt;::swap()</a>; it is provided so that Vector&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first vector whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second vector whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f617ed59595ca8e0a6109b423d2831b" name="ga5f617ed59595ca8e0a6109b423d2831b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f617ed59595ca8e0a6109b423d2831b">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given arbitrary precision integer to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>This global function does the same thing as the member function <a class="el" href="classregina_1_1IntegerBase.html#a0b299c99a8c59b3d1532e185b26d6a85" title="Writes the tight encoding of this integer to the given output stream.">IntegerBase::tightEncode()</a>. However, this global function is more efficient if the integer argument is an rvalue reference (since the const member function induces an extra deep copy).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#ga0118b9ecfaa863e512e118df0ed5b883" title="Returns the tight encoding of the given arbitrary precision integer.">tightEncoding()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0118b9ecfaa863e512e118df0ed5b883" name="ga0118b9ecfaa863e512e118df0ed5b883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0118b9ecfaa863e512e118df0ed5b883">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool withInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; withInfinity &gt;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given arbitrary precision integer. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>This global function does the same thing as the member function <a class="el" href="classregina_1_1IntegerBase.html#ae4a7584e0692ec2a1594490e4a095527" title="Returns the tight encoding of this integer.">IntegerBase::tightEncoding()</a>. However, this global function is more efficient if the integer argument is an rvalue reference (since the const member function induces an extra deep copy).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ga50aca1651103070774d22bb4cf4df140" name="ga50aca1651103070774d22bb4cf4df140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50aca1651103070774d22bb4cf4df140">&#9670;&#160;</a></span>torsionAutInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> regina::torsionAutInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>invF</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an automorphism of an abelian group, this procedure computes the inverse automorphism. </p>
<p>The abelian group is of the form <code>Z_p1 + Z_p2 + ... + Z_pn</code>. The input is an n-by-n matrix <em>A</em> which represents a lift of the automorphism to just some n-by-n matrix. Specifically, you have a little commutative diagram with <code>Z^n --A--&gt; Z^n</code> covering the automorphism of <code>Z_p1 + Z_p2 + ... + Z_pn</code>, where the maps down are the direct sum of the standard quotients <code>Z --&gt; Z_pi</code>. So if you want this procedure to give you meaningful output, <em>A</em> must be a lift of a genuine automorphism of <code>Z_p1 + ... + Z_pn</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The list p1, p2, ..., pn is a list of invariant factors, which means that p1|p2, ..., p{n-1}|pn.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Either <em>input</em> is not a square matrix, and/or the length of <em>invF</em> is different from the side length of <em>input</em>. Note that the <em>contents</em> of <em>invF</em> (specifically, the divisibility property) are not checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the n-by-n matrix <em>A</em>, which must be a lift of a genuine automorphism as described above. </td></tr>
    <tr><td class="paramname">invF</td><td>the list p1, p2, ..., pn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse automorphism, also described as an n-by-n matrix as per the discussion above.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga7db2a4173e00dd5232fa395caa80ca3a" name="ga7db2a4173e00dd5232fa395caa80ca3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db2a4173e00dd5232fa395caa80ca3a">&#9670;&#160;</a></span>binomSmall_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::detail::binomSmall_[17][17]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,4,6,4,1,0,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,5,10,10,5,1,0,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,6,15,20,15,6,1,0,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,7,21,35,35,21,7,1,0,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,8,28,56,70,56,28,8,1,0,0,0,0,0,0,0,0},</div>
<div class="line">    {1,9,36,84,126,126,84,36,9,1,0,0,0,0,0,0,0},</div>
<div class="line">    {1,10,45,120,210,252,210,120,45,10,1,0,0,0,0,0,0},</div>
<div class="line">    {1,11,55,165,330,462,462,330,165,55,11,1,0,0,0,0,0},</div>
<div class="line">    {1,12,66,220,495,792,924,792,495,220,66,12,1,0,0,0,0},</div>
<div class="line">    {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1,0,0,0},</div>
<div class="line">    {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1,0,0},</div>
<div class="line">    {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1,0},</div>
<div class="line">    {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1}</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>A lookup table that stores (<em>n</em> choose <em>k</em>) for all <em>n</em> ≤ <em>16</em>. </p>
<p>For all values 0 ≤ <em>k</em> ≤ <em>n</em> ≤ 16, the value <em>binomSmall_</em>[<em>n</em>][<em>k</em>] is the binomial coefficient (<em>n</em> choose <em>k</em>).</p>
<p>This array is used in the implementation of the function <a class="el" href="#ga3b6dccba582fc983e1ea9d27fdd634ab" title="Returns the binomial coefficient n choose k in constant time for small arguments (n ≤ 16).">binomSmall()</a>. End users should call <a class="el" href="#ga3b6dccba582fc983e1ea9d27fdd634ab" title="Returns the binomial coefficient n choose k in constant time for small arguments (n ≤ 16).">binomSmall()</a> instead of referring to this array directly. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
