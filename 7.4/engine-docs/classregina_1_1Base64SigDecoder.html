<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::Base64SigDecoder&lt; Iterator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Base64SigDecoder.html">Base64SigDecoder</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1Base64SigDecoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Base64SigDecoder&lt; Iterator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A helper class for reading signatures that use base64 encodings.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;utilities/sigutils.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfffa822958ac659211e2dac8735b369" id="r_adfffa822958ac659211e2dac8735b369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfffa822958ac659211e2dac8735b369">Base64SigDecoder</a> (Iterator encoding, Iterator end, bool skipInitialWhitespace=true)</td></tr>
<tr class="memdesc:adfffa822958ac659211e2dac8735b369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new decoder for the given encoded string.  <br /></td></tr>
<tr class="separator:adfffa822958ac659211e2dac8735b369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccfcb35d9945a835d16b6b580c6b6b8" id="r_a5ccfcb35d9945a835d16b6b580c6b6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ccfcb35d9945a835d16b6b580c6b6b8">skipWhitespace</a> ()</td></tr>
<tr class="memdesc:a5ccfcb35d9945a835d16b6b580c6b6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current position past any whitespace.  <br /></td></tr>
<tr class="separator:a5ccfcb35d9945a835d16b6b580c6b6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c1d48905d5f8f80c72cde37efdc34" id="r_a183c1d48905d5f8f80c72cde37efdc34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183c1d48905d5f8f80c72cde37efdc34">done</a> (bool ignoreWhitespace=true) const</td></tr>
<tr class="memdesc:a183c1d48905d5f8f80c72cde37efdc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the current position has reached the end of the string.  <br /></td></tr>
<tr class="separator:a183c1d48905d5f8f80c72cde37efdc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea004daccbcb97809758596fb5c151" id="r_a2eea004daccbcb97809758596fb5c151"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eea004daccbcb97809758596fb5c151">peek</a> () const</td></tr>
<tr class="memdesc:a2eea004daccbcb97809758596fb5c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character at the current position in the encoded string.  <br /></td></tr>
<tr class="separator:a2eea004daccbcb97809758596fb5c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aadc40a99cf4e869bd34078a479397d" id="r_a4aadc40a99cf4e869bd34078a479397d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aadc40a99cf4e869bd34078a479397d">skip</a> ()</td></tr>
<tr class="memdesc:a4aadc40a99cf4e869bd34078a479397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances to the next position in the encoded string.  <br /></td></tr>
<tr class="separator:a4aadc40a99cf4e869bd34078a479397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55833c43cb9f88c5fde0ca00f7f888" id="r_a5c55833c43cb9f88c5fde0ca00f7f888"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a5c55833c43cb9f88c5fde0ca00f7f888"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c55833c43cb9f88c5fde0ca00f7f888">decodeSingle</a> ()</td></tr>
<tr class="memdesc:a5c55833c43cb9f88c5fde0ca00f7f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the 6-bit integer value represented by the next single base64 character.  <br /></td></tr>
<tr class="separator:a5c55833c43cb9f88c5fde0ca00f7f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7813a0d9b43e724528c9d4357cce9" id="r_a4aa7813a0d9b43e724528c9d4357cce9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aa7813a0d9b43e724528c9d4357cce9">decodeSize</a> ()</td></tr>
<tr class="memdesc:a4aa7813a0d9b43e724528c9d4357cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the next non-negative integer value (typically representing the size of some object), without knowing in advance how many base64 characters were used to encode it.  <br /></td></tr>
<tr class="separator:a4aa7813a0d9b43e724528c9d4357cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca27b73dc34b39aeb498dee0d910ee" id="r_a9fca27b73dc34b39aeb498dee0d910ee"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a9fca27b73dc34b39aeb498dee0d910ee"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fca27b73dc34b39aeb498dee0d910ee">decodeInt</a> (int nChars)</td></tr>
<tr class="memdesc:a9fca27b73dc34b39aeb498dee0d910ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the next non-negative integer value, assuming this uses a fixed number of base64 characters.  <br /></td></tr>
<tr class="separator:a9fca27b73dc34b39aeb498dee0d910ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29881c91434484845527bfbb9eadfee7" id="r_a29881c91434484845527bfbb9eadfee7"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:a29881c91434484845527bfbb9eadfee7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29881c91434484845527bfbb9eadfee7">decodeInts</a> (OutputIterator output, size_t count, int nChars)</td></tr>
<tr class="memdesc:a29881c91434484845527bfbb9eadfee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a sequence of non-negative integer values, assuming that each individual value uses a fixed number of base64 characters.  <br /></td></tr>
<tr class="separator:a29881c91434484845527bfbb9eadfee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b517c662af89df20643c01fee04c8" id="r_ad08b517c662af89df20643c01fee04c8"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ad08b517c662af89df20643c01fee04c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FixedArray.html">FixedArray</a>&lt; IntType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad08b517c662af89df20643c01fee04c8">decodeInts</a> (size_t count, int nChars)</td></tr>
<tr class="memdesc:ad08b517c662af89df20643c01fee04c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a sequence of non-negative integer values, assuming that each individual value uses a fixed number of base64 characters.  <br /></td></tr>
<tr class="separator:ad08b517c662af89df20643c01fee04c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59ad970ae06ae016c7ca5cc94208c78" id="r_ab59ad970ae06ae016c7ca5cc94208c78"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:ab59ad970ae06ae016c7ca5cc94208c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab59ad970ae06ae016c7ca5cc94208c78">decodeTrits</a> (OutputIterator result)</td></tr>
<tr class="memdesc:ab59ad970ae06ae016c7ca5cc94208c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes three trits from a single base64 character, and returns these using an output iterator.  <br /></td></tr>
<tr class="separator:ab59ad970ae06ae016c7ca5cc94208c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c106df451cdc0e1750cfa22b7fa092e" id="r_a2c106df451cdc0e1750cfa22b7fa092e"><td class="memItemLeft" align="right" valign="top">std::array&lt; uint8_t, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c106df451cdc0e1750cfa22b7fa092e">decodeTrits</a> ()</td></tr>
<tr class="memdesc:a2c106df451cdc0e1750cfa22b7fa092e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes three trits from a single base64 character, and returns these as a fixed-size array.  <br /></td></tr>
<tr class="separator:a2c106df451cdc0e1750cfa22b7fa092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f504a1ced092bd0183a19999a8f4e" id="r_a065f504a1ced092bd0183a19999a8f4e"><td class="memItemLeft" align="right" valign="top"><a id="a065f504a1ced092bd0183a19999a8f4e" name="a065f504a1ced092bd0183a19999a8f4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Base64SigDecoder</b> (const <a class="el" href="classregina_1_1Base64SigDecoder.html">Base64SigDecoder</a> &amp;)=delete</td></tr>
<tr class="separator:a065f504a1ced092bd0183a19999a8f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038fde4585b89fe891cb434d03613375" id="r_a038fde4585b89fe891cb434d03613375"><td class="memItemLeft" align="right" valign="top"><a id="a038fde4585b89fe891cb434d03613375" name="a038fde4585b89fe891cb434d03613375"></a>
<a class="el" href="classregina_1_1Base64SigDecoder.html">Base64SigDecoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1Base64SigDecoder.html">Base64SigDecoder</a> &amp;)=delete</td></tr>
<tr class="separator:a038fde4585b89fe891cb434d03613375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6cf0cf24f9366a0d7f3478dc3be4bebd" id="r_a6cf0cf24f9366a0d7f3478dc3be4bebd"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf0cf24f9366a0d7f3478dc3be4bebd">isValid</a> (char c)</td></tr>
<tr class="memdesc:a6cf0cf24f9366a0d7f3478dc3be4bebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character one of the printable base64 characters recognised by this class?  <br /></td></tr>
<tr class="separator:a6cf0cf24f9366a0d7f3478dc3be4bebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Iterator&gt;<br />
class regina::Base64SigDecoder&lt; Iterator &gt;</div><p>A helper class for reading signatures that use base64 encodings. </p>
<p>These are (in particular) used in the default encodings for Regina's own isomorphism signatures and knot signatures.</p>
<p>To use this class: create a new <a class="el" href="classregina_1_1Base64SigDecoder.html" title="A helper class for reading signatures that use base64 encodings.">Base64SigDecoder</a> by passing details of the encoded string to its constructor, and then call its <code>decode...()</code> member functions to read values sequentially from the encoding.</p>
<p>This class will keep track of a current position in the encoded string. Each call to a <code>decode...()</code> member function will advance this position accordingly (but never beyond the end of the string).</p>
<p>This base64 encoding uses the characters: <code>a..zA..Z0..9+-</code></p>
<p>Baes64 decoders are single-use objects: they cannot be copied, moved or swapped.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this base64 encoding uses a different set of printable symbols from the encoding used in <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">utilities/base64.h</a>. This should not be a problem: Regina uses this encoding exclusively for signatures, and uses <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">utilities/base64.h</a> exclusively for encoding files.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The type <em>Iterator</em> is an implementation detail, and is hidden from Python users. Just use the unadorned type name <code><a class="el" href="classregina_1_1Base64SigDecoder.html" title="A helper class for reading signatures that use base64 encodings.">Base64SigDecoder</a></code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>a forward iterator whose associated value type is <code>char</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adfffa822958ac659211e2dac8735b369" name="adfffa822958ac659211e2dac8735b369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfffa822958ac659211e2dac8735b369">&#9670;&#160;</a></span>Base64SigDecoder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::Base64SigDecoder </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>encoding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skipInitialWhitespace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new decoder for the given encoded string. </p>
<p>The string itself should be passed as an iterator range. This iterator range must remain valid for the entire lifespan of this decoder.</p>
<dl class="section user"><dt>Python</dt><dd>Instead of an iterator range, this constructor takes a Python string. In Python (but not C++), the decoder will also keep a deep copy of the string, to ensure the lifespan requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>an iterator pointing to the beginning of the encoded string. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator that marks the end of the encoded string. </td></tr>
    <tr><td class="paramname">skipInitialWhitespace</td><td><code>true</code> if the current position should immediately advance past any initial whitespace in the given string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9fca27b73dc34b39aeb498dee0d910ee" name="a9fca27b73dc34b39aeb498dee0d910ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fca27b73dc34b39aeb498dee0d910ee">&#9670;&#160;</a></span>decodeInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeInt </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nChars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the next non-negative integer value, assuming this uses a fixed number of base64 characters. </p>
<p>This integer value would typically have been encoded using <a class="el" href="classregina_1_1Base64SigEncoder.html#af7e392bd3aafed2f43105343ff12669b" title="Encodes the given non-negative integer using a fixed number of base64 characters.">Base64SigEncoder::encodeInt()</a>, with the same <em>nChars</em> argument.</p>
<p>Specifically, it will be assumed that the integer has been broken into <em>nChars</em> 6-bit blocks, with each block encoded as a single base64 character, and with the blocks presented in order from lowest to highest significance.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#af7e392bd3aafed2f43105343ff12669b" title="Encodes the given non-negative integer using a fixed number of base64 characters.">Base64SigEncoder::encodeInt()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are fewer than <em>nChars</em> characters available in the encoded string, or a character was encountered that was not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be a native C++ <code>long</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>a native C++ integer type. The result will be assembled using bitwise OR and bitwise shift lefts, and it is assumed that the programmer has chosen an integer type large enough to contain whatever values they expect to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nChars</td><td>the number of base64 characters to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer that was decoded. </dd></dl>

</div>
</div>
<a id="a29881c91434484845527bfbb9eadfee7" name="a29881c91434484845527bfbb9eadfee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29881c91434484845527bfbb9eadfee7">&#9670;&#160;</a></span>decodeInts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeInts </td>
          <td>(</td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nChars</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a sequence of non-negative integer values, assuming that each individual value uses a fixed number of base64 characters. </p>
<p>Each such integer value would typically have been encoded using <a class="el" href="classregina_1_1Base64SigEncoder.html#af7e392bd3aafed2f43105343ff12669b" title="Encodes the given non-negative integer using a fixed number of base64 characters.">Base64SigEncoder::encodeInt()</a> or <a class="el" href="classregina_1_1Base64SigEncoder.html#aad9c8b9e07c327dad414e6f78f5afe7c" title="Encodes a sequence of non-negative integers, each using a fixed number of base64 characters.">Base64SigEncoder::encodeInts()</a>, with the same <em>nChars</em> argument.</p>
<p>Specifically, it will be assumed that each integer has been broken into <em>nChars</em> 6-bit blocks, with each block encoded as a single base64 character, and with the blocks presented in order from lowest to highest significance.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#aad9c8b9e07c327dad414e6f78f5afe7c" title="Encodes a sequence of non-negative integers, each using a fixed number of base64 characters.">Base64SigEncoder::encodeInts()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are fewer than `count × nChars` characters available in the encoded string, or a character was encountered that was not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can use the variant of this routine that does not take an output iterator, but instead returns the sequence of integers that were decoded.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>an output iterator whose associated value type is a native C++ integer type. Each integer that is decoded will be assembled using bitwise OR and bitwise shift lefts, and it is assumed that the programmer has chosen an integer type large enough to contain whatever values they expect to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an iterator to use for output. Each integer that is decoded will be passed to this iterator using the usual dereference-assign-increment pattern (<code>*output++ = value</code>). It is assumed that this output iterator is able to accept <em>count</em> values in this way. </td></tr>
    <tr><td class="paramname">count</td><td>the number of integers to decode. </td></tr>
    <tr><td class="paramname">nChars</td><td>the number of base64 characters to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08b517c662af89df20643c01fee04c8" name="ad08b517c662af89df20643c01fee04c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b517c662af89df20643c01fee04c8">&#9670;&#160;</a></span>decodeInts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FixedArray.html">FixedArray</a>&lt; IntType &gt; <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeInts </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nChars</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a sequence of non-negative integer values, assuming that each individual value uses a fixed number of base64 characters. </p>
<p>Each such integer value would typically have been encoded using <a class="el" href="classregina_1_1Base64SigEncoder.html#af7e392bd3aafed2f43105343ff12669b" title="Encodes the given non-negative integer using a fixed number of base64 characters.">Base64SigEncoder::encodeInt()</a> or <a class="el" href="classregina_1_1Base64SigEncoder.html#aad9c8b9e07c327dad414e6f78f5afe7c" title="Encodes a sequence of non-negative integers, each using a fixed number of base64 characters.">Base64SigEncoder::encodeInts()</a>, with the same <em>nChars</em> argument.</p>
<p>Specifically, it will be assumed that each integer has been broken into <em>nChars</em> 6-bit blocks, with each block encoded as a single base64 character, and with the blocks presented in order from lowest to highest significance.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#aad9c8b9e07c327dad414e6f78f5afe7c" title="Encodes a sequence of non-negative integers, each using a fixed number of base64 characters.">Base64SigEncoder::encodeInts()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are fewer than `count × nChars` characters available in the encoded string, or a character was encountered that was not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be a native C++ <code>long</code>. This routine returns a Python list of integers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>a native C++ integer type. The result will be assembled using bitwise OR and bitwise shift lefts, and it is assumed that the programmer has chosen an integer type large enough to contain whatever values they expect to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of integers to decode. </td></tr>
    <tr><td class="paramname">nChars</td><td>the number of base64 characters to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence of integers that were decoded. </dd></dl>

</div>
</div>
<a id="a5c55833c43cb9f88c5fde0ca00f7f888" name="a5c55833c43cb9f88c5fde0ca00f7f888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55833c43cb9f88c5fde0ca00f7f888">&#9670;&#160;</a></span>decodeSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeSingle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the 6-bit integer value represented by the next single base64 character. </p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#acb59fbebaa8f4ae5aec7b27989a2b076" title="Encodes the given 6-bit integer using a single base64 character.">Base64SigEncoder::encodeSingle()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are no more characters remaining in the encoded string, or the next character is not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be a native C++ <code>long</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>a native C++ integer type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding integer, which will be between 0 and 63 inclusive. </dd></dl>

</div>
</div>
<a id="a4aa7813a0d9b43e724528c9d4357cce9" name="a4aa7813a0d9b43e724528c9d4357cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa7813a0d9b43e724528c9d4357cce9">&#9670;&#160;</a></span>decodeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, int &gt; <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the next non-negative integer value (typically representing the size of some object), without knowing in advance how many base64 characters were used to encode it. </p>
<p>This integer value must have been encoded using <a class="el" href="classregina_1_1Base64SigEncoder.html#ab36bb86ef65cfeb92424bbe7ba29c906" title="Encodes the given non-negative integer (typically representing the size of some object),...">Base64SigEncoder::encodeSize()</a>.</p>
<p>A typical use case would be where <em>size</em> represents the number of top-dimensional simplices in a triangulation, or the number of crossings in a link diagram.</p>
<p>This routine also returns the smallest integer <em>b</em> with the property that any integer <em>x</em> between 0 and <em>size</em> inclusive can be encoded using <em>b</em> base64 characters. Typically these <em>x</em> would be <em>indices</em> into an object (e.g., top-dimensional simplex numbers, or crossing numbers). More precisely, <em>b</em> is the same integer that was returned when <em>size</em> was encoded using encodeSize(). Typically you would pass <em>b</em> to subsequent calls to <a class="el" href="#a9fca27b73dc34b39aeb498dee0d910ee" title="Decodes the next non-negative integer value, assuming this uses a fixed number of base64 characters.">decodeInt()</a>.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#ab36bb86ef65cfeb92424bbe7ba29c906" title="Encodes the given non-negative integer (typically representing the size of some object),...">Base64SigEncoder::encodeSize()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are not enough characters available in the encoded string, or a character was encountered that was not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>size</em>, <em>b</em>), where <em>size</em> is the integer that was decoded, and <em>b</em> is the number of base64 characters described above. </dd></dl>

</div>
</div>
<a id="a2c106df451cdc0e1750cfa22b7fa092e" name="a2c106df451cdc0e1750cfa22b7fa092e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c106df451cdc0e1750cfa22b7fa092e">&#9670;&#160;</a></span>decodeTrits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; uint8_t, 3 &gt; <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeTrits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes three trits from a single base64 character, and returns these as a fixed-size array. </p>
<p>A <em>trit</em> is either 0, 1 or 2.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#aee4fe810418fbd72f3e18c2c6828217b" title="Encodes a sequence of trits.">Base64SigEncoder::encodeTrits()</a>; see that routine for details of the encoding.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are no more characters remaining in the encoded string, or the next character is not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the three trits that were decoded. </dd></dl>

</div>
</div>
<a id="ab59ad970ae06ae016c7ca5cc94208c78" name="ab59ad970ae06ae016c7ca5cc94208c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59ad970ae06ae016c7ca5cc94208c78">&#9670;&#160;</a></span>decodeTrits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::decodeTrits </td>
          <td>(</td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes three trits from a single base64 character, and returns these using an output iterator. </p>
<p>A <em>trit</em> is either 0, 1 or 2.</p>
<p>The inverse to this routine is <a class="el" href="classregina_1_1Base64SigEncoder.html#aee4fe810418fbd72f3e18c2c6828217b" title="Encodes a sequence of trits.">Base64SigEncoder::encodeTrits()</a>; see that routine for details of the encoding.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>There are no more characters remaining in the encoded string, or the next character is not a valid base64 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can use the variant of this routine that takes no arguments and returns a fixed-size array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>an output iterator pointing to the location where the resulting trits will be stored; it must be possible to write and advance this iterator at least three times. Each trit will be written as a <code>uint8_t</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183c1d48905d5f8f80c72cde37efdc34" name="a183c1d48905d5f8f80c72cde37efdc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c1d48905d5f8f80c72cde37efdc34">&#9670;&#160;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::done </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreWhitespace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the current position has reached the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignoreWhitespace</td><td><code>true</code> if we should ignore any trailing whitespace. If there is whitespace at the current position, the current position will not be changed; this will merely make the test succeed if <em>only</em> whitespace characters remain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the current position is the end of the string. </dd></dl>

</div>
</div>
<a id="a6cf0cf24f9366a0d7f3478dc3be4bebd" name="a6cf0cf24f9366a0d7f3478dc3be4bebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf0cf24f9366a0d7f3478dc3be4bebd">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the given character one of the printable base64 characters recognised by this class? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the character to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>c</em> is one of the 64 printable characters described in the class notes. </dd></dl>

</div>
</div>
<a id="a2eea004daccbcb97809758596fb5c151" name="a2eea004daccbcb97809758596fb5c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eea004daccbcb97809758596fb5c151">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::peek </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character at the current position in the encoded string. </p>
<p>The current position will not move.</p>
<dl class="section return"><dt>Returns</dt><dd>the character at the current position, or 0 if there are no more characters available. </dd></dl>

</div>
</div>
<a id="a4aadc40a99cf4e869bd34078a479397d" name="a4aadc40a99cf4e869bd34078a479397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aadc40a99cf4e869bd34078a479397d">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::skip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances to the next position in the encoded string. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The current position has not yet reached the end of the string. </dd></dl>

</div>
</div>
<a id="a5ccfcb35d9945a835d16b6b580c6b6b8" name="a5ccfcb35d9945a835d16b6b580c6b6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccfcb35d9945a835d16b6b580c6b6b8">&#9670;&#160;</a></span>skipWhitespace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Base64SigDecoder.html">regina::Base64SigDecoder</a>&lt; Iterator &gt;::skipWhitespace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the current position past any whitespace. </p>
<p>The movement will stop upon reaching either a non-whitespace character or the end of the string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/<a class="el" href="sigutils_8h.html">sigutils.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
