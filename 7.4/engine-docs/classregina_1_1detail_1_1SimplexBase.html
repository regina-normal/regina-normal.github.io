<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::detail::SimplexBase&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="namespaceregina_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1detail_1_1SimplexBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::detail::SimplexBase&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__detail.html">Implementation details</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Helper class that provides core functionality for a top-dimensional simplex in a <em>dim</em>-manifold triangulation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/detail/simplex.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::detail::SimplexBase&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1detail_1_1SimplexBase.png" usemap="#regina::detail::SimplexBase_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::detail::SimplexBase_3C_20dim_20_3E_map" name="regina::detail::SimplexBase_3C_20dim_20_3E_map">
<area href="classregina_1_1MarkedElement.html" title="A base class for elements of MarkedVector." alt="regina::MarkedElement" shape="rect" coords="0,0,229,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SimplexBase&lt; dim &gt; &gt;" shape="rect" coords="239,0,468,24"/>
<area href="classregina_1_1Face_3_01dim_00_01dim_01_4.html" title="Represents a top-dimensional simplex in a dim-manifold triangulation." alt="regina::Face&lt; dim, dim &gt;" shape="rect" coords="119,112,348,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af6da480bdff6442179d26466c48983c7" id="r_af6da480bdff6442179d26466c48983c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6da480bdff6442179d26466c48983c7">FacetMask</a> = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;dim + 1&gt;::utype</td></tr>
<tr class="memdesc:af6da480bdff6442179d26466c48983c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type with at least <em>dim</em>+1 bits.  <br /></td></tr>
<tr class="separator:af6da480bdff6442179d26466c48983c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7a17790e0ba731b149dfb55f4ebd70" id="r_a5e7a17790e0ba731b149dfb55f4ebd70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e7a17790e0ba731b149dfb55f4ebd70">LockMask</a> = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;dim + 2&gt;::utype</td></tr>
<tr class="memdesc:a5e7a17790e0ba731b149dfb55f4ebd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type with at least <em>dim</em>+2 bits.  <br /></td></tr>
<tr class="separator:a5e7a17790e0ba731b149dfb55f4ebd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00178392c44456529f5250de6bc448ef" id="r_a00178392c44456529f5250de6bc448ef"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00178392c44456529f5250de6bc448ef">description</a> () const</td></tr>
<tr class="memdesc:a00178392c44456529f5250de6bc448ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description associated with this simplex.  <br /></td></tr>
<tr class="separator:a00178392c44456529f5250de6bc448ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d949a6ec9b90b7c9fce5c9da6dc52d6" id="r_a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d949a6ec9b90b7c9fce5c9da6dc52d6">setDescription</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description associated with this simplex.  <br /></td></tr>
<tr class="separator:a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf51cda05f67725962436cae590a0ff" id="r_abbf51cda05f67725962436cae590a0ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf51cda05f67725962436cae590a0ff">index</a> () const</td></tr>
<tr class="memdesc:abbf51cda05f67725962436cae590a0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of this simplex in the underlying triangulation.  <br /></td></tr>
<tr class="separator:abbf51cda05f67725962436cae590a0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c12cf55a47ae78e9b4e91ce46c838d" id="r_ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c12cf55a47ae78e9b4e91ce46c838d">adjacentSimplex</a> (int facet) const</td></tr>
<tr class="memdesc:ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the adjacent simplex that is glued to the given facet of this simplex.  <br /></td></tr>
<tr class="separator:ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ac592b6db07dba1487e054be273799" id="r_a39ac592b6db07dba1487e054be273799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ac592b6db07dba1487e054be273799">adjacentGluing</a> (int facet) const</td></tr>
<tr class="memdesc:a39ac592b6db07dba1487e054be273799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet.  <br /></td></tr>
<tr class="separator:a39ac592b6db07dba1487e054be273799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09416bf06b05b67bad21b9e5184e3584" id="r_a09416bf06b05b67bad21b9e5184e3584"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09416bf06b05b67bad21b9e5184e3584">adjacentFacet</a> (int facet) const</td></tr>
<tr class="memdesc:a09416bf06b05b67bad21b9e5184e3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>.  <br /></td></tr>
<tr class="separator:a09416bf06b05b67bad21b9e5184e3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb23e0e94cf30e7fe953691c926af6" id="r_a9cdb23e0e94cf30e7fe953691c926af6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cdb23e0e94cf30e7fe953691c926af6">hasBoundary</a> () const</td></tr>
<tr class="memdesc:a9cdb23e0e94cf30e7fe953691c926af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this simplex has any facets that lie on the triangulation boundary.  <br /></td></tr>
<tr class="separator:a9cdb23e0e94cf30e7fe953691c926af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f0a3046ec46f13f270bbc82193c5cc" id="r_ad1f0a3046ec46f13f270bbc82193c5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f0a3046ec46f13f270bbc82193c5cc">join</a> (int myFacet, <a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *you, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; gluing)</td></tr>
<tr class="memdesc:ad1f0a3046ec46f13f270bbc82193c5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the given facet of this simplex to some facet of another simplex.  <br /></td></tr>
<tr class="separator:ad1f0a3046ec46f13f270bbc82193c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d139902e93c8ddd7c17cd6f67729b22" id="r_a4d139902e93c8ddd7c17cd6f67729b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d139902e93c8ddd7c17cd6f67729b22">unjoin</a> (int myFacet)</td></tr>
<tr class="memdesc:a4d139902e93c8ddd7c17cd6f67729b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues the given facet of this simplex from whatever it is joined to.  <br /></td></tr>
<tr class="separator:a4d139902e93c8ddd7c17cd6f67729b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df524a7bf262cb0c43ec9d7c39b7687" id="r_a0df524a7bf262cb0c43ec9d7c39b7687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df524a7bf262cb0c43ec9d7c39b7687">isolate</a> ()</td></tr>
<tr class="memdesc:a0df524a7bf262cb0c43ec9d7c39b7687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues this simplex from any adjacent simplices.  <br /></td></tr>
<tr class="separator:a0df524a7bf262cb0c43ec9d7c39b7687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade04b3e3b11936271f6212af4ea80065" id="r_ade04b3e3b11936271f6212af4ea80065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade04b3e3b11936271f6212af4ea80065">lock</a> ()</td></tr>
<tr class="memdesc:ade04b3e3b11936271f6212af4ea80065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks this top-dimensional simplex.  <br /></td></tr>
<tr class="separator:ade04b3e3b11936271f6212af4ea80065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affacd41a6d53fcb1028aa3edbe0cf1cc" id="r_affacd41a6d53fcb1028aa3edbe0cf1cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc">lockFacet</a> (int facet)</td></tr>
<tr class="memdesc:affacd41a6d53fcb1028aa3edbe0cf1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the given facet of this top-dimensional simplex.  <br /></td></tr>
<tr class="separator:affacd41a6d53fcb1028aa3edbe0cf1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaf2c8a818d2aee173c308dc0ed283b" id="r_afbaf2c8a818d2aee173c308dc0ed283b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbaf2c8a818d2aee173c308dc0ed283b">unlock</a> ()</td></tr>
<tr class="memdesc:afbaf2c8a818d2aee173c308dc0ed283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks this top-dimensional simplex.  <br /></td></tr>
<tr class="separator:afbaf2c8a818d2aee173c308dc0ed283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad212e14b6c4b06f1f060d7a746d244c4" id="r_ad212e14b6c4b06f1f060d7a746d244c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad212e14b6c4b06f1f060d7a746d244c4">unlockFacet</a> (int facet)</td></tr>
<tr class="memdesc:ad212e14b6c4b06f1f060d7a746d244c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the given facet of this top-dimensional simplex.  <br /></td></tr>
<tr class="separator:ad212e14b6c4b06f1f060d7a746d244c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae735357568263f6741c81b7a422b18be" id="r_ae735357568263f6741c81b7a422b18be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae735357568263f6741c81b7a422b18be">unlockAll</a> ()</td></tr>
<tr class="memdesc:ae735357568263f6741c81b7a422b18be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks this top-dimensional simplex and all of its facets.  <br /></td></tr>
<tr class="separator:ae735357568263f6741c81b7a422b18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aa20fa27d7dcbb6fb65b115e01f4c8" id="r_a87aa20fa27d7dcbb6fb65b115e01f4c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87aa20fa27d7dcbb6fb65b115e01f4c8">isLocked</a> () const</td></tr>
<tr class="memdesc:a87aa20fa27d7dcbb6fb65b115e01f4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this top-dimensional simplex is locked.  <br /></td></tr>
<tr class="separator:a87aa20fa27d7dcbb6fb65b115e01f4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63b1c7a7514c4bb40053100cd237bb5" id="r_aa63b1c7a7514c4bb40053100cd237bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63b1c7a7514c4bb40053100cd237bb5">isFacetLocked</a> (int facet) const</td></tr>
<tr class="memdesc:aa63b1c7a7514c4bb40053100cd237bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given facet of this top-dimensional simplex is locked.  <br /></td></tr>
<tr class="separator:aa63b1c7a7514c4bb40053100cd237bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da080b2d13e92b72f295e8a01cb01bf" id="r_a7da080b2d13e92b72f295e8a01cb01bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5e7a17790e0ba731b149dfb55f4ebd70">LockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7da080b2d13e92b72f295e8a01cb01bf">lockMask</a> () const</td></tr>
<tr class="memdesc:a7da080b2d13e92b72f295e8a01cb01bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask indicating which of this simplex and/or its individual facets are locked.  <br /></td></tr>
<tr class="separator:a7da080b2d13e92b72f295e8a01cb01bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eca32827dd4091d889ad31dcbb97d8" id="r_ab4eca32827dd4091d889ad31dcbb97d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4eca32827dd4091d889ad31dcbb97d8">triangulation</a> () const</td></tr>
<tr class="memdesc:ab4eca32827dd4091d889ad31dcbb97d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation to which this simplex belongs.  <br /></td></tr>
<tr class="separator:ab4eca32827dd4091d889ad31dcbb97d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae91a7cee2cdc36220b08d9fe96985f7" id="r_aae91a7cee2cdc36220b08d9fe96985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae91a7cee2cdc36220b08d9fe96985f7">component</a> () const</td></tr>
<tr class="memdesc:aae91a7cee2cdc36220b08d9fe96985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component of the triangulation to which this simplex belongs.  <br /></td></tr>
<tr class="separator:aae91a7cee2cdc36220b08d9fe96985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727ea46d74705043806e29b1fe32c460" id="r_a727ea46d74705043806e29b1fe32c460"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a727ea46d74705043806e29b1fe32c460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a> (int face) const</td></tr>
<tr class="memdesc:a727ea46d74705043806e29b1fe32c460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex.  <br /></td></tr>
<tr class="separator:a727ea46d74705043806e29b1fe32c460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518c8ed0a013ce3c1dbb20a698b75603" id="r_a518c8ed0a013ce3c1dbb20a698b75603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a518c8ed0a013ce3c1dbb20a698b75603">vertex</a> (int i) const</td></tr>
<tr class="memdesc:a518c8ed0a013ce3c1dbb20a698b75603"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;0&gt;()</a>.  <br /></td></tr>
<tr class="separator:a518c8ed0a013ce3c1dbb20a698b75603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8084f81244f1dc7762a660e5bef7d0de" id="r_a8084f81244f1dc7762a660e5bef7d0de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8084f81244f1dc7762a660e5bef7d0de">edge</a> (int i) const</td></tr>
<tr class="memdesc:a8084f81244f1dc7762a660e5bef7d0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;1&gt;()</a>.  <br /></td></tr>
<tr class="separator:a8084f81244f1dc7762a660e5bef7d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0895af896d276deb85472bf9c1580c50" id="r_a0895af896d276deb85472bf9c1580c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0895af896d276deb85472bf9c1580c50">triangle</a> (int i) const</td></tr>
<tr class="memdesc:a0895af896d276deb85472bf9c1580c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;2&gt;()</a>.  <br /></td></tr>
<tr class="separator:a0895af896d276deb85472bf9c1580c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9846eebe589ac51da7492654fdd4d57f" id="r_a9846eebe589ac51da7492654fdd4d57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9846eebe589ac51da7492654fdd4d57f">tetrahedron</a> (int i) const</td></tr>
<tr class="memdesc:a9846eebe589ac51da7492654fdd4d57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;3&gt;()</a>.  <br /></td></tr>
<tr class="separator:a9846eebe589ac51da7492654fdd4d57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec21c78291855911ee3df06cf98fbf" id="r_a9fec21c78291855911ee3df06cf98fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fec21c78291855911ee3df06cf98fbf">pentachoron</a> (int i) const</td></tr>
<tr class="memdesc:a9fec21c78291855911ee3df06cf98fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;4&gt;()</a>.  <br /></td></tr>
<tr class="separator:a9fec21c78291855911ee3df06cf98fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73249760967ab8c0a6a274a27a7107b2" id="r_a73249760967ab8c0a6a274a27a7107b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73249760967ab8c0a6a274a27a7107b2">edge</a> (int i, int j) const</td></tr>
<tr class="memdesc:a73249760967ab8c0a6a274a27a7107b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edge of this simplex that connects the two given vertices of this simplex.  <br /></td></tr>
<tr class="separator:a73249760967ab8c0a6a274a27a7107b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f66b0a702a6b374af4f0830d9b2fe0" id="r_ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0">faceMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex.  <br /></td></tr>
<tr class="separator:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1897cda2880a990c43b8204e7c84ae" id="r_a6f1897cda2880a990c43b8204e7c84ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f1897cda2880a990c43b8204e7c84ae">vertexMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a6f1897cda2880a990c43b8204e7c84ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;0&gt;()</a>.  <br /></td></tr>
<tr class="separator:a6f1897cda2880a990c43b8204e7c84ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f115f464c4ca45a3fed98ad0c3ff2" id="r_a6b7f115f464c4ca45a3fed98ad0c3ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7f115f464c4ca45a3fed98ad0c3ff2">edgeMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a6b7f115f464c4ca45a3fed98ad0c3ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;1&gt;()</a>.  <br /></td></tr>
<tr class="separator:a6b7f115f464c4ca45a3fed98ad0c3ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4026cd53c2c99c5a542a57f059638190" id="r_a4026cd53c2c99c5a542a57f059638190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4026cd53c2c99c5a542a57f059638190">triangleMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a4026cd53c2c99c5a542a57f059638190"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;2&gt;()</a>.  <br /></td></tr>
<tr class="separator:a4026cd53c2c99c5a542a57f059638190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e52cfa234a402b1ba76dbcbc4726475" id="r_a1e52cfa234a402b1ba76dbcbc4726475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e52cfa234a402b1ba76dbcbc4726475">tetrahedronMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a1e52cfa234a402b1ba76dbcbc4726475"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;3&gt;()</a>.  <br /></td></tr>
<tr class="separator:a1e52cfa234a402b1ba76dbcbc4726475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b98b70d3a0dcdbcfa1ada8f9ccf8f8" id="r_a11b98b70d3a0dcdbcfa1ada8f9ccf8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b98b70d3a0dcdbcfa1ada8f9ccf8f8">pentachoronMapping</a> (int <a class="el" href="#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a11b98b70d3a0dcdbcfa1ada8f9ccf8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;4&gt;()</a>.  <br /></td></tr>
<tr class="separator:a11b98b70d3a0dcdbcfa1ada8f9ccf8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d5105d19509368d155e9f8c497f5e4" id="r_aa0d5105d19509368d155e9f8c497f5e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d5105d19509368d155e9f8c497f5e4">orientation</a> () const</td></tr>
<tr class="memdesc:aa0d5105d19509368d155e9f8c497f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation of this simplex in the <em>dim</em>-dimensional triangulation.  <br /></td></tr>
<tr class="separator:aa0d5105d19509368d155e9f8c497f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da19b23a42f47afe636a2cff5f0eee7" id="r_a9da19b23a42f47afe636a2cff5f0eee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da19b23a42f47afe636a2cff5f0eee7">facetInMaximalForest</a> (int facet) const</td></tr>
<tr class="memdesc:a9da19b23a42f47afe636a2cff5f0eee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation.  <br /></td></tr>
<tr class="separator:a9da19b23a42f47afe636a2cff5f0eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb07d86f5e49e7cf9effbcfa7645b7ce" id="r_adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb07d86f5e49e7cf9effbcfa7645b7ce">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98d5138a8528b99a8a77b4533784a4" id="r_abf98d5138a8528b99a8a77b4533784a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf98d5138a8528b99a8a77b4533784a4">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:abf98d5138a8528b99a8a77b4533784a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:abf98d5138a8528b99a8a77b4533784a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae0422e6904cdf32ce0d50793bb23fc" id="r_a9ae0422e6904cdf32ce0d50793bb23fc"><td class="memItemLeft" align="right" valign="top"><a id="a9ae0422e6904cdf32ce0d50793bb23fc" name="a9ae0422e6904cdf32ce0d50793bb23fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SimplexBase</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;)=delete</td></tr>
<tr class="separator:a9ae0422e6904cdf32ce0d50793bb23fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce8926a572f1551693082d598c399a4" id="r_a7ce8926a572f1551693082d598c399a4"><td class="memItemLeft" align="right" valign="top"><a id="a7ce8926a572f1551693082d598c399a4" name="a7ce8926a572f1551693082d598c399a4"></a>
<a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;)=delete</td></tr>
<tr class="separator:a7ce8926a572f1551693082d598c399a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5035a670e370a16699d1cf1c3649da8" id="r_af5035a670e370a16699d1cf1c3649da8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html#af5035a670e370a16699d1cf1c3649da8">markedIndex</a> () const</td></tr>
<tr class="memdesc:af5035a670e370a16699d1cf1c3649da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <br /></td></tr>
<tr class="separator:af5035a670e370a16699d1cf1c3649da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0285a5ebde8504bbd2def6182a511764" id="r_a0285a5ebde8504bbd2def6182a511764"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0285a5ebde8504bbd2def6182a511764">dimension</a> = dim</td></tr>
<tr class="memdesc:a0285a5ebde8504bbd2def6182a511764"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of the triangulation containing this simplex.  <br /></td></tr>
<tr class="separator:a0285a5ebde8504bbd2def6182a511764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd4045f14bd236b73cb0ac84b161827" id="r_acbd4045f14bd236b73cb0ac84b161827"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd4045f14bd236b73cb0ac84b161827">subdimension</a> = dim</td></tr>
<tr class="memdesc:acbd4045f14bd236b73cb0ac84b161827"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of this simplex.  <br /></td></tr>
<tr class="separator:acbd4045f14bd236b73cb0ac84b161827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1f6e247acf0c607c9a86722492ca5a1e" id="r_a1f6e247acf0c607c9a86722492ca5a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f6e247acf0c607c9a86722492ca5a1e">SimplexBase</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:a1f6e247acf0c607c9a86722492ca5a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex with no description and no facets joined to anything.  <br /></td></tr>
<tr class="separator:a1f6e247acf0c607c9a86722492ca5a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72d946efc3a8d31707d18b91e6aef8" id="r_abc72d946efc3a8d31707d18b91e6aef8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc72d946efc3a8d31707d18b91e6aef8">SimplexBase</a> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;clone, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:abc72d946efc3a8d31707d18b91e6aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex whose description and locks are cloned from the given simplex, and with no facets joined to anything.  <br /></td></tr>
<tr class="separator:abc72d946efc3a8d31707d18b91e6aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76cd3794530804f51f058fde6b86b09" id="r_aa76cd3794530804f51f058fde6b86b09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa76cd3794530804f51f058fde6b86b09">SimplexBase</a> (std::string desc, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:aa76cd3794530804f51f058fde6b86b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex with the given description, no locks, and no facets joined to anything.  <br /></td></tr>
<tr class="separator:aa76cd3794530804f51f058fde6b86b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf0938b3117fb7b3fc26304d5541e0" id="r_ad7bf0938b3117fb7b3fc26304d5541e0"><td class="memTemplParams" colspan="2">template&lt;int useDim&gt; </td></tr>
<tr class="memitem:ad7bf0938b3117fb7b3fc26304d5541e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7bf0938b3117fb7b3fc26304d5541e0">sameDegreesAt</a> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p) const</td></tr>
<tr class="memdesc:ad7bf0938b3117fb7b3fc26304d5541e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>useDim</em>-face degrees of this and the given simplex are identical, under the given relabelling.  <br /></td></tr>
<tr class="separator:ad7bf0938b3117fb7b3fc26304d5541e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1392ae583030f05629f71d6e7d3eb69f" id="r_a1392ae583030f05629f71d6e7d3eb69f"><td class="memTemplParams" colspan="2">template&lt;int... useDim&gt; </td></tr>
<tr class="memitem:a1392ae583030f05629f71d6e7d3eb69f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1392ae583030f05629f71d6e7d3eb69f">sameDegreesAt</a> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p, std::integer_sequence&lt; int, useDim... &gt;) const</td></tr>
<tr class="memdesc:a1392ae583030f05629f71d6e7d3eb69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces whose dimensions are contained in the integer pack <em>useDim</em>.  <br /></td></tr>
<tr class="separator:a1392ae583030f05629f71d6e7d3eb69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5568151bbbf92a4593d1836c8e954c07" id="r_a5568151bbbf92a4593d1836c8e954c07"><td class="memItemLeft" align="right" valign="top"><a id="a5568151bbbf92a4593d1836c8e954c07" name="a5568151bbbf92a4593d1836c8e954c07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TriangulationBase&lt; dim &gt;</b></td></tr>
<tr class="separator:a5568151bbbf92a4593d1836c8e954c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac4dded60d8f6ec4e40d49ca37e9057" id="r_a4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top"><a id="a4ac4dded60d8f6ec4e40d49ca37e9057" name="a4ac4dded60d8f6ec4e40d49ca37e9057"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Triangulation&lt; dim &gt;</b></td></tr>
<tr class="separator:a4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02d35e7992eff6bd43e68de6864065" id="r_a2f02d35e7992eff6bd43e68de6864065"><td class="memItemLeft" align="right" valign="top"><a id="a2f02d35e7992eff6bd43e68de6864065" name="a2f02d35e7992eff6bd43e68de6864065"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLSimplexReader&lt; dim &gt;</b></td></tr>
<tr class="separator:a2f02d35e7992eff6bd43e68de6864065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac377521d7bc0dc2b8ac276195d4b2e" id="r_a7ac377521d7bc0dc2b8ac276195d4b2e"><td class="memItemLeft" align="right" valign="top"><a id="a7ac377521d7bc0dc2b8ac276195d4b2e" name="a7ac377521d7bc0dc2b8ac276195d4b2e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTriangulationReader&lt; dim &gt;</b></td></tr>
<tr class="separator:a7ac377521d7bc0dc2b8ac276195d4b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::detail::SimplexBase&lt; dim &gt;</div><p>Helper class that provides core functionality for a top-dimensional simplex in a <em>dim</em>-manifold triangulation. </p>
<p>Each top-dimensional simplex is represented by the class Simplex&lt;dim&gt;, which uses this as a base class. End users should not need to refer to <a class="el" href="classregina_1_1detail_1_1SimplexBase.html" title="Helper class that provides core functionality for a top-dimensional simplex in a dim-manifold triangu...">SimplexBase</a> directly.</p>
<p>See the Simplex template class notes for further information, including details of how the vertices and facets of each simplex are numbered.</p>
<p>Neither this class nor the "end user" class Simplex&lt;dim&gt; support value semantics: they cannot be copied, swapped, or manually constructed. Their memory is managed by the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> class, and their locations in memory define them. See Simplex&lt;dim&gt; for further details.</p>
<dl class="section user"><dt>Python</dt><dd>This base class is not present, but the "end user" class Simplex&lt;dim&gt; is.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af6da480bdff6442179d26466c48983c7" name="af6da480bdff6442179d26466c48983c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6da480bdff6442179d26466c48983c7">&#9670;&#160;</a></span>FacetMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::FacetMask = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;dim + 1&gt;::utype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned integer type with at least <em>dim</em>+1 bits. </p>
<p>This can be used as a bitmask for the <em>dim</em>+1 facets (or vertices) of a <em>dim</em>-simplex. </p>

</div>
</div>
<a id="a5e7a17790e0ba731b149dfb55f4ebd70" name="a5e7a17790e0ba731b149dfb55f4ebd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7a17790e0ba731b149dfb55f4ebd70">&#9670;&#160;</a></span>LockMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::LockMask = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;dim + 2&gt;::utype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned integer type with at least <em>dim</em>+2 bits. </p>
<p>The <em>i</em>th bit indicates whether facet <em>i</em> of the simplex is locked for 0 ≤ <em>i</em> ≤ <em>dim</em>, and the (<em>dim</em>+2)th bit indicates whether the simplex itself is locked. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f6e247acf0c607c9a86722492ca5a1e" name="a1f6e247acf0c607c9a86722492ca5a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6e247acf0c607c9a86722492ca5a1e">&#9670;&#160;</a></span>SimplexBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::SimplexBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex with no description and no facets joined to anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which the new simplex belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc72d946efc3a8d31707d18b91e6aef8" name="abc72d946efc3a8d31707d18b91e6aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72d946efc3a8d31707d18b91e6aef8">&#9670;&#160;</a></span>SimplexBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::SimplexBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clone</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>tri</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex whose description and locks are cloned from the given simplex, and with no facets joined to anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clone</td><td>the simplex whose details should be cloned. </td></tr>
    <tr><td class="paramname">tri</td><td>the triangulation to which the new simplex belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa76cd3794530804f51f058fde6b86b09" name="aa76cd3794530804f51f058fde6b86b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76cd3794530804f51f058fde6b86b09">&#9670;&#160;</a></span>SimplexBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::SimplexBase </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>tri</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex with the given description, no locks, and no facets joined to anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give the new simplex. </td></tr>
    <tr><td class="paramname">tri</td><td>the triangulation to which the new simplex belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09416bf06b05b67bad21b9e5184e3584" name="a09416bf06b05b67bad21b9e5184e3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09416bf06b05b67bad21b9e5184e3584">&#9670;&#160;</a></span>adjacentFacet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentFacet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>. </p>
<p>The return value from this routine is identical to adjacentGluing(<em>facet</em>)[<em>facet</em>].</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding facet number of the adjacent simplex that is glued to the given facet of this simplex. </dd></dl>

</div>
</div>
<a id="a39ac592b6db07dba1487e054be273799" name="a39ac592b6db07dba1487e054be273799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ac592b6db07dba1487e054be273799">&#9670;&#160;</a></span>adjacentGluing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentGluing </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet. </p>
<p>In detail: suppose that the given facet of this simplex is glued to an adjacent simplex <em>A</em>. Then this gluing induces a mapping from the vertices of this simplex to the vertices of <em>A</em>. We can express this mapping in the form of a permutation <em>p</em>, where:</p>
<ul>
<li>for any <em>v</em> ≠ <em>facet</em>, the gluing identifies vertex <em>v</em> of this simplex with vertex <em>p</em>[<em>v</em>] of simplex <em>A</em>;</li>
<li><em>p</em>[<em>facet</em>] indicates the facet of <em>A</em> that is on the other side of the gluing (i.e., the facet of <em>A</em> that is glued to the given facet of this simplex).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation that maps the vertices of this simplex to the vertices of the adjacent simplex, as described above. </dd></dl>

</div>
</div>
<a id="ad0c12cf55a47ae78e9b4e91ce46c838d" name="ad0c12cf55a47ae78e9b4e91ce46c838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c12cf55a47ae78e9b4e91ce46c838d">&#9670;&#160;</a></span>adjacentSimplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentSimplex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the adjacent simplex that is glued to the given facet of this simplex. </p>
<p>If there is no adjacent simplex (i.e., the given facet lies on the triangulation boundary), then this routine will return <code>null</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex to examine; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacent simplex glued to the given facet, or <code>null</code> if the given facet lies on the boundary. </dd></dl>

</div>
</div>
<a id="aae91a7cee2cdc36220b08d9fe96985f7" name="aae91a7cee2cdc36220b08d9fe96985f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae91a7cee2cdc36220b08d9fe96985f7">&#9670;&#160;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connected component of the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this simplex. </dd></dl>

</div>
</div>
<a id="a00178392c44456529f5250de6bc448ef" name="a00178392c44456529f5250de6bc448ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00178392c44456529f5250de6bc448ef">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::description </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description associated with this simplex. </p>
<dl class="section return"><dt>Returns</dt><dd>the description of this simplex, or the empty string if no description is stored. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt;, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a8084f81244f1dc7762a660e5bef7d0de" name="a8084f81244f1dc7762a660e5bef7d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8084f81244f1dc7762a660e5bef7d0de">&#9670;&#160;</a></span>edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;1&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face()</a> for further information. </p>

</div>
</div>
<a id="a73249760967ab8c0a6a274a27a7107b2" name="a73249760967ab8c0a6a274a27a7107b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73249760967ab8c0a6a274a27a7107b2">&#9670;&#160;</a></span>edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the edge of this simplex that connects the two given vertices of this simplex. </p>
<p>This is a convenience routine to avoid more cumbersome calls to <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html#aa5b31f7b5e66f5435fec37daf3e30d50" title="Identifies which subdim-face in a dim-dimensional simplex is represented by the first (subdim + 1) el...">Edge&lt;dim&gt;::faceNumber()</a>. In dimensions 3 and 4 (where the array Edge&lt;dim&gt;::edgeNumber is defined), this routine is identical to calling <code>edge(Edge&lt;dim&gt;::edgeNumber[i][j])</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the vertex of this simplex that forms one endpoint of the edge; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">j</td><td>the vertex of this simplex that forms the other endpoint of the edge; this must be between 0 and <em>dim</em> inclusive, and must also be different from <em>i</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge of this simplex that connects vertices <em>i</em> and <em>j</em> of this simplex. </dd></dl>

</div>
</div>
<a id="a6b7f115f464c4ca45a3fed98ad0c3ff2" name="a6b7f115f464c4ca45a3fed98ad0c3ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f115f464c4ca45a3fed98ad0c3ff2">&#9670;&#160;</a></span>edgeMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::edgeMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;1&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> for further information. </p>

</div>
</div>
<a id="a727ea46d74705043806e29b1fe32c460" name="a727ea46d74705043806e29b1fe32c460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727ea46d74705043806e29b1fe32c460">&#9670;&#160;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex. </p>
<p>See <a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering&lt;dim, subdim&gt;</a> for the conventions of how <em>subdim</em>-faces are numbered within a <em>dim</em>-simplex.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the subface to examine. This must be between 0 and (<em>dim</em> - 1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>subdim</em>-face of the triangulation. </dd></dl>

</div>
</div>
<a id="ab5f66b0a702a6b374af4f0830d9b2fe0" name="ab5f66b0a702a6b374af4f0830d9b2fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f66b0a702a6b374af4f0830d9b2fe0">&#9670;&#160;</a></span>faceMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::faceMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex. </p>
<p>Specifically:</p>
<ul>
<li>Suppose several <em>subdim</em>-faces of several top-dimensional simplices are identified within the overall triangulation. Then we call this a single "&lt;i&gt;subdim&lt;/i&gt;-face of the triangulation", and arbitrarily label its vertices (0, ..., <em>subdim</em>).</li>
<li>Now let <em>F</em> denote the <em>subdim</em>-face of the triangulation that corresponds to <em>subdim</em>-face number <em>face</em> of this simplex. Then this routine returns a map from vertices (0, ..., <em>subdim</em>) of <em>F</em> to the corresponding vertex numbers of this simplex.</li>
<li>In particular, if this routine returns the permutation <em>p</em>, then the images <em>p</em>[0,...,<em>subdim</em>] will be some permutation of the vertices <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html#adf38141ecaf39180ca0e7882413fad19" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Face&lt;dim, subdim&gt;::ordering</a>[0,...,<em>subdim</em>].</li>
<li>If <em>F</em> also appears as face number <em>k</em> in some other simplex <em>s</em>, then for each <em>i</em> in the range 0 ≤ <em>i</em> ≤ <em>subdim</em>, vertex <code>p[i]</code> of this simplex will be identified with vertex <code>s.faceMapping(k)[i]</code> of simplex <em>s</em>.</li>
</ul>
<p>If the link of the underlying <em>subdim</em>-face is orientable, then this permutation maps the remaining numbers (<em>subdim</em>+1, ..., <em>dim</em>) to the remaining vertex numbers of this simplex in a manner that preserves orientation as you walk through the many different simplices that contain the same underlying <em>subdim</em>-face. Specifically:</p>
<ul>
<li>The images of (<em>subdim</em>+1, ..., <em>dim</em>) under this permutation imply an orientation for the (<em>dim</em> - <em>subdim</em> - 1)-face opposite <em>F</em> in this simplex. These orientations will be consistent for all simplices containing <em>F</em>.</li>
<li>For faces of codimension two (e.g., edges in a 3-manifold triangulation), this orientation condition is even stronger. Here the link of the face <em>F</em> must be a path (for a boundary face) or a cycle (for an internal face). In each simplex we can form a directed edge from the image of <em>dim</em>-1 to the image of <em>dim</em> under this permutation, and together these directed edges form a directed path or cycle that follows the link of the face <em>F</em>. Moreover, an iteration through the corresponding FaceEmbedding&lt;dim, subdim&gt; objects in order from <code>F.begin()</code> to <code>F.end()</code>, will follow this directed path in order from start to end. (In the case where the link of <em>F</em> is a cycle, the start point in the list of <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a> objects will be arbitrary.)</li>
</ul>
<p>Note that, even if the link is orientable, there are still arbitrary decisions to be made for the images of (<em>subdim</em>+1, ..., <em>dim</em>), since there will always be (<em>dim</em>-<em>subdim</em>)!/2 possible mappings that yield the correct orientation.</p>
<p>If this simplex (and therefore the face <em>F</em>) belongs to an <em>orientable</em> component of the triangulation, then there will also be connections between <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> and the orientations of the top-dimensional simplices (as returned by <a class="el" href="#aa0d5105d19509368d155e9f8c497f5e4" title="Returns the orientation of this simplex in the dim-dimensional triangulation.">orientation()</a>):</p>
<ul>
<li>If <em>subdim</em> is less than (<em>dim</em> - 1), then the sign of the permutation returned by <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> will always be equal to the orientation of this simplex.</li>
<li>If <em>subdim</em> is equal to (<em>dim</em> - 1), then the face <em>F</em> can only belong to either one or two top-dimensional simplices; let <em>s0</em> and <em>s1</em> be the simplices corresponding to <code>F.embedding(0)</code> and (if it exists) <code>F.embedding(1)</code> respectively. Then in the simplex <em>s0</em>, the sign of the <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> permutation will match the orientation of <em>s0</em>, and in <em>s1</em> (if it exists), the sign of the <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> permutation will be negative the orientation of <em>s1</em>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This routine returns the same permutation as <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html#a8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;dim, subdim&gt;::vertices()</a>, in the context of the FaceEmbedding&lt;dim, subdim&gt; object that refers to <em>subdim</em>-face number <em>face</em> of this simplex.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>faceMapping(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the subface to examine. This must be between 0 and (<em>dim</em> - 1) inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>subdim</em>-face of the triangulation to the vertices of this simplex. </dd></dl>

</div>
</div>
<a id="a9da19b23a42f47afe636a2cff5f0eee7" name="a9da19b23a42f47afe636a2cff5f0eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da19b23a42f47afe636a2cff5f0eee7">&#9670;&#160;</a></span>facetInMaximalForest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::facetInMaximalForest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation. </p>
<p>When the skeletal structure of a triangulation is first computed, a maximal forest in the dual 1-skeleton of the triangulation is also constructed. Each dual edge in this maximal forest represents a (<em>dim</em>-1)-face of the (primal) triangulation.</p>
<p>This maximal forest will remain fixed until the triangulation changes, at which point it will be recomputed (as will all other skeletal objects, such as connected components and so on). There is no guarantee that, when it is recomputed, the maximal forest will use the same dual edges as before.</p>
<p>This routine identifies which (<em>dim</em>-1)-faces of the triangulation belong to the dual forest. Because it lives in the Simplex class, this routine can even be used for those dimensions that do not have explicit classes for (<em>dim</em>-1)-faces of the triangulation.</p>
<p>If the skeleton has already been computed, then this routine is very fast (since it just returns a precomputed answer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given facet of this simplex corresponds to a dual edge in the maximal forest chosen for the dual 1-skeleton. </dd></dl>

</div>
</div>
<a id="a9cdb23e0e94cf30e7fe953691c926af6" name="a9cdb23e0e94cf30e7fe953691c926af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdb23e0e94cf30e7fe953691c926af6">&#9670;&#160;</a></span>hasBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::hasBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this simplex has any facets that lie on the triangulation boundary. </p>
<p>In other words, this routine determines whether any facet of this simplex is not currently glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this simplex has any boundary facets. </dd></dl>

</div>
</div>
<a id="abbf51cda05f67725962436cae590a0ff" name="abbf51cda05f67725962436cae590a0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf51cda05f67725962436cae590a0ff">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of this simplex in the underlying triangulation. </p>
<p>The index will be an integer between 0 and <code><a class="el" href="#ab4eca32827dd4091d889ad31dcbb97d8" title="Returns the triangulation to which this simplex belongs.">triangulation()</a>.size()-1</code> inclusive.</p>
<p>Note that indexing may change when a simplex is added to or removed from the underlying triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of this simplex. </dd></dl>

</div>
</div>
<a id="aa63b1c7a7514c4bb40053100cd237bb5" name="aa63b1c7a7514c4bb40053100cd237bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63b1c7a7514c4bb40053100cd237bb5">&#9670;&#160;</a></span>isFacetLocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::isFacetLocked </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given facet of this top-dimensional simplex is locked. </p>
<p>Essentially, locking a facet means that that facet must not change. See <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>Note that you can also lock an entire top-dimensional simplex; see <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> for details. This routine does <em>not</em> test whether the top-dimensional simplex is locked; it only tests for a lock on the given facet.</p>
<p>See <a class="el" href="#a7da080b2d13e92b72f295e8a01cb01bf" title="Returns a bitmask indicating which of this simplex and/or its individual facets are locked.">lockMask()</a> for a convenient way to test in a single query whether this simplex and/or any of its facets are locked. Also, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac40a47a823d15f016cd0efeb9d1b1644" title="Identifies whether any top-dimensional simplices and/or any of their facets are locked.">Triangulation&lt;dim&gt;::hasLocks()</a> offers a simple way to test whether a triangulation has any locked <em>dim</em>-simplices or facets at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>indicates which facet of this simplex to examine; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given facet of this simplex is locked. </dd></dl>

</div>
</div>
<a id="a87aa20fa27d7dcbb6fb65b115e01f4c8" name="a87aa20fa27d7dcbb6fb65b115e01f4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aa20fa27d7dcbb6fb65b115e01f4c8">&#9670;&#160;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::isLocked </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this top-dimensional simplex is locked. </p>
<p>Essentially, locking a simplex means that that simplex must not change. See <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> for full details on how locks work and what their implications are.</p>
<p>Note that you can also lock the individual facets of a simplex (that is, its (<em>dim</em>-1)-faces); see <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for details. This routine does <em>not</em> test whether any facets of this simplex are locked; it only tests for a lock on the top-dimensional simplex itself.</p>
<p>See <a class="el" href="#a7da080b2d13e92b72f295e8a01cb01bf" title="Returns a bitmask indicating which of this simplex and/or its individual facets are locked.">lockMask()</a> for a convenient way to test in a single query whether this simplex and/or any of its facets are locked. Also, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac40a47a823d15f016cd0efeb9d1b1644" title="Identifies whether any top-dimensional simplices and/or any of their facets are locked.">Triangulation&lt;dim&gt;::hasLocks()</a> offers a simple way to test whether a triangulation has any locked <em>dim</em>-simplices or facets at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this simplex is locked. </dd></dl>

</div>
</div>
<a id="a0df524a7bf262cb0c43ec9d7c39b7687" name="a0df524a7bf262cb0c43ec9d7c39b7687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df524a7bf262cb0c43ec9d7c39b7687">&#9670;&#160;</a></span>isolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::isolate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unglues this simplex from any adjacent simplices. </p>
<p>As a result, every facet of this simplex will become a boundary facet, and this simplex will form its own separate component of the underlying triangulation.</p>
<p>If there were any adjacent simplices to begin with, these will be updated automatically.</p>
<p>This routine is safe to call even if there are no adjacent simplices (in which case it will do nothing).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>At least one facet of this simplex is non-boundary and currently locked. This exception will be thrown before any change is made. See <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for further details on how facet locks work and what their implications are. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1f0a3046ec46f13f270bbc82193c5cc" name="ad1f0a3046ec46f13f270bbc82193c5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f0a3046ec46f13f270bbc82193c5cc">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::join </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>myFacet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; *</td>          <td class="paramname"><span class="paramname"><em>you</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;</td>          <td class="paramname"><span class="paramname"><em>gluing</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins the given facet of this simplex to some facet of another simplex. </p>
<p>The other simplex will be updated automatically (i.e., you only need to call <a class="el" href="#ad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">join()</a> from one side of the gluing).</p>
<p>You may join a facet of this simplex to some different facet of the same simplex (i.e., you may pass <em>you</em> == <code>this</code>), though you cannot join a facet to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given simplex belong to the same triangulation. </dd>
<dd>
The given facet of this simplex is not currently glued to anything. </dd>
<dd>
The corresponding facet of the other simplex (i.e., facet <em>gluing</em>[<em>myFacet</em>] of <em>you</em>) is likewise not currently glued to anything. </dd>
<dd>
We are not attempting to glue a facet to itself (i.e., we do not have both <em>you</em> == <code>this</code> and <em>gluing</em>[<em>myFacet</em>] == <em>myFacet</em>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>At least one of the conditions above fails; that is, either the two simplices being joined belong to different triangulations, or one of the two facets being joined is already joined to something, or you are trying to join the same facet of the same simplex to itself.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>The given facet of this simplex is currently locked. This exception will be thrown before any change is made. See <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for further details on how facet locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex that will be glued to the given simplex <em>you</em>. This facet number must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">you</td><td>the other simplex that will be glued to the given facet of this simplex. </td></tr>
    <tr><td class="paramname">gluing</td><td>a permutation that describes how the vertices of this simplex will map to the vertices of <em>you</em> across the new gluing. This permutation should be in the form described by <a class="el" href="#a39ac592b6db07dba1487e054be273799" title="Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex acro...">adjacentGluing()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade04b3e3b11936271f6212af4ea80065" name="ade04b3e3b11936271f6212af4ea80065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade04b3e3b11936271f6212af4ea80065">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks this top-dimensional simplex. </p>
<p>Essentially, locking a simplex means that that simplex must not change. Specifically:</p>
<ul>
<li>A locked simplex cannot be removed completely (e.g., via <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">Triangulation&lt;dim&gt;::removeSimplex()</a> or via moves such as edge collapses or 2-0 moves).</li>
<li>A locked simplex cannot be subdivided (e.g., via <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">Triangulation&lt;dim&gt;::subdivide()</a>, or via a 1-(<em>dim</em>+1) Pachner move).</li>
<li>A locked simplex cannot be merged with adjacent simplices (e.g., via any of the other Pachner moves).</li>
</ul>
<p>Regina's own automatic retriangulation routines (such as Triangulation&lt;dim&gt;::simplify() or Triangulation&lt;dim&gt;::retriangulate()) will simply avoid changing any locked simplices. If the user attempts to manually force a change (e.g., by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">Triangulation&lt;dim&gt;::subdivide()</a>), then a <a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a> exception will be thrown.</p>
<p>It is safe to call this function even if this simplex is already locked.</p>
<p>Note that you can also lock the individual facets of a simplex (that is, its (<em>dim</em>-1)-faces); see <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for details. Locking a simplex does <em>not</em> imply that its facets will be automatically locked also; these are independent concepts.</p>
<p>The <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> copy constructor and assignment operators will preserve locks (i.e., the simplices/facets of the new triangulation will be locked in the same way as the simplices/facets of the source).</p>
<p>Locks will not interfere with the destruction of a triangulation (i.e., the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> destructor does not check for locks).</p>
<p>Changing locks is considered a modification of the triangulation (in particular, if the triangulation is wrapped in a packet then the appropriate change events will be fired). </p>

</div>
</div>
<a id="affacd41a6d53fcb1028aa3edbe0cf1cc" name="affacd41a6d53fcb1028aa3edbe0cf1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affacd41a6d53fcb1028aa3edbe0cf1cc">&#9670;&#160;</a></span>lockFacet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::lockFacet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the given facet of this top-dimensional simplex. </p>
<p>Essentially, locking a facet means that that facet must not change. Specifically:</p>
<ul>
<li>A locked boundary facet cannot be glued to some other top-dimensional simplex (e.g., via <a class="el" href="#ad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">join()</a>).</li>
<li>A locked internal (non-boundary) facet cannot made boundary by explicitly ungluing (e.g., via <a class="el" href="#a4d139902e93c8ddd7c17cd6f67729b22" title="Unglues the given facet of this simplex from whatever it is joined to.">unjoin()</a> or <a class="el" href="#a0df524a7bf262cb0c43ec9d7c39b7687" title="Unglues this simplex from any adjacent simplices.">isolate()</a>).</li>
<li>A locked facet cannot be removed completely (e.g., a facet internal to the region where a Pachner move is performed, or a facet internal to the region removed by a 2-0 move or edge collapse).</li>
<li>A locked facet cannot be subdivided (e.g., via <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">Triangulation&lt;dim&gt;::subdivide()</a>.</li>
</ul>
<p>There are some important exceptions to these rules:</p>
<ul>
<li>We do allow moves on the triangulation that topologically "flatten" a region beside a locked facet <em>F</em>, as long as <em>F</em> survives topologically. For example, we allow 2-0 moves or edge collapses that merge <em>F</em> with a parallel (<em>dim-1</em>)-face, even if this changes <em>F</em> from internal to boundary (because <em>F</em> was merged with a boundary facet). Likewise, we allow boundary shellings that expose an internal locked facet to the boundary (because this is a "topological flattening", not just an arbitrary ungluing). In all such cases, the lock "moves" with <em>F</em> to its new (possibly merged, possibly boundary) location.</li>
<li>Further to the previous point: we do <em>not</em> allow boundary shellings that remove a locked <em>boundary</em> facet G. This is because <em>G</em> does not survive topologically (i.e., the resulting boundary facets after the shelling are not isotopies of <em>G</em>).</li>
<li>We also allow moves that "pry open" a (<em>dim-1</em>)-face <em>F</em> to become a pair of parallel faces <em>F1</em>, <em>F2</em>, between which new material is inserted. For example, this kind of operation happens with pinchEdge() and connected sum operations in dimension 3, and snapEdge() in dimension 4. In this case, the lock will move across to one of <em>F1</em> or <em>F2</em>. In particular, if <em>F</em> was originally boundary then the lock will move to whichever of <em>F1</em> or <em>F2</em> is boundary after the operation is complete; otherwise the choice of <em>F1</em> versus <em>F2</em> is arbitrary.</li>
</ul>
<p>Regina's own automatic retriangulation routines (such as Triangulation&lt;dim&gt;::simplify() or Triangulation&lt;dim&gt;::retriangulate()) will simply avoid changing any locked facets. If the user attempts to manually force a change (e.g., by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491" title="Does a barycentric subdivision of the triangulation.">Triangulation&lt;dim&gt;::subdivide()</a>), then a <a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a> exception will be thrown.</p>
<p>Regina will always ensure that the locks on facets are consistent. That is, if some facet <em>F</em> of some top-dimensional simplex is glued to some facet <em>G</em> of some top-dimensional simplex, then whenever <em>F</em> is locked/unlocked, Regina will automatically lock/unlock <em>G</em> also.</p>
<p>It is safe to call this function even if the given facet is already locked.</p>
<p>Note that you can also lock an entire top-dimensional simplex; see <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> for details. Locking a simplex does <em>not</em> imply that its facets will be automatically locked also, or vice versa; these are independent concepts.</p>
<p>The <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> copy constructor and assignment operators will preserve locks (i.e., the simplices/facets of the new triangulation will be locked in the same way as the simplices/facets of the source).</p>
<p>Locks will not interfere with the destruction of a triangulation (i.e., the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> destructor does not check for locks).</p>
<p>Changing locks is considered a modification of the triangulation (in particular, if the triangulation is wrapped in a packet then the appropriate change events will be fired).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>indicates which facet of this simplex to lock; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7da080b2d13e92b72f295e8a01cb01bf" name="a7da080b2d13e92b72f295e8a01cb01bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da080b2d13e92b72f295e8a01cb01bf">&#9670;&#160;</a></span>lockMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt;<a class="el" href="#a5e7a17790e0ba731b149dfb55f4ebd70">::LockMask</a> <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::lockMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask indicating which of this simplex and/or its individual facets are locked. </p>
<p>Essentially, locking a top-dimensional simplex or one of its facets means that that simplex or facet must not change. See <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> and <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>This routine returns a bitmask containing <code>dim+2</code> bits (here we number the bits so that the 0th bit is the least significant). The <em>k</em>th bit is set if and only if the <em>k</em>th facet of this simplex is locked, for 0 ≤ <em>k</em> ≤ <em>dim</em>. Finally, the (<em>dim</em>+1)th bit is set if and only if this simplex itself is locked.</p>
<p>See also <a class="el" href="#a87aa20fa27d7dcbb6fb65b115e01f4c8" title="Determines whether this top-dimensional simplex is locked.">isLocked()</a> and <a class="el" href="#aa63b1c7a7514c4bb40053100cd237bb5" title="Determines whether the given facet of this top-dimensional simplex is locked.">isFacetLocked()</a> for a more convenient way to query the simplex and/or one of its facets individually, and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac40a47a823d15f016cd0efeb9d1b1644" title="Identifies whether any top-dimensional simplices and/or any of their facets are locked.">Triangulation&lt;dim&gt;::hasLocks()</a> for a simple way to query all top-dimensional simplices and their facets across the entire triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>a bitmask indicating which of this simplex and/or its facets are locked. This bitmask will be returned using a native C++ unsigned integer type of the appropriate size. </dd></dl>

</div>
</div>
<a id="af5035a670e370a16699d1cf1c3649da8" name="af5035a670e370a16699d1cf1c3649da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5035a670e370a16699d1cf1c3649da8">&#9670;&#160;</a></span>markedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedElement::markedIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>. </p>
<p>If this object does not belong to an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>, the return value is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the index at which this object is stored. </dd></dl>

</div>
</div>
<a id="aa0d5105d19509368d155e9f8c497f5e4" name="aa0d5105d19509368d155e9f8c497f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d5105d19509368d155e9f8c497f5e4">&#9670;&#160;</a></span>orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::orientation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the orientation of this simplex in the <em>dim</em>-dimensional triangulation. </p>
<p>The orientation of each top-dimensional simplex is always +1 or -1. In an orientable component of a triangulation, adjacent simplices have the same orientations if one could be transposed onto the other without reflection, and they have opposite orientations if a reflection would be required. In a non-orientable component, orientations are arbitrary (but they will still all be +1 or -1).</p>
<p>In each component, the top-dimensional simplex with smallest index will always have orientation +1. In particular, simplex 0 will always have orientation +1.</p>
<dl class="section return"><dt>Returns</dt><dd>+1 or -1 according to the orientation of this simplex. </dd></dl>

</div>
</div>
<a id="a9fec21c78291855911ee3df06cf98fbf" name="a9fec21c78291855911ee3df06cf98fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec21c78291855911ee3df06cf98fbf">&#9670;&#160;</a></span>pentachoron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 4 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::pentachoron </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;4&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 5.</p>
<p>See <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face()</a> for further information. </p>

</div>
</div>
<a id="a11b98b70d3a0dcdbcfa1ada8f9ccf8f8" name="a11b98b70d3a0dcdbcfa1ada8f9ccf8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b98b70d3a0dcdbcfa1ada8f9ccf8f8">&#9670;&#160;</a></span>pentachoronMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::pentachoronMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;4&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 5.</p>
<p>See <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> for further information. </p>

</div>
</div>
<a id="ad7bf0938b3117fb7b3fc26304d5541e0" name="ad7bf0938b3117fb7b3fc26304d5541e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf0938b3117fb7b3fc26304d5541e0">&#9670;&#160;</a></span>sameDegreesAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int useDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::sameDegreesAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>useDim</em>-face degrees of this and the given simplex are identical, under the given relabelling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em>, <em>useDim</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="a1392ae583030f05629f71d6e7d3eb69f" name="a1392ae583030f05629f71d6e7d3eb69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1392ae583030f05629f71d6e7d3eb69f">&#9670;&#160;</a></span>sameDegreesAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int... useDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::sameDegreesAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integer_sequence&lt; int, useDim... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces whose dimensions are contained in the integer pack <em>useDim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em> and every facial dimension <em>k</em> in the integer pack <em>useDim</em>, <em>k</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="a6d949a6ec9b90b7c9fce5c9da6dc52d6" name="a6d949a6ec9b90b7c9fce5c9da6dc52d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d949a6ec9b90b7c9fce5c9da6dc52d6">&#9670;&#160;</a></span>setDescription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::setDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the description associated with this simplex. </p>
<p>This may be any text whatsoever; typically it is intended to be human-readable. Descriptions do not need to be unique.</p>
<p>To remove an existing description, you can simply set the description to the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the new description to assign to this simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt;, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a9846eebe589ac51da7492654fdd4d57f" name="a9846eebe589ac51da7492654fdd4d57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9846eebe589ac51da7492654fdd4d57f">&#9670;&#160;</a></span>tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 3 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;3&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p>See <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face()</a> for further information. </p>

</div>
</div>
<a id="a1e52cfa234a402b1ba76dbcbc4726475" name="a1e52cfa234a402b1ba76dbcbc4726475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e52cfa234a402b1ba76dbcbc4726475">&#9670;&#160;</a></span>tetrahedronMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::tetrahedronMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;3&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 4.</p>
<p>See <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> for further information. </p>

</div>
</div>
<a id="a0895af896d276deb85472bf9c1580c50" name="a0895af896d276deb85472bf9c1580c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0895af896d276deb85472bf9c1580c50">&#9670;&#160;</a></span>triangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 2 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;2&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p>See <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face()</a> for further information. </p>

</div>
</div>
<a id="a4026cd53c2c99c5a542a57f059638190" name="a4026cd53c2c99c5a542a57f059638190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4026cd53c2c99c5a542a57f059638190">&#9670;&#160;</a></span>triangleMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::triangleMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;2&gt;()</a>. </p>
<p>This alias is available for dimensions <em>dim</em> ≥ 3.</p>
<p>See <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> for further information. </p>

</div>
</div>
<a id="ab4eca32827dd4091d889ad31dcbb97d8" name="ab4eca32827dd4091d889ad31dcbb97d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eca32827dd4091d889ad31dcbb97d8">&#9670;&#160;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the triangulation containing this simplex. </dd></dl>

</div>
</div>
<a id="a4d139902e93c8ddd7c17cd6f67729b22" name="a4d139902e93c8ddd7c17cd6f67729b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d139902e93c8ddd7c17cd6f67729b22">&#9670;&#160;</a></span>unjoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga7e32fdbdb01da2a61c025e86b559a5c4">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unjoin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>myFacet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unglues the given facet of this simplex from whatever it is joined to. </p>
<p>As a result, the given facet of this simplex will become a boundary facet.</p>
<p>If there was an adjacent simplex to begin with, then this other simplex will be updated automatically (i.e., you only need to call <a class="el" href="#a4d139902e93c8ddd7c17cd6f67729b22" title="Unglues the given facet of this simplex from whatever it is joined to.">unjoin()</a> from one side of the gluing).</p>
<p>This routine is safe to call even if the given facet is already a boundary facet (in which case it will do nothing).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1LockViolation.html" title="An exception thrown when an attempt is made to violate a simplex or facet lock.">LockViolation</a></td><td>The given facet of this simplex is currently locked. This exception will be thrown before any change is made. See <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for further details on how facet locks work and what their implications are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex whose gluing we will undo. This should be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplex that was originally glued to the given facet of this simplex, or <code>null</code> if this was already a boundary facet. </dd></dl>

</div>
</div>
<a id="afbaf2c8a818d2aee173c308dc0ed283b" name="afbaf2c8a818d2aee173c308dc0ed283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaf2c8a818d2aee173c308dc0ed283b">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks this top-dimensional simplex. </p>
<p>Essentially, locking a simplex means that that simplex must not change. See <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> for full details on how locks work and what their implications are.</p>
<p>It is safe to call this function even if this simplex is already unlocked.</p>
<p>Note that you can also lock the individual facets of a simplex (that is, its (<em>dim</em>-1)-faces); see <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for details. Unlocking a simplex does <em>not</em> imply that its facets will be automatically unlocked also; these are independent concepts.</p>
<p>See <a class="el" href="#ae735357568263f6741c81b7a422b18be" title="Unlocks this top-dimensional simplex and all of its facets.">unlockAll()</a> for a convenient way to unlock this simplex and all of its facets in a single function call. Also, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac66330cee32127dad0c2ac14874acd71" title="Unlocks all top-dimensional simplices and their facets.">Triangulation&lt;dim&gt;::unlockAll()</a> offers a simple way to unlock all <em>dim</em>-simplices and their facets across an entire triangulation. </p>

</div>
</div>
<a id="ae735357568263f6741c81b7a422b18be" name="ae735357568263f6741c81b7a422b18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae735357568263f6741c81b7a422b18be">&#9670;&#160;</a></span>unlockAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unlockAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks this top-dimensional simplex and all of its facets. </p>
<p>Essentially, locking a simplex or one of its facets means that that simplex or facet must not change. See <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> and <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>Regina will always ensure that the locks on facets are consistent. That is, if some facet <em>F</em> of some top-dimensional simplex is glued to some facet <em>G</em> of some top-dimensional simplex, then whenever <em>F</em> is locked/unlocked, Regina will automatically lock/unlock <em>G</em> also.</p>
<p>It is safe to call this function even if this simplex and all of its facets are already unlocked.</p>
<p>See also <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac66330cee32127dad0c2ac14874acd71" title="Unlocks all top-dimensional simplices and their facets.">Triangulation&lt;dim&gt;::unlockAll()</a> for a simple way to unlock all <em>dim</em>-simplices and their facets across an entire triangulation. </p>

</div>
</div>
<a id="ad212e14b6c4b06f1f060d7a746d244c4" name="ad212e14b6c4b06f1f060d7a746d244c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad212e14b6c4b06f1f060d7a746d244c4">&#9670;&#160;</a></span>unlockFacet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unlockFacet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the given facet of this top-dimensional simplex. </p>
<p>Essentially, locking a facet means that that facet must not change. See <a class="el" href="#affacd41a6d53fcb1028aa3edbe0cf1cc" title="Locks the given facet of this top-dimensional simplex.">lockFacet()</a> for full details on how locks work and what their implications are.</p>
<p>Regina will always ensure that the locks on facets are consistent. That is, if some facet <em>F</em> of some top-dimensional simplex is glued to some facet <em>G</em> of some top-dimensional simplex, then whenever <em>F</em> is locked/unlocked, Regina will automatically lock/unlock <em>G</em> also.</p>
<p>It is safe to call this function even if the given facet is already unlocked.</p>
<p>Note that you can also lock an entire top-dimensional simplex; see <a class="el" href="#ade04b3e3b11936271f6212af4ea80065" title="Locks this top-dimensional simplex.">lock()</a> for details. Unlocking a simplex does <em>not</em> imply that its facets will be automatically unlocked also, or vice versa; these are independent concepts.</p>
<p>See <a class="el" href="#ae735357568263f6741c81b7a422b18be" title="Unlocks this top-dimensional simplex and all of its facets.">unlockAll()</a> for a convenient way to unlock this simplex and all of its facets in a single function call. Also, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac66330cee32127dad0c2ac14874acd71" title="Unlocks all top-dimensional simplices and their facets.">Triangulation&lt;dim&gt;::unlockAll()</a> offers a simple way to unlock all <em>dim</em>-simplices and their facets across an entire triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>indicates which facet of this simplex to unlock; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a>&lt; dim &gt;, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a518c8ed0a013ce3c1dbb20a698b75603" name="a518c8ed0a013ce3c1dbb20a698b75603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518c8ed0a013ce3c1dbb20a698b75603">&#9670;&#160;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 0 &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face&lt;0&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#a727ea46d74705043806e29b1fe32c460" title="Returns the subdim-face of the underlying triangulation that appears as the given subdim-face of this...">face()</a> for further information. </p>

</div>
</div>
<a id="a6f1897cda2880a990c43b8204e7c84ae" name="a6f1897cda2880a990c43b8204e7c84ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1897cda2880a990c43b8204e7c84ae">&#9670;&#160;</a></span>vertexMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::vertexMapping </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping&lt;0&gt;()</a>. </p>
<p>This alias is available for all dimensions <em>dim</em>.</p>
<p>See <a class="el" href="#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a> for further information. </p>

</div>
</div>
<a id="abf98d5138a8528b99a8a77b4533784a4" name="abf98d5138a8528b99a8a77b4533784a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf98d5138a8528b99a8a77b4533784a4">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb07d86f5e49e7cf9effbcfa7645b7ce" name="adb07d86f5e49e7cf9effbcfa7645b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb07d86f5e49e7cf9effbcfa7645b7ce">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0285a5ebde8504bbd2def6182a511764" name="a0285a5ebde8504bbd2def6182a511764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0285a5ebde8504bbd2def6182a511764">&#9670;&#160;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of the triangulation containing this simplex. </p>

</div>
</div>
<a id="acbd4045f14bd236b73cb0ac84b161827" name="acbd4045f14bd236b73cb0ac84b161827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd4045f14bd236b73cb0ac84b161827">&#9670;&#160;</a></span>subdimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::subdimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of this simplex. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/detail/<a class="el" href="detail_2simplex_8h.html">simplex.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
