<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>File <a class="el" href="matrixops_8h.html">matrixops.h</a>  </dt>
<dd><a class="anchor" id="_todo000022"></a><em>Feature (long-term):</em> Add a routine to find the rank of an integer matrix; use this to show the rank of the matching equations.  </dd>
<dt>Class <a class="el" href="classregina_1_1AbelianGroup.html">regina::AbelianGroup</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like. </dd>
<dt>Class <a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a>  </dt>
<dd><a class="anchor" id="_todo000038"></a><em>Optimise:</em> Insist that sizeof(Piece) is a power of two, and replace expensive division/mod operations with cheap bit operations. </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43">regina::detail::FacetPairingBase&lt; dim &gt;::findAllPairings</a>  (size_t nSimplices, <a class="el" href="classregina_1_1BoolSet.html" title="A set of booleans.">BoolSet</a> boundary, int nBdryFacets, Action &amp;&amp;action, Args &amp;&amp;... args)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000032"></a><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="interdd"></p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac568895b8abeb672289fcee779ebf01a">regina::detail::TriangulationBase&lt; dim &gt;::isIsomorphicTo</a>  (const Triangulation&lt; dim &gt; &amp;other) const</dt>
<dd><a class="anchor" id="_todo000034"></a><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others. </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0e7139822eb449840c13dbcc304f8491">regina::detail::TriangulationBase&lt; dim &gt;::subdivide</a>  ()</dt>
<dd><a class="anchor" id="_todo000033"></a>Lock the topological properties of the underlying manifold, to avoid recomputing them after the subdivision. However, only do this for <em>valid</em> triangulations (since we can have scenarios where invalid triangulations becoming valid and ideal after subdivision, which may change properties such as Triangulation&lt;4&gt;::knownSimpleLinks).  </dd>
<dt>Class <a class="el" href="classregina_1_1DiscSetTet.html">regina::DiscSetTet</a>  </dt>
<dd><a class="anchor" id="_todo000028"></a><em>Bug (long-term):</em> Have some error flag so we can barf politely if the number of normal discs of a given type does not fit into an <code>unsigned long</code>. See how this affects <a class="el" href="classregina_1_1DiscSetTetData.html" title="Stores data of type T for every normal disc inside a single tetrahedron.">DiscSetTetData</a> also. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a89c47bb2ac248e34e3fe7b6cb1b6eb9d">regina::GluingPermSearcher&lt; 2 &gt;::runSearch</a>  (Action &amp;&amp;action, Args &amp;&amp;... args)</dt>
<dd><a class="anchor" id="_todo000013"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a8a30b20a6f0b9051de8dcddb562cb572">regina::GluingPermSearcher&lt; 3 &gt;::runSearch</a>  (Action &amp;&amp;action, Args &amp;&amp;... args)</dt>
<dd><a class="anchor" id="_todo000014"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html#a4e5b57833b26c0b78c689633b8ea7359">regina::GluingPermSearcher&lt; 4 &gt;::runSearch</a>  (Action &amp;&amp;action, Args &amp;&amp;... args)</dt>
<dd><a class="anchor" id="_todo000015"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Class <a class="el" href="classregina_1_1GraphLoop.html">regina::GraphLoop</a>  </dt>
<dd><a class="anchor" id="_todo000017"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix. </dd>
<dt>Class <a class="el" href="classregina_1_1GraphPair.html">regina::GraphPair</a>  </dt>
<dd><a class="anchor" id="_todo000018"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix. </dd>
<dt>Class <a class="el" href="classregina_1_1GraphTriple.html">regina::GraphTriple</a>  </dt>
<dd><a class="anchor" id="_todo000019"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix. </dd>
<dt>Member <a class="el" href="classregina_1_1GroupExpression.html#a1d02f0fa24e3d333ce3bcfb4e6acee1a">regina::GroupExpression::relabellingsThisToOther</a>  (const <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> &amp;other, bool cyclic=false) const</dt>
<dd><a class="anchor" id="_todo000003"></a>Change this to use less heavyweight types and less deep copying. </dd>
<dt>Class <a class="el" href="classregina_1_1GroupPresentation.html">regina::GroupPresentation</a>  </dt>
<dd><a class="anchor" id="_todo000002"></a>Let's make intelligent simplify a tad more intelligent, and the GUI call a bit more safe. Perhaps parallelize the GUI call, and give users parameters to ensure it won't crash the computer. Also look at the FPGroup package. We should also have a simple way of creating <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> objects directly from text strings. We would like to have something like <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>( numGens, "abAAB", "bccd" ) etc., with arbitrary numbers of relators. Maybe std::tuple. Or "variadic templates"? </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#a4eaffe47a96e9a314e584e521d24e812">regina::GroupPresentation::prettyRewriting</a>  ()</dt>
<dd><a class="anchor" id="_todo000006"></a>As a final step, make elementary simplifications to aid in seeing standard relators like commutators. </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#a6dd5465442f764dcca7c9f83683144ff">regina::GroupPresentation::recogniseGroup</a>  (bool moreUtf8=false) const</dt>
<dd><a class="anchor" id="_todo000005"></a><em>Feature (long-term):</em> Make this recognition more effective. </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#a8289666edbc70c23ae947f7697b514dc">regina::GroupPresentation::smallCancellation</a>  ()</dt>
<dd><a class="anchor" id="_todo000004"></a><em>Optimise (long-term):</em> This routine could use some small tweaks - recognition of utility of some score==0 moves, such as commutators, for example. </dd>
<dt>Class <a class="el" href="classregina_1_1HomGroupPresentation.html">regina::HomGroupPresentation</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Add a routine to attempt to verify validity of homomorphism. </dd>
<dt>Class <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">regina::HomMarkedAbelianGroup</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000009"></a><em>Optimise (long-term):</em> preImageOf in CC and SNF coordinates. This routine would return a generating list of elements in the preimage, thought of as an affine subspace. Or maybe just one element together with the kernel inclusion. IMO smarter to be a list because that way there's a more pleasant way to make it empty. Or we could have a variety of routines among these themes. Store some minimal data for efficient computations of preImage, eventually replacing the internals of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ae98817af093689b1c8ec4af15c253cd2" title="Returns the inverse to a HomMarkedAbelianGroup.">inverseHom()</a> with a more flexible set of tools. Also add an isInImage() in various coordinates.</p>
<p class="interdd"><a class="anchor" id="_todo000010"></a><em>Optimise (long-term):</em> <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2779b4feadb621b496a2ec8e6f8eadc4" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> have completely different set of descriptors if an endomorphism domain = codomain (not so important at the moment though). New descriptors would include things like automorphism, projection, differential, finite order, etc.</p>
<p class="enddd"><a class="anchor" id="_todo000011"></a><em>Optimise (long-term):</em> Add map factorization, so that every homomorphism can be split as a composite of a projection followed by an inclusion. Add kernelInclusion(), coKerMap(), etc. Add a liftMap() call, i.e., a procedure to find a lift of a map if one exists. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1Isomorphism.html#a5ab10fe5c9b8c532c178bc16b1d48fa8">regina::Isomorphism&lt; dim &gt;::operator()</a>  (const Triangulation&lt; dim &gt; &amp;tri) const</dt>
<dd><a class="anchor" id="_todo000037"></a>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied. </dd>
<dt>Class <a class="el" href="classregina_1_1MarkedAbelianGroup.html">regina::MarkedAbelianGroup</a>  </dt>
<dd><a class="anchor" id="_todo000008"></a><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalHypersurface.html#a1a49d406024a72fda5fc843e087668f2">regina::NormalHypersurface::triangulate</a>  () const</dt>
<dd><a class="anchor" id="_todo000016"></a><em>Bug:</em> Check for absurdly large numbers of pieces and return <code>null</code> accordingly. </dd>
<dt>Class <a class="el" href="classregina_1_1NormalSurface.html">regina::NormalSurface</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000029"></a><em>Feature:</em> Calculation of Euler characteristic and orientability for non-compact surfaces. </p>
<p class="interdd"></p>
<p class="enddd"><em>Feature (long-term):</em> Determine which faces in the solution space a normal surface belongs to. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#a793261174b6628c83659b523b84ab943">regina::NormalSurface::isCompressingDisc</a>  (bool knownConnected=false) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000030"></a><em>Optimise:</em> Reimplement this to avoid cutting along surfaces. </p>
<p class="interdd"></p>
<p class="enddd"><em>Bug:</em> Check for absurdly large numbers of discs and bail accordingly. </p>
</dd>
<dt>Class <a class="el" href="classregina_1_1NormalSurfaces.html">regina::NormalSurfaces</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000031"></a><em>Feature:</em> Allow custom matching equations. </p>
<p class="interdd"></p>
<p class="interdd"><em>Feature:</em> Allow enumeration with some coordinates explicitly set to zero. </p>
<p class="interdd"></p>
<p class="interdd"><em>Feature:</em> Allow generating only closed surfaces. </p>
<p class="interdd"></p>
<p class="enddd"><em>Feature:</em> Generate facets of the solution space representing embedded surfaces. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1Primes.html#a3e357e3d10095e07d841ad2251219446">regina::Primes::primeDecomp</a>  (const Integer &amp;n)</dt>
<dd><a class="anchor" id="_todo000023"></a><em>Optimise:</em> Add a version that does not return the factors by value. </dd>
<dt>Member <a class="el" href="classregina_1_1Primes.html#ad9fc0db2a816d6c57b7c890c80f788d7">regina::Primes::primePowerDecomp</a>  (const Integer &amp;n)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000024"></a><em>Optimise:</em> Implement this routine natively to avoid the overhead of the temporary <a class="el" href="classregina_1_1Primes.html#a3e357e3d10095e07d841ad2251219446" title="Returns the prime factorisation of the given integer as a list of individual primes (or suspected pri...">primeDecomp()</a> vector.</p>
<p class="enddd"><a class="anchor" id="_todo000025"></a><em>Optimise:</em> Add a version that does not return the factors by value. </p>
</dd>
<dt>Class <a class="el" href="classregina_1_1SatRegion.html">regina::SatRegion</a>  </dt>
<dd><a class="anchor" id="_todo000027"></a><em>Feature:</em> Have this class track the boundary components properly, with annuli grouped and oriented according to the region boundaries (as opposed to individual block boundaries). </dd>
<dt>Class <a class="el" href="classregina_1_1SFSpace.html">regina::SFSpace</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000020"></a><em>Feature (long-term):</em> Implement recognition of more common names. </p>
<p class="interdd"></p>
<p class="enddd"><em>Feature (long-term):</em> Implement triangulation construction and homology calculation for more Seifert fibred spaces. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1SigCensus.html#abf7527cd205c9fce68bb4ce3c03738d6">regina::SigCensus::formCensus</a>  (unsigned order, Action &amp;&amp;action, Args &amp;&amp;... args)</dt>
<dd><a class="anchor" id="_todo000026"></a><em>Feature:</em> Add support for symbols of differing case. </dd>
<dt>Class <a class="el" href="classregina_1_1TorusBundle.html">regina::TorusBundle</a>  </dt>
<dd><a class="anchor" id="_todo000021"></a><em>Feature:</em> Implement the == operator for finding conjugate and inverse matrices. </dd>
<dt>Member <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a1fedd4382ce66d6a186b486e8e3ab6d1">regina::Triangulation&lt; 3 &gt;::simplify</a>  ()</dt>
<dd><a class="anchor" id="_todo000035"></a><em>Optimise:</em> Include random 2-3 moves to get out of wells. </dd>
<dt>Member <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0fc9af1481723b228eb0ea76825d69c6">regina::Triangulation&lt; 3 &gt;::truncateIdeal</a>  ()</dt>
<dd><a class="anchor" id="_todo000036"></a><em>Optimise (long-term):</em> Have this routine only use as many tetrahedra as are necessary, leaving finite vertices alone.</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
