<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: regina::SpatialLink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1SpatialLink-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SpatialLink Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a specific embedding of a directed knot or link in real 3-dimensional space.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;link/spatiallink.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SpatialLink:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SpatialLink.png" usemap="#regina::SpatialLink_map" alt=""/>
  <map id="regina::SpatialLink_map" name="regina::SpatialLink_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; SpatialLink &gt;" shape="rect" coords="0,0,203,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SpatialLink &gt;" shape="rect" coords="213,0,416,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4fc64965e2cddc257fd242b6e80f6984" id="r_a4fc64965e2cddc257fd242b6e80f6984"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> = <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt;double&gt;</td></tr>
<tr class="memdesc:a4fc64965e2cddc257fd242b6e80f6984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single point on the path that a link component takes through three-dimensional space.  <br /></td></tr>
<tr class="separator:a4fc64965e2cddc257fd242b6e80f6984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2621fd92d1ea0dfaf2e1739229656bb" id="r_ad2621fd92d1ea0dfaf2e1739229656bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2621fd92d1ea0dfaf2e1739229656bb">Component</a> = std::vector&lt;<a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a>&gt;</td></tr>
<tr class="memdesc:ad2621fd92d1ea0dfaf2e1739229656bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single link component.  <br /></td></tr>
<tr class="separator:ad2621fd92d1ea0dfaf2e1739229656bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10f79dd6c4de1c8b90b77ab0953d9c" id="r_a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a0d10f79dd6c4de1c8b90b77ab0953d9c">PacketChangeGroup</a></td></tr>
<tr class="memdesc:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.  <br /></td></tr>
<tr class="separator:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247" id="r_ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88" id="r_a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1" id="r_ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ade8dc363cfd599aeecbbb3c3f32e1143" id="r_ade8dc363cfd599aeecbbb3c3f32e1143"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade8dc363cfd599aeecbbb3c3f32e1143">SpatialLink</a> ()=default</td></tr>
<tr class="memdesc:ade8dc363cfd599aeecbbb3c3f32e1143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty link.  <br /></td></tr>
<tr class="separator:ade8dc363cfd599aeecbbb3c3f32e1143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd32e14de32afd40a92667fb67919f8" id="r_a4bd32e14de32afd40a92667fb67919f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd32e14de32afd40a92667fb67919f8">SpatialLink</a> (const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;)=default</td></tr>
<tr class="memdesc:a4bd32e14de32afd40a92667fb67919f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link.  <br /></td></tr>
<tr class="separator:a4bd32e14de32afd40a92667fb67919f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68cf90b8ea8c96eb1077c306a2d844a" id="r_aa68cf90b8ea8c96eb1077c306a2d844a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68cf90b8ea8c96eb1077c306a2d844a">SpatialLink</a> (<a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aa68cf90b8ea8c96eb1077c306a2d844a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given link into this new link.  <br /></td></tr>
<tr class="separator:aa68cf90b8ea8c96eb1077c306a2d844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5228693c4c600d67ce8441e69456064" id="r_ab5228693c4c600d67ce8441e69456064"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:ab5228693c4c600d67ce8441e69456064"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5228693c4c600d67ce8441e69456064">SpatialLink</a> (iterator begin, iterator end)</td></tr>
<tr class="memdesc:ab5228693c4c600d67ce8441e69456064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link whose components are supplied by the given sequences of points in 3-space.  <br /></td></tr>
<tr class="separator:ab5228693c4c600d67ce8441e69456064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b721389f24befd54d5a92e3b2711da" id="r_ae8b721389f24befd54d5a92e3b2711da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b721389f24befd54d5a92e3b2711da">SpatialLink</a> (std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> &gt; &gt; <a class="el" href="#a53b3634d24a9bf525a1a435c33881988">components</a>)</td></tr>
<tr class="memdesc:ae8b721389f24befd54d5a92e3b2711da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link whose components are given by hard-coded sequences of points in 3-space.  <br /></td></tr>
<tr class="separator:ae8b721389f24befd54d5a92e3b2711da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Nodes and Components</div></td></tr>
<tr class="memitem:a3b1cb4710d4e356292e396eadaa14c1f" id="r_a3b1cb4710d4e356292e396eadaa14c1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1cb4710d4e356292e396eadaa14c1f">size</a> () const</td></tr>
<tr class="memdesc:a3b1cb4710d4e356292e396eadaa14c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of nodes in this spatial link.  <br /></td></tr>
<tr class="separator:a3b1cb4710d4e356292e396eadaa14c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86e767c6c78e87954e7e0974d9a5afb" id="r_af86e767c6c78e87954e7e0974d9a5afb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af86e767c6c78e87954e7e0974d9a5afb">isEmpty</a> () const</td></tr>
<tr class="memdesc:af86e767c6c78e87954e7e0974d9a5afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link is empty.  <br /></td></tr>
<tr class="separator:af86e767c6c78e87954e7e0974d9a5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d63fa4837de13efc9afd200a3d79a" id="r_a419d63fa4837de13efc9afd200a3d79a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419d63fa4837de13efc9afd200a3d79a">countComponents</a> () const</td></tr>
<tr class="memdesc:a419d63fa4837de13efc9afd200a3d79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of components in this link.  <br /></td></tr>
<tr class="separator:a419d63fa4837de13efc9afd200a3d79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd71e66a759a5d44e4d97bc461e1f7" id="r_ad3cd71e66a759a5d44e4d97bc461e1f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad2621fd92d1ea0dfaf2e1739229656bb">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3cd71e66a759a5d44e4d97bc461e1f7">component</a> (size_t index) const</td></tr>
<tr class="memdesc:ad3cd71e66a759a5d44e4d97bc461e1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the component at the given index within this link.  <br /></td></tr>
<tr class="separator:ad3cd71e66a759a5d44e4d97bc461e1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3634d24a9bf525a1a435c33881988" id="r_a53b3634d24a9bf525a1a435c33881988"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b3634d24a9bf525a1a435c33881988">components</a> () const</td></tr>
<tr class="memdesc:a53b3634d24a9bf525a1a435c33881988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all components of this link.  <br /></td></tr>
<tr class="separator:a53b3634d24a9bf525a1a435c33881988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccb1edef469efb584d5c91b183d169b" id="r_aeccb1edef469efb584d5c91b183d169b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccb1edef469efb584d5c91b183d169b">componentSize</a> (size_t componentIndex) const</td></tr>
<tr class="memdesc:aeccb1edef469efb584d5c91b183d169b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes that are stored for the given component of this link.  <br /></td></tr>
<tr class="separator:aeccb1edef469efb584d5c91b183d169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798f95551ad129f9598aab3b9a442f63" id="r_a798f95551ad129f9598aab3b9a442f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a798f95551ad129f9598aab3b9a442f63">node</a> (size_t componentIndex, size_t nodeIndex) const</td></tr>
<tr class="memdesc:a798f95551ad129f9598aab3b9a442f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a particular node belong to a particular component of this link.  <br /></td></tr>
<tr class="separator:a798f95551ad129f9598aab3b9a442f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45658408d1c95a745616e14a2696c92d" id="r_a45658408d1c95a745616e14a2696c92d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45658408d1c95a745616e14a2696c92d">radius</a> () const</td></tr>
<tr class="memdesc:a45658408d1c95a745616e14a2696c92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radius that should be used when rendering this link.  <br /></td></tr>
<tr class="separator:a45658408d1c95a745616e14a2696c92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e262c5576f8a2e624cbc561f88fbccc" id="r_a3e262c5576f8a2e624cbc561f88fbccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e262c5576f8a2e624cbc561f88fbccc">setRadius</a> (double useRadius)</td></tr>
<tr class="memdesc:a3e262c5576f8a2e624cbc561f88fbccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the given radius should be used when rendering this link.  <br /></td></tr>
<tr class="separator:a3e262c5576f8a2e624cbc561f88fbccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9da1e48e4e9a018e0ead0547c3b5e" id="r_a6ca9da1e48e4e9a018e0ead0547c3b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca9da1e48e4e9a018e0ead0547c3b5e">clearRadius</a> ()</td></tr>
<tr class="memdesc:a6ca9da1e48e4e9a018e0ead0547c3b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any user-specified radius to use when rendering this link.  <br /></td></tr>
<tr class="separator:a6ca9da1e48e4e9a018e0ead0547c3b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfa554a4613d3762ec71352e3d8705a" id="r_a3bfa554a4613d3762ec71352e3d8705a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bfa554a4613d3762ec71352e3d8705a">hasRadius</a> () const</td></tr>
<tr class="memdesc:a3bfa554a4613d3762ec71352e3d8705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the user has set their own custom radius to use when rendering this link.  <br /></td></tr>
<tr class="separator:a3bfa554a4613d3762ec71352e3d8705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55c180dbe58e6de2a4eb78aecd6d3d" id="r_a3c55c180dbe58e6de2a4eb78aecd6d3d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c55c180dbe58e6de2a4eb78aecd6d3d">defaultRadius</a> () const</td></tr>
<tr class="memdesc:a3c55c180dbe58e6de2a4eb78aecd6d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sensible default radius to use when rendering the link.  <br /></td></tr>
<tr class="separator:a3c55c180dbe58e6de2a4eb78aecd6d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521f10452934fac4ef481a2e7ed14c6e" id="r_a521f10452934fac4ef481a2e7ed14c6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a521f10452934fac4ef481a2e7ed14c6e">operator==</a> (const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;other) const</td></tr>
<tr class="memdesc:a521f10452934fac4ef481a2e7ed14c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this link is identical to the given link.  <br /></td></tr>
<tr class="separator:a521f10452934fac4ef481a2e7ed14c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf48867ebe9e024aa029600effb34821" id="r_adf48867ebe9e024aa029600effb34821"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a>, <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf48867ebe9e024aa029600effb34821">range</a> () const</td></tr>
<tr class="memdesc:adf48867ebe9e024aa029600effb34821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of coordinates that this link occupies.  <br /></td></tr>
<tr class="separator:adf48867ebe9e024aa029600effb34821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Editing</div></td></tr>
<tr class="memitem:a9755b62e7eb8622858742497d4a5c496" id="r_a9755b62e7eb8622858742497d4a5c496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9755b62e7eb8622858742497d4a5c496">operator=</a> (const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;src)</td></tr>
<tr class="memdesc:a9755b62e7eb8622858742497d4a5c496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given link.  <br /></td></tr>
<tr class="separator:a9755b62e7eb8622858742497d4a5c496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d724345455f244be594c555c5f3a983" id="r_a8d724345455f244be594c555c5f3a983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d724345455f244be594c555c5f3a983">operator=</a> (<a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a8d724345455f244be594c555c5f3a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given link into this link.  <br /></td></tr>
<tr class="separator:a8d724345455f244be594c555c5f3a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9c83e1765931ae2e34ae140b0afa09" id="r_a3a9c83e1765931ae2e34ae140b0afa09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a9c83e1765931ae2e34ae140b0afa09">swap</a> (<a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;other)</td></tr>
<tr class="memdesc:a3a9c83e1765931ae2e34ae140b0afa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given link.  <br /></td></tr>
<tr class="separator:a3a9c83e1765931ae2e34ae140b0afa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490f571cbc82db9f2df4e4860ca363c" id="r_ad490f571cbc82db9f2df4e4860ca363c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad490f571cbc82db9f2df4e4860ca363c">scale</a> (double factor)</td></tr>
<tr class="memdesc:ad490f571cbc82db9f2df4e4860ca363c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the entire link by the given factor.  <br /></td></tr>
<tr class="separator:ad490f571cbc82db9f2df4e4860ca363c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cddfcddc2da6d48790af2bc67dfc36b" id="r_a5cddfcddc2da6d48790af2bc67dfc36b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cddfcddc2da6d48790af2bc67dfc36b">translate</a> (const <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt; double &gt; &amp;vector)</td></tr>
<tr class="memdesc:a5cddfcddc2da6d48790af2bc67dfc36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the entire link by the given vector.  <br /></td></tr>
<tr class="separator:a5cddfcddc2da6d48790af2bc67dfc36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c54d18dbf2be2d28efd1d00507f779" id="r_ad3c54d18dbf2be2d28efd1d00507f779"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c54d18dbf2be2d28efd1d00507f779">reflect</a> (int axis=2)</td></tr>
<tr class="memdesc:ad3c54d18dbf2be2d28efd1d00507f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects the link in plane perpendicular to the given axis.  <br /></td></tr>
<tr class="separator:ad3c54d18dbf2be2d28efd1d00507f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cbdd38546374d5bbef6bbaf4210106" id="r_a47cbdd38546374d5bbef6bbaf4210106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47cbdd38546374d5bbef6bbaf4210106">refine</a> ()</td></tr>
<tr class="memdesc:a47cbdd38546374d5bbef6bbaf4210106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional nodes to make the embedding appear smoother.  <br /></td></tr>
<tr class="separator:a47cbdd38546374d5bbef6bbaf4210106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8074d347253f6a214a14f5f0adc394" id="r_acb8074d347253f6a214a14f5f0adc394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb8074d347253f6a214a14f5f0adc394">refine</a> (int sub)</td></tr>
<tr class="memdesc:acb8074d347253f6a214a14f5f0adc394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a configurable number of additional nodes to make the embedding appear smoother.  <br /></td></tr>
<tr class="separator:acb8074d347253f6a214a14f5f0adc394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Links</div></td></tr>
<tr class="memitem:a6741b57e312ab75dedad76466f127ce6" id="r_a6741b57e312ab75dedad76466f127ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6741b57e312ab75dedad76466f127ce6">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a6741b57e312ab75dedad76466f127ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this link to the given output stream.  <br /></td></tr>
<tr class="separator:a6741b57e312ab75dedad76466f127ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561086e910f9db25b6b2c24d34c41af0" id="r_a561086e910f9db25b6b2c24d34c41af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a561086e910f9db25b6b2c24d34c41af0">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a561086e910f9db25b6b2c24d34c41af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this link to the given output stream.  <br /></td></tr>
<tr class="separator:a561086e910f9db25b6b2c24d34c41af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b" id="r_a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Links</h2></td></tr>
<tr class="memitem:a067a66ccc9862e75418f6590a8e9f3ab" id="r_a067a66ccc9862e75418f6590a8e9f3ab"><td class="memItemLeft" align="right" valign="top"><a id="a067a66ccc9862e75418f6590a8e9f3ab" name="a067a66ccc9862e75418f6590a8e9f3ab"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLSpatialLinkReader</b></td></tr>
<tr class="separator:a067a66ccc9862e75418f6590a8e9f3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab117f386805b9fe9735a990559e7f7bb" id="r_ab117f386805b9fe9735a990559e7f7bb"><td class="memItemLeft" align="right" valign="top"><a id="ab117f386805b9fe9735a990559e7f7bb" name="ab117f386805b9fe9735a990559e7f7bb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLWriter&lt; SpatialLink &gt;</b></td></tr>
<tr class="separator:ab117f386805b9fe9735a990559e7f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3e556b7f8169fbde6d289fa3cf7fb" id="r_afae3e556b7f8169fbde6d289fa3cf7fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afae3e556b7f8169fbde6d289fa3cf7fb">fromKnotPlot</a> (const char *filename)</td></tr>
<tr class="memdesc:afae3e556b7f8169fbde6d289fa3cf7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from a KnotPlot data file.  <br /></td></tr>
<tr class="separator:afae3e556b7f8169fbde6d289fa3cf7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a specific embedding of a directed knot or link in real 3-dimensional space. </p>
<p>This class <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> is a "purely geometric" representation of a link, as opposed to the <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class which is a "purely combinatorial" representation (holding the combintorics of a 2-dimensional link diagram, with no geometric information at all about the specific placements of strands or crossings).</p>
<p>One caveat with using the <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> class is that it uses floating point arithmetic. This makes it good for visualisation purposes, but makes it susceptible to floating point errors. If you need to perform exact computations (for example, of link invariants), use the <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class instead.</p>
<p>This class supports links with any number of components (including zero). Each component is made up of a non-empty sequence of nodes, which are points in 3-dimensional space represented by objects of type <a class="el" href="structregina_1_1Vector3D.html" title="Represents a vector in real three-dimensional space.">Vector3D</a>. The nodes in each component are connected by straight line segments to form a closed loop.</p>
<p>It is assumed that this indeed forms an embedding (i.e., no two nodes are equal, no node meets any other line segment beyond the two that it sits between on its link component, and no two line segments meet beyond the expect cases of two adjacent segments touching at their common endpoint). This is <em>not</em> checked, and indeed the use of floating point arithmetic makes it difficult to check this precisely. Note that, as a consequence of forming an embedding, each link component must contain at least three nodes.</p>
<p>It is assumed that the underlying coordinate system is right-handed.</p>
<p>Like the regular <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> and <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> classes, <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> is not a packet type that can be inserted directly into the packet tree. Instead it is a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. Therefore:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a>, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include a <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> in the packet tree, you must create a new PacketOf&lt;SpatialLink&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a>, and so inherits the full <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> interface.</li>
</ul>
<p>If you are adding new functions to this class that edit the internal data structures of the link, you must remember to surround these changes with a ChangeAndClearSpan. This manages bookkeeping such as clearing computed properties, and (if this link <em>does</em> belong to a packet) firing packet change events.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad2621fd92d1ea0dfaf2e1739229656bb" name="ad2621fd92d1ea0dfaf2e1739229656bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2621fd92d1ea0dfaf2e1739229656bb">&#9670;&#160;</a></span>Component</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad2621fd92d1ea0dfaf2e1739229656bb">regina::SpatialLink::Component</a> = std::vector&lt;<a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a single link component. </p>
<p>This is stored as a sequence of nodes:</p>
<ul>
<li>each node in the sequence is joined by a straight line segment to the node that follows it (and likewise, the last node is joined to the first);</li>
<li>the orientation of the link component follows the path in order from the first node to the last (and then cycling back to the front of the sequence again).</li>
</ul>
<p><a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> components must not be empty. As a consequence, since they describe embeddings, each component must have at least three nodes. </p>

</div>
</div>
<a id="a4fc64965e2cddc257fd242b6e80f6984" name="a4fc64965e2cddc257fd242b6e80f6984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc64965e2cddc257fd242b6e80f6984">&#9670;&#160;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">regina::SpatialLink::Node</a> = <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a single point on the path that a link component takes through three-dimensional space. </p>

</div>
</div>
<a id="a0d10f79dd6c4de1c8b90b77ab0953d9c" name="a0d10f79dd6c4de1c8b90b77ab0953d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10f79dd6c4de1c8b90b77ab0953d9c">&#9670;&#160;</a></span>PacketChangeGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt;::PacketChangeGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes. </p>
<p>This type alias is used in the same way as <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a>: it is purely for the benefit of the human reader, used to indicate that an event span is present purely for optimisation (and in particular, that the code would still be correct without it).</p>
<p>See <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a> for further details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade8dc363cfd599aeecbbb3c3f32e1143" name="ade8dc363cfd599aeecbbb3c3f32e1143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8dc363cfd599aeecbbb3c3f32e1143">&#9670;&#160;</a></span>SpatialLink() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SpatialLink::SpatialLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty link. </p>
<p>This will have zero components. </p>

</div>
</div>
<a id="a4bd32e14de32afd40a92667fb67919f8" name="a4bd32e14de32afd40a92667fb67919f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd32e14de32afd40a92667fb67919f8">&#9670;&#160;</a></span>SpatialLink() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SpatialLink::SpatialLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link. </p>

</div>
</div>
<a id="aa68cf90b8ea8c96eb1077c306a2d844a" name="aa68cf90b8ea8c96eb1077c306a2d844a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68cf90b8ea8c96eb1077c306a2d844a">&#9670;&#160;</a></span>SpatialLink() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SpatialLink::SpatialLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given link into this new link. </p>
<p>This is a fast (constant time) operation.</p>
<p>The link that is passed will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this link is freshly constructed (and therefore has no listeners yet), and because we assume that the source link is about to be destroyed (an action that <em>will</em> fire a packet destruction event). </dd></dl>

</div>
</div>
<a id="ab5228693c4c600d67ce8441e69456064" name="ab5228693c4c600d67ce8441e69456064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5228693c4c600d67ce8441e69456064">&#9670;&#160;</a></span>SpatialLink() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::SpatialLink::SpatialLink </td>
          <td>(</td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new link whose components are supplied by the given sequences of points in 3-space. </p>
<p>Each element of the given sequence should represent a separate link component. Each component should be given as a sequence of at least three points in 3-space (any reasonable container type will do; see the requirements for the <em>iterator</em> type below). These are the points that will be stored directly in the <a class="el" href="classregina_1_1Component.html" title="A connected component of a dim-manifold triangulation.">Component</a> structure, which means that to form the actual geometry of the link component:</p>
<ul>
<li>each node in the sequence is joined by a straight line segment to the node that follows it (and likewise, the last node is joined to the first);</li>
<li>the orientation of the link component follows the path in order from the first node to the last (and then cycling back to the front of the sequence again).</li>
</ul>
<p>This constructor induces a deep copy of the given data.</p>
<dl class="section user"><dt>Python</dt><dd>Instead of the iterators <em>begin</em> and <em>end</em>, this routine takes either (i) a Python list of lists of triples of real numbers, or (ii) a Python list of lists of <a class="el" href="structregina_1_1Vector3D.html" title="Represents a vector in real three-dimensional space.">Vector3D</a> objects.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>the iterator type used to access the full sequence of nodes in each link component. This must satisfy the following requirements: (i) when dereferenced, the resulting object (which represents a single link component) has appropriate <code>begin()</code> and <code>end()</code> functions; and (ii) when <em>those</em> iterators are dereferenced, the resulting object (which represents an individual point along some link component) is convertible to a <a class="el" href="structregina_1_1Vector3D.html">Vector3D&lt;double&gt;</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the beginning of the sequence of link components. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the sequence of components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b721389f24befd54d5a92e3b2711da" name="ae8b721389f24befd54d5a92e3b2711da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b721389f24befd54d5a92e3b2711da">&#9670;&#160;</a></span>SpatialLink() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SpatialLink::SpatialLink </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>components</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new link whose components are given by hard-coded sequences of points in 3-space. </p>
<p>Each element of the given list should represent a separate link component. Each component should be given as a sequence of at least three points in 3-space. These are the points that will be stored directly in the <a class="el" href="classregina_1_1Component.html" title="A connected component of a dim-manifold triangulation.">Component</a> structure, which means that to form the actual geometry of the link component:</p>
<ul>
<li>each node in the sequence is joined by a straight line segment to the node that follows it (and likewise, the last node is joined to the first);</li>
<li>the orientation of the link component follows the path in order from the first node to the last (and then cycling back to the front of the sequence again).</li>
</ul>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the Python construtor that takes either a Python list of lists of triples of reals, or a Python list of lists of <a class="el" href="structregina_1_1Vector3D.html" title="Represents a vector in real three-dimensional space.">Vector3D</a> objects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">components</td><td>the full sequences of nodes in each link component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&#160;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt;::anonID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p>This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p>The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p>These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="a6ca9da1e48e4e9a018e0ead0547c3b5e" name="a6ca9da1e48e4e9a018e0ead0547c3b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca9da1e48e4e9a018e0ead0547c3b5e">&#9670;&#160;</a></span>clearRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::clearRadius </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any user-specified radius to use when rendering this link. </p>
<p>Any subsequent calls to <a class="el" href="#a45658408d1c95a745616e14a2696c92d" title="Returns the radius that should be used when rendering this link.">radius()</a> will return a sensible default, as computed by <a class="el" href="#a3c55c180dbe58e6de2a4eb78aecd6d3d" title="Returns a sensible default radius to use when rendering the link.">defaultRadius()</a>. </p>

</div>
</div>
<a id="ad3cd71e66a759a5d44e4d97bc461e1f7" name="ad3cd71e66a759a5d44e4d97bc461e1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd71e66a759a5d44e4d97bc461e1f7">&#9670;&#160;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad2621fd92d1ea0dfaf2e1739229656bb">SpatialLink::Component</a> &amp; regina::SpatialLink::component </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the component at the given index within this link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="#a419d63fa4837de13efc9afd200a3d79a" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the component at the given index. </dd></dl>

</div>
</div>
<a id="a53b3634d24a9bf525a1a435c33881988" name="a53b3634d24a9bf525a1a435c33881988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b3634d24a9bf525a1a435c33881988">&#9670;&#160;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::SpatialLink::components </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all components of this link. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Each element of the list will be a constant reference to some component; more precisely, iterating through this list is equivalent to calling <code>component(0)</code>, <code>component(1)</code>, ..., <code>component(<a class="el" href="#a419d63fa4837de13efc9afd200a3d79a" title="Returns the number of components in this link.">countComponents()</a>-1)</code> in turn. As an example, your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="#ad2621fd92d1ea0dfaf2e1739229656bb">SpatialLink::Component</a>&amp; c : link.<a class="code hl_function" href="#a53b3634d24a9bf525a1a435c33881988">components</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1SpatialLink_html_a53b3634d24a9bf525a1a435c33881988"><div class="ttname"><a href="#a53b3634d24a9bf525a1a435c33881988">regina::SpatialLink::components</a></div><div class="ttdeci">auto components() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all components of this link.</div><div class="ttdef"><b>Definition</b> spatiallink.h:802</div></div>
<div class="ttc" id="aclassregina_1_1SpatialLink_html_ad2621fd92d1ea0dfaf2e1739229656bb"><div class="ttname"><a href="#ad2621fd92d1ea0dfaf2e1739229656bb">regina::SpatialLink::Component</a></div><div class="ttdeci">std::vector&lt; Node &gt; Component</div><div class="ttdoc">Represents a single link component.</div><div class="ttdef"><b>Definition</b> spatiallink.h:128</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the link exists: even as components are added and/or removed, it will always reflect the components that are currently in the link. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="#a53b3634d24a9bf525a1a435c33881988" title="Returns an object that allows iteration through and random access to all components of this link.">components()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all components. </dd></dl>

</div>
</div>
<a id="aeccb1edef469efb584d5c91b183d169b" name="aeccb1edef469efb584d5c91b183d169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccb1edef469efb584d5c91b183d169b">&#9670;&#160;</a></span>componentSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SpatialLink::componentSize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>componentIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes that are stored for the given component of this link. </p>
<p>This is equivalent to calling <code>component[componentIndex].<a class="el" href="#a3b1cb4710d4e356292e396eadaa14c1f" title="Returns the total number of nodes in this spatial link.">size()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentIndex</td><td>indicates the link component to query; this must be between 0 and <code><a class="el" href="#a419d63fa4837de13efc9afd200a3d79a" title="Returns the number of components in this link.">countComponents()</a> - 1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes stored for the requested component. </dd></dl>

</div>
</div>
<a id="a419d63fa4837de13efc9afd200a3d79a" name="a419d63fa4837de13efc9afd200a3d79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d63fa4837de13efc9afd200a3d79a">&#9670;&#160;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SpatialLink::countComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of components in this link. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="a3c55c180dbe58e6de2a4eb78aecd6d3d" name="a3c55c180dbe58e6de2a4eb78aecd6d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c55c180dbe58e6de2a4eb78aecd6d3d">&#9670;&#160;</a></span>defaultRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double regina::SpatialLink::defaultRadius </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sensible default radius to use when rendering the link. </p>
<p>Specifically, this is the radius to use for the balls and cylinders used in the 3-D model.</p>
<p>Currently this routine makes a "barely educated" decision: it looks only at the scale of the embedding, without studying the complexity of the knot or the closeness of the strands. Specifically, it chooses some fixed fraction of the minimum range amongst the <em>x</em>, <em>y</em> and <em>z</em> dimensions.</p>
<p>Eventually this will be replaced with something intelligent that factors in how far apart the strands are, and will (as a result) guarantee that the renderings of no-adjacent strands will not collide.</p>
<p>This function is expensive to call the first time, but it caches its value and so subsesquent calls are essentially instantaneous (until the embedding of the link changes, at which point the cached value will be cleared).</p>
<dl class="section return"><dt>Returns</dt><dd>a sensible default radius to use for rendering. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="afae3e556b7f8169fbde6d289fa3cf7fb" name="afae3e556b7f8169fbde6d289fa3cf7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae3e556b7f8169fbde6d289fa3cf7fb">&#9670;&#160;</a></span>fromKnotPlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> regina::SpatialLink::fromKnotPlot </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from a KnotPlot data file. </p>
<p>Since KnotPlot files are in a binary format, this routine takes a <em>filename</em> (not the file contents).</p>
<p>For further information on the KnotPlot file format, see <a href="https://knotplot.com/manual/FileFormats.html">https://knotplot.com/manual/FileFormats.html</a> .</p>
<dl class="section warning"><dt>Warning</dt><dd>The KnotPlot binary data format makes use of 32-bit and 64-bit floating-point numbers. For the time being, this means that this import will <em>only</em> work on systems where <code>float</code> and <code>double</code> are 32-bit and 64-bit respectively. This is at least true on <code>x86_64</code> chips (64-bit intel) and <code>arm64</code> chips (e.g., Apple Silicon). The sizes of the floating point types will be checked, and if this requirement fails to hold then this routine will throw a <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> exception.</dd>
<dd>
While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test whether the link is embedded. It is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>If the given argument is a filename, then this routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the filename, and simply passes it through to low-level C/C++ file I/O routines.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>The given file could not be read.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The contents of the given file could not be interpreted as a KnotPlot data file, or the data file contains a structure that cannot be represented by a <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> (e.g., a link that is cut open leaving free ends).</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>The chipset on this machine uses floating-point types that are incompatible with KnotPlot's binary file format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of a KnotPlot data file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed spatial link. </dd></dl>

</div>
</div>
<a id="a3bfa554a4613d3762ec71352e3d8705a" name="a3bfa554a4613d3762ec71352e3d8705a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfa554a4613d3762ec71352e3d8705a">&#9670;&#160;</a></span>hasRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SpatialLink::hasRadius </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the user has set their own custom radius to use when rendering this link. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a custom radius has been set (e.g., via <a class="el" href="#a3e262c5576f8a2e624cbc561f88fbccc" title="Indicates that the given radius should be used when rendering this link.">setRadius()</a>), or <code>false</code> if the default radius should be used (as computed by <a class="el" href="#a3c55c180dbe58e6de2a4eb78aecd6d3d" title="Returns a sensible default radius to use when rendering the link.">defaultRadius()</a>). </dd></dl>

</div>
</div>
<a id="af86e767c6c78e87954e7e0974d9a5afb" name="af86e767c6c78e87954e7e0974d9a5afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86e767c6c78e87954e7e0974d9a5afb">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SpatialLink::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link is empty. </p>
<p>An empty link is one with no components at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link is empty. </dd></dl>

</div>
</div>
<a id="a798f95551ad129f9598aab3b9a442f63" name="a798f95551ad129f9598aab3b9a442f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798f95551ad129f9598aab3b9a442f63">&#9670;&#160;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">SpatialLink::Node</a> &amp; regina::SpatialLink::node </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>componentIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nodeIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a particular node belong to a particular component of this link. </p>
<p>This is equivalent to calling <code>component[componentIndex][nodeIndex]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentIndex</td><td>indicates the component of the link to which the requested node belongs; this must be between 0 and <code><a class="el" href="#a419d63fa4837de13efc9afd200a3d79a" title="Returns the number of components in this link.">countComponents()</a> - 1</code> inclusive. </td></tr>
    <tr><td class="paramname">nodeIndex</td><td>indicates which node to return from the given component; this must be between 0 and <code>componentSize(componentIndex) - 1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9755b62e7eb8622858742497d4a5c496" name="a9755b62e7eb8622858742497d4a5c496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9755b62e7eb8622858742497d4a5c496">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp; regina::SpatialLink::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="a8d724345455f244be594c555c5f3a983" name="a8d724345455f244be594c555c5f3a983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d724345455f244be594c555c5f3a983">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp; regina::SpatialLink::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given link into this link. </p>
<p>This is a fast (constant time) operation.</p>
<p>The link that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this link which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="a521f10452934fac4ef481a2e7ed14c6e" name="a521f10452934fac4ef481a2e7ed14c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521f10452934fac4ef481a2e7ed14c6e">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SpatialLink::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this link is identical to the given link. </p>
<p>Here "identical" means that both links follow exactly the same paths through 3-dimensional space, with their components and nodes stored in exactly the same order.</p>
<p>If any rendering radii have been fixed (e.g., via <a class="el" href="#a3e262c5576f8a2e624cbc561f88fbccc" title="Indicates that the given radius should be used when rendering this link.">setRadius()</a>), these will be ignored for the purpose of this comparison.</p>
<dl class="section warning"><dt>Warning</dt><dd>Equality and inequailty testing, while supported, is extremely fragile, since it relies on floating point comparisons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two links are identical. </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&#160;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p>There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine Triangulation&lt;3&gt;::inAnyPacket() will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p>The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&#160;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a45658408d1c95a745616e14a2696c92d" name="a45658408d1c95a745616e14a2696c92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45658408d1c95a745616e14a2696c92d">&#9670;&#160;</a></span>radius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double regina::SpatialLink::radius </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radius that should be used when rendering this link. </p>
<p>Specifically, this is the radius to use for the balls and cylinders used in the 3-D model.</p>
<p>If the user has fixed their own radius (e.g., via <a class="el" href="#a3e262c5576f8a2e624cbc561f88fbccc" title="Indicates that the given radius should be used when rendering this link.">setRadius()</a>), then that radius will be returned. Otherwise a sensible default (as computed by <a class="el" href="#a3c55c180dbe58e6de2a4eb78aecd6d3d" title="Returns a sensible default radius to use when rendering the link.">defaultRadius()</a>) will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the radius to use when rendering this link. </dd></dl>

</div>
</div>
<a id="adf48867ebe9e024aa029600effb34821" name="adf48867ebe9e024aa029600effb34821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf48867ebe9e024aa029600effb34821">&#9670;&#160;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a>, <a class="el" href="#a4fc64965e2cddc257fd242b6e80f6984">Node</a> &gt; regina::SpatialLink::range </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range of coordinates that this link occupies. </p>
<p>Specifically, this routine returns a pair <code>(min, max)</code>, where <em>min</em> contains the minimum <em>x</em>, <em>y</em> and <em>z</em> coordinates over all nodes, and <em>max</em> contains the maximum <em>x</em>, <em>y</em> and <em>z</em> coordinates over all nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>the range of coordinates. If this link contains no nodes at all then this routine will return <code>((0,0,0), (0,0,0))</code>. </dd></dl>

</div>
</div>
<a id="a47cbdd38546374d5bbef6bbaf4210106" name="a47cbdd38546374d5bbef6bbaf4210106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cbdd38546374d5bbef6bbaf4210106">&#9670;&#160;</a></span>refine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::refine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds additional nodes to make the embedding appear smoother. </p>
<p>Specifically, each adjacent pair of nodes will have one new node inserted between them (thereby doubling the number of nodes and arcs overall). This new node is <em>not</em> added at the midpoint of line segment between the two original nodes (which would not help with smoothing); instead it is calculated to lie on a Catmull-Rom spline defined by the original nodes. This spline is configured to have tension τ=0.5.</p>
<p>See also <a class="el" href="#acb8074d347253f6a214a14f5f0adc394" title="Adds a configurable number of additional nodes to make the embedding appear smoother.">refine(int)</a>, which allows for many new nodes to be inserted between each adjacent pair of original nodes. Calling <code><a class="el" href="#a47cbdd38546374d5bbef6bbaf4210106" title="Adds additional nodes to make the embedding appear smoother.">refine()</a></code> is equivalent to calling <code>refine(2)</code> (but uses a more streamlined implementation).</p>
<dl class="section warning"><dt>Warning</dt><dd>In the current implementation, there is no guarantee that this operation will not inadvertently pass one strand through another. (This could happen, for instance, if two parts of the link with very tight curvature pass very close to one another). The hope is to explicitly prevent this in a later implementation. </dd></dl>

</div>
</div>
<a id="acb8074d347253f6a214a14f5f0adc394" name="acb8074d347253f6a214a14f5f0adc394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8074d347253f6a214a14f5f0adc394">&#9670;&#160;</a></span>refine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::refine </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sub</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a configurable number of additional nodes to make the embedding appear smoother. </p>
<p>Specifically, each adjacent pair of nodes will have <code>sub - 1</code> new nodes inserted between them (thereby multiplying the number of nodes and arcs by <em>sub</em> overall). The new nodes are <em>not</em> added along the line segments joining the original nodes (since this would not help with smoothing); instead they are calculated to lie on Catmull-Rom splines defined by the original nodes. These splines are configured to have tension τ=0.5.</p>
<p>See also <a class="el" href="#a47cbdd38546374d5bbef6bbaf4210106" title="Adds additional nodes to make the embedding appear smoother.">refine()</a>, which allows for many new nodes to be inserted between each adjacent pair of original nodes. Calling <code><a class="el" href="#a47cbdd38546374d5bbef6bbaf4210106" title="Adds additional nodes to make the embedding appear smoother.">refine()</a></code> is equivalent to calling <code>refine(2)</code> (but uses a more streamlined implementation).</p>
<dl class="section warning"><dt>Warning</dt><dd>In the current implementation, there is no guarantee that this operation will not inadvertently pass one strand through another. (This could happen, for instance, if two parts of the link with very tight curvature pass very close to one another). The hope is to explicitly prevent this in a later implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>the number of pieces that each original arc (i.e., line segment) should be subdivided into. This must be at least 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3c54d18dbf2be2d28efd1d00507f779" name="ad3c54d18dbf2be2d28efd1d00507f779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c54d18dbf2be2d28efd1d00507f779">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::reflect </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reflects the link in plane perpendicular to the given axis. </p>
<p>Specifically:</p>
<ul>
<li>if <em>axis</em> is 0 then all <em>x</em> coordinates will be negated;</li>
<li>if <em>axis</em> is 1 then all <em>y</em> coordinates will be negated;</li>
<li>if <em>axis</em> is 2 then all <em>z</em> coordinates will be negated.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The argument <em>axis</em> was not 0, 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>indicates the axis of reflection, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad490f571cbc82db9f2df4e4860ca363c" name="ad490f571cbc82db9f2df4e4860ca363c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad490f571cbc82db9f2df4e4860ca363c">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::scale </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>factor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the entire link by the given factor. </p>
<p>Specifically, all coordinates of all nodes will be multiplied by <em>factor</em>.</p>
<p>The rendering radius, if this has been fixed, will be scaled also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the scaling factor; this must not be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e262c5576f8a2e624cbc561f88fbccc" name="a3e262c5576f8a2e624cbc561f88fbccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e262c5576f8a2e624cbc561f88fbccc">&#9670;&#160;</a></span>setRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::setRadius </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>useRadius</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the given radius should be used when rendering this link. </p>
<p>The given value will be returned by any subsequent calls to <a class="el" href="#a45658408d1c95a745616e14a2696c92d" title="Returns the radius that should be used when rendering this link.">radius()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useRadius</td><td>the radius to use when rendering this link; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b1cb4710d4e356292e396eadaa14c1f" name="a3b1cb4710d4e356292e396eadaa14c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1cb4710d4e356292e396eadaa14c1f">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SpatialLink::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of nodes in this spatial link. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is not a constant time operation, since it sums the sizes of the individual components.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of nodes. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a3a9c83e1765931ae2e34ae140b0afa09" name="a3a9c83e1765931ae2e34ae140b0afa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9c83e1765931ae2e34ae140b0afa09">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given link. </p>
<p>All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both links which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cddfcddc2da6d48790af2bc67dfc36b" name="a5cddfcddc2da6d48790af2bc67dfc36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cddfcddc2da6d48790af2bc67dfc36b">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1Vector3D.html">Vector3D</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the entire link by the given vector. </p>
<p>Specifically, the <em>x</em>, <em>y</em> and <em>z</em> coordinates of all nodes will be incremented by <code>vector.x</code>, <code>vector.y</code> and <code>vector.z</code> respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>holds the three constants that should be added to the <em>x</em>, <em>y</em> and <em>z</em> coordinates of every node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a561086e910f9db25b6b2c24d34c41af0" name="a561086e910f9db25b6b2c24d34c41af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561086e910f9db25b6b2c24d34c41af0">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6741b57e312ab75dedad76466f127ce6" name="a6741b57e312ab75dedad76466f127ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6741b57e312ab75dedad76466f127ce6">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpatialLink::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&#160;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1SpatialLink.html">SpatialLink</a> &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p>As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="spatiallink_8h.html">spatiallink.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
