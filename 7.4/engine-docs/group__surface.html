<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4 Calculation Engine: Normal Surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Normal Surfaces</div></div>
</div><!--header-->
<div class="contents">

<p>Normal surfaces in 3-manifold triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single normal disc in a normal surface.  <a href="structregina_1_1DiscSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTet.html">regina::DiscSetTet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of normal discs inside a single tetrahedron.  <a href="classregina_1_1DiscSetTet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc inside a single tetrahedron.  <a href="classregina_1_1DiscSetTetData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">regina::DiscSetSurfaceDataImpl&lt; TetData &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a piece of data alongside every normal disc within a particular normal surface.  <a href="classregina_1_1DiscSetSurfaceDataImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSpecIterator.html">regina::DiscSpecIterator&lt; TetData &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator used for running through all normal discs in a normal surface.  <a href="classregina_1_1DiscSpecIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscType.html">regina::DiscType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a single normal or almost normal disc type within a triangulation.  <a href="structregina_1_1DiscType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalEncoding.html">regina::NormalEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates precisely how a normal surface is encoded by an integer vector.  <a href="classregina_1_1NormalEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalInfo.html">regina::NormalInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to query general information about different normal coordinate systems.  <a href="classregina_1_1NormalInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html">regina::NormalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single normal surface in a 3-manifold triangulation.  <a href="classregina_1_1NormalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html">regina::NormalSurfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of normal surfaces in a 3-manifold triangulation.  <a href="classregina_1_1NormalSurfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PrismSpec.html">regina::PrismSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single triangular prism in a tetrahedron.  <a href="structregina_1_1PrismSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html">regina::SurfaceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that accepts or rejects normal surfaces.  <a href="classregina_1_1SurfaceFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterCombination.html">regina::SurfaceFilterCombination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that simply combines other filters.  <a href="classregina_1_1SurfaceFilterCombination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterProperties.html">regina::SurfaceFilterProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that filters by basic properties of the normal surface.  <a href="classregina_1_1SurfaceFilterProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf918f9a37ff9466f63c76861b06049a0" id="r_gaf918f9a37ff9466f63c76861b06049a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf918f9a37ff9466f63c76861b06049a0">REGINA_SURFACE_FILTER</a>(id,  name)</td></tr>
<tr class="memdesc:gaf918f9a37ff9466f63c76861b06049a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a descendant class of SurfaceFilter.  <br /></td></tr>
<tr class="separator:gaf918f9a37ff9466f63c76861b06049a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga864fe61a07208207090a4eb7598839ed" id="r_ga864fe61a07208207090a4eb7598839ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga864fe61a07208207090a4eb7598839ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga864fe61a07208207090a4eb7598839ed">regina::DiscSetSurfaceData</a> = <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt;<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:ga864fe61a07208207090a4eb7598839ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that stores data of type <em>T</em> alongside every normal disc within a particular normal surface.  <br /></td></tr>
<tr class="separator:ga864fe61a07208207090a4eb7598839ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8534c28f2196bfd0422d0ad3d5d637" id="r_ga2c8534c28f2196bfd0422d0ad3d5d637"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c8534c28f2196bfd0422d0ad3d5d637">regina::DiscSetSurface</a> = <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt;<a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>&gt;</td></tr>
<tr class="memdesc:ga2c8534c28f2196bfd0422d0ad3d5d637"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that builds all of the normal discs within a particular normal surface, but does not store any additional data alongside them.  <br /></td></tr>
<tr class="separator:ga2c8534c28f2196bfd0422d0ad3d5d637"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9817fc7125c53daea4e3f3cbfe987a47" id="r_ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a> { <br />
&#160;&#160;<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47aeb6d8ae6f20283755b339c0dc273988b">regina::NormalCoords::Standard</a> = 0
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ae9017664588010860a92ceb5f8fcb824">regina::NormalCoords::Quad</a> = 1
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ae7be66e319a0f89d315c43fbd570ffc9">regina::NormalCoords::QuadClosed</a> = 10
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ac412b47e7eb6b9d99d536f6fbca2c838">regina::NormalCoords::AlmostNormal</a> = 102
, <br />
&#160;&#160;<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a2864e1ab8ba4dc3b772e78526de8e8ca">regina::NormalCoords::LegacyAlmostNormal</a> = 100
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a34c5f14ffe856e97f39b4ad9f9048909">regina::NormalCoords::QuadOct</a> = 101
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ab1252784f6b80915b3a8abcd9c94ebe6">regina::NormalCoords::QuadOctClosed</a> = 110
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ae4a297a0f76119a442c2595ac040673e">regina::NormalCoords::Edge</a> = 200
, <br />
&#160;&#160;<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a2b73f91683611c489560a1d163e37902">regina::NormalCoords::Arc</a> = 201
, <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a45f4ce6c3306644b1efe333f4f8d6929">regina::NormalCoords::Angle</a> = 400
<br />
 }</td></tr>
<tr class="memdesc:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different coordinate systems that can be used for enumerating and/or displaying normal surfaces.  <a href="#ga9817fc7125c53daea4e3f3cbfe987a47">More...</a><br /></td></tr>
<tr class="separator:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae42d1212a1d908d6aa2ab4c7a14232" id="r_ga3ae42d1212a1d908d6aa2ab4c7a14232"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">regina::NormalList</a> { <br />
&#160;&#160;<a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a7a1920d61156abc05a60135aefe8bc67">regina::NormalList::Default</a> = 0x0000
, <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232abc00874da66eef26f89c0a03906a3ae4">regina::NormalList::EmbeddedOnly</a> = 0x0001
, <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a53cf9fe215e818e1748af66ee9dbad37">regina::NormalList::ImmersedSingular</a> = 0x0002
, <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232ab22b929ba52471a02d18bb3a4e4472e6">regina::NormalList::Vertex</a> = 0x0004
, <br />
&#160;&#160;<a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a2863bc264d070388a94111bc05f77f0f">regina::NormalList::Fundamental</a> = 0x0008
, <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a0cc0a0507cf3d31e5089f420a4cf8b4b">regina::NormalList::Legacy</a> = 0x4000
, <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af">regina::NormalList::Custom</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:ga3ae42d1212a1d908d6aa2ab4c7a14232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation.  <a href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">More...</a><br /></td></tr>
<tr class="separator:ga3ae42d1212a1d908d6aa2ab4c7a14232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd653b63635d07722feea911712b3e58" id="r_gafd653b63635d07722feea911712b3e58"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd653b63635d07722feea911712b3e58">regina::NormalAlg</a> { <br />
&#160;&#160;<a class="el" href="#ggafd653b63635d07722feea911712b3e58a7a1920d61156abc05a60135aefe8bc67">regina::NormalAlg::Default</a> = 0x0000
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58af279e3f44c2f502531c70aaa101c2ab9">regina::NormalAlg::VertexViaReduced</a> = 0x0001
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a5b801b9bd4e7fd3b12d99147562fb5db">regina::NormalAlg::VertexStandardDirect</a> = 0x0002
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58ac171c36de7a120802c6b176c9dc75d44">regina::NormalAlg::VertexTree</a> = 0x0010
, <br />
&#160;&#160;<a class="el" href="#ggafd653b63635d07722feea911712b3e58a2849bd47941b15cda86da9e2509e1b3f">regina::NormalAlg::VertexDD</a> = 0x0020
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a7e1a566bdee3c0ca511dfca5d7171446">regina::NormalAlg::HilbertPrimal</a> = 0x0100
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a55250977478abbb8f6b06eda399607aa">regina::NormalAlg::HilbertDual</a> = 0x0200
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a0d71a66dba5726fd459f001cebb57462">regina::NormalAlg::HilbertCD</a> = 0x0400
, <br />
&#160;&#160;<a class="el" href="#ggafd653b63635d07722feea911712b3e58a4c304ef8875d9e4cf69936a021ed2149">regina::NormalAlg::HilbertFullCone</a> = 0x0800
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a0cc0a0507cf3d31e5089f420a4cf8b4b">regina::NormalAlg::Legacy</a> = 0x4000
, <a class="el" href="#ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af">regina::NormalAlg::Custom</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:gafd653b63635d07722feea911712b3e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations.  <a href="#gafd653b63635d07722feea911712b3e58">More...</a><br /></td></tr>
<tr class="separator:gafd653b63635d07722feea911712b3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3bddca5e5ddf81edfe8b2db4ba133df" id="r_gaf3bddca5e5ddf81edfe8b2db4ba133df"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf3bddca5e5ddf81edfe8b2db4ba133df">regina::NormalTransform</a> { <br />
&#160;&#160;<a class="el" href="#ggaf3bddca5e5ddf81edfe8b2db4ba133dfa6451acff3949df15728e6bf5ac19a9ee">regina::NormalTransform::ConvertReducedToStandard</a> = 0x01
, <a class="el" href="#ggaf3bddca5e5ddf81edfe8b2db4ba133dfab56920aa73778f6fa761ac00f7cf9c8f">regina::NormalTransform::ConvertStandardToReduced</a> = 0x02
, <a class="el" href="#ggaf3bddca5e5ddf81edfe8b2db4ba133dfabbe74036b762f63c9f358a66ad353ee7">regina::NormalTransform::FilterCompatible</a> = 0x10
, <a class="el" href="#ggaf3bddca5e5ddf81edfe8b2db4ba133dfac81dc6ce70b10630e1bda6ff1b3a2843">regina::NormalTransform::FilterDisjoint</a> = 0x20
, <br />
&#160;&#160;<a class="el" href="#ggaf3bddca5e5ddf81edfe8b2db4ba133dfaa14d13419f68b566b5870bdb6e564a09">regina::NormalTransform::FilterIncompressible</a> = 0x30
<br />
 }</td></tr>
<tr class="memdesc:gaf3bddca5e5ddf81edfe8b2db4ba133df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different ways in which Regina can transform one normal surface list into another.  <a href="#gaf3bddca5e5ddf81edfe8b2db4ba133df">More...</a><br /></td></tr>
<tr class="separator:gaf3bddca5e5ddf81edfe8b2db4ba133df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0ca401e07b0f6528d36d68064ff961" id="r_ga1e0ca401e07b0f6528d36d68064ff961"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">regina::SurfaceExport</a> { <br />
&#160;&#160;<a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a49ee3087348e8d44e1feda1917443987">regina::SurfaceExport::Name</a> = 0x0001
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a0a7532036415f2491bf5f952220827b8">regina::SurfaceExport::Euler</a> = 0x0002
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961af4b37c01ca682deab6ecd69bf5e06fe5">regina::SurfaceExport::Orient</a> = 0x0004
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a23cacdef82dcc2b928a439e224c75d3f">regina::SurfaceExport::Sides</a> = 0x0008
, <br />
&#160;&#160;<a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a0f20c16ad87524747188349aa8069c74">regina::SurfaceExport::Bdry</a> = 0x0010
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a97e7c9a7d06eac006a28bf05467fcc8b">regina::SurfaceExport::Link</a> = 0x0020
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508">regina::SurfaceExport::Type</a> = 0x0040
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961a6adf97f83acf6453d4a6a4b1070f3754">regina::SurfaceExport::None</a> = 0
, <br />
&#160;&#160;<a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961afc742013094ae4c79be3b0c44f259220">regina::SurfaceExport::AllButName</a> = 0x007e
, <a class="el" href="#gga1e0ca401e07b0f6528d36d68064ff961ab1c94ca2fbc3e78fc30069c8d0f01680">regina::SurfaceExport::All</a> = 0x007f
<br />
 }</td></tr>
<tr class="memdesc:ga1e0ca401e07b0f6528d36d68064ff961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.  <a href="#ga1e0ca401e07b0f6528d36d68064ff961">More...</a><br /></td></tr>
<tr class="separator:ga1e0ca401e07b0f6528d36d68064ff961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ab803471723156fb2ecb24b7b1c859" id="r_ga38ab803471723156fb2ecb24b7b1c859"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a> { <a class="el" href="#gga38ab803471723156fb2ecb24b7b1c859a24782791f84f9ed8aeacf8a5b8408f56">regina::SurfaceFilterType::LegacyDefault</a> = 0
, <a class="el" href="#gga38ab803471723156fb2ecb24b7b1c859a9fc2d28c05ed9eb1d75ba4465abf15a9">regina::SurfaceFilterType::Properties</a> = 1
, <a class="el" href="#gga38ab803471723156fb2ecb24b7b1c859a47ac923d219501859fb68fed8c8db77b">regina::SurfaceFilterType::Combination</a> = 2
 }</td></tr>
<tr class="memdesc:ga38ab803471723156fb2ecb24b7b1c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations.  <a href="#ga38ab803471723156fb2ecb24b7b1c859">More...</a><br /></td></tr>
<tr class="separator:ga38ab803471723156fb2ecb24b7b1c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeb62505986baff30554f9495f5ab3688" id="r_gaeb62505986baff30554f9495f5ab3688"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb62505986baff30554f9495f5ab3688">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gaeb62505986baff30554f9495f5ab3688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <br /></td></tr>
<tr class="separator:gaeb62505986baff30554f9495f5ab3688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17dfc1f57595cbc9ec5662a76d25c161" id="r_ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga17dfc1f57595cbc9ec5662a76d25c161">regina::numberDiscsAwayFromVertex</a> (int discType, int vertex)</td></tr>
<tr class="memdesc:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not normal discs of the given type are numbered away from the given vertex.  <br /></td></tr>
<tr class="separator:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc8d5800d8613931ff0483a8388308c" id="r_gaacc8d5800d8613931ff0483a8388308c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaacc8d5800d8613931ff0483a8388308c">regina::discOrientationFollowsEdge</a> (int discType, int vertex, int edgeStart, int edgeEnd)</td></tr>
<tr class="memdesc:gaacc8d5800d8613931ff0483a8388308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc.  <br /></td></tr>
<tr class="separator:gaacc8d5800d8613931ff0483a8388308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0885312336b0f4a9fad50c1981865173" id="r_ga0885312336b0f4a9fad50c1981865173"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0885312336b0f4a9fad50c1981865173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0885312336b0f4a9fad50c1981865173">regina::swap</a> (<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga0885312336b0f4a9fad50c1981865173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given disc sets.  <br /></td></tr>
<tr class="separator:ga0885312336b0f4a9fad50c1981865173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5a1287f454c11db949a064cbf5d672" id="r_gaeb5a1287f454c11db949a064cbf5d672"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaeb5a1287f454c11db949a064cbf5d672"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeb5a1287f454c11db949a064cbf5d672">regina::swap</a> (<a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gaeb5a1287f454c11db949a064cbf5d672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given disc sets.  <br /></td></tr>
<tr class="separator:gaeb5a1287f454c11db949a064cbf5d672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d42ed9b68e522ff445b5d3e777176f4" id="r_ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d42ed9b68e522ff445b5d3e777176f4">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;type)</td></tr>
<tr class="memdesc:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc type to the given output stream.  <br /></td></tr>
<tr class="separator:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f09787723e70a659f2265930870231e" id="r_ga2f09787723e70a659f2265930870231e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f09787723e70a659f2265930870231e">regina::operator|</a> (<a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a> lhs, <a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a> rhs)</td></tr>
<tr class="memdesc:ga2f09787723e70a659f2265930870231e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bitwise OR of the two given flags.  <br /></td></tr>
<tr class="separator:ga2f09787723e70a659f2265930870231e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15969a39fab7ec3da69d80797433cf25" id="r_ga15969a39fab7ec3da69d80797433cf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15969a39fab7ec3da69d80797433cf25">regina::operator|</a> (<a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a> lhs, <a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a> rhs)</td></tr>
<tr class="memdesc:ga15969a39fab7ec3da69d80797433cf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bitwise OR of the two given flags.  <br /></td></tr>
<tr class="separator:ga15969a39fab7ec3da69d80797433cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54184754081d5cb2bf5ae20fab667a49" id="r_ga54184754081d5cb2bf5ae20fab667a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga54184754081d5cb2bf5ae20fab667a49">regina::swap</a> (<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;a, <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga54184754081d5cb2bf5ae20fab667a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given normal surfaces.  <br /></td></tr>
<tr class="separator:ga54184754081d5cb2bf5ae20fab667a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f3f5da6b482e8fb13e4e91f541e7f5" id="r_ga50f3f5da6b482e8fb13e4e91f541e7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50f3f5da6b482e8fb13e4e91f541e7f5">regina::operator|</a> (<a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a> lhs, <a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a> rhs)</td></tr>
<tr class="memdesc:ga50f3f5da6b482e8fb13e4e91f541e7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bitwise OR of the two given flags.  <br /></td></tr>
<tr class="separator:ga50f3f5da6b482e8fb13e4e91f541e7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad10219a0cd0d5bd3261bc36fb9a997a" id="r_gaad10219a0cd0d5bd3261bc36fb9a997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad10219a0cd0d5bd3261bc36fb9a997a">regina::swap</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;lhs, <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaad10219a0cd0d5bd3261bc36fb9a997a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given lists.  <br /></td></tr>
<tr class="separator:gaad10219a0cd0d5bd3261bc36fb9a997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a05e667b9a2ad50bcd17541c652bcc7" id="r_ga1a05e667b9a2ad50bcd17541c652bcc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a05e667b9a2ad50bcd17541c652bcc7">regina::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triangulation, <a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga1a05e667b9a2ad50bcd17541c652bcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the set of normal surface matching equations for the given triangulation using the given coordinate system.  <br /></td></tr>
<tr class="separator:ga1a05e667b9a2ad50bcd17541c652bcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f34aa52f4c65b2bcd7b0611b08b373a" id="r_ga6f34aa52f4c65b2bcd7b0611b08b373a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ValidityConstraints.html">ValidityConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6f34aa52f4c65b2bcd7b0611b08b373a">regina::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triangulation, <a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga6f34aa52f4c65b2bcd7b0611b08b373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the validity constraints representing the condition that normal surfaces be embedded.  <br /></td></tr>
<tr class="separator:ga6f34aa52f4c65b2bcd7b0611b08b373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eccc9cb94753e2c763c840460a5bbd5" id="r_ga0eccc9cb94753e2c763c840460a5bbd5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0eccc9cb94753e2c763c840460a5bbd5">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:ga0eccc9cb94753e2c763c840460a5bbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given prism specifier to the given output stream.  <br /></td></tr>
<tr class="separator:ga0eccc9cb94753e2c763c840460a5bbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35759e4e4e70d1b0ab9f281a7b572cd6" id="r_ga35759e4e4e70d1b0ab9f281a7b572cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga35759e4e4e70d1b0ab9f281a7b572cd6">regina::swap</a> (<a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;a, <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;b)</td></tr>
<tr class="memdesc:ga35759e4e4e70d1b0ab9f281a7b572cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given combination filters.  <br /></td></tr>
<tr class="separator:ga35759e4e4e70d1b0ab9f281a7b572cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac184aeb6cc3d2da89a3e5e72853d7c3" id="r_gaac184aeb6cc3d2da89a3e5e72853d7c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac184aeb6cc3d2da89a3e5e72853d7c3">regina::swap</a> (<a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;a, <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;b)</td></tr>
<tr class="memdesc:gaac184aeb6cc3d2da89a3e5e72853d7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given property-based filters.  <br /></td></tr>
<tr class="separator:gaac184aeb6cc3d2da89a3e5e72853d7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga97d454b13fbddb464094146796f19fec" id="r_ga97d454b13fbddb464094146796f19fec"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97d454b13fbddb464094146796f19fec">regina::quadSeparating</a> [4][4]</td></tr>
<tr class="memdesc:ga97d454b13fbddb464094146796f19fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.  <br /></td></tr>
<tr class="separator:ga97d454b13fbddb464094146796f19fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161c786acec999baa4d539e59d61fa8a" id="r_ga161c786acec999baa4d539e59d61fa8a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga161c786acec999baa4d539e59d61fa8a">regina::quadMeeting</a> [4][4][2]</td></tr>
<tr class="memdesc:ga161c786acec999baa4d539e59d61fa8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types meet which edges in a tetrahedron.  <br /></td></tr>
<tr class="separator:ga161c786acec999baa4d539e59d61fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b2917f4b34f6e5cbc850c30a5e2c8e" id="r_gae5b2917f4b34f6e5cbc850c30a5e2c8e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5b2917f4b34f6e5cbc850c30a5e2c8e">regina::quadDefn</a> [3][4]</td></tr>
<tr class="memdesc:gae5b2917f4b34f6e5cbc850c30a5e2c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which vertices each quadrilateral type separates in a tetrahedron.  <br /></td></tr>
<tr class="separator:gae5b2917f4b34f6e5cbc850c30a5e2c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4c9c0b9cce8f830ffa30f20a82b6d8" id="r_gaff4c9c0b9cce8f830ffa30f20a82b6d8"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaff4c9c0b9cce8f830ffa30f20a82b6d8">regina::quadPartner</a> [3][4]</td></tr>
<tr class="memdesc:gaff4c9c0b9cce8f830ffa30f20a82b6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron.  <br /></td></tr>
<tr class="separator:gaff4c9c0b9cce8f830ffa30f20a82b6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf493c20711e8970eaacdfd15842eae1e" id="r_gaf493c20711e8970eaacdfd15842eae1e"><td class="memItemLeft" align="right" valign="top">constexpr std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf493c20711e8970eaacdfd15842eae1e">regina::quadString</a> [3] = { &quot;01/23&quot;, &quot;02/13&quot;, &quot;03/12&quot; }</td></tr>
<tr class="memdesc:gaf493c20711e8970eaacdfd15842eae1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains strings that can be used to represent each quadrilateral type in a tetrahedron.  <br /></td></tr>
<tr class="separator:gaf493c20711e8970eaacdfd15842eae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c87df41b7d18490de378b0d42d65b60" id="r_ga7c87df41b7d18490de378b0d42d65b60"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c87df41b7d18490de378b0d42d65b60">regina::triDiscArcs</a> [4][3]</td></tr>
<tr class="memdesc:ga7c87df41b7d18490de378b0d42d65b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc.  <br /></td></tr>
<tr class="separator:ga7c87df41b7d18490de378b0d42d65b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5e68787b9a0130ffbee14797ed3392" id="r_gadc5e68787b9a0130ffbee14797ed3392"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc5e68787b9a0130ffbee14797ed3392">regina::quadDiscArcs</a> [3][4]</td></tr>
<tr class="memdesc:gadc5e68787b9a0130ffbee14797ed3392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc.  <br /></td></tr>
<tr class="separator:gadc5e68787b9a0130ffbee14797ed3392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3194707749e55b555701ea4b65f3295c" id="r_ga3194707749e55b555701ea4b65f3295c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3194707749e55b555701ea4b65f3295c">regina::octDiscArcs</a> [3][8]</td></tr>
<tr class="memdesc:ga3194707749e55b555701ea4b65f3295c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc.  <br /></td></tr>
<tr class="separator:ga3194707749e55b555701ea4b65f3295c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Normal surfaces in 3-manifold triangulations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf918f9a37ff9466f63c76861b06049a0" name="gaf918f9a37ff9466f63c76861b06049a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf918f9a37ff9466f63c76861b06049a0">&#9670;&#160;</a></span>REGINA_SURFACE_FILTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_SURFACE_FILTER</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> SurfaceFilterType filterTypeID = id; \</div>
<div class="line">        <span class="keyword">inline</span> SurfaceFilterType filterType()<span class="keyword"> const override </span>{ \</div>
<div class="line">            <span class="keywordflow">return</span> id; \</div>
<div class="line">        } \</div>
<div class="line">        <span class="keyword">inline</span> std::string filterTypeName()<span class="keyword"> const override </span>{ \</div>
<div class="line">            <span class="keywordflow">return</span> name; \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a descendant class of SurfaceFilter. </p>
<p>Every descendant class of SurfaceFilter <em>must</em> include REGINA_SURFACE_FILTER at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>filterTypeID</em>, which is equal to the corresponding SurfaceFilterType constant;</li>
<li>declarations and implementations of the virtual functions SurfaceFilter::filterType() and SurfaceFilter::filterTypeName();</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the corresponding SurfaceFilterType constant. </td></tr>
    <tr><td class="paramname">name</td><td>a human-readable name for this filter type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2c8534c28f2196bfd0422d0ad3d5d637" name="ga2c8534c28f2196bfd0422d0ad3d5d637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8534c28f2196bfd0422d0ad3d5d637">&#9670;&#160;</a></span>DiscSetSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2c8534c28f2196bfd0422d0ad3d5d637">regina::DiscSetSurface</a> = <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt;<a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A structure that builds all of the normal discs within a particular normal surface, but does not store any additional data alongside them. </p>
<p>This structure can be used for iterating through disc types, and for moving between adjacent disc types within a surface. </p>

</div>
</div>
<a id="ga864fe61a07208207090a4eb7598839ed" name="ga864fe61a07208207090a4eb7598839ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864fe61a07208207090a4eb7598839ed">&#9670;&#160;</a></span>DiscSetSurfaceData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga864fe61a07208207090a4eb7598839ed">regina::DiscSetSurfaceData</a> = <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt;<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A structure that stores data of type <em>T</em> alongside every normal disc within a particular normal surface. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gafd653b63635d07722feea911712b3e58" name="gafd653b63635d07722feea911712b3e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd653b63635d07722feea911712b3e58">&#9670;&#160;</a></span>NormalAlg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gafd653b63635d07722feea911712b3e58">regina::NormalAlg</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations. </p>
<p>This enumeration type is used with normal surface enumeration routines, such as the <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> class constructor.</p>
<p>These values can be combined using the bitwise OR operator (resulting in an object of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;NormalAlg&gt;</code>). In particular, if a hypersurface enumeration function takes an argument of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;NormalAlg&gt;</code>, then you can pass a single NormalAlg constant, or a bitwise combination of such constants <code>(flag1 | flag2)</code>, or empty braces <code>{}</code> to indicate no flags at all (which is equivalent to passing <code><a class="el" href="#ggafd653b63635d07722feea911712b3e58a7a1920d61156abc05a60135aefe8bc67" title="An empty flag, indicating to an enumeration routine that it should use its default behaviour.">NormalAlg::Default</a></code>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a7a1920d61156abc05a60135aefe8bc67" name="ggafd653b63635d07722feea911712b3e58a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58af279e3f44c2f502531c70aaa101c2ab9" name="ggafd653b63635d07722feea911712b3e58af279e3f44c2f502531c70aaa101c2ab9"></a>VertexViaReduced&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should first enumerate in quadrilateral or quadrilateral-octagon coordinates, and then expand this "reduced" solution set to the (typically larger) "standard" solution set. </p>
<p>This is typically much faster than a direct enumeration in standard normal or almost normal coordinates, and enumeration routines will use this option where possible unless explicitly requested not to (via the flag VertexStandardDirect).</p>
<p>For an explanation of this procedure, see B. A. Burton, "Converting between quadrilateral and standard solution sets in
normal surface theory", Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>This flag is incompatible with VertexStandardDirect. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a5b801b9bd4e7fd3b12d99147562fb5db" name="ggafd653b63635d07722feea911712b3e58a5b801b9bd4e7fd3b12d99147562fb5db"></a>VertexStandardDirect&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should work directly in that coordinate system, and should not go via the "reduced" (quadrilateral or quadrilateral-octagon) coordinate system. </p>
<p>This is typically <em>much</em> slower than going via the reduced system, and users should only request this if they have a specialised need. See VertexViaReduced for further information.</p>
<p>This flag is incompatible with VertexViaReduced. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58ac171c36de7a120802c6b176c9dc75d44" name="ggafd653b63635d07722feea911712b3e58ac171c36de7a120802c6b176c9dc75d44"></a>VertexTree&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that the tree traversal algorithm should be used. </p>
<p>This algorithm is based on linear and integer programming techniques, and has many desirable properties including a relatively low overhead. Enumeration algorithms will use it if possible unless a different method is explicitly requested.</p>
<p>For details on the tree traversal algorithm, see B. A. Burton and M. Ozlen, "A tree traversal algorithm for decision problems in
knot theory and 3-manifold topology", Algorithmica 65 (2013), pp. 772-801.</p>
<p>This flag is incompatible with VertexDD. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a2849bd47941b15cda86da9e2509e1b3f" name="ggafd653b63635d07722feea911712b3e58a2849bd47941b15cda86da9e2509e1b3f"></a>VertexDD&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that a modified double description method should be used. </p>
<p>This algorithm can suffer from a combinatorial explosion with larger problems, leading to extremely large time and memory footprints. Users should only request this if they have some specialised need.</p>
<p>For details on the modified double description method, see B. A. Burton, "Optimizing the double description method for
normal surface enumeration", Mathematics of Computation 79 (2010), pp. 453-484.</p>
<p>This flag is incompatible with VertexTree. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a7e1a566bdee3c0ca511dfca5d7171446" name="ggafd653b63635d07722feea911712b3e58a7e1a566bdee3c0ca511dfca5d7171446"></a>HilbertPrimal&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the primal method should be used for enumerating a Hilbert basis. </p>
<p>The primal method is recommended, and enumeration algorithms will use it if possible unless a different method is explicitly requested. This method uses code from Normaliz for parts of its processing.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with <a class="el" href="classregina_1_1HilbertDual.html" title="Implements a modified dual algorithm for enumerating Hilbert bases.">HilbertDual</a>, <a class="el" href="classregina_1_1HilbertCD.html" title="Implements a modified Contejean-Devie algorithm for enumerating Hilbert bases.">HilbertCD</a> and HilbertFullCone. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a55250977478abbb8f6b06eda399607aa" name="ggafd653b63635d07722feea911712b3e58a55250977478abbb8f6b06eda399607aa"></a>HilbertDual&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the dual method should be used for enumerating a Hilbert basis. </p>
<p>The dual method is fast (like the primal method), but its performance is highly variable; for this reason the primal method is recommended instead. This method does not make use of Normaliz, and is the recommended method for situations in which Normaliz is not available for some reason.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with <a class="el" href="classregina_1_1HilbertPrimal.html" title="Implements a modified primal algorithm for enumerating Hilbert bases.">HilbertPrimal</a>, <a class="el" href="classregina_1_1HilbertCD.html" title="Implements a modified Contejean-Devie algorithm for enumerating Hilbert bases.">HilbertCD</a> and HilbertFullCone. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a0d71a66dba5726fd459f001cebb57462" name="ggafd653b63635d07722feea911712b3e58a0d71a66dba5726fd459f001cebb57462"></a>HilbertCD&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a modified Contejean-Devie procedure should be used for enumerating a Hilbert basis. </p>
<p>The Contejean-Devie procedure is typically <em>much</em> slower than either the primal or dual method, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with <a class="el" href="classregina_1_1HilbertPrimal.html" title="Implements a modified primal algorithm for enumerating Hilbert bases.">HilbertPrimal</a>, <a class="el" href="classregina_1_1HilbertDual.html" title="Implements a modified dual algorithm for enumerating Hilbert bases.">HilbertDual</a> and HilbertFullCone. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a4c304ef8875d9e4cf69936a021ed2149" name="ggafd653b63635d07722feea911712b3e58a4c304ef8875d9e4cf69936a021ed2149"></a>HilbertFullCone&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a Hilbert basis for the full solution cone should be constructed, and additional combinatorial constraints (such as the quadrilateral constraints) should only be enforced as the final step. </p>
<p>If you are only enumerating properly embedded surfaces then this procedure <em>extremely</em> slow, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with <a class="el" href="classregina_1_1HilbertPrimal.html" title="Implements a modified primal algorithm for enumerating Hilbert bases.">HilbertPrimal</a>, <a class="el" href="classregina_1_1HilbertDual.html" title="Implements a modified dual algorithm for enumerating Hilbert bases.">HilbertDual</a> and <a class="el" href="classregina_1_1HilbertCD.html" title="Implements a modified Contejean-Devie algorithm for enumerating Hilbert bases.">HilbertCD</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a0cc0a0507cf3d31e5089f420a4cf8b4b" name="ggafd653b63635d07722feea911712b3e58a0cc0a0507cf3d31e5089f420a4cf8b4b"></a>Legacy&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was enumerated using an older version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of the algorithm used to build each list, and so in such cases no further algorithmic information is available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af" name="ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af"></a>Custom&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was built using a customised algorithm. </p>
<p>In such cases, no further details on the algorithm are available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9817fc7125c53daea4e3f3cbfe987a47" name="ga9817fc7125c53daea4e3f3cbfe987a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9817fc7125c53daea4e3f3cbfe987a47">&#9670;&#160;</a></span>NormalCoords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents different coordinate systems that can be used for enumerating and/or displaying normal surfaces. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own coordinate system, you should choose an ID ≥ 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47aeb6d8ae6f20283755b339c0dc273988b" name="gga9817fc7125c53daea4e3f3cbfe987a47aeb6d8ae6f20283755b339c0dc273988b"></a>Standard&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral coordinates for normal surfaces. </p>
<p>Regina can both enumerate and view surfaces in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ae9017664588010860a92ceb5f8fcb824" name="gga9817fc7125c53daea4e3f3cbfe987a47ae9017664588010860a92ceb5f8fcb824"></a>Quad&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates for normal surfaces. </p>
<p>For details, see "Normal surface Q-theory", Jeffrey L. Tollefson, Pacific J. Math. 183 (1998), no. 2, 359&ndash;374.</p>
<p>Regina can both enumerate and view surfaces in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ae7be66e319a0f89d315c43fbd570ffc9" name="gga9817fc7125c53daea4e3f3cbfe987a47ae7be66e319a0f89d315c43fbd570ffc9"></a>QuadClosed&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral coordinates, as described by <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ae9017664588010860a92ceb5f8fcb824" title="Represents quadrilateral coordinates for normal surfaces.">NormalCoords::Quad</a>; however, the enumeration procedure introduces additional constraints. The resulting solution space is the space Q_0 as described in "Computing closed
essential surfaces in knot complements", by Burton, Coward and Tillmann, in SCG ’13: Proceedings of the 29th Annual Symposium on Computational Geometry, ACM, 2013, pp. 405–414.</p>
<p>Note that, if a vertex surface in quad coordinates is closed, it will always be a vertex surface in this system of "closed quad coordinates". However, the converse is not true: a vertex surface in closed quad coordinates need not be a vertex in "plain" quad coordinates.</p>
<p>Regina can enumerate surfaces in this coordinate system, but it is not for viewing. You can just view the surfaces in quad coordinates (<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ae9017664588010860a92ceb5f8fcb824" title="Represents quadrilateral coordinates for normal surfaces.">NormalCoords::Quad</a>) instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. These conditions will be checked when building the matching equations, and Regina will throw an <a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a> exception if they are not met.</dd>
<dd>
SnapPea must be able to work with the underlying triangulation, without retriangulating. This should follow from the previous constraints; however, it will also be checked when building the matching equations, and Regina will throw an <a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a> exception if this requirement is not met. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ac412b47e7eb6b9d99d536f6fbca2c838" name="gga9817fc7125c53daea4e3f3cbfe987a47ac412b47e7eb6b9d99d536f6fbca2c838"></a>AlmostNormal&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
<p>Regina can both enumerate and view surfaces in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a2864e1ab8ba4dc3b772e78526de8e8ca" name="gga9817fc7125c53daea4e3f3cbfe987a47a2864e1ab8ba4dc3b772e78526de8e8ca"></a>LegacyAlmostNormal&#160;</td><td class="fielddoc"><p>Indicates that a list of almost normal surfaces was created using Regina 4.5.1 or earlier, where surfaces with more than one octagon of the same type were stripped out of the final solution set. </p>
<p>As of Regina 4.6 such surfaces are now included in the solution set, since we need them if we wish to enumerate <em>all</em> almost normal surfaces (not just the <em>vertex</em> almost normal surfaces).</p>
<p>Regina cannot enumerate or view surfaces in this coordinate system. It is only used for reading legacy data files. If you have a list that uses this system, you can just view the surfaces in standard almost normal coordinates (<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47ac412b47e7eb6b9d99d536f6fbca2c838" title="Represents standard triangle-quadrilateral-octagon coordinates for octagonal almost normal surfaces.">NormalCoords::AlmostNormal</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a34c5f14ffe856e97f39b4ad9f9048909" name="gga9817fc7125c53daea4e3f3cbfe987a47a34c5f14ffe856e97f39b4ad9f9048909"></a>QuadOct&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
<p>For details, see "Quadrilateral-octagon coordinates for almost normal surfaces", Benjamin A. Burton, Experiment. Math. 19 (2010), 285-315.</p>
<p>Regina can both enumerate and view surfaces in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ab1252784f6b80915b3a8abcd9c94ebe6" name="gga9817fc7125c53daea4e3f3cbfe987a47ab1252784f6b80915b3a8abcd9c94ebe6"></a>QuadOctClosed&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-almost normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral-octagon coordinates, as described by <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a34c5f14ffe856e97f39b4ad9f9048909" title="Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces.">NormalCoords::QuadOct</a>; however, the enumeration procedure introduces additional constraints.</p>
<p>Note that, if a vertex surface in quad-oct coordinates is closed, it will always be a vertex surface in this system of "closed quad-oct
coordinates". However, the converse is not true: a vertex surface in closed quad-oct coordinates need not be a vertex in "plain" quad-oct coordinates.</p>
<p>Regina can enumerate surfaces in this coordinate system, but it is not for viewing. You can just view the surfaces in quad-oct coordinates (<a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a34c5f14ffe856e97f39b4ad9f9048909" title="Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces.">NormalCoords::QuadOct</a>) instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. These conditions will be checked when building the matching equations, and Regina will throw an <a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a> exception if they are not met.</dd>
<dd>
SnapPea must be able to work with the underlying triangulation, without retriangulating. This should follow from the previous constraints; however, it will also be checked when building the matching equations, and Regina will throw an <a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a> exception if this requirement is not met. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ae4a297a0f76119a442c2595ac040673e" name="gga9817fc7125c53daea4e3f3cbfe987a47ae4a297a0f76119a442c2595ac040673e"></a>Edge&#160;</td><td class="fielddoc"><p>Represents edge weight coordinates for normal surfaces. </p>
<p>This coordinate system is for display only: Regina can view surfaces in this coordinate system, but it cannot use it to enumerate or create surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a2b73f91683611c489560a1d163e37902" name="gga9817fc7125c53daea4e3f3cbfe987a47a2b73f91683611c489560a1d163e37902"></a>Arc&#160;</td><td class="fielddoc"><p>Represents triangle arc coordinates for normal surfaces. </p>
<p>This coordinate system is for display only: Regina can view surfaces in this coordinate system, but it cannot use it to enumerate or create surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a45f4ce6c3306644b1efe333f4f8d6929" name="gga9817fc7125c53daea4e3f3cbfe987a47a45f4ce6c3306644b1efe333f4f8d6929"></a>Angle&#160;</td><td class="fielddoc"><p>Represents angle structure coordinates. </p>
<p>This coordinate system is <em>not</em> for use with normal surfaces: it cannot be used either to display them or enumerate them. Instead it is for use with angle structures on triangulations. Because the combinatorics and linear algebra of angle strutures are tightly related to those of normal surfaces, we include <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a45f4ce6c3306644b1efe333f4f8d6929" title="Represents angle structure coordinates.">NormalCoords::Angle</a> here so that angle structure routines can make use of some of Regina's existing normal surface machinery.</p>
<p>For a triangulation with <em>n</em> tetrahedra, this system has 3<em>n</em>+1 coordinates. The first 3<em>n</em> are analogous to quadrilateral coordinates (specifically, for each quadrilateral type <em>Q</em>, the corresponding angle structure coordinate represents the pair of angles in the same tetrahedron that <em>Q</em> does not meet). The final coordinate is a scaling coordinate, used to projectivise the angle structure polytope so that it becomes a polyhedral cone that is invariant under (positive) scaling. If the final scaling coordinate is <em>s</em>, then a rational value of <em>x</em> in any other coordinate position should be interpreted as the angle (<em>x</em>/<em>s</em>)π.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This coordinate system must not be used with any of Regina's routines unless they explicitly declare that <a class="el" href="#gga9817fc7125c53daea4e3f3cbfe987a47a45f4ce6c3306644b1efe333f4f8d6929" title="Represents angle structure coordinates.">NormalCoords::Angle</a> is allowed. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga3ae42d1212a1d908d6aa2ab4c7a14232" name="ga3ae42d1212a1d908d6aa2ab4c7a14232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">&#9670;&#160;</a></span>NormalList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">regina::NormalList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation. </p>
<p>This enumeration type is used with normal surface enumeration routines, such as the <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> class constructor.</p>
<p>The NormalList enumeration refers to the <em>contents</em> of the list, whereas the NormalAlg enumeration refers to the <em>algorithm</em> used to build it.</p>
<p>These values can be combined using the bitwise OR operator (resulting in an object of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;NormalList&gt;</code>). In particular, if a hypersurface enumeration function takes an argument of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;NormalList&gt;</code>, then you can pass a single NormalList constant, or a bitwise combination of such constants <code>(flag1 | flag2)</code>, or empty braces <code>{}</code> to indicate no flags at all (which is equivalent to passing <code><a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a7a1920d61156abc05a60135aefe8bc67" title="An empty flag, indicating to an enumeration routine that it should use its default behaviour.">NormalList::Default</a></code>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232a7a1920d61156abc05a60135aefe8bc67" name="gga3ae42d1212a1d908d6aa2ab4c7a14232a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232abc00874da66eef26f89c0a03906a3ae4" name="gga3ae42d1212a1d908d6aa2ab4c7a14232abc00874da66eef26f89c0a03906a3ae4"></a>EmbeddedOnly&#160;</td><td class="fielddoc"><p>Indicates that this list is restricted to properly embedded surfaces only. </p>
<p>This flag is incompatible with ImmersedSingular. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232a53cf9fe215e818e1748af66ee9dbad37" name="gga3ae42d1212a1d908d6aa2ab4c7a14232a53cf9fe215e818e1748af66ee9dbad37"></a>ImmersedSingular&#160;</td><td class="fielddoc"><p>Indicates that the scope of this list includes not just properly embedded surfaces, but also immersed and/or branched surfaces. </p>
<p>This is no guarantee that the list <em>contains</em> immersed and/or branched surfaces; it merely states that such surfaces have not been explicitly excluded (in particular, the quadrilateral constraints have not been enforced).</p>
<p>This flag is incompatible with EmbeddedOnly. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232ab22b929ba52471a02d18bb3a4e4472e6" name="gga3ae42d1212a1d908d6aa2ab4c7a14232ab22b929ba52471a02d18bb3a4e4472e6"></a>Vertex&#160;</td><td class="fielddoc"><p>Indicates a list of all vertex normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with Fundamental. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232a2863bc264d070388a94111bc05f77f0f" name="gga3ae42d1212a1d908d6aa2ab4c7a14232a2863bc264d070388a94111bc05f77f0f"></a>Fundamental&#160;</td><td class="fielddoc"><p>Indicates a list of all fundamental normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with Vertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232a0cc0a0507cf3d31e5089f420a4cf8b4b" name="gga3ae42d1212a1d908d6aa2ab4c7a14232a0cc0a0507cf3d31e5089f420a4cf8b4b"></a>Legacy&#160;</td><td class="fielddoc"><p>Indicates a list that was constructed using an old version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of how each list was constructed, beyond whether immersed and/or singular surfaces were included. Therefore no information is available for such lists, other than the presence or absence of the EmbeddedOnly and/or ImmersedSingular flags.</p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af" name="gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af"></a>Custom&#160;</td><td class="fielddoc"><p>Indicates some other type of list, typically hand-crafted by the user or built by some customised algorithm. </p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf3bddca5e5ddf81edfe8b2db4ba133df" name="gaf3bddca5e5ddf81edfe8b2db4ba133df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3bddca5e5ddf81edfe8b2db4ba133df">&#9670;&#160;</a></span>NormalTransform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gaf3bddca5e5ddf81edfe8b2db4ba133df">regina::NormalTransform</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents different ways in which Regina can transform one normal surface list into another. </p>
<p>Each type of transformation comes with its own preconditions on the original normal surface list and/or its underlying triangulation; these preconditions are documented alongside the individual enumeration values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf3bddca5e5ddf81edfe8b2db4ba133dfa6451acff3949df15728e6bf5ac19a9ee" name="ggaf3bddca5e5ddf81edfe8b2db4ba133dfa6451acff3949df15728e6bf5ac19a9ee"></a>ConvertReducedToStandard&#160;</td><td class="fielddoc"><p>Converts the set of all embedded vertex normal surfaces in quadrilateral or quadrilateral-octagon coordinates to the set of all embedded vertex normal surfaces in standard normal or standard almost normal coordinates respectively. </p>
<p>It should be emphasised that this routine does <em>not</em> simply convert vectors from one coordinate system to another; instead it converts a full set of vertex surfaces in quad or quad-oct coordinates into a full set of vertex surfaces in standard normal or almost normal coordinates. Typically there are many more vertex surfaces in standard coordinates (all of which this routine will find).</p>
<p>This conversion process is typically <em>much</em> faster than enumerating surfaces directly in standard coordinates. However, normally you would not need to invoke this transformation yourself, since the standard enumeration process will use it automatically when possible. That is, when asked to build a list of standard vertex surfaces, the <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> constructor will (if possible) first find all quad or quad-oct vertex surfaces and then use this procedure to convert the solution set.</p>
<p>Nevertheless, this standalone transformation is provided as a convenience for users who already have a set of quad or quad-oct vertex surfaces, and who simply wish to convert them to a set of standard vertex surfaces without the implicit cost of enumerating the quad or quad-oct vertex surfaces again.</p>
<p>The conversion algorithm is described in detail in "Converting between
quadrilateral and standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>The preconditions for using this transformation:</p>
<ul>
<li>The underlying triangulation is valid, and has no ideal vertices.</li>
<li>The input to this transformation is exactly the set of all embedded vertex surfaces in quadrilateral or quadrilateral-octagon coordinates. This will be checked by examining NormalSurface::coords() and NormalSurface::which(). </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggaf3bddca5e5ddf81edfe8b2db4ba133dfab56920aa73778f6fa761ac00f7cf9c8f" name="ggaf3bddca5e5ddf81edfe8b2db4ba133dfab56920aa73778f6fa761ac00f7cf9c8f"></a>ConvertStandardToReduced&#160;</td><td class="fielddoc"><p>Converts the set of all embedded vertex normal surfaces in standard normal or standard almost normal coordinates to the set of all embedded vertex normal surfaces in quadrilateral or quadrilateral-octagon coordinates respectively. </p>
<p>It should be emphasised that this routine does <em>not</em> simply convert vectors from one coordinate system to another; instead it converts a full set of vertex surfaces in standard normal or almost normal coordinates into a full set of vertex surfaces in quad or quad-oct coordinates. Typically there are far fewer vertex surfaces in quad or quad-oct coordinates (all of which this routine will find).</p>
<p>The conversion algorithm is described in detail in "Converting between
quadrilateral and standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>The preconditions for using this transformation:</p>
<ul>
<li>The underlying triangulation is valid, and has no ideal vertices.</li>
<li>The input to this transformation is exactly the set of all embedded vertex surfaces in standard normal or almost normal coordinates. This will be checked by examining NormalSurface::coords() and NormalSurface::which(). </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggaf3bddca5e5ddf81edfe8b2db4ba133dfabbe74036b762f63c9f358a66ad353ee7" name="ggaf3bddca5e5ddf81edfe8b2db4ba133dfabbe74036b762f63c9f358a66ad353ee7"></a>FilterCompatible&#160;</td><td class="fielddoc"><p>Selects only the surfaces in the input list that have at least one locally compatible partner. </p>
<p>That is, a surface <em>S</em> from the input list will be included in the output list if and only if there is some other surface <em>T</em> in the input list for which <em>S</em> and <em>T</em> are locally compatible. See <a class="el" href="classregina_1_1NormalSurface.html#aa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">NormalSurface::locallyCompatible()</a> for further details on compatibility testing.</p>
<p>Be aware that, since vertex links are compatible with everything, if the input list contains a vertex link plus at least one other surface, then the output list will be identical to the input.</p>
<p>For the output list, which() will include the flag <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af" title="Indicates some other type of list, typically hand-crafted by the user or built by some customised alg...">NormalList::Custom</a>, and algorithm() will be precisely <a class="el" href="#ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af" title="Indicates that a normal surface list was built using a customised algorithm.">NormalAlg::Custom</a>.</p>
<p>The preconditions for using this transformation:</p>
<ul>
<li>The input list contains only embedded normal or almost normal surfaces. This will be checked by examining NormalSurface::which(). </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggaf3bddca5e5ddf81edfe8b2db4ba133dfac81dc6ce70b10630e1bda6ff1b3a2843" name="ggaf3bddca5e5ddf81edfe8b2db4ba133dfac81dc6ce70b10630e1bda6ff1b3a2843"></a>FilterDisjoint&#160;</td><td class="fielddoc"><p>Selects only the surfaces in the input list that have at least one disjoint partner. </p>
<p>That is, a surface <em>S</em> from the input list will be included in the output list if and only if there is some other surface <em>T</em> in the input list for which <em>S</em> and <em>T</em> can be made to intersect nowhere at all, without changing either normal isotopy class. See <a class="el" href="classregina_1_1NormalSurface.html#a7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">NormalSurface::disjoint()</a> for further details on disjointness testing.</p>
<p>This transformation comes with some caveats:</p>
<ul>
<li>It cannot deal with empty, disconnected or non-compact surfaces. Such surfaces will be silently ignored, and will not be used in any disjointness tests (in particular, they will never be considered as a "disjoint partner" for any other surface).</li>
<li>Since vertex links can always be made disjoint from other surfaces, if the input list contains a vertex link plus at least one other surface, then the output list will be identical to the input.</li>
</ul>
<p>For the output list, which() will include the flag <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af" title="Indicates some other type of list, typically hand-crafted by the user or built by some customised alg...">NormalList::Custom</a>, and algorithm() will be precisely <a class="el" href="#ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af" title="Indicates that a normal surface list was built using a customised algorithm.">NormalAlg::Custom</a>.</p>
<p>The preconditions for using this transformation:</p>
<ul>
<li>The input list contains only embedded normal or almost normal surfaces. This will be checked by examining NormalSurface::which(). </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggaf3bddca5e5ddf81edfe8b2db4ba133dfaa14d13419f68b566b5870bdb6e564a09" name="ggaf3bddca5e5ddf81edfe8b2db4ba133dfaa14d13419f68b566b5870bdb6e564a09"></a>FilterIncompressible&#160;</td><td class="fielddoc"><p>Selects only the surfaces in the input list that "might" represent two-sided incompressible surfaces. </p>
<p>More precisely, this transformation considers all two-sided surfaces in the input list, as well as the two-sided double covers of all one-sided surfaces in the input list (see below for details on how one-sided surfaces are handled). Each of these surfaces is examined using relatively fast heuristic tests for incompressibility. Any surface that is definitely <em>not</em> incompressible is ignored, and all other surfaces are placed in the output list.</p>
<p>Therefore, it is guaranteed that every incompressible surface from the input list will be included in the output list. However, each individual output surface might or might not be incompressible.</p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a40448875fc5e68801492acfd10dc680b" title="Determines whether this is an incompressible surface within the surrounding 3-manifold.">NormalSurface::isIncompressible()</a> for the definition of incompressibility that is used here. Note in particular that spheres are <em>never</em> considered incompressible.</p>
<p>As indicated above, this filter works exclusively with two-sided surfaces. If a surface in the input list is one-sided, the heuristic incompressibility tests will be run on its two-sided double cover. Nevertheless, if the tests pass, the original one-sided surface (not the double cover) will be added to the output list.</p>
<p>Currently the heuristic tests include (i) throwing away all vertex links and thin edge links, and then (ii) cutting along the remaining surfaces and running <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">Triangulation&lt;3&gt;::hasSimpleCompressingDisc()</a> on the resulting bounded triangulations. For more details on these tests see "The Weber-Seifert dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<p>For the output list, which() will include the flag <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232a90589c47f06eb971d548591f23c285af" title="Indicates some other type of list, typically hand-crafted by the user or built by some customised alg...">NormalList::Custom</a>, and algorithm() will be precisely <a class="el" href="#ggafd653b63635d07722feea911712b3e58a90589c47f06eb971d548591f23c285af" title="Indicates that a normal surface list was built using a customised algorithm.">NormalAlg::Custom</a>.</p>
<p>The preconditions for using this transformation:</p>
<ul>
<li>The underlying 3-manifold triangulation is valid and closed.</li>
<li>The input list contains only compact, connected, embedded normal surfaces. In particular, almost normal surfaces are not supported.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this transformation is subject to change in future versions of Regina, since additional tests may be added to improve the power of this filtering. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga1e0ca401e07b0f6528d36d68064ff961" name="ga1e0ca401e07b0f6528d36d68064ff961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e0ca401e07b0f6528d36d68064ff961">&#9670;&#160;</a></span>SurfaceExport</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">regina::SurfaceExport</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to describe a field, or a set of fields, that can be exported alongside a normal surface list. </p>
<p>This enumeration type is used with export routines such as <a class="el" href="classregina_1_1NormalSurfaces.html#a07731485243442b7a413f5f67c872dae" title="Exports this list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVStandard()</a> or <a class="el" href="classregina_1_1NormalSurfaces.html#ae5460928bcac184233c6f918ac33dff5" title="Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVEdgeWeight()</a>.</p>
<p>This type describes fields to export <em>in addition</em> to normal coordinates, not the normal coordinates themselves (which are always exported). Each field describes some property of a single normal surface, and corresponds to a single column in a table of normal surfaces.</p>
<p>This enumeration names individual fields, as well as some common combinations of fields (such as <code>None</code> and <code>All</code>). Fields can be combined using the bitwise OR operator (resulting in an object of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;SurfaceExport&gt;</code>). In particular, if a surface export function takes an argument of type <code><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a>&lt;SurfaceExport&gt;</code>, then you can pass a single SurfaceExport constant, or a bitwise combination of such constants <code>(field1 | field2)</code>, or empty braces <code>{}</code> to indicate no fields at all.</p>
<p>The list of available fields may grow with future releases of Regina. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a49ee3087348e8d44e1feda1917443987" name="gga1e0ca401e07b0f6528d36d68064ff961a49ee3087348e8d44e1feda1917443987"></a>Name&#160;</td><td class="fielddoc"><p>Represents the user-assigned surface name. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a0a7532036415f2491bf5f952220827b8" name="gga1e0ca401e07b0f6528d36d68064ff961a0a7532036415f2491bf5f952220827b8"></a>Euler&#160;</td><td class="fielddoc"><p>Represents the calculated Euler characteristic of a surface. </p>
<p>This will be an integer, and will be left empty if the Euler characteristic cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961af4b37c01ca682deab6ecd69bf5e06fe5" name="gga1e0ca401e07b0f6528d36d68064ff961af4b37c01ca682deab6ecd69bf5e06fe5"></a>Orient&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is orientable. </p>
<p>This will be the string <code>TRUE</code> or <code>FALSE</code>, or will be left empty if the orientability cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a23cacdef82dcc2b928a439e224c75d3f" name="gga1e0ca401e07b0f6528d36d68064ff961a23cacdef82dcc2b928a439e224c75d3f"></a>Sides&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is one-sided or two-sided. </p>
<p>This will be the integer 1 or 2, or will be left empty if the "sidedness" cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a0f20c16ad87524747188349aa8069c74" name="gga1e0ca401e07b0f6528d36d68064ff961a0f20c16ad87524747188349aa8069c74"></a>Bdry&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is bounded. </p>
<p>In most cases, this will be one of the strings "closed", "real bdry" or "infinite" (where "infinite" indicates a surface with infinitely many discs). For spun-normal surfaces in certain ideal triangulations, this string will be followed by the boundary slopes of the surface at the cusps: these written as a list of pairs (<em>p</em>, <em>q</em>), one for each cusp, indicating that the boundary curves of the surface run <em>p</em> times around the meridian and <em>q</em> times around the longitude. See <a class="el" href="classregina_1_1NormalSurface.html#adc6df0a57dfc810cbde7845cd8ae9a31" title="Computes the information about the boundary slopes of this surface at each cusp of the triangulation.">NormalSurface::boundaryIntersections()</a> for further information on interpreting these values. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a97e7c9a7d06eac006a28bf05467fcc8b" name="gga1e0ca401e07b0f6528d36d68064ff961a97e7c9a7d06eac006a28bf05467fcc8b"></a>Link&#160;</td><td class="fielddoc"><p>Represents whether a surface is a single vertex link or a thin edge link. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#af98616d2b0b270a6a427133d3cd88cae" title="Determines whether or not a positive rational multiple of this surface is the link of a single vertex...">NormalSurface::isVertexLink()</a> and <a class="el" href="classregina_1_1NormalSurface.html#ab82721dfe41b187548593091b7274e6e" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single e...">NormalSurface::isThinEdgeLink()</a> for details. This will be written as a human-readable string. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508" name="gga1e0ca401e07b0f6528d36d68064ff961aa1fa27779242b4902f7ae3bdd5c6d508"></a>Type&#160;</td><td class="fielddoc"><p>Represents any additional high-level properties of a surface, such as whether it is a splitting surface or a central surface. </p>
<p>This will be written as a human-readable string. This field is somewhat arbitrary, and the precise properties it describes are subject to change in future releases of Regina. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961a6adf97f83acf6453d4a6a4b1070f3754" name="gga1e0ca401e07b0f6528d36d68064ff961a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Indicates that no fields should be exported (except for the normal coordinates, which are always exported). </p>
<dl class="section user"><dt>Python</dt><dd>This constant is called <code>Nil</code>, since <code>None</code> is a reserved word in Python. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961afc742013094ae4c79be3b0c44f259220" name="gga1e0ca401e07b0f6528d36d68064ff961afc742013094ae4c79be3b0c44f259220"></a>AllButName&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, except for the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1e0ca401e07b0f6528d36d68064ff961ab1c94ca2fbc3e78fc30069c8d0f01680" name="gga1e0ca401e07b0f6528d36d68064ff961ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, including the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga38ab803471723156fb2ecb24b7b1c859" name="ga38ab803471723156fb2ecb24b7b1c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ab803471723156fb2ecb24b7b1c859">&#9670;&#160;</a></span>SurfaceFilterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a24782791f84f9ed8aeacf8a5b8408f56" name="gga38ab803471723156fb2ecb24b7b1c859a24782791f84f9ed8aeacf8a5b8408f56"></a>LegacyDefault&#160;</td><td class="fielddoc"><p>A legacy constant representing a do-nothing filter that accepts any normal surface. </p>
<p>This type of filter could technically appear in a second-generation Regina data file, though it is unlikely that this feature was ever used in practice (in particular, filters of this type could not be created through the GUI). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a9fc2d28c05ed9eb1d75ba4465abf15a9" name="gga38ab803471723156fb2ecb24b7b1c859a9fc2d28c05ed9eb1d75ba4465abf15a9"></a>Properties&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a> subclass: a filter that examines simple properties of a normal surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a47ac923d219501859fb68fed8c8db77b" name="gga38ab803471723156fb2ecb24b7b1c859a47ac923d219501859fb68fed8c8db77b"></a>Combination&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a> subclass: a filter that combines other filters using boolean AND or OR. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaacc8d5800d8613931ff0483a8388308c" name="gaacc8d5800d8613931ff0483a8388308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc8d5800d8613931ff0483a8388308c">&#9670;&#160;</a></span>discOrientationFollowsEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::discOrientationFollowsEdge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>discType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc. </p>
<p>Natural boundary orientation is defined by arrays <a class="el" href="#ga7c87df41b7d18490de378b0d42d65b60" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular...">regina::triDiscArcs</a>, <a class="el" href="#gadc5e68787b9a0130ffbee14797ed3392" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilate...">regina::quadDiscArcs</a> and <a class="el" href="#ga3194707749e55b555701ea4b65f3295c" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal ...">regina::octDiscArcs</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc lies on a normal disc of the given type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex about which the normal arc runs. </td></tr>
    <tr><td class="paramname">edgeStart</td><td>the start vertex of the edge to which the normal arc is parallel. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end vertex of the edge to which the normal arc is parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f34aa52f4c65b2bcd7b0611b08b373a" name="ga6f34aa52f4c65b2bcd7b0611b08b373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f34aa52f4c65b2bcd7b0611b08b373a">&#9670;&#160;</a></span>makeEmbeddedConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ValidityConstraints.html">ValidityConstraints</a> regina::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the given coordinate system.</p>
<p>For some coordinate systems, these will include additional constraints of a similar nature (i.e., restricting which combinations of coordinates may be non-zero). For instance, in almost normal coordinates, there will typically be an extra constraint insisting that at most one octagon type is non-zero across the entire triangulation.</p>
<p>These are the constraints that will be used when enumerating embedded surfaces in the given coordinate system (i.e., when the default flag <a class="el" href="#gga3ae42d1212a1d908d6aa2ab4c7a14232abc00874da66eef26f89c0a03906a3ae4" title="Indicates that this list is restricted to properly embedded surfaces only.">NormalList::EmbeddedOnly</a> is used). They will not be used when the enumeration allows for immersed and/or singular surfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of validity constraints. </dd></dl>

</div>
</div>
<a id="ga1a05e667b9a2ad50bcd17541c652bcc7" name="ga1a05e667b9a2ad50bcd17541c652bcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a05e667b9a2ad50bcd17541c652bcc7">&#9670;&#160;</a></span>makeMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> regina::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the set of normal surface matching equations for the given triangulation using the given coordinate system. </p>
<p>These are the matching equations that will be used when enumerating normal surfaces in the coordinate system <em>coords</em>.</p>
<p>Each equation will be represented as a row of the resulting matrix. Each column of the matrix represents a coordinate in the given coordinate system.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The matching equations could not be created for the given triangulation in the given coordinate system, due to an error that should have been preventable with the right checks in advance. This can only happen in certain coordinate systems, and for all such coordinate systems this is explicitly described in the NormalCoords enum documentation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The matching equations could not be created for the given triangulation in the given coordinate system, due to an error that was "genuinely" unforseeable. Again this can only happen in certain coordinate systems, where this is explicitly described in the NormalCoords enum documentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting set of matching equations. </dd></dl>

</div>
</div>
<a id="ga17dfc1f57595cbc9ec5662a76d25c161" name="ga17dfc1f57595cbc9ec5662a76d25c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17dfc1f57595cbc9ec5662a76d25c161">&#9670;&#160;</a></span>numberDiscsAwayFromVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::numberDiscsAwayFromVertex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>discType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not normal discs of the given type are numbered away from the given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex under consideration; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if normal discs of the given type are numbered away from the given vertex, or <code>false</code> if they are numbered towards the given vertex. </dd></dl>

</div>
</div>
<a id="gaeb62505986baff30554f9495f5ab3688" name="gaeb62505986baff30554f9495f5ab3688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb62505986baff30554f9495f5ab3688">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga4d42ed9b68e522ff445b5d3e777176f4" name="ga4d42ed9b68e522ff445b5d3e777176f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d42ed9b68e522ff445b5d3e777176f4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc type to the given output stream. </p>
<p>The disc type will be written as a pair <code>(tetIndex, type)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0eccc9cb94753e2c763c840460a5bbd5" name="ga0eccc9cb94753e2c763c840460a5bbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eccc9cb94753e2c763c840460a5bbd5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given prism specifier to the given output stream. </p>
<p>The prism specifier will be written as a pair <code>(tetIndex, edge)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the prism specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga15969a39fab7ec3da69d80797433cf25" name="ga15969a39fab7ec3da69d80797433cf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15969a39fab7ec3da69d80797433cf25">&#9670;&#160;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a> &gt; regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gafd653b63635d07722feea911712b3e58">NormalAlg</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga2f09787723e70a659f2265930870231e" name="ga2f09787723e70a659f2265930870231e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f09787723e70a659f2265930870231e">&#9670;&#160;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a> &gt; regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga3ae42d1212a1d908d6aa2ab4c7a14232">NormalList</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga50f3f5da6b482e8fb13e4e91f541e7f5" name="ga50f3f5da6b482e8fb13e4e91f541e7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f3f5da6b482e8fb13e4e91f541e7f5">&#9670;&#160;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a> &gt; regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1e0ca401e07b0f6528d36d68064ff961">SurfaceExport</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="gaeb5a1287f454c11db949a064cbf5d672" name="gaeb5a1287f454c11db949a064cbf5d672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5a1287f454c11db949a064cbf5d672">&#9670;&#160;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html">DiscSetSurfaceDataImpl</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given disc sets. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html#af71bedc448d8f72c5fd0d0577c2aed91" title="Swaps the contents of this and the given disc set.">DiscSetSurfaceDataImpl::swap()</a>; it is provided so that <a class="el" href="classregina_1_1DiscSetSurfaceDataImpl.html" title="Stores a piece of data alongside every normal disc within a particular normal surface.">DiscSetSurfaceDataImpl</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first disc set whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second disc set whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0885312336b0f4a9fad50c1981865173" name="ga0885312336b0f4a9fad50c1981865173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0885312336b0f4a9fad50c1981865173">&#9670;&#160;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given disc sets. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1DiscSetTetData.html#ad7b073f47f2ca9b102f7ae335f0f5a4f" title="Swaps the contents of this and the given disc set.">DiscSetTetData::swap()</a>; it is provided so that <a class="el" href="classregina_1_1DiscSetTetData.html" title="Stores data of type T for every normal disc inside a single tetrahedron.">DiscSetTetData</a> meets the C++ Swappable requirements.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first disc set whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second disc set whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54184754081d5cb2bf5ae20fab667a49" name="ga54184754081d5cb2bf5ae20fab667a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54184754081d5cb2bf5ae20fab667a49">&#9670;&#160;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given normal surfaces. </p>
<p>This is a fast (constant time) operation.</p>
<p>This global routine simply calls <a class="el" href="classregina_1_1NormalSurface.html#ae9a6541e5a18984537c70e105c84bced" title="Swaps the contents of this and the given normal surface.">NormalSurface::swap()</a>; it is provided so that <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first normal surface whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second normal surface whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad10219a0cd0d5bd3261bc36fb9a997a" name="gaad10219a0cd0d5bd3261bc36fb9a997a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad10219a0cd0d5bd3261bc36fb9a997a">&#9670;&#160;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given lists. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1NormalSurfaces.html#a6a6ad6281b288ede6f558ed36fb44541" title="Swaps the contents of this and the given list.">NormalSurfaces::swap()</a>; it is provided so that <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> meets the C++ Swappable requirements.</p>
<p>See <a class="el" href="classregina_1_1NormalSurfaces.html#a6a6ad6281b288ede6f558ed36fb44541" title="Swaps the contents of this and the given list.">NormalSurfaces::swap()</a> for more details.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both lists which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the list whose contents should be swapped with <em>rhs</em>. </td></tr>
    <tr><td class="paramname">rhs</td><td>the list whose contents should be swapped with <em>lhs</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35759e4e4e70d1b0ab9f281a7b572cd6" name="ga35759e4e4e70d1b0ab9f281a7b572cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35759e4e4e70d1b0ab9f281a7b572cd6">&#9670;&#160;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given combination filters. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a1afb37b36aaa0a214614562a2c7822e9" title="Swaps the contents of this and the given filter.">SurfaceFilterCombination::swap()</a>; it is provided so that <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first filter whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second filter whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac184aeb6cc3d2da89a3e5e72853d7c3" name="gaac184aeb6cc3d2da89a3e5e72853d7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac184aeb6cc3d2da89a3e5e72853d7c3">&#9670;&#160;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given property-based filters. </p>
<p>This global routine simply calls <a class="el" href="classregina_1_1SurfaceFilterProperties.html#a26e17940f8174144122e4fad0b1ca6cb" title="Swaps the contents of this and the given filter.">SurfaceFilterProperties::swap()</a>; it is provided so that <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first filter whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second filter whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3194707749e55b555701ea4b65f3295c" name="ga3194707749e55b555701ea4b65f3295c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3194707749e55b555701ea4b65f3295c">&#9670;&#160;</a></span>octDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::octDiscArcs[3][8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    Perm&lt;4&gt;(0,3,1,2), Perm&lt;4&gt;(0,1,2,3), Perm&lt;4&gt;(2,0,3,1), Perm&lt;4&gt;(2,3,1,0),</div>
<div class="line">    Perm&lt;4&gt;(1,2,0,3), Perm&lt;4&gt;(1,0,3,2), Perm&lt;4&gt;(3,1,2,0), Perm&lt;4&gt;(3,2,0,1),</div>
<div class="line">    Perm&lt;4&gt;(0,1,2,3), Perm&lt;4&gt;(0,2,3,1), Perm&lt;4&gt;(3,0,1,2), Perm&lt;4&gt;(3,1,2,0),</div>
<div class="line">    Perm&lt;4&gt;(2,3,0,1), Perm&lt;4&gt;(2,0,1,3), Perm&lt;4&gt;(1,2,3,0), Perm&lt;4&gt;(1,3,0,2),</div>
<div class="line">    Perm&lt;4&gt;(0,2,3,1), Perm&lt;4&gt;(0,3,1,2), Perm&lt;4&gt;(1,0,2,3), Perm&lt;4&gt;(1,2,3,0),</div>
<div class="line">    Perm&lt;4&gt;(3,1,0,2), Perm&lt;4&gt;(3,0,2,1), Perm&lt;4&gt;(2,3,1,0), Perm&lt;4&gt;(2,1,0,3)</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>octDiscArcs[i]</code> lists the boundary arcs of the octagonal disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<p>Note that permutation <code>octDiscArcs[i][j]</code> will be even precisely when <code>j</code> is 0, 1, 4 or 5. </p>

</div>
</div>
<a id="gae5b2917f4b34f6e5cbc850c30a5e2c8e" name="gae5b2917f4b34f6e5cbc850c30a5e2c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b2917f4b34f6e5cbc850c30a5e2c8e">&#9670;&#160;</a></span>quadDefn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::quadDefn[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { 0, 1, 2, 3 }, { 0, 2, 1, 3 }, { 0, 3, 1, 2 }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists which vertices each quadrilateral type separates in a tetrahedron. </p>
<p>See <a class="el" href="#ga97d454b13fbddb464094146796f19fec" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> splits the vertex pairs <code>quadDefn[i][0,1]</code> and <code>quadDefn[i][2,3]</code>.</p>
<p>It is guaranteed that:</p>
<ul>
<li><code>quadDefn[i][0] &lt; quadDefn[i][1]</code>;</li>
<li><code>quadDefn[i][2] &lt; quadDefn[i][3]</code>;</li>
<li><code>quadDefn[i][0] &lt; quadDefn[i][2]</code>.</li>
</ul>
<p>This array contains similar information to the function <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html#adf38141ecaf39180ca0e7882413fad19" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Edge&lt;3&gt;::ordering()</a>. Instead of quadDefn[<em>i</em>][<em>j</em>], you can call <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html#adf38141ecaf39180ca0e7882413fad19" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Edge&lt;3&gt;::ordering</a>(<em>i</em>)[<em>j</em>]; this will give the same results for <em>j</em> = 0 and 1, but it might switch the results for <em>j</em> = 2 and 3. </p>

</div>
</div>
<a id="gadc5e68787b9a0130ffbee14797ed3392" name="gadc5e68787b9a0130ffbee14797ed3392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc5e68787b9a0130ffbee14797ed3392">&#9670;&#160;</a></span>quadDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::quadDiscArcs[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    Perm&lt;4&gt;(0,2,3,1), Perm&lt;4&gt;(3,0,1,2), Perm&lt;4&gt;(1,3,2,0), Perm&lt;4&gt;(2,1,0,3),</div>
<div class="line">    Perm&lt;4&gt;(0,3,1,2), Perm&lt;4&gt;(1,0,2,3), Perm&lt;4&gt;(2,1,3,0), Perm&lt;4&gt;(3,2,0,1),</div>
<div class="line">    Perm&lt;4&gt;(0,1,2,3), Perm&lt;4&gt;(2,0,3,1), Perm&lt;4&gt;(3,2,1,0), Perm&lt;4&gt;(1,3,0,2)</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>quadDiscArcs[i]</code> lists the boundary arcs of the quadrilateral disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<p>Note that permutation <code>quadDiscArcs[i][j]</code> will be even precisely when <code>j</code> is even. </p>

</div>
</div>
<a id="ga161c786acec999baa4d539e59d61fa8a" name="ga161c786acec999baa4d539e59d61fa8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161c786acec999baa4d539e59d61fa8a">&#9670;&#160;</a></span>quadMeeting</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::quadMeeting[4][4][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { {-1,-1}, { 1, 2}, { 0, 2}, { 0, 1} },</div>
<div class="line">    { { 1, 2}, {-1,-1}, { 0, 1}, { 0, 2} },</div>
<div class="line">    { { 0, 2}, { 0, 1}, {-1,-1}, { 1, 2} },</div>
<div class="line">    { { 0, 1}, { 0, 2}, { 1, 2}, {-1,-1} }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists which quadrilateral types meet which edges in a tetrahedron. </p>
<p>See <a class="el" href="#ga97d454b13fbddb464094146796f19fec" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p><code>quadMeeting[i][j][0,1]</code> are the numbers of the two quadrilateral types that meet the edge joining tetrahedron vertices <code>i</code> and <code>j</code>. </p>

</div>
</div>
<a id="gaff4c9c0b9cce8f830ffa30f20a82b6d8" name="gaff4c9c0b9cce8f830ffa30f20a82b6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff4c9c0b9cce8f830ffa30f20a82b6d8">&#9670;&#160;</a></span>quadPartner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::quadPartner[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { 1, 0, 3, 2}, { 2, 3, 0, 1}, { 3, 2, 1, 0}</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="#ga97d454b13fbddb464094146796f19fec" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> pairs vertex <code>v</code> with vertex <code>quadPartner[i][v]</code>. </p>

</div>
</div>
<a id="ga97d454b13fbddb464094146796f19fec" name="ga97d454b13fbddb464094146796f19fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d454b13fbddb464094146796f19fec">&#9670;&#160;</a></span>quadSeparating</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::quadSeparating[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { -1, 0, 1, 2 }, {  0,-1, 2, 1 }, {  1, 2,-1, 0 }, {  2, 1, 0,-1 }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists which quadrilateral types separate which pairs of vertices in a tetrahedron. </p>
<p>As outlined in <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a>, there are three quadrilateral types in a tetrahedron, numbered 0, 1 and 2. Each quadrilateral type separates the four tetrahedron vertices 0,1,2,3 into two pairs. <code>quadSeparating[i][j]</code> is the number of the quadrilateral type that keeps vertices <code>i</code> and <code>j</code> together.</p>
<p>It is guaranteed that quadrilateral type <em>i</em> will keep the vertices of edge <em>i</em> together (and will therefore also keep the vertices of edge <em>5-i</em> together). </p>

</div>
</div>
<a id="gaf493c20711e8970eaacdfd15842eae1e" name="gaf493c20711e8970eaacdfd15842eae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf493c20711e8970eaacdfd15842eae1e">&#9670;&#160;</a></span>quadString</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::quadString[3] = { &quot;01/23&quot;, &quot;02/13&quot;, &quot;03/12&quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains strings that can be used to represent each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="#ga97d454b13fbddb464094146796f19fec" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>The string describing quadrilateral type <code>i</code> is <code>quadString[i]</code> and is of the form <code>02/13</code>, which in this case is the quadrilateral type that splits vertices 0,2 from vertices 1,3.</p>
<p>Some older compilers (such as GCC 10 and GCC 11) do not support constexpr strings. In such cases, this constant will be marked <code>inline const</code> but not <code>constexpr</code>. </p>

</div>
</div>
<a id="ga7c87df41b7d18490de378b0d42d65b60" name="ga7c87df41b7d18490de378b0d42d65b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c87df41b7d18490de378b0d42d65b60">&#9670;&#160;</a></span>triDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::triDiscArcs[4][3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    Perm&lt;4&gt;(0,1,2,3), Perm&lt;4&gt;(0,2,3,1), Perm&lt;4&gt;(0,3,1,2),</div>
<div class="line">    Perm&lt;4&gt;(1,0,3,2), Perm&lt;4&gt;(1,3,2,0), Perm&lt;4&gt;(1,2,0,3),</div>
<div class="line">    Perm&lt;4&gt;(2,3,0,1), Perm&lt;4&gt;(2,0,1,3), Perm&lt;4&gt;(2,1,3,0),</div>
<div class="line">    Perm&lt;4&gt;(3,2,1,0), Perm&lt;4&gt;(3,1,0,2), Perm&lt;4&gt;(3,0,2,1)</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>triDiscArcs[i]</code> lists the boundary arcs of the triangular disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<p>Note that every permutation in this array is even. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
